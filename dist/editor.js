var IT = Object.defineProperty;
var xy = (t) => {
  throw TypeError(t);
};
var NT = (t, e, r) => e in t ? IT(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var vs = (t, e, r) => NT(t, typeof e != "symbol" ? e + "" : e, r), Zh = (t, e, r) => e.has(t) || xy("Cannot " + r);
var Y = (t, e, r) => (Zh(t, e, "read from private field"), r ? r.call(t) : e.get(t)), At = (t, e, r) => e.has(t) ? xy("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r), mt = (t, e, r, s) => (Zh(t, e, "write to private field"), s ? s.call(t, r) : e.set(t, r), r), Dy = (t, e, r) => (Zh(t, e, "access private method"), r);
var by = (t, e, r, s) => ({
  set _(i) {
    mt(t, e, i, r);
  },
  get _() {
    return Y(t, e, s);
  }
});
const MT = "function", LT = "undefined", sa = "object", sD = "string", Lf = "array", Wu = "number", Qo = "boolean", _T = "date";
const jc = (t, e) => typeof t === e, RT = (t, e) => t instanceof e, tn = (t) => jc(t, sa), ll = (t) => jc(t, sD), lt = (t) => jc(t, MT), vy = (t) => !Number.isNaN(t), ks = (t) => jc(t, LT), qT = (t) => Array.isArray(t), Sy = (t) => RT(t, Date) && !isNaN(t), rn = (t) => t === null, jT = (t) => t.replace(/-([a-z0-9])/g, (e, r) => r.toUpperCase());
function XT(t) {
  if (ll(t))
    try {
      return JSON.parse(`{${t.replace(/^\s*{/, "").replace(/}\s*$/, "").split(/((?:[^;^,"']|"[^"]*"|'[^']*')+)/).filter((e) => !["", ";", ","].includes(e.trim())).map((e) => e.split(":")).map((e) => `"${e[0].trim()}":${Bo(e[1].trim(), void 0, !0)}`).join(",")}}`);
    } catch {
      try {
        return Bo(t);
      } catch (r) {
        console.error(r);
        return;
      }
    }
  if (tn(t))
    return t;
}
function iD(t) {
  if (ll(t))
    return t.trim().startsWith("[") ? (t.match(/\[(.*?)[^\]]]/g) || []).map((e) => iD(e.substring(
      1,
      e.length - 1
    ))) : t.split(/[,;]/).map((e) => Bo(e.trim()));
  if (qT(t))
    return t;
}
function Bo(t, e, r = !1) {
  if (!ll(t))
    return t;
  if (t = ZT(t.trim()), e === Lf)
    return iD(t);
  if (e === sa)
    return XT(t);
  if (ks(e) || e === Wu) {
    if (ks(t) || t === "")
      return;
    let s = +t;
    if (vy(s) || e === Wu)
      return s;
  }
  if (ks(e) || e === Qo) {
    if (t === "true")
      return !0;
    if (t === "false")
      return !1;
    if (e === Qo)
      return t === "0" ? !1 : !!t;
  }
  if (e === _T) {
    try {
      let s = new Date(t);
      if (vy(s.getTime()))
        return s;
    } catch {
    }
    return;
  }
  if (ks(e) || e === sD)
    return r ? `"${t}"` : t;
}
function ZT(t) {
  return t[0] === "'" && t[t.length - 1] === "'" || t[0] === '"' && t[t.length - 1] === '"' ? t.substring(1, t.length - 1) : t;
}
const wy = /* @__PURE__ */ new WeakSet();
let go = !1;
const Io = (t, e) => !tn(t) || rn(t) || !lt(e) ? t : function r(s) {
  if (wy.has(s))
    return s;
  for (let n in s)
    tn(s[n]) && !rn(s[n]) && (s[n] = r(s[n]));
  const i = new Proxy(s, {
    get(n, a) {
      let l = Reflect.get(s, a);
      return lt(l) && Sy(n) && ll(a) && a.substring(0, 3) === "set" && lt(e) && (l = function(...c) {
        const p = Reflect.get(n, a).apply(n, c);
        return !go && e(t), p;
      }), Sy(n) ? l.bind(n) : l;
    },
    set(n, a, l) {
      let c;
      const p = n[a] === l;
      return tn(l) && !rn(l) ? c = Reflect.set(n, a, r(l)) : c = Reflect.set(n, a, l), !go && !p && e(t), c;
    },
    deleteProperty(n, a) {
      let l = Reflect.deleteProperty(n, a);
      return !go && e(t), l;
    }
  });
  return wy.add(i), i;
}(t);
Io.stop = () => go = !0;
Io.start = () => go = !1;
const Va = !1, jl = !0;
function VT(t) {
  return t === null ? null : t.constructor ? new t.constructor() : {};
}
function td(t) {
  if (!tn(t))
    return t;
  const e = t === null ? null : Object.assign(VT(t), t);
  for (let r in e)
    tn(e[r]) && (e[r] = td(e[r]));
  return e;
}
function zT(t, e) {
  const r = [], s = [];
  function i(a, l) {
    if (rn(a) || rn(l))
      return Va;
    if (lt(a.valueOf) && // valueOf() is a function in both values
    lt(l.valueOf) && (a !== a.valueOf() || l !== l.valueOf()))
      return a.valueOf() === l.valueOf() && a.constructor === l.constructor;
    if (r.indexOf(a) > -1 && // Check if the object has been previously processed
    s.indexOf(l) > -1)
      return jl;
    let c = Object.keys(a), p = Object.keys(l);
    if (c.length !== p.length)
      return Va;
    if (c.length > 0) {
      r.push(a), s.push(l);
      let d = c.length;
      for (; d--; ) {
        const m = c[d];
        if (!n(a[m], l[m]))
          return Va;
      }
    }
    return jl;
  }
  function n(a, l) {
    if (a === l)
      return jl;
    const c = typeof a;
    return c !== typeof l ? Va : c === Wu && // Special case: Not is a Number (NaN !== NaN)
    isNaN(a) && isNaN(l) ? jl : c === sa ? i(a, l) : Va;
  }
  return n(t, e);
}
const nt = Symbol(), Gu = Symbol(), os = Symbol(), rd = Object.defineProperty;
function UT(t, e, r, s = !1) {
  if (!(t.ready === !1 || !e))
    if (s)
      r ? t.setAttribute(e, "") : t.removeAttribute(e);
    else {
      const i = rn(r) || ks(r) ? "" : r.toString();
      t.hasAttribute(e) && t.getAttribute(e) !== i && t.setAttribute(e, i);
    }
}
function YT(t) {
  this[nt] = {};
  let e = t;
  do {
    const r = Cu.get(e);
    for (let s in r)
      if (r.hasOwnProperty(s) && this.hasOwnProperty(s)) {
        const i = this[s];
        delete this[s], this[s] = ks(i) ? td(r[s]) : i;
      } else s in this[nt] || (this[nt][s] = td(r[s]));
    e = Object.getPrototypeOf(e);
  } while (e !== HTMLElement);
}
function WT() {
  new MutationObserver((t) => {
    t.some((e) => !e.attributeName) && this[os]("update"), (ks(this.ready) || this.ready) && lt(this[Gu]) && this[Gu](t);
  }).observe(this, { attributes: !0, childList: !0, subtree: !0, characterData: !0 });
}
const Cu = /* @__PURE__ */ new WeakMap();
class _f extends HTMLElement {
  constructor() {
    super(), YT.call(this, new.target), lt(this[Gu]) && WT.call(this);
  }
  /**
   * Fire an event
   * @private
   * @param {string} event             - event name
   * @param {Object} [detail={}]       - optional event detail object
   * @param {boolean} [composed=false] - optional event propagate across the shadow DOM boundary
   * @returns {boolean}                - return true
   */
  [os](e, r = {}, s = !1) {
    return this.dispatchEvent(new CustomEvent(
      e,
      { bubbles: !0, cancelable: !0, detail: r, composed: s }
    ));
  }
}
function GT(t, e) {
  e.propertyName || (e.propertyName = jT(e.name)), nD(t, {
    ...e,
    name: e.propertyName,
    attribute: e.name
  });
  const r = Object.getPrototypeOf(t), s = "observedAttributes", i = Object.getOwnPropertyDescriptor(
    t,
    s
  ), n = Object.getOwnPropertyDescriptor(
    r,
    s
  );
  let a = i ? i.get : void 0;
  rd(
    t,
    s,
    JT(
      t,
      e,
      r,
      a,
      i,
      n
    )
  );
  const l = "attributeChangedCallback", c = Object.getOwnPropertyDescriptor(
    t.prototype,
    l
  ), p = Object.getOwnPropertyDescriptor(
    r.prototype,
    l
  );
  let d = c ? c.value : void 0;
  rd(
    t.prototype,
    l,
    HT(e, d, p)
  );
}
function HT(t, e, r) {
  return {
    /**
     * @this {Base}
     */
    value: function(s, i, n) {
      if (t.name === s) {
        const a = t.propertyName;
        this[a] !== n && (t.type === Qo ? this[a] = this.hasAttribute(t.name) : this[a] = Bo(n, t.type));
      } else e && e.apply(this, arguments);
      r != null && r.value && r.value.apply(this, arguments);
    },
    enumerable: !1,
    writable: !0,
    configurable: !0
  };
}
function JT(t, e, r, s, i, n) {
  const a = {
    enumerable: !1,
    configurable: !0
  };
  return i ? n ? a.get = function() {
    return [
      e.name,
      ...s.call(t),
      ...n.get.call(r)
    ];
  } : a.get = function() {
    return [e.name, ...s.call(t)];
  } : a.get = n ? function() {
    return [e.name, ...n.get.call(r)];
  } : function() {
    return [e.name];
  }, a;
}
function nD(t, e) {
  rd(
    t.prototype,
    e.name,
    {
      set: aD(e),
      get: ek(e),
      configurable: !0,
      enumerable: !1
    }
  ), Cu.has(t) || Cu.set(t, {}), Cu.get(t)[e.name] = e.value;
}
function KT(t, e) {
  rn(t.posUpdateEvent) || (t.posUpdateEvent ? this[os](t.posUpdateEvent, { [t.name]: e }) : this[os]("update", { [t.name]: e })), lt(t.posUpdate) ? t.posUpdate.call(this, e) : lt(this[t.posUpdate]) && this[t.posUpdate]();
}
function aD(t) {
  return function(e) {
    let r = this[nt];
    lt(t.preUpdate) && !t.preUpdate.call(this, e) || (t.schema && (Io.stop(), e = t.schema.normalize(e), Io.start()), !(!tn(e) && zT(r[t.name], e)) && (lt(t.set) ? t.set.call(this, e) : r[t.name] = ll(e) && t.type ? (
      // String conversion updated
      Bo(e, t.type)
    ) : (
      // Other values
      e
    ), t.attribute && ![Lf, sa].includes(t.type) && UT(this, t.attribute, e, t.type === Qo), KT.call(this, t, e)));
  };
}
function ek(t) {
  return function() {
    if (lt(t.get))
      return t.get.call(this);
    {
      const e = this[nt];
      switch (t.type) {
        case Wu:
          return ks(e[t.name]) ? void 0 : Number(e[t.name]);
        case Qo:
          return !!e[t.name];
        case sa:
        case Lf:
          return Io(
            e[t.name] || (t.type === sa ? {} : []),
            (r) => aD(t).call(this, r)
          );
        default:
          return e[t.name];
      }
    }
  };
}
function tk(t, e) {
  e = e.toLowerCase(), customElements.get(e) || customElements.define(e, t);
}
function rk(t, e = {}) {
  return e.prop = (...r) => (r.forEach((s) => nD(t, { ...s })), e), e.attr = (...r) => (r.forEach((s) => GT(t, { ...s })), e), e.tag = (r) => (tk(t, r), e), e.extension = e.ext = (r) => (r.call(e, e, t), e), e;
}
_f.CHANGE = Gu;
_f.FIRE_EVENT = os;
function Ay(t, e) {
  const r = /* @__PURE__ */ new WeakMap(), s = [];
  return function(...i) {
    return clearTimeout(r.get(this)), new Promise((n, a) => {
      s.push({ resolve: n, reject: a }), r.set(this, setTimeout(() => {
        try {
          const l = t.apply(this, i);
          s.forEach((c) => c.resolve(l));
        } catch (l) {
          s.forEach((c) => c.reject(l));
        } finally {
          s.length = 0;
        }
      }, e));
    });
  };
}
function Cy(t, e) {
  return function(...r) {
    if (t.apply(this, r))
      return e.apply(this, r);
  };
}
function Ey(t, e) {
  return function(...r) {
    const s = t.apply(this, r);
    return lt(s.then) ? s.then((i) => e.call(this, i) || i) : e.call(this, s) || s;
  };
}
const Ty = 1, Rf = Symbol(), qf = Symbol(), Mn = Symbol(), Nr = Symbol(), ky = Symbol(), Vh = Symbol(), Py = (t, e) => {
  var r;
  return (r = t[e]) == null ? void 0 : r.forEach((s) => lt(s) && s.apply(t));
};
class Fi extends _f {
  /**
   * @constructor
   * @param {boolean} [ready]
   */
  constructor(e) {
    super(), this.attachShadow({ mode: "open" }), this[nt].ready = e || !1, this[nt].rendered = !1, ks(e) && (this.ready = !0);
  }
  /**
   * ready state
   * @type {boolean}
   */
  get ready() {
    return this[nt].ready;
  }
  set ready(e) {
    const r = this[nt], s = r.ready;
    r.ready = !!e, s === !1 && r.ready === !0 && (this[os]("ready", { ready: !0 }), lt(this[Nr]) && this[Nr]());
  }
  /**
   * rendered state
   * @returns {boolean}
   */
  get rendered() {
    return this[nt].rendered;
  }
  set rendered(e) {
    const r = this[nt], s = r.rendered;
    r.rendered = !!e, s === !1 && r.rendered === !0 && this[os]("render", { rendered: !0 });
  }
  /**
   * Connected with the parent DOM
   *   - Resize observer
   * @private
   */
  connectedCallback() {
    let e = this.getBoundingClientRect(), r = getComputedStyle(this).flexDirection;
    const s = () => {
      let { width: i, height: n } = this.getBoundingClientRect(), a = getComputedStyle(this).flexDirection;
      (i !== e.width || n !== e.height || a !== r) && (lt(this[ky]) && this[ky](
        i,
        n,
        i - e.width,
        n - e.height
      ), e = { width: i, height: n }, r = a, this[os]("resize", e)), this[nt]._resizeObserver = window.requestAnimationFrame(s);
    };
    s(), Py(this, Rf);
  }
  /**
   * Disconnected of parent DOM
   *   - Remove resize observer
   * @private
   */
  disconnectedCallback() {
    window.cancelAnimationFrame(this[nt]._resizeObserver), Py(this, qf);
  }
}
Fi.prototype[Rf] = [];
Fi.prototype[qf] = [];
function sk(t, e) {
  var s, i, n, a;
  const r = {
    name: e.name.startsWith("--") ? e.name : `--${e.name}`,
    initialValue: (i = (s = e.initialValue) != null ? s : e.value) != null ? i : "",
    syntax: (n = e.syntax) != null ? n : "*",
    inherits: (a = e.inherits) != null ? a : !0
  };
  t.prototype[Vh] || (t.prototype[Vh] = {}), t.prototype[Vh][r.name] = r;
}
function ik(t) {
  if (lt(t.prototype[Nr])) {
    const e = t.prototype[Nr];
    t.prototype[Nr] = Cy(
      function() {
        return this.rendered = !1, this.ready;
      },
      Ay(
        Ey(
          async function() {
            return e.apply(this);
          },
          function(r) {
            this.rendered = r !== !1, this.rendered && lt(this[Mn]) && this[Mn]();
          }
        ),
        Ty
      )
    );
  }
  if (lt(t.prototype[Mn])) {
    const e = t.prototype[Mn];
    t.prototype[Mn] = Cy(
      function(r) {
        return r && (this[nt].rendered = !0), this.ready && this[nt].rendered;
      },
      Ay(
        Ey(
          async function(...r) {
            return e.apply(this, r);
          },
          function() {
            this[os]("refresh");
          }
        ),
        Ty
      )
    );
  }
}
function oD(t) {
  ik(t);
  const e = rk(t, {
    style: (...r) => (r.forEach((s) => sk(t, { ...s })), e)
  });
  return e;
}
Fi.RENDER = Nr;
Fi.REFRESH = Mn;
Fi.ONCONNECT = Rf;
Fi.ONDISCONNECT = qf;
var nk = Object.create, jf = Object.defineProperty, ak = Object.getOwnPropertyDescriptor, ok = Object.getOwnPropertyNames, lk = Object.getPrototypeOf, uk = Object.prototype.hasOwnProperty, lD = (t) => {
  throw TypeError(t);
}, ck = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), Xf = (t, e) => {
  for (var r in e) jf(t, r, { get: e[r], enumerable: !0 });
}, hk = (t, e, r, s) => {
  if (e && typeof e == "object" || typeof e == "function") for (let i of ok(e)) !uk.call(t, i) && i !== r && jf(t, i, { get: () => e[i], enumerable: !(s = ak(e, i)) || s.enumerable });
  return t;
}, pk = (t, e, r) => (r = t != null ? nk(lk(t)) : {}, hk(jf(r, "default", { value: t, enumerable: !0 }), t)), dk = (t, e, r) => e.has(t) || lD("Cannot " + r), fk = (t, e, r) => e.has(t) ? lD("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r), za = (t, e, r) => (dk(t, e, "access private method"), r), mk = ck((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e() {
    return new Proxy({}, { get: () => (n) => n });
  }
  var r = /\r\n|[\n\r\u2028\u2029]/;
  function s(n, a, l) {
    let c = Object.assign({ column: 0, line: -1 }, n.start), p = Object.assign({}, c, n.end), { linesAbove: d = 2, linesBelow: m = 3 } = l || {}, y = c.line, g = c.column, x = p.line, v = p.column, w = Math.max(y - (d + 1), 0), C = Math.min(a.length, x + m);
    y === -1 && (w = 0), x === -1 && (C = a.length);
    let b = x - y, k = {};
    if (b) for (let Q = 0; Q <= b; Q++) {
      let F = Q + y;
      if (!g) k[F] = !0;
      else if (Q === 0) {
        let $ = a[F - 1].length;
        k[F] = [g, $ - g + 1];
      } else if (Q === b) k[F] = [0, v];
      else {
        let $ = a[F - Q].length;
        k[F] = [0, $];
      }
    }
    else g === v ? g ? k[y] = [g, 0] : k[y] = !0 : k[y] = [g, v - g];
    return { start: w, end: C, markerLines: k };
  }
  function i(n, a, l = {}) {
    let c = e(), p = n.split(r), { start: d, end: m, markerLines: y } = s(a, p, l), g = a.start && typeof a.start.column == "number", x = String(m).length, v = n.split(r, m).slice(d, m).map((w, C) => {
      let b = d + 1 + C, k = ` ${` ${b}`.slice(-x)} |`, Q = y[b], F = !y[b + 1];
      if (Q) {
        let $ = "";
        if (Array.isArray(Q)) {
          let N = w.slice(0, Math.max(Q[0] - 1, 0)).replace(/[^\t]/g, " "), _ = Q[1] || 1;
          $ = [`
 `, c.gutter(k.replace(/\d/g, " ")), " ", N, c.marker("^").repeat(_)].join(""), F && l.message && ($ += " " + c.message(l.message));
        }
        return [c.marker(">"), c.gutter(k), w.length > 0 ? ` ${w}` : "", $].join("");
      } else return ` ${c.gutter(k)}${w.length > 0 ? ` ${w}` : ""}`;
    }).join(`
`);
    return l.message && !g && (v = `${" ".repeat(x + 1)}${l.message}
${v}`), v;
  }
  t.codeFrameColumns = i;
}), gk = {};
Xf(gk, { __debug: () => k$, check: () => E$, doc: () => VD, format: () => hl, formatWithCursor: () => UD, getSupportInfo: () => T$, util: () => zD, version: () => t$ });
var yk = (t, e, r, s) => {
  if (!(t && e == null)) return e.replaceAll ? e.replaceAll(r, s) : r.global ? e.replace(r, s) : e.split(r).join(s);
}, Xc = yk, Ok = class {
  diff(e, r, s = {}) {
    let i;
    typeof s == "function" ? (i = s, s = {}) : "callback" in s && (i = s.callback);
    let n = this.castInput(e, s), a = this.castInput(r, s), l = this.removeEmpty(this.tokenize(n, s)), c = this.removeEmpty(this.tokenize(a, s));
    return this.diffWithOptionsObj(l, c, s, i);
  }
  diffWithOptionsObj(e, r, s, i) {
    var n;
    let a = (b) => {
      if (b = this.postProcess(b, s), i) {
        setTimeout(function() {
          i(b);
        }, 0);
        return;
      } else return b;
    }, l = r.length, c = e.length, p = 1, d = l + c;
    s.maxEditLength != null && (d = Math.min(d, s.maxEditLength));
    let m = (n = s.timeout) !== null && n !== void 0 ? n : 1 / 0, y = Date.now() + m, g = [{ oldPos: -1, lastComponent: void 0 }], x = this.extractCommon(g[0], r, e, 0, s);
    if (g[0].oldPos + 1 >= c && x + 1 >= l) return a(this.buildValues(g[0].lastComponent, r, e));
    let v = -1 / 0, w = 1 / 0, C = () => {
      for (let b = Math.max(v, -p); b <= Math.min(w, p); b += 2) {
        let k, Q = g[b - 1], F = g[b + 1];
        Q && (g[b - 1] = void 0);
        let $ = !1;
        if (F) {
          let _ = F.oldPos - b;
          $ = F && 0 <= _ && _ < l;
        }
        let N = Q && Q.oldPos + 1 < c;
        if (!$ && !N) {
          g[b] = void 0;
          continue;
        }
        if (!N || $ && Q.oldPos < F.oldPos ? k = this.addToPath(F, !0, !1, 0, s) : k = this.addToPath(Q, !1, !0, 1, s), x = this.extractCommon(k, r, e, b, s), k.oldPos + 1 >= c && x + 1 >= l) return a(this.buildValues(k.lastComponent, r, e)) || !0;
        g[b] = k, k.oldPos + 1 >= c && (w = Math.min(w, b - 1)), x + 1 >= l && (v = Math.max(v, b + 1));
      }
      p++;
    };
    if (i) (function b() {
      setTimeout(function() {
        if (p > d || Date.now() > y) return i(void 0);
        C() || b();
      }, 0);
    })();
    else for (; p <= d && Date.now() <= y; ) {
      let b = C();
      if (b) return b;
    }
  }
  addToPath(e, r, s, i, n) {
    let a = e.lastComponent;
    return a && !n.oneChangePerToken && a.added === r && a.removed === s ? { oldPos: e.oldPos + i, lastComponent: { count: a.count + 1, added: r, removed: s, previousComponent: a.previousComponent } } : { oldPos: e.oldPos + i, lastComponent: { count: 1, added: r, removed: s, previousComponent: a } };
  }
  extractCommon(e, r, s, i, n) {
    let a = r.length, l = s.length, c = e.oldPos, p = c - i, d = 0;
    for (; p + 1 < a && c + 1 < l && this.equals(s[c + 1], r[p + 1], n); ) p++, c++, d++, n.oneChangePerToken && (e.lastComponent = { count: 1, previousComponent: e.lastComponent, added: !1, removed: !1 });
    return d && !n.oneChangePerToken && (e.lastComponent = { count: d, previousComponent: e.lastComponent, added: !1, removed: !1 }), e.oldPos = c, p;
  }
  equals(e, r, s) {
    return s.comparator ? s.comparator(e, r) : e === r || !!s.ignoreCase && e.toLowerCase() === r.toLowerCase();
  }
  removeEmpty(e) {
    let r = [];
    for (let s = 0; s < e.length; s++) e[s] && r.push(e[s]);
    return r;
  }
  castInput(e, r) {
    return e;
  }
  tokenize(e, r) {
    return Array.from(e);
  }
  join(e) {
    return e.join("");
  }
  postProcess(e, r) {
    return e;
  }
  get useLongestToken() {
    return !1;
  }
  buildValues(e, r, s) {
    let i = [], n;
    for (; e; ) i.push(e), n = e.previousComponent, delete e.previousComponent, e = n;
    i.reverse();
    let a = i.length, l = 0, c = 0, p = 0;
    for (; l < a; l++) {
      let d = i[l];
      if (d.removed) d.value = this.join(s.slice(p, p + d.count)), p += d.count;
      else {
        if (!d.added && this.useLongestToken) {
          let m = r.slice(c, c + d.count);
          m = m.map(function(y, g) {
            let x = s[p + g];
            return x.length > y.length ? x : y;
          }), d.value = this.join(m);
        } else d.value = this.join(r.slice(c, c + d.count));
        c += d.count, d.added || (p += d.count);
      }
    }
    return i;
  }
}, xk = class extends Ok {
  tokenize(e) {
    return e.slice();
  }
  join(e) {
    return e;
  }
  removeEmpty(e) {
    return e;
  }
}, Dk = new xk();
function bk(t, e, r) {
  return Dk.diff(t, e, r);
}
function vk(t) {
  let e = t.indexOf("\r");
  return e !== -1 ? t.charAt(e + 1) === `
` ? "crlf" : "cr" : "lf";
}
function Zf(t) {
  switch (t) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
function uD(t, e) {
  let r;
  switch (e) {
    case `
`:
      r = /\n/gu;
      break;
    case "\r":
      r = /\r/gu;
      break;
    case `\r
`:
      r = /\r\n/gu;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(e)}.`);
  }
  let s = t.match(r);
  return s ? s.length : 0;
}
function Sk(t) {
  return Xc(!1, t, /\r\n?/gu, `
`);
}
var On = "string", $s = "array", $i = "cursor", js = "indent", Xs = "align", Zs = "trim", Gt = "group", ms = "fill", ur = "if-break", Vs = "indent-if-break", zs = "line-suffix", Us = "line-suffix-boundary", vt = "line", gs = "label", wr = "break-parent", cD = /* @__PURE__ */ new Set([$i, js, Xs, Zs, Gt, ms, ur, Vs, zs, Us, vt, gs, wr]), wk = (t, e, r) => {
  if (!(t && e == null)) return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, ht = wk;
function Ak(t) {
  let e = t.length;
  for (; e > 0 && (t[e - 1] === "\r" || t[e - 1] === `
`); ) e--;
  return e < t.length ? t.slice(0, e) : t;
}
function Ck(t) {
  if (typeof t == "string") return On;
  if (Array.isArray(t)) return $s;
  if (!t) return;
  let { type: e } = t;
  if (cD.has(e)) return e;
}
var xn = Ck, Ek = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function Tk(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object") return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (xn(t)) throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]") return `Unexpected doc '${r}'.`;
  let s = Ek([...cD].map((i) => `'${i}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${s}.`;
}
var kk = class extends Error {
  constructor(r) {
    super(Tk(r));
    vs(this, "name", "InvalidDocError");
    this.doc = r;
  }
}, ia = kk, Fy = {};
function Pk(t, e, r, s) {
  let i = [t];
  for (; i.length > 0; ) {
    let n = i.pop();
    if (n === Fy) {
      r(i.pop());
      continue;
    }
    r && i.push(n, Fy);
    let a = xn(n);
    if (!a) throw new ia(n);
    if ((e == null ? void 0 : e(n)) !== !1) switch (a) {
      case $s:
      case ms: {
        let l = a === $s ? n : n.parts;
        for (let c = l.length, p = c - 1; p >= 0; --p) i.push(l[p]);
        break;
      }
      case ur:
        i.push(n.flatContents, n.breakContents);
        break;
      case Gt:
        if (s && n.expandedStates) for (let l = n.expandedStates.length, c = l - 1; c >= 0; --c) i.push(n.expandedStates[c]);
        else i.push(n.contents);
        break;
      case Xs:
      case js:
      case Vs:
      case gs:
      case zs:
        i.push(n.contents);
        break;
      case On:
      case $i:
      case Zs:
      case Us:
      case vt:
      case wr:
        break;
      default:
        throw new ia(n);
    }
  }
}
var Vf = Pk;
function Zc(t, e) {
  if (typeof t == "string") return e(t);
  let r = /* @__PURE__ */ new Map();
  return s(t);
  function s(n) {
    if (r.has(n)) return r.get(n);
    let a = i(n);
    return r.set(n, a), a;
  }
  function i(n) {
    switch (xn(n)) {
      case $s:
        return e(n.map(s));
      case ms:
        return e({ ...n, parts: n.parts.map(s) });
      case ur:
        return e({ ...n, breakContents: s(n.breakContents), flatContents: s(n.flatContents) });
      case Gt: {
        let { expandedStates: a, contents: l } = n;
        return a ? (a = a.map(s), l = a[0]) : l = s(l), e({ ...n, contents: l, expandedStates: a });
      }
      case Xs:
      case js:
      case Vs:
      case gs:
      case zs:
        return e({ ...n, contents: s(n.contents) });
      case On:
      case $i:
      case Zs:
      case Us:
      case vt:
      case wr:
        return e(n);
      default:
        throw new ia(n);
    }
  }
}
function zf(t, e, r) {
  let s = r, i = !1;
  function n(a) {
    if (i) return !1;
    let l = e(a);
    l !== void 0 && (i = !0, s = l);
  }
  return Vf(t, n), s;
}
function Fk(t) {
  if (t.type === Gt && t.break || t.type === vt && t.hard || t.type === wr) return !0;
}
function $k(t) {
  return zf(t, Fk, !1);
}
function $y(t) {
  if (t.length > 0) {
    let e = ht(!1, t, -1);
    !e.expandedStates && !e.break && (e.break = "propagated");
  }
  return null;
}
function Qk(t) {
  let e = /* @__PURE__ */ new Set(), r = [];
  function s(n) {
    if (n.type === wr && $y(r), n.type === Gt) {
      if (r.push(n), e.has(n)) return !1;
      e.add(n);
    }
  }
  function i(n) {
    n.type === Gt && r.pop().break && $y(r);
  }
  Vf(t, s, i, !0);
}
function Bk(t) {
  return t.type === vt && !t.hard ? t.soft ? "" : " " : t.type === ur ? t.flatContents : t;
}
function Ik(t) {
  return Zc(t, Bk);
}
function Qy(t) {
  for (t = [...t]; t.length >= 2 && ht(!1, t, -2).type === vt && ht(!1, t, -1).type === wr; ) t.length -= 2;
  if (t.length > 0) {
    let e = yo(ht(!1, t, -1));
    t[t.length - 1] = e;
  }
  return t;
}
function yo(t) {
  switch (xn(t)) {
    case js:
    case Vs:
    case Gt:
    case zs:
    case gs: {
      let e = yo(t.contents);
      return { ...t, contents: e };
    }
    case ur:
      return { ...t, breakContents: yo(t.breakContents), flatContents: yo(t.flatContents) };
    case ms:
      return { ...t, parts: Qy(t.parts) };
    case $s:
      return Qy(t);
    case On:
      return Ak(t);
    case Xs:
    case $i:
    case Zs:
    case Us:
    case vt:
    case wr:
      break;
    default:
      throw new ia(t);
  }
  return t;
}
function hD(t) {
  return yo(Mk(t));
}
function Nk(t) {
  switch (xn(t)) {
    case ms:
      if (t.parts.every((e) => e === "")) return "";
      break;
    case Gt:
      if (!t.contents && !t.id && !t.break && !t.expandedStates) return "";
      if (t.contents.type === Gt && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates) return t.contents;
      break;
    case Xs:
    case js:
    case Vs:
    case zs:
      if (!t.contents) return "";
      break;
    case ur:
      if (!t.flatContents && !t.breakContents) return "";
      break;
    case $s: {
      let e = [];
      for (let r of t) {
        if (!r) continue;
        let [s, ...i] = Array.isArray(r) ? r : [r];
        typeof s == "string" && typeof ht(!1, e, -1) == "string" ? e[e.length - 1] += s : e.push(s), e.push(...i);
      }
      return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
    }
    case On:
    case $i:
    case Zs:
    case Us:
    case vt:
    case gs:
    case wr:
      break;
    default:
      throw new ia(t);
  }
  return t;
}
function Mk(t) {
  return Zc(t, (e) => Nk(e));
}
function Lk(t, e = mD) {
  return Zc(t, (r) => typeof r == "string" ? gD(e, r.split(`
`)) : r);
}
function _k(t) {
  if (t.type === vt) return !0;
}
function Rk(t) {
  return zf(t, _k, !1);
}
function Eu(t, e) {
  return t.type === gs ? { ...t, contents: e(t.contents) } : e(t);
}
var qk = () => {
}, jk = qk;
function Hu(t) {
  return { type: js, contents: t };
}
function na(t, e) {
  return { type: Xs, contents: e, n: t };
}
function pD(t, e = {}) {
  return jk(e.expandedStates), { type: Gt, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function Xk(t) {
  return na(Number.NEGATIVE_INFINITY, t);
}
function Zk(t) {
  return na({ type: "root" }, t);
}
function Vk(t) {
  return na(-1, t);
}
function zk(t, e) {
  return pD(t[0], { ...e, expandedStates: t });
}
function Uk(t) {
  return { type: ms, parts: t };
}
function Yk(t, e = "", r = {}) {
  return { type: ur, breakContents: t, flatContents: e, groupId: r.groupId };
}
function Wk(t, e) {
  return { type: Vs, contents: t, groupId: e.groupId, negate: e.negate };
}
function sd(t) {
  return { type: zs, contents: t };
}
var Gk = { type: Us }, Vc = { type: wr }, Hk = { type: Zs }, Uf = { type: vt, hard: !0 }, dD = { type: vt, hard: !0, literal: !0 }, fD = { type: vt }, Jk = { type: vt, soft: !0 }, sn = [Uf, Vc], mD = [dD, Vc], Ui = { type: $i };
function gD(t, e) {
  let r = [];
  for (let s = 0; s < e.length; s++) s !== 0 && r.push(t), r.push(e[s]);
  return r;
}
function yD(t, e, r) {
  let s = t;
  if (e > 0) {
    for (let i = 0; i < Math.floor(e / r); ++i) s = Hu(s);
    s = na(e % r, s), s = na(Number.NEGATIVE_INFINITY, s);
  }
  return s;
}
function Kk(t, e) {
  return t ? { type: gs, label: t, contents: e } : e;
}
function ws(t) {
  var e;
  if (!t) return "";
  if (Array.isArray(t)) {
    let r = [];
    for (let s of t) if (Array.isArray(s)) r.push(...ws(s));
    else {
      let i = ws(s);
      i !== "" && r.push(i);
    }
    return r;
  }
  return t.type === ur ? { ...t, breakContents: ws(t.breakContents), flatContents: ws(t.flatContents) } : t.type === Gt ? { ...t, contents: ws(t.contents), expandedStates: (e = t.expandedStates) == null ? void 0 : e.map(ws) } : t.type === ms ? { type: "fill", parts: t.parts.map(ws) } : t.contents ? { ...t, contents: ws(t.contents) } : t;
}
function eP(t) {
  let e = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ new Set();
  return s(ws(t));
  function s(n, a, l) {
    var c, p;
    if (typeof n == "string") return JSON.stringify(n);
    if (Array.isArray(n)) {
      let d = n.map(s).filter(Boolean);
      return d.length === 1 ? d[0] : `[${d.join(", ")}]`;
    }
    if (n.type === vt) {
      let d = ((c = l == null ? void 0 : l[a + 1]) == null ? void 0 : c.type) === wr;
      return n.literal ? d ? "literalline" : "literallineWithoutBreakParent" : n.hard ? d ? "hardline" : "hardlineWithoutBreakParent" : n.soft ? "softline" : "line";
    }
    if (n.type === wr) return ((p = l == null ? void 0 : l[a - 1]) == null ? void 0 : p.type) === vt && l[a - 1].hard ? void 0 : "breakParent";
    if (n.type === Zs) return "trim";
    if (n.type === js) return "indent(" + s(n.contents) + ")";
    if (n.type === Xs) return n.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + s(n.contents) + ")" : n.n < 0 ? "dedent(" + s(n.contents) + ")" : n.n.type === "root" ? "markAsRoot(" + s(n.contents) + ")" : "align(" + JSON.stringify(n.n) + ", " + s(n.contents) + ")";
    if (n.type === ur) return "ifBreak(" + s(n.breakContents) + (n.flatContents ? ", " + s(n.flatContents) : "") + (n.groupId ? (n.flatContents ? "" : ', ""') + `, { groupId: ${i(n.groupId)} }` : "") + ")";
    if (n.type === Vs) {
      let d = [];
      n.negate && d.push("negate: true"), n.groupId && d.push(`groupId: ${i(n.groupId)}`);
      let m = d.length > 0 ? `, { ${d.join(", ")} }` : "";
      return `indentIfBreak(${s(n.contents)}${m})`;
    }
    if (n.type === Gt) {
      let d = [];
      n.break && n.break !== "propagated" && d.push("shouldBreak: true"), n.id && d.push(`id: ${i(n.id)}`);
      let m = d.length > 0 ? `, { ${d.join(", ")} }` : "";
      return n.expandedStates ? `conditionalGroup([${n.expandedStates.map((y) => s(y)).join(",")}]${m})` : `group(${s(n.contents)}${m})`;
    }
    if (n.type === ms) return `fill([${n.parts.map((d) => s(d)).join(", ")}])`;
    if (n.type === zs) return "lineSuffix(" + s(n.contents) + ")";
    if (n.type === Us) return "lineSuffixBoundary";
    if (n.type === gs) return `label(${JSON.stringify(n.label)}, ${s(n.contents)})`;
    if (n.type === $i) return "cursor";
    throw new Error("Unknown doc type " + n.type);
  }
  function i(n) {
    if (typeof n != "symbol") return JSON.stringify(String(n));
    if (n in e) return e[n];
    let a = n.description || "symbol";
    for (let l = 0; ; l++) {
      let c = a + (l > 0 ? ` #${l}` : "");
      if (!r.has(c)) return r.add(c), e[n] = `Symbol.for(${JSON.stringify(c)})`;
    }
  }
}
var tP = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function rP(t) {
  return t === 12288 || t >= 65281 && t <= 65376 || t >= 65504 && t <= 65510;
}
function sP(t) {
  return t >= 4352 && t <= 4447 || t === 8986 || t === 8987 || t === 9001 || t === 9002 || t >= 9193 && t <= 9196 || t === 9200 || t === 9203 || t === 9725 || t === 9726 || t === 9748 || t === 9749 || t >= 9776 && t <= 9783 || t >= 9800 && t <= 9811 || t === 9855 || t >= 9866 && t <= 9871 || t === 9875 || t === 9889 || t === 9898 || t === 9899 || t === 9917 || t === 9918 || t === 9924 || t === 9925 || t === 9934 || t === 9940 || t === 9962 || t === 9970 || t === 9971 || t === 9973 || t === 9978 || t === 9981 || t === 9989 || t === 9994 || t === 9995 || t === 10024 || t === 10060 || t === 10062 || t >= 10067 && t <= 10069 || t === 10071 || t >= 10133 && t <= 10135 || t === 10160 || t === 10175 || t === 11035 || t === 11036 || t === 11088 || t === 11093 || t >= 11904 && t <= 11929 || t >= 11931 && t <= 12019 || t >= 12032 && t <= 12245 || t >= 12272 && t <= 12287 || t >= 12289 && t <= 12350 || t >= 12353 && t <= 12438 || t >= 12441 && t <= 12543 || t >= 12549 && t <= 12591 || t >= 12593 && t <= 12686 || t >= 12688 && t <= 12773 || t >= 12783 && t <= 12830 || t >= 12832 && t <= 12871 || t >= 12880 && t <= 42124 || t >= 42128 && t <= 42182 || t >= 43360 && t <= 43388 || t >= 44032 && t <= 55203 || t >= 63744 && t <= 64255 || t >= 65040 && t <= 65049 || t >= 65072 && t <= 65106 || t >= 65108 && t <= 65126 || t >= 65128 && t <= 65131 || t >= 94176 && t <= 94180 || t === 94192 || t === 94193 || t >= 94208 && t <= 100343 || t >= 100352 && t <= 101589 || t >= 101631 && t <= 101640 || t >= 110576 && t <= 110579 || t >= 110581 && t <= 110587 || t === 110589 || t === 110590 || t >= 110592 && t <= 110882 || t === 110898 || t >= 110928 && t <= 110930 || t === 110933 || t >= 110948 && t <= 110951 || t >= 110960 && t <= 111355 || t >= 119552 && t <= 119638 || t >= 119648 && t <= 119670 || t === 126980 || t === 127183 || t === 127374 || t >= 127377 && t <= 127386 || t >= 127488 && t <= 127490 || t >= 127504 && t <= 127547 || t >= 127552 && t <= 127560 || t === 127568 || t === 127569 || t >= 127584 && t <= 127589 || t >= 127744 && t <= 127776 || t >= 127789 && t <= 127797 || t >= 127799 && t <= 127868 || t >= 127870 && t <= 127891 || t >= 127904 && t <= 127946 || t >= 127951 && t <= 127955 || t >= 127968 && t <= 127984 || t === 127988 || t >= 127992 && t <= 128062 || t === 128064 || t >= 128066 && t <= 128252 || t >= 128255 && t <= 128317 || t >= 128331 && t <= 128334 || t >= 128336 && t <= 128359 || t === 128378 || t === 128405 || t === 128406 || t === 128420 || t >= 128507 && t <= 128591 || t >= 128640 && t <= 128709 || t === 128716 || t >= 128720 && t <= 128722 || t >= 128725 && t <= 128727 || t >= 128732 && t <= 128735 || t === 128747 || t === 128748 || t >= 128756 && t <= 128764 || t >= 128992 && t <= 129003 || t === 129008 || t >= 129292 && t <= 129338 || t >= 129340 && t <= 129349 || t >= 129351 && t <= 129535 || t >= 129648 && t <= 129660 || t >= 129664 && t <= 129673 || t >= 129679 && t <= 129734 || t >= 129742 && t <= 129756 || t >= 129759 && t <= 129769 || t >= 129776 && t <= 129784 || t >= 131072 && t <= 196605 || t >= 196608 && t <= 262141;
}
var iP = (t) => !(rP(t) || sP(t)), nP = /[^\x20-\x7F]/u;
function aP(t) {
  if (!t) return 0;
  if (!nP.test(t)) return t.length;
  t = t.replace(tP(), "  ");
  let e = 0;
  for (let r of t) {
    let s = r.codePointAt(0);
    s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (e += iP(s) ? 1 : 2);
  }
  return e;
}
var Yf = aP, qt = Symbol("MODE_BREAK"), Gr = Symbol("MODE_FLAT"), Xn = Symbol("cursor"), id = Symbol("DOC_FILL_PRINTED_LENGTH");
function OD() {
  return { value: "", length: 0, queue: [] };
}
function oP(t, e) {
  return nd(t, { type: "indent" }, e);
}
function lP(t, e, r) {
  return e === Number.NEGATIVE_INFINITY ? t.root || OD() : e < 0 ? nd(t, { type: "dedent" }, r) : e ? e.type === "root" ? { ...t, root: t } : nd(t, { type: typeof e == "string" ? "stringAlign" : "numberAlign", n: e }, r) : t;
}
function nd(t, e, r) {
  let s = e.type === "dedent" ? t.queue.slice(0, -1) : [...t.queue, e], i = "", n = 0, a = 0, l = 0;
  for (let x of s) switch (x.type) {
    case "indent":
      d(), r.useTabs ? c(1) : p(r.tabWidth);
      break;
    case "stringAlign":
      d(), i += x.n, n += x.n.length;
      break;
    case "numberAlign":
      a += 1, l += x.n;
      break;
    default:
      throw new Error(`Unexpected type '${x.type}'`);
  }
  return y(), { ...t, value: i, length: n, queue: s };
  function c(x) {
    i += "	".repeat(x), n += r.tabWidth * x;
  }
  function p(x) {
    i += " ".repeat(x), n += x;
  }
  function d() {
    r.useTabs ? m() : y();
  }
  function m() {
    a > 0 && c(a), g();
  }
  function y() {
    l > 0 && p(l), g();
  }
  function g() {
    a = 0, l = 0;
  }
}
function ad(t) {
  let e = 0, r = 0, s = t.length;
  e: for (; s--; ) {
    let i = t[s];
    if (i === Xn) {
      r++;
      continue;
    }
    for (let n = i.length - 1; n >= 0; n--) {
      let a = i[n];
      if (a === " " || a === "	") e++;
      else {
        t[s] = i.slice(0, n + 1);
        break e;
      }
    }
  }
  if (e > 0 || r > 0) for (t.length = s + 1; r-- > 0; ) t.push(Xn);
  return e;
}
function Xl(t, e, r, s, i, n) {
  var p;
  if (r === Number.POSITIVE_INFINITY) return !0;
  let a = e.length, l = [t], c = [];
  for (; r >= 0; ) {
    if (l.length === 0) {
      if (a === 0) return !0;
      l.push(e[--a]);
      continue;
    }
    let { mode: d, doc: m } = l.pop(), y = xn(m);
    switch (y) {
      case On:
        c.push(m), r -= Yf(m);
        break;
      case $s:
      case ms: {
        let g = y === $s ? m : m.parts, x = (p = m[id]) != null ? p : 0;
        for (let v = g.length - 1; v >= x; v--) l.push({ mode: d, doc: g[v] });
        break;
      }
      case js:
      case Xs:
      case Vs:
      case gs:
        l.push({ mode: d, doc: m.contents });
        break;
      case Zs:
        r += ad(c);
        break;
      case Gt: {
        if (n && m.break) return !1;
        let g = m.break ? qt : d, x = m.expandedStates && g === qt ? ht(!1, m.expandedStates, -1) : m.contents;
        l.push({ mode: g, doc: x });
        break;
      }
      case ur: {
        let g = (m.groupId ? i[m.groupId] || Gr : d) === qt ? m.breakContents : m.flatContents;
        g && l.push({ mode: d, doc: g });
        break;
      }
      case vt:
        if (d === qt || m.hard) return !0;
        m.soft || (c.push(" "), r--);
        break;
      case zs:
        s = !0;
        break;
      case Us:
        if (s) return !1;
        break;
    }
  }
  return !1;
}
function zc(t, e) {
  var y;
  let r = {}, s = e.printWidth, i = Zf(e.endOfLine), n = 0, a = [{ ind: OD(), mode: qt, doc: t }], l = [], c = !1, p = [], d = 0;
  for (Qk(t); a.length > 0; ) {
    let { ind: g, mode: x, doc: v } = a.pop();
    switch (xn(v)) {
      case On: {
        let w = i !== `
` ? Xc(!1, v, `
`, i) : v;
        l.push(w), a.length > 0 && (n += Yf(w));
        break;
      }
      case $s:
        for (let w = v.length - 1; w >= 0; w--) a.push({ ind: g, mode: x, doc: v[w] });
        break;
      case $i:
        if (d >= 2) throw new Error("There are too many 'cursor' in doc.");
        l.push(Xn), d++;
        break;
      case js:
        a.push({ ind: oP(g, e), mode: x, doc: v.contents });
        break;
      case Xs:
        a.push({ ind: lP(g, v.n, e), mode: x, doc: v.contents });
        break;
      case Zs:
        n -= ad(l);
        break;
      case Gt:
        switch (x) {
          case Gr:
            if (!c) {
              a.push({ ind: g, mode: v.break ? qt : Gr, doc: v.contents });
              break;
            }
          case qt: {
            c = !1;
            let w = { ind: g, mode: Gr, doc: v.contents }, C = s - n, b = p.length > 0;
            if (!v.break && Xl(w, a, C, b, r)) a.push(w);
            else if (v.expandedStates) {
              let k = ht(!1, v.expandedStates, -1);
              if (v.break) {
                a.push({ ind: g, mode: qt, doc: k });
                break;
              } else for (let Q = 1; Q < v.expandedStates.length + 1; Q++) if (Q >= v.expandedStates.length) {
                a.push({ ind: g, mode: qt, doc: k });
                break;
              } else {
                let F = v.expandedStates[Q], $ = { ind: g, mode: Gr, doc: F };
                if (Xl($, a, C, b, r)) {
                  a.push($);
                  break;
                }
              }
            } else a.push({ ind: g, mode: qt, doc: v.contents });
            break;
          }
        }
        v.id && (r[v.id] = ht(!1, a, -1).mode);
        break;
      case ms: {
        let w = s - n, C = (y = v[id]) != null ? y : 0, { parts: b } = v, k = b.length - C;
        if (k === 0) break;
        let Q = b[C + 0], F = b[C + 1], $ = { ind: g, mode: Gr, doc: Q }, N = { ind: g, mode: qt, doc: Q }, _ = Xl($, [], w, p.length > 0, r, !0);
        if (k === 1) {
          _ ? a.push($) : a.push(N);
          break;
        }
        let W = { ind: g, mode: Gr, doc: F }, V = { ind: g, mode: qt, doc: F };
        if (k === 2) {
          _ ? a.push(W, $) : a.push(V, N);
          break;
        }
        let j = b[C + 2], B = { ind: g, mode: x, doc: { ...v, [id]: C + 2 } };
        Xl({ ind: g, mode: Gr, doc: [Q, F, j] }, [], w, p.length > 0, r, !0) ? a.push(B, W, $) : _ ? a.push(B, V, $) : a.push(B, V, N);
        break;
      }
      case ur:
      case Vs: {
        let w = v.groupId ? r[v.groupId] : x;
        if (w === qt) {
          let C = v.type === ur ? v.breakContents : v.negate ? v.contents : Hu(v.contents);
          C && a.push({ ind: g, mode: x, doc: C });
        }
        if (w === Gr) {
          let C = v.type === ur ? v.flatContents : v.negate ? Hu(v.contents) : v.contents;
          C && a.push({ ind: g, mode: x, doc: C });
        }
        break;
      }
      case zs:
        p.push({ ind: g, mode: x, doc: v.contents });
        break;
      case Us:
        p.length > 0 && a.push({ ind: g, mode: x, doc: Uf });
        break;
      case vt:
        switch (x) {
          case Gr:
            if (v.hard) c = !0;
            else {
              v.soft || (l.push(" "), n += 1);
              break;
            }
          case qt:
            if (p.length > 0) {
              a.push({ ind: g, mode: x, doc: v }, ...p.reverse()), p.length = 0;
              break;
            }
            v.literal ? g.root ? (l.push(i, g.root.value), n = g.root.length) : (l.push(i), n = 0) : (n -= ad(l), l.push(i + g.value), n = g.length);
            break;
        }
        break;
      case gs:
        a.push({ ind: g, mode: x, doc: v.contents });
        break;
      case wr:
        break;
      default:
        throw new ia(v);
    }
    a.length === 0 && p.length > 0 && (a.push(...p.reverse()), p.length = 0);
  }
  let m = l.indexOf(Xn);
  if (m !== -1) {
    let g = l.indexOf(Xn, m + 1);
    if (g === -1) return { formatted: l.filter((C) => C !== Xn).join("") };
    let x = l.slice(0, m).join(""), v = l.slice(m + 1, g).join(""), w = l.slice(g + 1).join("");
    return { formatted: x + v + w, cursorNodeStart: x.length, cursorNodeText: v };
  }
  return { formatted: l.join("") };
}
function uP(t, e, r = 0) {
  let s = 0;
  for (let i = r; i < t.length; ++i) t[i] === "	" ? s = s + e - s % e : s++;
  return s;
}
var Wf = uP, ji, od, Tu, cP = class {
  constructor(e) {
    fk(this, ji), this.stack = [e];
  }
  get key() {
    var s;
    let { stack: e, siblings: r } = this;
    return (s = ht(!1, e, r === null ? -2 : -4)) != null ? s : null;
  }
  get index() {
    return this.siblings === null ? null : ht(!1, this.stack, -2);
  }
  get node() {
    return ht(!1, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: e } = this, r = ht(!1, e, -3);
    return Array.isArray(r) ? r : null;
  }
  get next() {
    let { siblings: e } = this;
    return e === null ? null : e[this.index + 1];
  }
  get previous() {
    let { siblings: e } = this;
    return e === null ? null : e[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: e, index: r } = this;
    return e !== null && r === e.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...za(this, ji, Tu).call(this)];
  }
  getName() {
    let { stack: e } = this, { length: r } = e;
    return r > 1 ? ht(!1, e, -2) : null;
  }
  getValue() {
    return ht(!1, this.stack, -1);
  }
  getNode(e = 0) {
    let r = za(this, ji, od).call(this, e);
    return r === -1 ? null : this.stack[r];
  }
  getParentNode(e = 0) {
    return this.getNode(e + 1);
  }
  call(e, ...r) {
    let { stack: s } = this, { length: i } = s, n = ht(!1, s, -1);
    for (let a of r) n = n[a], s.push(a, n);
    try {
      return e(this);
    } finally {
      s.length = i;
    }
  }
  callParent(e, r = 0) {
    let s = za(this, ji, od).call(this, r + 1), i = this.stack.splice(s + 1);
    try {
      return e(this);
    } finally {
      this.stack.push(...i);
    }
  }
  each(e, ...r) {
    let { stack: s } = this, { length: i } = s, n = ht(!1, s, -1);
    for (let a of r) n = n[a], s.push(a, n);
    try {
      for (let a = 0; a < n.length; ++a) s.push(a, n[a]), e(this, a, n), s.length -= 2;
    } finally {
      s.length = i;
    }
  }
  map(e, ...r) {
    let s = [];
    return this.each((i, n, a) => {
      s[n] = e(i, n, a);
    }, ...r), s;
  }
  match(...e) {
    let r = this.stack.length - 1, s = null, i = this.stack[r--];
    for (let n of e) {
      if (i === void 0) return !1;
      let a = null;
      if (typeof s == "number" && (a = s, s = this.stack[r--], i = this.stack[r--]), n && !n(i, s, a)) return !1;
      s = this.stack[r--], i = this.stack[r--];
    }
    return !0;
  }
  findAncestor(e) {
    for (let r of za(this, ji, Tu).call(this)) if (e(r)) return r;
  }
  hasAncestor(e) {
    for (let r of za(this, ji, Tu).call(this)) if (e(r)) return !0;
    return !1;
  }
};
ji = /* @__PURE__ */ new WeakSet(), od = function(t) {
  let { stack: e } = this;
  for (let r = e.length - 1; r >= 0; r -= 2) if (!Array.isArray(e[r]) && --t < 0) return r;
  return -1;
}, Tu = function* () {
  let { stack: t } = this;
  for (let e = t.length - 3; e >= 0; e -= 2) {
    let r = t[e];
    Array.isArray(r) || (yield r);
  }
};
var hP = cP, xD = new Proxy(() => {
}, { get: () => xD }), ld = xD;
function pP(t) {
  return t !== null && typeof t == "object";
}
var dP = pP;
function* Uc(t, e) {
  let { getVisitorKeys: r, filter: s = () => !0 } = e, i = (n) => dP(n) && s(n);
  for (let n of r(t)) {
    let a = t[n];
    if (Array.isArray(a)) for (let l of a) i(l) && (yield l);
    else i(a) && (yield a);
  }
}
function* fP(t, e) {
  let r = [t];
  for (let s = 0; s < r.length; s++) {
    let i = r[s];
    for (let n of Uc(i, e)) yield n, r.push(n);
  }
}
function mP(t, e) {
  return Uc(t, e).next().done;
}
function ul(t) {
  return (e, r, s) => {
    let i = !!(s != null && s.backwards);
    if (r === !1) return !1;
    let { length: n } = e, a = r;
    for (; a >= 0 && a < n; ) {
      let l = e.charAt(a);
      if (t instanceof RegExp) {
        if (!t.test(l)) return a;
      } else if (!t.includes(l)) return a;
      i ? a-- : a++;
    }
    return a === -1 || a === n ? a : !1;
  };
}
var gP = ul(/\s/u), vi = ul(" 	"), DD = ul(",; 	"), bD = ul(/[^\n\r]/u);
function yP(t, e, r) {
  let s = !!(r != null && r.backwards);
  if (e === !1) return !1;
  let i = t.charAt(e);
  if (s) {
    if (t.charAt(e - 1) === "\r" && i === `
`) return e - 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return e - 1;
  } else {
    if (i === "\r" && t.charAt(e + 1) === `
`) return e + 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return e + 1;
  }
  return e;
}
var on = yP;
function OP(t, e, r = {}) {
  let s = vi(t, r.backwards ? e - 1 : e, r), i = on(t, s, r);
  return s !== i;
}
var Di = OP;
function xP(t) {
  return Array.isArray(t) && t.length > 0;
}
var DP = xP, vD = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]), bP = (t) => Object.keys(t).filter((e) => !vD.has(e));
function vP(t) {
  return t ? (e) => t(e, vD) : bP;
}
var Yc = vP;
function SP(t) {
  let e = t.type || t.kind || "(unknown type)", r = String(t.name || t.id && (typeof t.id == "object" ? t.id.name : t.id) || t.key && (typeof t.key == "object" ? t.key.name : t.key) || t.value && (typeof t.value == "object" ? "" : String(t.value)) || t.operator || "");
  return r.length > 20 && (r = r.slice(0, 19) + ""), e + (r ? " " + r : "");
}
function Gf(t, e) {
  var r;
  ((r = t.comments) != null ? r : t.comments = []).push(e), e.printed = !1, e.nodeDescription = SP(t);
}
function Oo(t, e) {
  e.leading = !0, e.trailing = !1, Gf(t, e);
}
function Xi(t, e, r) {
  e.leading = !1, e.trailing = !1, r && (e.marker = r), Gf(t, e);
}
function xo(t, e) {
  e.leading = !1, e.trailing = !0, Gf(t, e);
}
var zh = /* @__PURE__ */ new WeakMap();
function Hf(t, e) {
  var c;
  if (zh.has(t)) return zh.get(t);
  let { printer: { getCommentChildNodes: r, canAttachComment: s, getVisitorKeys: i }, locStart: n, locEnd: a } = e;
  if (!s) return [];
  let l = ((c = r == null ? void 0 : r(t, e)) != null ? c : [...Uc(t, { getVisitorKeys: Yc(i) })]).flatMap((p) => s(p) ? [p] : Hf(p, e));
  return l.sort((p, d) => n(p) - n(d) || a(p) - a(d)), zh.set(t, l), l;
}
function SD(t, e, r, s) {
  let { locStart: i, locEnd: n } = r, a = i(e), l = n(e), c = Hf(t, r), p, d, m = 0, y = c.length;
  for (; m < y; ) {
    let g = m + y >> 1, x = c[g], v = i(x), w = n(x);
    if (v <= a && l <= w) return SD(x, e, r, x);
    if (w <= a) {
      p = x, m = g + 1;
      continue;
    }
    if (l <= v) {
      d = x, y = g;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((s == null ? void 0 : s.type) === "TemplateLiteral") {
    let { quasis: g } = s, x = Yh(g, e, r);
    p && Yh(g, p, r) !== x && (p = null), d && Yh(g, d, r) !== x && (d = null);
  }
  return { enclosingNode: s, precedingNode: p, followingNode: d };
}
var Uh = () => !1;
function wP(t, e) {
  let { comments: r } = t;
  if (delete t.comments, !DP(r) || !e.printer.canAttachComment) return;
  let s = [], { printer: { experimentalFeatures: { avoidAstMutation: i = !1 } = {}, handleComments: n = {} }, originalText: a } = e, { ownLine: l = Uh, endOfLine: c = Uh, remaining: p = Uh } = n, d = r.map((m, y) => ({ ...SD(t, m, e), comment: m, text: a, options: e, ast: t, isLastComment: r.length - 1 === y }));
  for (let [m, y] of d.entries()) {
    let { comment: g, precedingNode: x, enclosingNode: v, followingNode: w, text: C, options: b, ast: k, isLastComment: Q } = y, F;
    if (i ? F = [y] : (g.enclosingNode = v, g.precedingNode = x, g.followingNode = w, F = [g, C, b, k, Q]), AP(C, b, d, m)) g.placement = "ownLine", l(...F) || (w ? Oo(w, g) : x ? xo(x, g) : Xi(v || k, g));
    else if (CP(C, b, d, m)) g.placement = "endOfLine", c(...F) || (x ? xo(x, g) : w ? Oo(w, g) : Xi(v || k, g));
    else if (g.placement = "remaining", !p(...F)) if (x && w) {
      let $ = s.length;
      $ > 0 && s[$ - 1].followingNode !== w && By(s, b), s.push(y);
    } else x ? xo(x, g) : w ? Oo(w, g) : Xi(v || k, g);
  }
  if (By(s, e), !i) for (let m of r) delete m.precedingNode, delete m.enclosingNode, delete m.followingNode;
}
var wD = (t) => !/[\S\n\u2028\u2029]/u.test(t);
function AP(t, e, r, s) {
  let { comment: i, precedingNode: n } = r[s], { locStart: a, locEnd: l } = e, c = a(i);
  if (n) for (let p = s - 1; p >= 0; p--) {
    let { comment: d, precedingNode: m } = r[p];
    if (m !== n || !wD(t.slice(l(d), c))) break;
    c = a(d);
  }
  return Di(t, c, { backwards: !0 });
}
function CP(t, e, r, s) {
  let { comment: i, followingNode: n } = r[s], { locStart: a, locEnd: l } = e, c = l(i);
  if (n) for (let p = s + 1; p < r.length; p++) {
    let { comment: d, followingNode: m } = r[p];
    if (m !== n || !wD(t.slice(c, a(d)))) break;
    c = l(d);
  }
  return Di(t, c);
}
function By(t, e) {
  var p;
  var r, s;
  let i = t.length;
  if (i === 0) return;
  let { precedingNode: n, followingNode: a } = t[0], l = e.locStart(a), c;
  for (c = i; c > 0; --c) {
    let { comment: d, precedingNode: m, followingNode: y } = t[c - 1];
    ld.strictEqual(m, n), ld.strictEqual(y, a);
    let g = e.originalText.slice(e.locEnd(d), l);
    if ((p = (s = (r = e.printer).isGap) == null ? void 0 : s.call(r, g, e)) != null ? p : /^[\s(]*$/u.test(g)) l = e.locStart(d);
    else break;
  }
  for (let [d, { comment: m }] of t.entries()) d < c ? xo(n, m) : Oo(a, m);
  for (let d of [n, a]) d.comments && d.comments.length > 1 && d.comments.sort((m, y) => e.locStart(m) - e.locStart(y));
  t.length = 0;
}
function Yh(t, e, r) {
  let s = r.locStart(e) - 1;
  for (let i = 1; i < t.length; ++i) if (s < r.locStart(t[i])) return i - 1;
  return 0;
}
function EP(t, e) {
  let r = e - 1;
  r = vi(t, r, { backwards: !0 }), r = on(t, r, { backwards: !0 }), r = vi(t, r, { backwards: !0 });
  let s = on(t, r, { backwards: !0 });
  return r !== s;
}
var Jf = EP;
function AD(t, e) {
  let r = t.node;
  return r.printed = !0, e.printer.printComment(t, e);
}
function TP(t, e) {
  var r;
  let s = t.node, i = [AD(t, e)], { printer: n, originalText: a, locStart: l, locEnd: c } = e;
  if ((r = n.isBlockComment) != null && r.call(n, s)) {
    let d = Di(a, c(s)) ? Di(a, l(s), { backwards: !0 }) ? sn : fD : " ";
    i.push(d);
  } else i.push(sn);
  let p = on(a, vi(a, c(s)));
  return p !== !1 && Di(a, p) && i.push(sn), i;
}
function kP(t, e, r) {
  var s;
  let i = t.node, n = AD(t, e), { printer: a, originalText: l, locStart: c } = e, p = (s = a.isBlockComment) == null ? void 0 : s.call(a, i);
  if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || Di(l, c(i), { backwards: !0 })) {
    let d = Jf(l, c(i));
    return { doc: sd([sn, d ? sn : "", n]), isBlock: p, hasLineSuffix: !0 };
  }
  return !p || r != null && r.hasLineSuffix ? { doc: [sd([" ", n]), Vc], isBlock: p, hasLineSuffix: !0 } : { doc: [" ", n], isBlock: p, hasLineSuffix: !1 };
}
function PP(t, e) {
  let r = t.node;
  if (!r) return {};
  let s = e[Symbol.for("printedComments")];
  if ((r.comments || []).filter((l) => !s.has(l)).length === 0) return { leading: "", trailing: "" };
  let i = [], n = [], a;
  return t.each(() => {
    let l = t.node;
    if (s != null && s.has(l)) return;
    let { leading: c, trailing: p } = l;
    c ? i.push(TP(t, e)) : p && (a = kP(t, e, a), n.push(a.doc));
  }, "comments"), { leading: i, trailing: n };
}
function FP(t, e, r) {
  let { leading: s, trailing: i } = PP(t, r);
  return !s && !i ? e : Eu(e, (n) => [s, n, i]);
}
function $P(t) {
  let { [Symbol.for("comments")]: e, [Symbol.for("printedComments")]: r } = t;
  for (let s of e) {
    if (!s.printed && !r.has(s)) throw new Error('Comment "' + s.value.trim() + '" was not printed. Please report this error!');
    delete s.printed;
  }
}
var CD = class extends Error {
  constructor() {
    super(...arguments);
    vs(this, "name", "ConfigError");
  }
}, Iy = class extends Error {
  constructor() {
    super(...arguments);
    vs(this, "name", "UndefinedParserError");
  }
}, QP = { checkIgnorePragma: { category: "Special", type: "boolean", default: !1, description: "Check whether the file's first docblock comment contains '@noprettier' or '@noformat' to determine if it should be formatted.", cliCategory: "Other" }, cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: !1, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (t) => typeof t == "string" || typeof t == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }, { value: "mjml", description: "MJML" }] }, plugins: { type: "path", array: !0, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (t) => typeof t == "string" || typeof t == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: !1, description: "Require either '@prettier' or '@format' to be present in the file's first docblock comment in order for it to be formatted.", cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: !1, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
function ED({ plugins: t = [], showDeprecated: e = !1 } = {}) {
  let r = t.flatMap((i) => {
    var n;
    return (n = i.languages) != null ? n : [];
  }), s = [];
  for (let i of IP(Object.assign({}, ...t.map(({ options: n }) => n), QP))) !e && i.deprecated || (Array.isArray(i.choices) && (e || (i.choices = i.choices.filter((n) => !n.deprecated)), i.name === "parser" && (i.choices = [...i.choices, ...BP(i.choices, r, t)])), i.pluginDefaults = Object.fromEntries(t.filter((n) => {
    var a;
    return ((a = n.defaultOptions) == null ? void 0 : a[i.name]) !== void 0;
  }).map((n) => [n.name, n.defaultOptions[i.name]])), s.push(i));
  return { languages: r, options: s };
}
function* BP(t, e, r) {
  let s = new Set(t.map((i) => i.value));
  for (let i of e) if (i.parsers) {
    for (let n of i.parsers) if (!s.has(n)) {
      s.add(n);
      let a = r.find((c) => c.parsers && Object.prototype.hasOwnProperty.call(c.parsers, n)), l = i.name;
      a != null && a.name && (l += ` (plugin: ${a.name})`), yield { value: n, description: l };
    }
  }
}
function IP(t) {
  let e = [];
  for (let [r, s] of Object.entries(t)) {
    let i = { name: r, ...s };
    Array.isArray(i.default) && (i.default = ht(!1, i.default, -1).value), e.push(i);
  }
  return e;
}
var NP = (t, e) => {
  if (!(t && e == null)) return e.toReversed || !Array.isArray(e) ? e.toReversed() : [...e].reverse();
}, MP = NP, Ny, My, Ly, _y, Ry, LP = ((Ny = globalThis.Deno) == null ? void 0 : Ny.build.os) === "windows" || ((Ly = (My = globalThis.navigator) == null ? void 0 : My.platform) == null ? void 0 : Ly.startsWith("Win")) || ((Ry = (_y = globalThis.process) == null ? void 0 : _y.platform) == null ? void 0 : Ry.startsWith("win")) || !1;
function TD(t) {
  if (t = t instanceof URL ? t : new URL(t), t.protocol !== "file:") throw new TypeError(`URL must be a file URL: received "${t.protocol}"`);
  return t;
}
function _P(t) {
  return t = TD(t), decodeURIComponent(t.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function RP(t) {
  t = TD(t);
  let e = decodeURIComponent(t.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  return t.hostname !== "" && (e = `\\\\${t.hostname}${e}`), e;
}
function qP(t) {
  return LP ? RP(t) : _P(t);
}
var jP = qP, XP = (t) => String(t).split(/[/\\]/u).pop();
function qy(t, e) {
  var s;
  if (!e) return;
  let r = XP(e).toLowerCase();
  return (s = t.find(({ filenames: i }) => i == null ? void 0 : i.some((n) => n.toLowerCase() === r))) != null ? s : t.find(({ extensions: i }) => i == null ? void 0 : i.some((n) => r.endsWith(n)));
}
function ZP(t, e) {
  var r, s;
  if (e) return (s = (r = t.find(({ name: i }) => i.toLowerCase() === e)) != null ? r : t.find(({ aliases: i }) => i == null ? void 0 : i.includes(e))) != null ? s : t.find(({ extensions: i }) => i == null ? void 0 : i.includes(`.${e}`));
}
function jy(t, e) {
  if (e) {
    if (String(e).startsWith("file:")) try {
      e = jP(e);
    } catch {
      return;
    }
    if (typeof e == "string") return t.find(({ isSupported: r }) => r == null ? void 0 : r({ filepath: e }));
  }
}
function VP(t, e) {
  var i, n, a, l, c;
  let r = MP(!1, t.plugins).flatMap((p) => {
    var d;
    return (d = p.languages) != null ? d : [];
  }), s = (c = (l = (a = (n = (i = ZP(r, e.language)) != null ? i : qy(r, e.physicalFile)) != null ? n : qy(r, e.file)) != null ? a : jy(r, e.physicalFile)) != null ? l : jy(r, e.file)) != null ? c : (e.physicalFile, void 0);
  return s == null ? void 0 : s.parsers[0];
}
var zP = VP, Zn = { key: (t) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(t) ? t : JSON.stringify(t), value(t) {
  if (t === null || typeof t != "object") return JSON.stringify(t);
  if (Array.isArray(t)) return `[${t.map((r) => Zn.value(r)).join(", ")}]`;
  let e = Object.keys(t);
  return e.length === 0 ? "{}" : `{ ${e.map((r) => `${Zn.key(r)}: ${Zn.value(t[r])}`).join(", ")} }`;
}, pair: ({ key: t, value: e }) => Zn.value({ [t]: e }) }, kD = new Proxy(String, { get: () => kD }), rs = kD, UP = (t, e, { descriptor: r }) => {
  let s = [`${rs.yellow(typeof t == "string" ? r.key(t) : r.pair(t))} is deprecated`];
  return e && s.push(`we now treat it as ${rs.blue(typeof e == "string" ? r.key(e) : r.pair(e))}`), s.join("; ") + ".";
}, PD = Symbol.for("vnopts.VALUE_NOT_EXIST"), ku = Symbol.for("vnopts.VALUE_UNCHANGED"), Xy = " ".repeat(2), YP = (t, e, r) => {
  let { text: s, list: i } = r.normalizeExpectedResult(r.schemas[t].expected(r)), n = [];
  return s && n.push(Zy(t, e, s, r.descriptor)), i && n.push([Zy(t, e, i.title, r.descriptor)].concat(i.values.map((a) => FD(a, r.loggerPrintWidth))).join(`
`)), $D(n, r.loggerPrintWidth);
};
function Zy(t, e, r, s) {
  return [`Invalid ${rs.red(s.key(t))} value.`, `Expected ${rs.blue(r)},`, `but received ${e === PD ? rs.gray("nothing") : rs.red(s.value(e))}.`].join(" ");
}
function FD({ text: t, list: e }, r) {
  let s = [];
  return t && s.push(`- ${rs.blue(t)}`), e && s.push([`- ${rs.blue(e.title)}:`].concat(e.values.map((i) => FD(i, r - Xy.length).replace(/^|\n/g, `$&${Xy}`))).join(`
`)), $D(s, r);
}
function $D(t, e) {
  if (t.length === 1) return t[0];
  let [r, s] = t, [i, n] = t.map((a) => a.split(`
`, 1)[0].length);
  return i > e && i > n ? s : r;
}
var Wh = [], Vy = [];
function WP(t, e) {
  if (t === e) return 0;
  let r = t;
  t.length > e.length && (t = e, e = r);
  let s = t.length, i = e.length;
  for (; s > 0 && t.charCodeAt(~-s) === e.charCodeAt(~-i); ) s--, i--;
  let n = 0;
  for (; n < s && t.charCodeAt(n) === e.charCodeAt(n); ) n++;
  if (s -= n, i -= n, s === 0) return i;
  let a, l, c, p, d = 0, m = 0;
  for (; d < s; ) Vy[d] = t.charCodeAt(n + d), Wh[d] = ++d;
  for (; m < i; ) for (a = e.charCodeAt(n + m), c = m++, l = m, d = 0; d < s; d++) p = a === Vy[d] ? c : c + 1, c = Wh[d], l = Wh[d] = c > l ? p > l ? l + 1 : p : p > c ? c + 1 : p;
  return l;
}
var QD = (t, e, { descriptor: r, logger: s, schemas: i }) => {
  let n = [`Ignored unknown option ${rs.yellow(r.pair({ key: t, value: e }))}.`], a = Object.keys(i).sort().find((l) => WP(t, l) < 3);
  a && n.push(`Did you mean ${rs.blue(r.key(a))}?`), s.warn(n.join(" "));
}, GP = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
function HP(t, e) {
  let r = new t(e), s = Object.create(r);
  for (let i of GP) i in e && (s[i] = JP(e[i], r, Qi.prototype[i].length));
  return s;
}
var Qi = class {
  static create(e) {
    return HP(this, e);
  }
  constructor(e) {
    this.name = e.name;
  }
  default(e) {
  }
  expected(e) {
    return "nothing";
  }
  validate(e, r) {
    return !1;
  }
  deprecated(e, r) {
    return !1;
  }
  forward(e, r) {
  }
  redirect(e, r) {
  }
  overlap(e, r, s) {
    return e;
  }
  preprocess(e, r) {
    return e;
  }
  postprocess(e, r) {
    return ku;
  }
};
function JP(t, e, r) {
  return typeof t == "function" ? (...s) => t(...s.slice(0, r - 1), e, ...s.slice(r - 1)) : () => t;
}
var KP = class extends Qi {
  constructor(e) {
    super(e), this._sourceName = e.sourceName;
  }
  expected(e) {
    return e.schemas[this._sourceName].expected(e);
  }
  validate(e, r) {
    return r.schemas[this._sourceName].validate(e, r);
  }
  redirect(e, r) {
    return this._sourceName;
  }
}, eF = class extends Qi {
  expected() {
    return "anything";
  }
  validate() {
    return !0;
  }
}, tF = class extends Qi {
  constructor({ valueSchema: e, name: r = e.name, ...s }) {
    super({ ...s, name: r }), this._valueSchema = e;
  }
  expected(e) {
    let { text: r, list: s } = e.normalizeExpectedResult(this._valueSchema.expected(e));
    return { text: r && `an array of ${r}`, list: s && { title: "an array of the following values", values: [{ list: s }] } };
  }
  validate(e, r) {
    if (!Array.isArray(e)) return !1;
    let s = [];
    for (let i of e) {
      let n = r.normalizeValidateResult(this._valueSchema.validate(i, r), i);
      n !== !0 && s.push(n.value);
    }
    return s.length === 0 ? !0 : { value: s };
  }
  deprecated(e, r) {
    let s = [];
    for (let i of e) {
      let n = r.normalizeDeprecatedResult(this._valueSchema.deprecated(i, r), i);
      n !== !1 && s.push(...n.map(({ value: a }) => ({ value: [a] })));
    }
    return s;
  }
  forward(e, r) {
    let s = [];
    for (let i of e) {
      let n = r.normalizeForwardResult(this._valueSchema.forward(i, r), i);
      s.push(...n.map(zy));
    }
    return s;
  }
  redirect(e, r) {
    let s = [], i = [];
    for (let n of e) {
      let a = r.normalizeRedirectResult(this._valueSchema.redirect(n, r), n);
      "remain" in a && s.push(a.remain), i.push(...a.redirect.map(zy));
    }
    return s.length === 0 ? { redirect: i } : { redirect: i, remain: s };
  }
  overlap(e, r) {
    return e.concat(r);
  }
};
function zy({ from: t, to: e }) {
  return { from: [t], to: e };
}
var rF = class extends Qi {
  expected() {
    return "true or false";
  }
  validate(e) {
    return typeof e == "boolean";
  }
};
function sF(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let s of t) {
    let i = s[e];
    if (r[i]) throw new Error(`Duplicate ${e} ${JSON.stringify(i)}`);
    r[i] = s;
  }
  return r;
}
function iF(t, e) {
  let r = /* @__PURE__ */ new Map();
  for (let s of t) {
    let i = s[e];
    if (r.has(i)) throw new Error(`Duplicate ${e} ${JSON.stringify(i)}`);
    r.set(i, s);
  }
  return r;
}
function nF() {
  let t = /* @__PURE__ */ Object.create(null);
  return (e) => {
    let r = JSON.stringify(e);
    return t[r] ? !0 : (t[r] = !0, !1);
  };
}
function aF(t, e) {
  let r = [], s = [];
  for (let i of t) e(i) ? r.push(i) : s.push(i);
  return [r, s];
}
function oF(t) {
  return t === Math.floor(t);
}
function lF(t, e) {
  if (t === e) return 0;
  let r = typeof t, s = typeof e, i = ["undefined", "object", "boolean", "number", "string"];
  return r !== s ? i.indexOf(r) - i.indexOf(s) : r !== "string" ? Number(t) - Number(e) : t.localeCompare(e);
}
function uF(t) {
  return (...e) => {
    let r = t(...e);
    return typeof r == "string" ? new Error(r) : r;
  };
}
function Uy(t) {
  return t === void 0 ? {} : t;
}
function BD(t) {
  if (typeof t == "string") return { text: t };
  let { text: e, list: r } = t;
  return cF((e || r) !== void 0, "Unexpected `expected` result, there should be at least one field."), r ? { text: e, list: { title: r.title, values: r.values.map(BD) } } : { text: e };
}
function Yy(t, e) {
  return t === !0 ? !0 : t === !1 ? { value: e } : t;
}
function Wy(t, e, r = !1) {
  return t === !1 ? !1 : t === !0 ? r ? !0 : [{ value: e }] : "value" in t ? [t] : t.length === 0 ? !1 : t;
}
function Gy(t, e) {
  return typeof t == "string" || "key" in t ? { from: e, to: t } : "from" in t ? { from: t.from, to: t.to } : { from: e, to: t.to };
}
function ud(t, e) {
  return t === void 0 ? [] : Array.isArray(t) ? t.map((r) => Gy(r, e)) : [Gy(t, e)];
}
function Hy(t, e) {
  let r = ud(typeof t == "object" && "redirect" in t ? t.redirect : t, e);
  return r.length === 0 ? { remain: e, redirect: r } : typeof t == "object" && "remain" in t ? { remain: t.remain, redirect: r } : { redirect: r };
}
function cF(t, e) {
  if (!t) throw new Error(e);
}
var hF = class extends Qi {
  constructor(e) {
    super(e), this._choices = iF(e.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
  }
  expected({ descriptor: e }) {
    let r = Array.from(this._choices.keys()).map((n) => this._choices.get(n)).filter(({ hidden: n }) => !n).map((n) => n.value).sort(lF).map(e.value), s = r.slice(0, -2), i = r.slice(-2);
    return { text: s.concat(i.join(" or ")).join(", "), list: { title: "one of the following values", values: r } };
  }
  validate(e) {
    return this._choices.has(e);
  }
  deprecated(e) {
    let r = this._choices.get(e);
    return r && r.deprecated ? { value: e } : !1;
  }
  forward(e) {
    let r = this._choices.get(e);
    return r ? r.forward : void 0;
  }
  redirect(e) {
    let r = this._choices.get(e);
    return r ? r.redirect : void 0;
  }
}, pF = class extends Qi {
  expected() {
    return "a number";
  }
  validate(e, r) {
    return typeof e == "number";
  }
}, dF = class extends pF {
  expected() {
    return "an integer";
  }
  validate(e, r) {
    return r.normalizeValidateResult(super.validate(e, r), e) === !0 && oF(e);
  }
}, Jy = class extends Qi {
  expected() {
    return "a string";
  }
  validate(e) {
    return typeof e == "string";
  }
}, fF = Zn, mF = QD, gF = YP, yF = UP, OF = class {
  constructor(e, r) {
    let { logger: s = console, loggerPrintWidth: i = 80, descriptor: n = fF, unknown: a = mF, invalid: l = gF, deprecated: c = yF, missing: p = () => !1, required: d = () => !1, preprocess: m = (g) => g, postprocess: y = () => ku } = r || {};
    this._utils = { descriptor: n, logger: s || { warn: () => {
    } }, loggerPrintWidth: i, schemas: sF(e, "name"), normalizeDefaultResult: Uy, normalizeExpectedResult: BD, normalizeDeprecatedResult: Wy, normalizeForwardResult: ud, normalizeRedirectResult: Hy, normalizeValidateResult: Yy }, this._unknownHandler = a, this._invalidHandler = uF(l), this._deprecatedHandler = c, this._identifyMissing = (g, x) => !(g in x) || p(g, x), this._identifyRequired = d, this._preprocess = m, this._postprocess = y, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = nF();
  }
  normalize(e) {
    let r = {}, s = [this._preprocess(e, this._utils)], i = () => {
      for (; s.length !== 0; ) {
        let n = s.shift(), a = this._applyNormalization(n, r);
        s.push(...a);
      }
    };
    i();
    for (let n of Object.keys(this._utils.schemas)) {
      let a = this._utils.schemas[n];
      if (!(n in r)) {
        let l = Uy(a.default(this._utils));
        "value" in l && s.push({ [n]: l.value });
      }
    }
    i();
    for (let n of Object.keys(this._utils.schemas)) {
      if (!(n in r)) continue;
      let a = this._utils.schemas[n], l = r[n], c = a.postprocess(l, this._utils);
      c !== ku && (this._applyValidation(c, n, a), r[n] = c);
    }
    return this._applyPostprocess(r), this._applyRequiredCheck(r), r;
  }
  _applyNormalization(e, r) {
    let s = [], { knownKeys: i, unknownKeys: n } = this._partitionOptionKeys(e);
    for (let a of i) {
      let l = this._utils.schemas[a], c = l.preprocess(e[a], this._utils);
      this._applyValidation(c, a, l);
      let p = ({ from: y, to: g }) => {
        s.push(typeof g == "string" ? { [g]: y } : { [g.key]: g.value });
      }, d = ({ value: y, redirectTo: g }) => {
        let x = Wy(l.deprecated(y, this._utils), c, !0);
        if (x !== !1) if (x === !0) this._hasDeprecationWarned(a) || this._utils.logger.warn(this._deprecatedHandler(a, g, this._utils));
        else for (let { value: v } of x) {
          let w = { key: a, value: v };
          if (!this._hasDeprecationWarned(w)) {
            let C = typeof g == "string" ? { key: g, value: v } : g;
            this._utils.logger.warn(this._deprecatedHandler(w, C, this._utils));
          }
        }
      };
      ud(l.forward(c, this._utils), c).forEach(p);
      let m = Hy(l.redirect(c, this._utils), c);
      if (m.redirect.forEach(p), "remain" in m) {
        let y = m.remain;
        r[a] = a in r ? l.overlap(r[a], y, this._utils) : y, d({ value: y });
      }
      for (let { from: y, to: g } of m.redirect) d({ value: y, redirectTo: g });
    }
    for (let a of n) {
      let l = e[a];
      this._applyUnknownHandler(a, l, r, (c, p) => {
        s.push({ [c]: p });
      });
    }
    return s;
  }
  _applyRequiredCheck(e) {
    for (let r of Object.keys(this._utils.schemas)) if (this._identifyMissing(r, e) && this._identifyRequired(r)) throw this._invalidHandler(r, PD, this._utils);
  }
  _partitionOptionKeys(e) {
    let [r, s] = aF(Object.keys(e).filter((i) => !this._identifyMissing(i, e)), (i) => i in this._utils.schemas);
    return { knownKeys: r, unknownKeys: s };
  }
  _applyValidation(e, r, s) {
    let i = Yy(s.validate(e, this._utils), e);
    if (i !== !0) throw this._invalidHandler(r, i.value, this._utils);
  }
  _applyUnknownHandler(e, r, s, i) {
    let n = this._unknownHandler(e, r, this._utils);
    if (n) for (let a of Object.keys(n)) {
      if (this._identifyMissing(a, n)) continue;
      let l = n[a];
      a in this._utils.schemas ? i(a, l) : s[a] = l;
    }
  }
  _applyPostprocess(e) {
    let r = this._postprocess(e, this._utils);
    if (r !== ku) {
      if (r.delete) for (let s of r.delete) delete e[s];
      if (r.override) {
        let { knownKeys: s, unknownKeys: i } = this._partitionOptionKeys(r.override);
        for (let n of s) {
          let a = r.override[n];
          this._applyValidation(a, n, this._utils.schemas[n]), e[n] = a;
        }
        for (let n of i) {
          let a = r.override[n];
          this._applyUnknownHandler(n, a, e, (l, c) => {
            let p = this._utils.schemas[l];
            this._applyValidation(c, l, p), e[l] = c;
          });
        }
      }
    }
  }
}, Gh;
function xF(t, e, { logger: r = !1, isCLI: s = !1, passThrough: i = !1, FlagSchema: n, descriptor: a } = {}) {
  if (s) {
    if (!n) throw new Error("'FlagSchema' option is required.");
    if (!a) throw new Error("'descriptor' option is required.");
  } else a = Zn;
  let l = i ? Array.isArray(i) ? (y, g) => i.includes(y) ? { [y]: g } : void 0 : (y, g) => ({ [y]: g }) : (y, g, x) => {
    let { _: v, ...w } = x.schemas;
    return QD(y, g, { ...x, schemas: w });
  }, c = DF(e, { isCLI: s, FlagSchema: n }), p = new OF(c, { logger: r, unknown: l, descriptor: a }), d = r !== !1;
  d && Gh && (p._hasDeprecationWarned = Gh);
  let m = p.normalize(t);
  return d && (Gh = p._hasDeprecationWarned), m;
}
function DF(t, { isCLI: e, FlagSchema: r }) {
  let s = [];
  e && s.push(eF.create({ name: "_" }));
  for (let i of t) s.push(bF(i, { isCLI: e, optionInfos: t, FlagSchema: r })), i.alias && e && s.push(KP.create({ name: i.alias, sourceName: i.name }));
  return s;
}
function bF(t, { isCLI: e, optionInfos: r, FlagSchema: s }) {
  let { name: i } = t, n = { name: i }, a, l = {};
  switch (t.type) {
    case "int":
      a = dF, e && (n.preprocess = Number);
      break;
    case "string":
      a = Jy;
      break;
    case "choice":
      a = hF, n.choices = t.choices.map((c) => c != null && c.redirect ? { ...c, redirect: { to: { key: t.name, value: c.redirect } } } : c);
      break;
    case "boolean":
      a = rF;
      break;
    case "flag":
      a = s, n.flags = r.flatMap((c) => [c.alias, c.description && c.name, c.oppositeDescription && `no-${c.name}`].filter(Boolean));
      break;
    case "path":
      a = Jy;
      break;
    default:
      throw new Error(`Unexpected type ${t.type}`);
  }
  if (t.exception ? n.validate = (c, p, d) => t.exception(c) || p.validate(c, d) : n.validate = (c, p, d) => c === void 0 || p.validate(c, d), t.redirect && (l.redirect = (c) => c ? { to: typeof t.redirect == "string" ? t.redirect : { key: t.redirect.option, value: t.redirect.value } } : void 0), t.deprecated && (l.deprecated = !0), e && !t.array) {
    let c = n.preprocess || ((p) => p);
    n.preprocess = (p, d, m) => d.preprocess(c(Array.isArray(p) ? ht(!1, p, -1) : p), m);
  }
  return t.array ? tF.create({ ...e ? { preprocess: (c) => Array.isArray(c) ? c : [c] } : {}, ...l, valueSchema: a.create(n) }) : a.create({ ...n, ...l });
}
var vF = xF, SF = (t, e, r) => {
  if (!(t && e == null)) {
    if (e.findLast) return e.findLast(r);
    for (let s = e.length - 1; s >= 0; s--) {
      let i = e[s];
      if (r(i, s, e)) return i;
    }
  }
}, ID = SF;
function ND(t, e) {
  if (!e) throw new Error("parserName is required.");
  let r = ID(!1, t, (i) => i.parsers && Object.prototype.hasOwnProperty.call(i.parsers, e));
  if (r) return r;
  let s = `Couldn't resolve parser "${e}".`;
  throw s += " Plugins must be explicitly added to the standalone bundle.", new CD(s);
}
function wF(t, e) {
  if (!e) throw new Error("astFormat is required.");
  let r = ID(!1, t, (i) => i.printers && Object.prototype.hasOwnProperty.call(i.printers, e));
  if (r) return r;
  let s = `Couldn't find plugin for AST format "${e}".`;
  throw s += " Plugins must be explicitly added to the standalone bundle.", new CD(s);
}
function Kf({ plugins: t, parser: e }) {
  let r = ND(t, e);
  return MD(r, e);
}
function MD(t, e) {
  let r = t.parsers[e];
  return typeof r == "function" ? r() : r;
}
function AF(t, e) {
  let r = t.printers[e];
  return typeof r == "function" ? r() : r;
}
var Ky = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
async function CF(t, e = {}) {
  var r;
  let s = { ...t };
  if (!s.parser) if (s.filepath) {
    if (s.parser = zP(s, { physicalFile: s.filepath }), !s.parser) throw new Iy(`No parser could be inferred for file "${s.filepath}".`);
  } else throw new Iy("No parser and no file path given, couldn't infer a parser.");
  let i = ED({ plugins: t.plugins, showDeprecated: !0 }).options, n = { ...Ky, ...Object.fromEntries(i.filter((y) => y.default !== void 0).map((y) => [y.name, y.default])) }, a = ND(s.plugins, s.parser), l = await MD(a, s.parser);
  s.astFormat = l.astFormat, s.locEnd = l.locEnd, s.locStart = l.locStart;
  let c = (r = a.printers) != null && r[l.astFormat] ? a : wF(s.plugins, l.astFormat), p = await AF(c, l.astFormat);
  s.printer = p;
  let d = c.defaultOptions ? Object.fromEntries(Object.entries(c.defaultOptions).filter(([, y]) => y !== void 0)) : {}, m = { ...n, ...d };
  for (let [y, g] of Object.entries(m)) (s[y] === null || s[y] === void 0) && (s[y] = g);
  return s.parser === "json" && (s.trailingComma = "none"), vF(s, i, { passThrough: Object.keys(Ky), ...e });
}
var wa = CF, EF = pk(mk());
async function TF(t, e) {
  let r = await Kf(e), s = r.preprocess ? r.preprocess(t, e) : t;
  e.originalText = s;
  let i;
  try {
    i = await r.parse(s, e, e);
  } catch (n) {
    kF(n, t);
  }
  return { text: s, ast: i };
}
function kF(t, e) {
  let { loc: r } = t;
  if (r) {
    let s = (0, EF.codeFrameColumns)(e, r, { highlightCode: !0 });
    throw t.message += `
` + s, t.codeFrame = s, t;
  }
  throw t;
}
var cl = TF;
async function PF(t, e, r, s, i) {
  var x;
  let { embeddedLanguageFormatting: n, printer: { embed: a, hasPrettierIgnore: l = () => !1, getVisitorKeys: c } } = r;
  if (!a || n !== "auto") return;
  if (a.length > 2) throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/plugins#optional-embed");
  let p = Yc((x = a.getVisitorKeys) != null ? x : c), d = [];
  g();
  let m = t.stack;
  for (let { print: v, node: w, pathStack: C } of d) try {
    t.stack = C;
    let b = await v(y, e, t, r);
    b && i.set(w, b);
  } catch (b) {
    if (globalThis.PRETTIER_DEBUG) throw b;
  }
  t.stack = m;
  function y(v, w) {
    return FF(v, w, r, s);
  }
  function g() {
    let { node: v } = t;
    if (v === null || typeof v != "object" || l(t)) return;
    for (let C of p(v)) Array.isArray(v[C]) ? t.each(g, C) : t.call(g, C);
    let w = a(t, r);
    if (w) {
      if (typeof w == "function") {
        d.push({ print: w, node: v, pathStack: [...t.stack] });
        return;
      }
      i.set(v, w);
    }
  }
}
async function FF(t, e, r, s) {
  let i = await wa({ ...r, ...e, parentParser: r.parser, originalText: t, cursorOffset: void 0, rangeStart: void 0, rangeEnd: void 0 }, { passThrough: !0 }), { ast: n } = await cl(t, i), a = await s(n, i);
  return hD(a);
}
function $F(t, e) {
  let { originalText: r, [Symbol.for("comments")]: s, locStart: i, locEnd: n, [Symbol.for("printedComments")]: a } = e, { node: l } = t, c = i(l), p = n(l);
  for (let d of s) i(d) >= c && n(d) <= p && a.add(d);
  return r.slice(c, p);
}
var QF = $F;
async function Wc(t, e) {
  ({ ast: t } = await LD(t, e));
  let r = /* @__PURE__ */ new Map(), s = new hP(t), i = /* @__PURE__ */ new Map();
  await PF(s, a, e, Wc, i);
  let n = await eO(s, e, a, void 0, i);
  if ($P(e), e.cursorOffset >= 0) {
    if (e.nodeAfterCursor && !e.nodeBeforeCursor) return [Ui, n];
    if (e.nodeBeforeCursor && !e.nodeAfterCursor) return [n, Ui];
  }
  return n;
  function a(c, p) {
    return c === void 0 || c === s ? l(p) : Array.isArray(c) ? s.call(() => l(p), ...c) : s.call(() => l(p), c);
  }
  function l(c) {
    let p = s.node;
    if (p == null) return "";
    let d = p && typeof p == "object" && c === void 0;
    if (d && r.has(p)) return r.get(p);
    let m = eO(s, e, a, c, i);
    return d && r.set(p, m), m;
  }
}
function eO(t, e, r, s, i) {
  var n;
  let { node: a } = t, { printer: l } = e, c;
  switch ((n = l.hasPrettierIgnore) != null && n.call(l, t) ? c = QF(t, e) : i.has(a) ? c = i.get(a) : c = l.print(t, e, r, s), a) {
    case e.cursorNode:
      c = Eu(c, (p) => [Ui, p, Ui]);
      break;
    case e.nodeBeforeCursor:
      c = Eu(c, (p) => [p, Ui]);
      break;
    case e.nodeAfterCursor:
      c = Eu(c, (p) => [Ui, p]);
      break;
  }
  return l.printComment && (!l.willPrintOwnComments || !l.willPrintOwnComments(t, e)) && (c = FP(t, c, e)), c;
}
async function LD(t, e) {
  var i;
  let r = (i = t.comments) != null ? i : [];
  e[Symbol.for("comments")] = r, e[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), wP(t, e);
  let { printer: { preprocess: s } } = e;
  return t = s ? await s(t, e) : t, { ast: t, comments: r };
}
function BF(t, e) {
  let { cursorOffset: r, locStart: s, locEnd: i } = e, n = Yc(e.printer.getVisitorKeys), a = (g) => s(g) <= r && i(g) >= r, l = t, c = [t];
  for (let g of fP(t, { getVisitorKeys: n, filter: a })) c.push(g), l = g;
  if (mP(l, { getVisitorKeys: n })) return { cursorNode: l };
  let p, d, m = -1, y = Number.POSITIVE_INFINITY;
  for (; c.length > 0 && (p === void 0 || d === void 0); ) {
    l = c.pop();
    let g = p !== void 0, x = d !== void 0;
    for (let v of Uc(l, { getVisitorKeys: n })) {
      if (!g) {
        let w = i(v);
        w <= r && w > m && (p = v, m = w);
      }
      if (!x) {
        let w = s(v);
        w >= r && w < y && (d = v, y = w);
      }
    }
  }
  return { nodeBeforeCursor: p, nodeAfterCursor: d };
}
var _D = BF;
function IF(t, e) {
  var l;
  let { printer: { massageAstNode: r, getVisitorKeys: s } } = e;
  if (!r) return t;
  let i = Yc(s), n = (l = r.ignoredProperties) != null ? l : /* @__PURE__ */ new Set();
  return a(t);
  function a(c, p) {
    if (!(c !== null && typeof c == "object")) return c;
    if (Array.isArray(c)) return c.map((g) => a(g, p)).filter(Boolean);
    let d = {}, m = new Set(i(c));
    for (let g in c) !Object.prototype.hasOwnProperty.call(c, g) || n.has(g) || (m.has(g) ? d[g] = a(c[g], c) : d[g] = c[g]);
    let y = r(c, d, p);
    if (y !== null) return y != null ? y : d;
  }
}
var NF = IF, MF = (t, e, r) => {
  if (!(t && e == null)) {
    if (e.findLastIndex) return e.findLastIndex(r);
    for (let s = e.length - 1; s >= 0; s--) {
      let i = e[s];
      if (r(i, s, e)) return s;
    }
    return -1;
  }
}, LF = MF, _F = ({ parser: t }) => t === "json" || t === "json5" || t === "jsonc" || t === "json-stringify";
function RF(t, e) {
  let r = [t.node, ...t.parentNodes], s = /* @__PURE__ */ new Set([e.node, ...e.parentNodes]);
  return r.find((i) => RD.has(i.type) && s.has(i));
}
function tO(t) {
  let e = LF(!1, t, (r) => r.type !== "Program" && r.type !== "File");
  return e === -1 ? t : t.slice(0, e + 1);
}
function qF(t, e, { locStart: r, locEnd: s }) {
  let i = t.node, n = e.node;
  if (i === n) return { startNode: i, endNode: n };
  let a = r(t.node);
  for (let c of tO(e.parentNodes)) if (r(c) >= a) n = c;
  else break;
  let l = s(e.node);
  for (let c of tO(t.parentNodes)) {
    if (s(c) <= l) i = c;
    else break;
    if (i === n) break;
  }
  return { startNode: i, endNode: n };
}
function cd(t, e, r, s, i = [], n) {
  let { locStart: a, locEnd: l } = r, c = a(t), p = l(t);
  if (!(e > p || e < c || n === "rangeEnd" && e === c || n === "rangeStart" && e === p)) {
    for (let d of Hf(t, r)) {
      let m = cd(d, e, r, s, [t, ...i], n);
      if (m) return m;
    }
    if (!s || s(t, i[0])) return { node: t, parentNodes: i };
  }
}
function jF(t, e) {
  return e !== "DeclareExportDeclaration" && t !== "TypeParameterDeclaration" && (t === "Directive" || t === "TypeAlias" || t === "TSExportAssignment" || t.startsWith("Declare") || t.startsWith("TSDeclare") || t.endsWith("Statement") || t.endsWith("Declaration"));
}
var RD = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), XF = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
function rO(t, e, r) {
  if (!e) return !1;
  switch (t.parser) {
    case "flow":
    case "hermes":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "oxc":
    case "oxc-ts":
    case "__babel_estree":
      return jF(e.type, r == null ? void 0 : r.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return RD.has(e.type);
    case "graphql":
      return XF.has(e.kind);
    case "vue":
      return e.tag !== "root";
  }
  return !1;
}
function ZF(t, e, r) {
  let { rangeStart: s, rangeEnd: i, locStart: n, locEnd: a } = e;
  ld.ok(i > s);
  let l = t.slice(s, i).search(/\S/u), c = l === -1;
  if (!c) for (s += l; i > s && !/\S/u.test(t[i - 1]); --i) ;
  let p = cd(r, s, e, (g, x) => rO(e, g, x), [], "rangeStart"), d = c ? p : cd(r, i, e, (g) => rO(e, g), [], "rangeEnd");
  if (!p || !d) return { rangeStart: 0, rangeEnd: 0 };
  let m, y;
  if (_F(e)) {
    let g = RF(p, d);
    m = g, y = g;
  } else ({ startNode: m, endNode: y } = qF(p, d, e));
  return { rangeStart: Math.min(n(m), n(y)), rangeEnd: Math.max(a(m), a(y)) };
}
var qD = "\uFEFF", sO = Symbol("cursor");
async function jD(t, e, r = 0) {
  if (!t || t.trim().length === 0) return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: s, text: i } = await cl(t, e);
  e.cursorOffset >= 0 && (e = { ...e, ..._D(s, e) });
  let n = await Wc(s, e);
  r > 0 && (n = yD([sn, n], r, e.tabWidth));
  let a = zc(n, e);
  if (r > 0) {
    let c = a.formatted.trim();
    a.cursorNodeStart !== void 0 && (a.cursorNodeStart -= a.formatted.indexOf(c), a.cursorNodeStart < 0 && (a.cursorNodeStart = 0, a.cursorNodeText = a.cursorNodeText.trimStart()), a.cursorNodeStart + a.cursorNodeText.length > c.length && (a.cursorNodeText = a.cursorNodeText.trimEnd())), a.formatted = c + Zf(e.endOfLine);
  }
  let l = e[Symbol.for("comments")];
  if (e.cursorOffset >= 0) {
    let c, p, d, m;
    if ((e.cursorNode || e.nodeBeforeCursor || e.nodeAfterCursor) && a.cursorNodeText) if (d = a.cursorNodeStart, m = a.cursorNodeText, e.cursorNode) c = e.locStart(e.cursorNode), p = i.slice(c, e.locEnd(e.cursorNode));
    else {
      if (!e.nodeBeforeCursor && !e.nodeAfterCursor) throw new Error("Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor");
      c = e.nodeBeforeCursor ? e.locEnd(e.nodeBeforeCursor) : 0;
      let C = e.nodeAfterCursor ? e.locStart(e.nodeAfterCursor) : i.length;
      p = i.slice(c, C);
    }
    else c = 0, p = i, d = 0, m = a.formatted;
    let y = e.cursorOffset - c;
    if (p === m) return { formatted: a.formatted, cursorOffset: d + y, comments: l };
    let g = p.split("");
    g.splice(y, 0, sO);
    let x = m.split(""), v = bk(g, x), w = d;
    for (let C of v) if (C.removed) {
      if (C.value.includes(sO)) break;
    } else w += C.count;
    return { formatted: a.formatted, cursorOffset: w, comments: l };
  }
  return { formatted: a.formatted, cursorOffset: -1, comments: l };
}
async function VF(t, e) {
  let { ast: r, text: s } = await cl(t, e), { rangeStart: i, rangeEnd: n } = ZF(s, e, r), a = s.slice(i, n), l = Math.min(i, s.lastIndexOf(`
`, i) + 1), c = s.slice(l, i).match(/^\s*/u)[0], p = Wf(c, e.tabWidth), d = await jD(a, { ...e, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: e.cursorOffset > i && e.cursorOffset <= n ? e.cursorOffset - i : -1, endOfLine: "lf" }, p), m = d.formatted.trimEnd(), { cursorOffset: y } = e;
  y > n ? y += m.length - a.length : d.cursorOffset >= 0 && (y = d.cursorOffset + i);
  let g = s.slice(0, i) + m + s.slice(n);
  if (e.endOfLine !== "lf") {
    let x = Zf(e.endOfLine);
    y >= 0 && x === `\r
` && (y += uD(g.slice(0, y), `
`)), g = Xc(!1, g, `
`, x);
  }
  return { formatted: g, cursorOffset: y, comments: d.comments };
}
function Hh(t, e, r) {
  return typeof e != "number" || Number.isNaN(e) || e < 0 || e > t.length ? r : e;
}
function iO(t, e) {
  let { cursorOffset: r, rangeStart: s, rangeEnd: i } = e;
  return r = Hh(t, r, -1), s = Hh(t, s, 0), i = Hh(t, i, t.length), { ...e, cursorOffset: r, rangeStart: s, rangeEnd: i };
}
function XD(t, e) {
  let { cursorOffset: r, rangeStart: s, rangeEnd: i, endOfLine: n } = iO(t, e), a = t.charAt(0) === qD;
  if (a && (t = t.slice(1), r--, s--, i--), n === "auto" && (n = vk(t)), t.includes("\r")) {
    let l = (c) => uD(t.slice(0, Math.max(c, 0)), `\r
`);
    r -= l(r), s -= l(s), i -= l(i), t = Sk(t);
  }
  return { hasBOM: a, text: t, options: iO(t, { ...e, cursorOffset: r, rangeStart: s, rangeEnd: i, endOfLine: n }) };
}
async function nO(t, e) {
  let r = await Kf(e);
  return !r.hasPragma || r.hasPragma(t);
}
async function zF(t, e) {
  var r;
  let s = await Kf(e);
  return (r = s.hasIgnorePragma) == null ? void 0 : r.call(s, t);
}
async function ZD(t, e) {
  let { hasBOM: r, text: s, options: i } = XD(t, await wa(e));
  if (i.rangeStart >= i.rangeEnd && s !== "" || i.requirePragma && !await nO(s, i) || i.checkIgnorePragma && await zF(s, i)) return { formatted: t, cursorOffset: e.cursorOffset, comments: [] };
  let n;
  return i.rangeStart > 0 || i.rangeEnd < s.length ? n = await VF(s, i) : (!i.requirePragma && i.insertPragma && i.printer.insertPragma && !await nO(s, i) && (s = i.printer.insertPragma(s)), n = await jD(s, i)), r && (n.formatted = qD + n.formatted, n.cursorOffset >= 0 && n.cursorOffset++), n;
}
async function UF(t, e, r) {
  let { text: s, options: i } = XD(t, await wa(e)), n = await cl(s, i);
  return r && (r.preprocessForPrint && (n.ast = await LD(n.ast, i)), r.massage && (n.ast = NF(n.ast, i))), n;
}
async function YF(t, e) {
  e = await wa(e);
  let r = await Wc(t, e);
  return zc(r, e);
}
async function WF(t, e) {
  let r = eP(t), { formatted: s } = await ZD(r, { ...e, parser: "__js_expression" });
  return s;
}
async function GF(t, e) {
  e = await wa(e);
  let { ast: r } = await cl(t, e);
  return e.cursorOffset >= 0 && (e = { ...e, ..._D(r, e) }), Wc(r, e);
}
async function HF(t, e) {
  return zc(t, await wa(e));
}
var VD = {};
Xf(VD, { builders: () => JF, printer: () => KF, utils: () => e$ });
var JF = { join: gD, line: fD, softline: Jk, hardline: sn, literalline: mD, group: pD, conditionalGroup: zk, fill: Uk, lineSuffix: sd, lineSuffixBoundary: Gk, cursor: Ui, breakParent: Vc, ifBreak: Yk, trim: Hk, indent: Hu, indentIfBreak: Wk, align: na, addAlignmentToDoc: yD, markAsRoot: Zk, dedentToRoot: Xk, dedent: Vk, hardlineWithoutBreakParent: Uf, literallineWithoutBreakParent: dD, label: Kk, concat: (t) => t }, KF = { printDocToString: zc }, e$ = { willBreak: $k, traverseDoc: Vf, findInDoc: zf, mapDoc: Zc, removeLines: Ik, stripTrailingHardline: hD, replaceEndOfLine: Lk, canBreak: Rk }, t$ = "3.6.2", zD = {};
Xf(zD, { addDanglingComment: () => Xi, addLeadingComment: () => Oo, addTrailingComment: () => xo, getAlignmentSize: () => Wf, getIndentSize: () => o$, getMaxContinuousCount: () => c$, getNextNonSpaceNonCommentCharacter: () => p$, getNextNonSpaceNonCommentCharacterIndex: () => v$, getPreferredQuote: () => f$, getStringWidth: () => Yf, hasNewline: () => Di, hasNewlineInRange: () => g$, hasSpaces: () => O$, isNextLineEmpty: () => C$, isNextLineEmptyAfterIndex: () => sm, isPreviousLineEmpty: () => w$, makeString: () => D$, skip: () => ul, skipEverythingButNewLine: () => bD, skipInlineComment: () => em, skipNewline: () => on, skipSpaces: () => vi, skipToLineEnd: () => DD, skipTrailingComment: () => tm, skipWhitespace: () => gP });
function r$(t, e) {
  if (e === !1) return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r) if (t.charAt(r) === "*" && t.charAt(r + 1) === "/") return r + 2;
  }
  return e;
}
var em = r$;
function s$(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? bD(t, e) : e;
}
var tm = s$;
function i$(t, e) {
  let r = null, s = e;
  for (; s !== r; ) r = s, s = vi(t, s), s = em(t, s), s = tm(t, s), s = on(t, s);
  return s;
}
var rm = i$;
function n$(t, e) {
  let r = null, s = e;
  for (; s !== r; ) r = s, s = DD(t, s), s = em(t, s), s = vi(t, s);
  return s = tm(t, s), s = on(t, s), s !== !1 && Di(t, s);
}
var sm = n$;
function a$(t, e) {
  let r = t.lastIndexOf(`
`);
  return r === -1 ? 0 : Wf(t.slice(r + 1).match(/^[\t ]*/u)[0], e);
}
var o$ = a$;
function l$(t) {
  if (typeof t != "string") throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function u$(t, e) {
  let r = t.match(new RegExp(`(${l$(e)})+`, "gu"));
  return r === null ? 0 : r.reduce((s, i) => Math.max(s, i.length / e.length), 0);
}
var c$ = u$;
function h$(t, e) {
  let r = rm(t, e);
  return r === !1 ? "" : t.charAt(r);
}
var p$ = h$, Zl = "'", aO = '"';
function d$(t, e) {
  let r = e === !0 || e === Zl ? Zl : aO, s = r === Zl ? aO : Zl, i = 0, n = 0;
  for (let a of t) a === r ? i++ : a === s && n++;
  return i > n ? s : r;
}
var f$ = d$;
function m$(t, e, r) {
  for (let s = e; s < r; ++s) if (t.charAt(s) === `
`) return !0;
  return !1;
}
var g$ = m$;
function y$(t, e, r = {}) {
  return vi(t, r.backwards ? e - 1 : e, r) !== e;
}
var O$ = y$;
function x$(t, e, r) {
  let s = e === '"' ? "'" : '"', i = Xc(!1, t, /\\(.)|(["'])/gsu, (n, a, l) => a === s ? a : l === e ? "\\" + l : l || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(a) ? a : "\\" + a));
  return e + i + e;
}
var D$ = x$;
function b$(t, e, r) {
  return rm(t, r(e));
}
function v$(t, e) {
  return arguments.length === 2 || typeof e == "number" ? rm(t, e) : b$(...arguments);
}
function S$(t, e, r) {
  return Jf(t, r(e));
}
function w$(t, e) {
  return arguments.length === 2 || typeof e == "number" ? Jf(t, e) : S$(...arguments);
}
function A$(t, e, r) {
  return sm(t, r(e));
}
function C$(t, e) {
  return arguments.length === 2 || typeof e == "number" ? sm(t, e) : A$(...arguments);
}
function Zi(t, e = 1) {
  return async (...r) => {
    var n, a;
    let s = (n = r[e]) != null ? n : {}, i = (a = s.plugins) != null ? a : [];
    return r[e] = { ...s, plugins: Array.isArray(i) ? i : Object.values(i) }, t(...r);
  };
}
var UD = Zi(ZD);
async function hl(t, e) {
  let { formatted: r } = await UD(t, { ...e, cursorOffset: -1 });
  return r;
}
async function E$(t, e) {
  return await hl(t, e) === t;
}
var T$ = Zi(ED, 0), k$ = { parse: Zi(UF), formatAST: Zi(YF), formatDoc: Zi(WF), printToDoc: Zi(GF), printDocToString: Zi(HF) }, P$ = Object.create, im = Object.defineProperty, F$ = Object.getOwnPropertyDescriptor, $$ = Object.getOwnPropertyNames, Q$ = Object.getPrototypeOf, B$ = Object.prototype.hasOwnProperty, I$ = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), nm = (t, e) => {
  for (var r in e) im(t, r, { get: e[r], enumerable: !0 });
}, N$ = (t, e, r, s) => {
  if (e && typeof e == "object" || typeof e == "function") for (let i of $$(e)) !B$.call(t, i) && i !== r && im(t, i, { get: () => e[i], enumerable: !(s = F$(e, i)) || s.enumerable });
  return t;
}, YD = (t, e, r) => (r = t != null ? P$(Q$(t)) : {}, N$(im(r, "default", { value: t, enumerable: !0 }), t)), WD = I$((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(u, o) {
    if (u == null) return {};
    var h = {};
    for (var f in u) if ({}.hasOwnProperty.call(u, f)) {
      if (o.indexOf(f) !== -1) continue;
      h[f] = u[f];
    }
    return h;
  }
  var r = class {
    constructor(u, o, h) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = u, this.column = o, this.index = h;
    }
  }, s = class {
    constructor(u, o) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = u, this.end = o;
    }
  };
  function i(u, o) {
    let { line: h, column: f, index: O } = u;
    return new r(h, f + o, O + o);
  }
  var n = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", a = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: n }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: n } }, l = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, c = (u) => u.type === "UpdateExpression" ? l.UpdateExpression[`${u.prefix}`] : l[u.type], p = { AccessorIsGenerator: ({ kind: u }) => `A ${u}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: u }) => `Missing initializer in ${u} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: u }) => `\`${u}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: u, exportName: o }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${u}' as '${o}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: u }) => `'${u === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: u }) => `Unsyntactic ${u === "BreakStatement" ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.", ImportBindingIsString: ({ importName: u }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${u}" as foo }\`?`, ImportCallArity: "`import()` requires exactly one or two arguments.", ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: u }) => `Expected number in radix ${u}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: u }) => `Escape sequence in keyword ${u}.`, InvalidIdentifier: ({ identifierName: u }) => `Invalid identifier ${u}.`, InvalidLhs: ({ ancestor: u }) => `Invalid left-hand side in ${c(u)}.`, InvalidLhsBinding: ({ ancestor: u }) => `Binding invalid left-hand side in ${c(u)}.`, InvalidLhsOptionalChaining: ({ ancestor: u }) => `Invalid optional chaining in the left-hand side of ${c(u)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: u }) => `Unexpected character '${u}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: u }) => `Private name #${u} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: u }) => `Label '${u}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: u }) => `This experimental syntax requires enabling the parser plugin: ${u.map((o) => JSON.stringify(o)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: u }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${u.map((o) => JSON.stringify(o)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: u }) => `Duplicate key "${u}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: u }) => `An export name cannot include a lone surrogate, found '\\u${u.toString(16)}'.`, ModuleExportUndefined: ({ localName: u }) => `Export '${u}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: u }) => `Private names are only allowed in property accesses (\`obj.#${u}\`) or in \`in\` expressions (\`#${u} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: u }) => `Duplicate private name #${u}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: u }) => `Unexpected keyword '${u}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: u }) => `Unexpected reserved word '${u}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: u, unexpected: o }) => `Unexpected token${o ? ` '${o}'.` : ""}${u ? `, expected "${u}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: u, onlyValidPropertyName: o }) => `The only valid meta property for ${u} is ${u}.${o}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationExport: "Using declaration cannot be exported.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: u }) => `Identifier '${u}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, d = { StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: u }) => `Assigning to '${u}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: u }) => `Binding '${u}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }, m = { ParseExpressionEmptyInput: "Unexpected parseExpression() input: The input is empty or contains only comments.", ParseExpressionExpectsEOF: ({ unexpected: u }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \`${String.fromCodePoint(u)}\`.` }, y = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), g = Object.assign({ PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: u }) => `Invalid topic token ${u}. In order to use ${u} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${u}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: u }) => `Hack-style pipe body cannot be an unparenthesized ${c({ type: u })}; please wrap it in parentheses.` }, { PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' }), x = ["message"];
  function v(u, o, h) {
    Object.defineProperty(u, o, { enumerable: !1, configurable: !0, value: h });
  }
  function w({ toMessage: u, code: o, reasonCode: h, syntaxPlugin: f }) {
    let O = h === "MissingPlugin" || h === "MissingOneOfPlugins";
    {
      let D = { AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter", AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters", ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference", SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter", SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter", SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType" };
      D[h] && (h = D[h]);
    }
    return function D(S, A) {
      let P = new SyntaxError();
      return P.code = o, P.reasonCode = h, P.loc = S, P.pos = S.index, P.syntaxPlugin = f, O && (P.missingPlugin = A.missingPlugin), v(P, "clone", function(E = {}) {
        var M;
        let { line: Z, column: H, index: ie } = (M = E.loc) != null ? M : S;
        return D(new r(Z, H, ie), Object.assign({}, A, E.details));
      }), v(P, "details", A), Object.defineProperty(P, "message", { configurable: !0, get() {
        let E = `${u(A)} (${S.line}:${S.column})`;
        return this.message = E, E;
      }, set(E) {
        Object.defineProperty(this, "message", { value: E, writable: !0 });
      } }), P;
    };
  }
  function C(u, o) {
    if (Array.isArray(u)) return (f) => C(f, u[0]);
    let h = {};
    for (let f of Object.keys(u)) {
      let O = u[f], D = typeof O == "string" ? { message: () => O } : typeof O == "function" ? { message: O } : O, { message: S } = D, A = e(D, x), P = typeof S == "string" ? () => S : S;
      h[f] = w(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: f, toMessage: P }, o ? { syntaxPlugin: o } : {}, A));
    }
    return h;
  }
  var b = Object.assign({}, C(a), C(p), C(d), C(m), C`pipelineOperator`(g));
  function k() {
    return { sourceType: "script", sourceFilename: void 0, startIndex: 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: !1, allowReturnOutsideFunction: !1, allowNewTargetOutsideFunction: !1, allowImportExportEverywhere: !1, allowSuperOutsideMethod: !1, allowUndeclaredExports: !1, allowYieldOutsideFunction: !1, plugins: [], strictMode: null, ranges: !1, tokens: !1, createImportExpressions: !1, createParenthesizedExpressions: !1, errorRecovery: !1, attachComment: !0, annexB: !0 };
  }
  function Q(u) {
    let o = k();
    if (u == null) return o;
    if (u.annexB != null && u.annexB !== !1) throw new Error("The `annexB` option can only be set to `false`.");
    for (let h of Object.keys(o)) u[h] != null && (o[h] = u[h]);
    if (o.startLine === 1) u.startIndex == null && o.startColumn > 0 ? o.startIndex = o.startColumn : u.startColumn == null && o.startIndex > 0 && (o.startColumn = o.startIndex);
    else if ((u.startColumn == null || u.startIndex == null) && u.startIndex != null) throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
    return o;
  }
  var { defineProperty: F } = Object, $ = (u, o) => {
    u && F(u, o, { enumerable: !1, value: u[o] });
  };
  function N(u) {
    return $(u.loc.start, "index"), $(u.loc.end, "index"), u;
  }
  var _ = (u) => class extends u {
    parse() {
      let o = N(super.parse());
      return this.optionFlags & 256 && (o.tokens = o.tokens.map(N)), o;
    }
    parseRegExpLiteral({ pattern: o, flags: h }) {
      let f = null;
      try {
        f = new RegExp(o, h);
      } catch {
      }
      let O = this.estreeParseLiteral(f);
      return O.regex = { pattern: o, flags: h }, O;
    }
    parseBigIntLiteral(o) {
      let h;
      try {
        h = BigInt(o);
      } catch {
        h = null;
      }
      let f = this.estreeParseLiteral(h);
      return f.bigint = String(f.value || o), f;
    }
    parseDecimalLiteral(o) {
      let h = this.estreeParseLiteral(null);
      return h.decimal = String(h.value || o), h;
    }
    estreeParseLiteral(o) {
      return this.parseLiteral(o, "Literal");
    }
    parseStringLiteral(o) {
      return this.estreeParseLiteral(o);
    }
    parseNumericLiteral(o) {
      return this.estreeParseLiteral(o);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(o) {
      return this.estreeParseLiteral(o);
    }
    estreeParseChainExpression(o, h) {
      let f = this.startNodeAtNode(o);
      return f.expression = o, this.finishNodeAt(f, "ChainExpression", h);
    }
    directiveToStmt(o) {
      let h = o.value;
      delete o.value, this.castNodeTo(h, "Literal"), h.raw = h.extra.raw, h.value = h.extra.expressionValue;
      let f = this.castNodeTo(o, "ExpressionStatement");
      return f.expression = h, f.directive = h.extra.rawValue, delete h.extra, f;
    }
    fillOptionalPropertiesForTSESLint(o) {
    }
    cloneEstreeStringLiteral(o) {
      let { start: h, end: f, loc: O, range: D, raw: S, value: A } = o, P = Object.create(o.constructor.prototype);
      return P.type = "Literal", P.start = h, P.end = f, P.loc = O, P.range = D, P.raw = S, P.value = A, P;
    }
    initFunction(o, h) {
      super.initFunction(o, h), o.expression = !1;
    }
    checkDeclaration(o) {
      o != null && this.isObjectProperty(o) ? this.checkDeclaration(o.value) : super.checkDeclaration(o);
    }
    getObjectOrClassMethodParams(o) {
      return o.value.params;
    }
    isValidDirective(o) {
      var h;
      return o.type === "ExpressionStatement" && o.expression.type === "Literal" && typeof o.expression.value == "string" && !((h = o.expression.extra) != null && h.parenthesized);
    }
    parseBlockBody(o, h, f, O, D) {
      super.parseBlockBody(o, h, f, O, D);
      let S = o.directives.map((A) => this.directiveToStmt(A));
      o.body = S.concat(o.body), delete o.directives;
    }
    parsePrivateName() {
      let o = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(o) : o;
    }
    convertPrivateNameToPrivateIdentifier(o) {
      let h = super.getPrivateNameSV(o);
      return o = o, delete o.id, o.name = h, this.castNodeTo(o, "PrivateIdentifier");
    }
    isPrivateName(o) {
      return this.getPluginOption("estree", "classFeatures") ? o.type === "PrivateIdentifier" : super.isPrivateName(o);
    }
    getPrivateNameSV(o) {
      return this.getPluginOption("estree", "classFeatures") ? o.name : super.getPrivateNameSV(o);
    }
    parseLiteral(o, h) {
      let f = super.parseLiteral(o, h);
      return f.raw = f.extra.raw, delete f.extra, f;
    }
    parseFunctionBody(o, h, f = !1) {
      super.parseFunctionBody(o, h, f), o.expression = o.body.type !== "BlockStatement";
    }
    parseMethod(o, h, f, O, D, S, A = !1) {
      let P = this.startNode();
      P.kind = o.kind, P = super.parseMethod(P, h, f, O, D, S, A), delete P.kind;
      let { typeParameters: E } = o;
      E && (delete o.typeParameters, P.typeParameters = E, this.resetStartLocationFromNode(P, E));
      let M = this.castNodeTo(P, "FunctionExpression");
      return o.value = M, S === "ClassPrivateMethod" && (o.computed = !1), S === "ObjectMethod" ? (o.kind === "method" && (o.kind = "init"), o.shorthand = !1, this.finishNode(o, "Property")) : this.finishNode(o, "MethodDefinition");
    }
    nameIsConstructor(o) {
      return o.type === "Literal" ? o.value === "constructor" : super.nameIsConstructor(o);
    }
    parseClassProperty(...o) {
      let h = super.parseClassProperty(...o);
      return this.getPluginOption("estree", "classFeatures") && this.castNodeTo(h, "PropertyDefinition"), h;
    }
    parseClassPrivateProperty(...o) {
      let h = super.parseClassPrivateProperty(...o);
      return this.getPluginOption("estree", "classFeatures") && (this.castNodeTo(h, "PropertyDefinition"), h.computed = !1), h;
    }
    parseClassAccessorProperty(o) {
      let h = super.parseClassAccessorProperty(o);
      return this.getPluginOption("estree", "classFeatures") && (h.abstract && this.hasPlugin("typescript") ? (delete h.abstract, this.castNodeTo(h, "TSAbstractAccessorProperty")) : this.castNodeTo(h, "AccessorProperty")), h;
    }
    parseObjectProperty(o, h, f, O) {
      let D = super.parseObjectProperty(o, h, f, O);
      return D && (D.kind = "init", this.castNodeTo(D, "Property")), D;
    }
    finishObjectProperty(o) {
      return o.kind = "init", this.finishNode(o, "Property");
    }
    isValidLVal(o, h, f) {
      return o === "Property" ? "value" : super.isValidLVal(o, h, f);
    }
    isAssignable(o, h) {
      return o != null && this.isObjectProperty(o) ? this.isAssignable(o.value, h) : super.isAssignable(o, h);
    }
    toAssignable(o, h = !1) {
      if (o != null && this.isObjectProperty(o)) {
        let { key: f, value: O } = o;
        this.isPrivateName(f) && this.classScope.usePrivateName(this.getPrivateNameSV(f), f.loc.start), this.toAssignable(O, h);
      } else super.toAssignable(o, h);
    }
    toAssignableObjectExpressionProp(o, h, f) {
      o.type === "Property" && (o.kind === "get" || o.kind === "set") ? this.raise(b.PatternHasAccessor, o.key) : o.type === "Property" && o.method ? this.raise(b.PatternHasMethod, o.key) : super.toAssignableObjectExpressionProp(o, h, f);
    }
    finishCallExpression(o, h) {
      let f = super.finishCallExpression(o, h);
      if (f.callee.type === "Import") {
        var O, D;
        this.castNodeTo(f, "ImportExpression"), f.source = f.arguments[0], f.options = (O = f.arguments[1]) != null ? O : null, f.attributes = (D = f.arguments[1]) != null ? D : null, delete f.arguments, delete f.callee;
      } else f.type === "OptionalCallExpression" ? this.castNodeTo(f, "CallExpression") : f.optional = !1;
      return f;
    }
    toReferencedArguments(o) {
      o.type !== "ImportExpression" && super.toReferencedArguments(o);
    }
    parseExport(o, h) {
      let f = this.state.lastTokStartLoc, O = super.parseExport(o, h);
      switch (O.type) {
        case "ExportAllDeclaration":
          O.exported = null;
          break;
        case "ExportNamedDeclaration":
          O.specifiers.length === 1 && O.specifiers[0].type === "ExportNamespaceSpecifier" && (this.castNodeTo(O, "ExportAllDeclaration"), O.exported = O.specifiers[0].exported, delete O.specifiers);
        case "ExportDefaultDeclaration":
          {
            var D;
            let { declaration: S } = O;
            (S == null ? void 0 : S.type) === "ClassDeclaration" && ((D = S.decorators) == null ? void 0 : D.length) > 0 && S.start === O.start && this.resetStartLocation(O, f);
          }
          break;
      }
      return O;
    }
    stopParseSubscript(o, h) {
      let f = super.stopParseSubscript(o, h);
      return h.optionalChainMember ? this.estreeParseChainExpression(f, o.loc.end) : f;
    }
    parseMember(o, h, f, O, D) {
      let S = super.parseMember(o, h, f, O, D);
      return S.type === "OptionalMemberExpression" ? this.castNodeTo(S, "MemberExpression") : S.optional = !1, S;
    }
    isOptionalMemberExpression(o) {
      return o.type === "ChainExpression" ? o.expression.type === "MemberExpression" : super.isOptionalMemberExpression(o);
    }
    hasPropertyAsPrivateName(o) {
      return o.type === "ChainExpression" && (o = o.expression), super.hasPropertyAsPrivateName(o);
    }
    isObjectProperty(o) {
      return o.type === "Property" && o.kind === "init" && !o.method;
    }
    isObjectMethod(o) {
      return o.type === "Property" && (o.method || o.kind === "get" || o.kind === "set");
    }
    castNodeTo(o, h) {
      let f = super.castNodeTo(o, h);
      return this.fillOptionalPropertiesForTSESLint(f), f;
    }
    cloneIdentifier(o) {
      let h = super.cloneIdentifier(o);
      return this.fillOptionalPropertiesForTSESLint(h), h;
    }
    cloneStringLiteral(o) {
      return o.type === "Literal" ? this.cloneEstreeStringLiteral(o) : super.cloneStringLiteral(o);
    }
    finishNodeAt(o, h, f) {
      return N(super.finishNodeAt(o, h, f));
    }
    finishNode(o, h) {
      let f = super.finishNode(o, h);
      return this.fillOptionalPropertiesForTSESLint(f), f;
    }
    resetStartLocation(o, h) {
      super.resetStartLocation(o, h), N(o);
    }
    resetEndLocation(o, h = this.state.lastTokEndLoc) {
      super.resetEndLocation(o, h), N(o);
    }
  }, W = class {
    constructor(u, o) {
      this.token = void 0, this.preserveSpace = void 0, this.token = u, this.preserveSpace = !!o;
    }
  }, V = { brace: new W("{"), j_oTag: new W("<tag"), j_cTag: new W("</tag"), j_expr: new W("<tag>...</tag>", !0) };
  V.template = new W("`", !0);
  var j = !0, B = !0, U = !0, oe = !0, he = !0, Re = !0, $e = class {
    constructor(u, o = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = u, this.keyword = o.keyword, this.beforeExpr = !!o.beforeExpr, this.startsExpr = !!o.startsExpr, this.rightAssociative = !!o.rightAssociative, this.isLoop = !!o.isLoop, this.isAssign = !!o.isAssign, this.prefix = !!o.prefix, this.postfix = !!o.postfix, this.binop = o.binop != null ? o.binop : null, this.updateContext = null;
    }
  }, ft = /* @__PURE__ */ new Map();
  function le(u, o = {}) {
    o.keyword = u;
    let h = ne(u, o);
    return ft.set(u, h), h;
  }
  function ve(u, o) {
    return ne(u, { beforeExpr: j, binop: o });
  }
  var ct = -1, qe = [], it = [], Kt = [], er = [], zr = [], Pr = [];
  function ne(u, o = {}) {
    var h, f, O, D;
    return ++ct, it.push(u), Kt.push((h = o.binop) != null ? h : -1), er.push((f = o.beforeExpr) != null ? f : !1), zr.push((O = o.startsExpr) != null ? O : !1), Pr.push((D = o.prefix) != null ? D : !1), qe.push(new $e(u, o)), ct;
  }
  function fe(u, o = {}) {
    var h, f, O, D;
    return ++ct, ft.set(u, ct), it.push(u), Kt.push((h = o.binop) != null ? h : -1), er.push((f = o.beforeExpr) != null ? f : !1), zr.push((O = o.startsExpr) != null ? O : !1), Pr.push((D = o.prefix) != null ? D : !1), qe.push(new $e("name", o)), ct;
  }
  var Ql = { bracketL: ne("[", { beforeExpr: j, startsExpr: B }), bracketHashL: ne("#[", { beforeExpr: j, startsExpr: B }), bracketBarL: ne("[|", { beforeExpr: j, startsExpr: B }), bracketR: ne("]"), bracketBarR: ne("|]"), braceL: ne("{", { beforeExpr: j, startsExpr: B }), braceBarL: ne("{|", { beforeExpr: j, startsExpr: B }), braceHashL: ne("#{", { beforeExpr: j, startsExpr: B }), braceR: ne("}"), braceBarR: ne("|}"), parenL: ne("(", { beforeExpr: j, startsExpr: B }), parenR: ne(")"), comma: ne(",", { beforeExpr: j }), semi: ne(";", { beforeExpr: j }), colon: ne(":", { beforeExpr: j }), doubleColon: ne("::", { beforeExpr: j }), dot: ne("."), question: ne("?", { beforeExpr: j }), questionDot: ne("?."), arrow: ne("=>", { beforeExpr: j }), template: ne("template"), ellipsis: ne("...", { beforeExpr: j }), backQuote: ne("`", { startsExpr: B }), dollarBraceL: ne("${", { beforeExpr: j, startsExpr: B }), templateTail: ne("...`", { startsExpr: B }), templateNonTail: ne("...${", { beforeExpr: j, startsExpr: B }), at: ne("@"), hash: ne("#", { startsExpr: B }), interpreterDirective: ne("#!..."), eq: ne("=", { beforeExpr: j, isAssign: oe }), assign: ne("_=", { beforeExpr: j, isAssign: oe }), slashAssign: ne("_=", { beforeExpr: j, isAssign: oe }), xorAssign: ne("_=", { beforeExpr: j, isAssign: oe }), moduloAssign: ne("_=", { beforeExpr: j, isAssign: oe }), incDec: ne("++/--", { prefix: he, postfix: Re, startsExpr: B }), bang: ne("!", { beforeExpr: j, prefix: he, startsExpr: B }), tilde: ne("~", { beforeExpr: j, prefix: he, startsExpr: B }), doubleCaret: ne("^^", { startsExpr: B }), doubleAt: ne("@@", { startsExpr: B }), pipeline: ve("|>", 0), nullishCoalescing: ve("??", 1), logicalOR: ve("||", 1), logicalAND: ve("&&", 2), bitwiseOR: ve("|", 3), bitwiseXOR: ve("^", 4), bitwiseAND: ve("&", 5), equality: ve("==/!=/===/!==", 6), lt: ve("</>/<=/>=", 7), gt: ve("</>/<=/>=", 7), relational: ve("</>/<=/>=", 7), bitShift: ve("<</>>/>>>", 8), bitShiftL: ve("<</>>/>>>", 8), bitShiftR: ve("<</>>/>>>", 8), plusMin: ne("+/-", { beforeExpr: j, binop: 9, prefix: he, startsExpr: B }), modulo: ne("%", { binop: 10, startsExpr: B }), star: ne("*", { binop: 10 }), slash: ve("/", 10), exponent: ne("**", { beforeExpr: j, binop: 11, rightAssociative: !0 }), _in: le("in", { beforeExpr: j, binop: 7 }), _instanceof: le("instanceof", { beforeExpr: j, binop: 7 }), _break: le("break"), _case: le("case", { beforeExpr: j }), _catch: le("catch"), _continue: le("continue"), _debugger: le("debugger"), _default: le("default", { beforeExpr: j }), _else: le("else", { beforeExpr: j }), _finally: le("finally"), _function: le("function", { startsExpr: B }), _if: le("if"), _return: le("return", { beforeExpr: j }), _switch: le("switch"), _throw: le("throw", { beforeExpr: j, prefix: he, startsExpr: B }), _try: le("try"), _var: le("var"), _const: le("const"), _with: le("with"), _new: le("new", { beforeExpr: j, startsExpr: B }), _this: le("this", { startsExpr: B }), _super: le("super", { startsExpr: B }), _class: le("class", { startsExpr: B }), _extends: le("extends", { beforeExpr: j }), _export: le("export"), _import: le("import", { startsExpr: B }), _null: le("null", { startsExpr: B }), _true: le("true", { startsExpr: B }), _false: le("false", { startsExpr: B }), _typeof: le("typeof", { beforeExpr: j, prefix: he, startsExpr: B }), _void: le("void", { beforeExpr: j, prefix: he, startsExpr: B }), _delete: le("delete", { beforeExpr: j, prefix: he, startsExpr: B }), _do: le("do", { isLoop: U, beforeExpr: j }), _for: le("for", { isLoop: U }), _while: le("while", { isLoop: U }), _as: fe("as", { startsExpr: B }), _assert: fe("assert", { startsExpr: B }), _async: fe("async", { startsExpr: B }), _await: fe("await", { startsExpr: B }), _defer: fe("defer", { startsExpr: B }), _from: fe("from", { startsExpr: B }), _get: fe("get", { startsExpr: B }), _let: fe("let", { startsExpr: B }), _meta: fe("meta", { startsExpr: B }), _of: fe("of", { startsExpr: B }), _sent: fe("sent", { startsExpr: B }), _set: fe("set", { startsExpr: B }), _source: fe("source", { startsExpr: B }), _static: fe("static", { startsExpr: B }), _using: fe("using", { startsExpr: B }), _yield: fe("yield", { startsExpr: B }), _asserts: fe("asserts", { startsExpr: B }), _checks: fe("checks", { startsExpr: B }), _exports: fe("exports", { startsExpr: B }), _global: fe("global", { startsExpr: B }), _implements: fe("implements", { startsExpr: B }), _intrinsic: fe("intrinsic", { startsExpr: B }), _infer: fe("infer", { startsExpr: B }), _is: fe("is", { startsExpr: B }), _mixins: fe("mixins", { startsExpr: B }), _proto: fe("proto", { startsExpr: B }), _require: fe("require", { startsExpr: B }), _satisfies: fe("satisfies", { startsExpr: B }), _keyof: fe("keyof", { startsExpr: B }), _readonly: fe("readonly", { startsExpr: B }), _unique: fe("unique", { startsExpr: B }), _abstract: fe("abstract", { startsExpr: B }), _declare: fe("declare", { startsExpr: B }), _enum: fe("enum", { startsExpr: B }), _module: fe("module", { startsExpr: B }), _namespace: fe("namespace", { startsExpr: B }), _interface: fe("interface", { startsExpr: B }), _type: fe("type", { startsExpr: B }), _opaque: fe("opaque", { startsExpr: B }), name: ne("name", { startsExpr: B }), placeholder: ne("%%", { startsExpr: B }), string: ne("string", { startsExpr: B }), num: ne("num", { startsExpr: B }), bigint: ne("bigint", { startsExpr: B }), decimal: ne("decimal", { startsExpr: B }), regexp: ne("regexp", { startsExpr: B }), privateName: ne("#name", { startsExpr: B }), eof: ne("eof"), jsxName: ne("jsxName"), jsxText: ne("jsxText", { beforeExpr: j }), jsxTagStart: ne("jsxTagStart", { startsExpr: B }), jsxTagEnd: ne("jsxTagEnd") };
  function xe(u) {
    return u >= 93 && u <= 133;
  }
  function tr(u) {
    return u <= 92;
  }
  function Fr(u) {
    return u >= 58 && u <= 133;
  }
  function Vg(u) {
    return u >= 58 && u <= 137;
  }
  function yE(u) {
    return er[u];
  }
  function qa(u) {
    return zr[u];
  }
  function OE(u) {
    return u >= 29 && u <= 33;
  }
  function zg(u) {
    return u >= 129 && u <= 131;
  }
  function xE(u) {
    return u >= 90 && u <= 92;
  }
  function Ph(u) {
    return u >= 58 && u <= 92;
  }
  function DE(u) {
    return u >= 39 && u <= 59;
  }
  function bE(u) {
    return u === 34;
  }
  function vE(u) {
    return Pr[u];
  }
  function SE(u) {
    return u >= 121 && u <= 123;
  }
  function wE(u) {
    return u >= 124 && u <= 130;
  }
  function ti(u) {
    return it[u];
  }
  function Bl(u) {
    return Kt[u];
  }
  function AE(u) {
    return u === 57;
  }
  function Il(u) {
    return u >= 24 && u <= 25;
  }
  function Ds(u) {
    return qe[u];
  }
  qe[8].updateContext = (u) => {
    u.pop();
  }, qe[5].updateContext = qe[7].updateContext = qe[23].updateContext = (u) => {
    u.push(V.brace);
  }, qe[22].updateContext = (u) => {
    u[u.length - 1] === V.template ? u.pop() : u.push(V.template);
  }, qe[143].updateContext = (u) => {
    u.push(V.j_expr, V.j_oTag);
  };
  var Fh = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", Ug = "-----------------------------------------------------------------------------------------------------------------------------------------------------", CE = new RegExp("[" + Fh + "]"), EE = new RegExp("[" + Fh + Ug + "]");
  Fh = Ug = null;
  var Yg = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], TE = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function $h(u, o) {
    let h = 65536;
    for (let f = 0, O = o.length; f < O; f += 2) {
      if (h += o[f], h > u) return !1;
      if (h += o[f + 1], h >= u) return !0;
    }
    return !1;
  }
  function bs(u) {
    return u < 65 ? u === 36 : u <= 90 ? !0 : u < 97 ? u === 95 : u <= 122 ? !0 : u <= 65535 ? u >= 170 && CE.test(String.fromCharCode(u)) : $h(u, Yg);
  }
  function kn(u) {
    return u < 48 ? u === 36 : u < 58 ? !0 : u < 65 ? !1 : u <= 90 ? !0 : u < 97 ? u === 95 : u <= 122 ? !0 : u <= 65535 ? u >= 170 && EE.test(String.fromCharCode(u)) : $h(u, Yg) || $h(u, TE);
  }
  var Qh = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, kE = new Set(Qh.keyword), PE = new Set(Qh.strict), FE = new Set(Qh.strictBind);
  function Wg(u, o) {
    return o && u === "await" || u === "enum";
  }
  function Gg(u, o) {
    return Wg(u, o) || PE.has(u);
  }
  function Hg(u) {
    return FE.has(u);
  }
  function Jg(u, o) {
    return Gg(u, o) || Hg(u);
  }
  function $E(u) {
    return kE.has(u);
  }
  function QE(u, o, h) {
    return u === 64 && o === 64 && bs(h);
  }
  var BE = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function IE(u) {
    return BE.has(u);
  }
  var Bh = class {
    constructor(u) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = u;
    }
  }, Ih = class {
    constructor(u, o) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = u, this.inModule = o;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get allowNewTarget() {
      return (this.currentThisScopeFlags() & 512) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let u = this.currentThisScopeFlags();
      return (u & 64) > 0 && (u & 2) === 0;
    }
    get inStaticBlock() {
      for (let u = this.scopeStack.length - 1; ; u--) {
        let { flags: o } = this.scopeStack[u];
        if (o & 128) return !0;
        if (o & 1731) return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get inBareCaseStatement() {
      return (this.currentScope().flags & 256) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(u) {
      return new Bh(u);
    }
    enter(u) {
      this.scopeStack.push(this.createScope(u));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(u) {
      return !!(u.flags & 130 || !this.parser.inModule && u.flags & 1);
    }
    declareName(u, o, h) {
      let f = this.currentScope();
      if (o & 8 || o & 16) {
        this.checkRedeclarationInScope(f, u, o, h);
        let O = f.names.get(u) || 0;
        o & 16 ? O = O | 4 : (f.firstLexicalName || (f.firstLexicalName = u), O = O | 2), f.names.set(u, O), o & 8 && this.maybeExportDefined(f, u);
      } else if (o & 4) for (let O = this.scopeStack.length - 1; O >= 0 && (f = this.scopeStack[O], this.checkRedeclarationInScope(f, u, o, h), f.names.set(u, (f.names.get(u) || 0) | 1), this.maybeExportDefined(f, u), !(f.flags & 1667)); --O) ;
      this.parser.inModule && f.flags & 1 && this.undefinedExports.delete(u);
    }
    maybeExportDefined(u, o) {
      this.parser.inModule && u.flags & 1 && this.undefinedExports.delete(o);
    }
    checkRedeclarationInScope(u, o, h, f) {
      this.isRedeclaredInScope(u, o, h) && this.parser.raise(b.VarRedeclaration, f, { identifierName: o });
    }
    isRedeclaredInScope(u, o, h) {
      if (!(h & 1)) return !1;
      if (h & 8) return u.names.has(o);
      let f = u.names.get(o);
      return h & 16 ? (f & 2) > 0 || !this.treatFunctionsAsVarInScope(u) && (f & 1) > 0 : (f & 2) > 0 && !(u.flags & 8 && u.firstLexicalName === o) || !this.treatFunctionsAsVarInScope(u) && (f & 4) > 0;
    }
    checkLocalExport(u) {
      let { name: o } = u;
      this.scopeStack[0].names.has(o) || this.undefinedExports.set(o, u.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let u = this.scopeStack.length - 1; ; u--) {
        let { flags: o } = this.scopeStack[u];
        if (o & 1667) return o;
      }
    }
    currentThisScopeFlags() {
      for (let u = this.scopeStack.length - 1; ; u--) {
        let { flags: o } = this.scopeStack[u];
        if (o & 1731 && !(o & 4)) return o;
      }
    }
  }, NE = class extends Bh {
    constructor(...u) {
      super(...u), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, ME = class extends Ih {
    createScope(u) {
      return new NE(u);
    }
    declareName(u, o, h) {
      let f = this.currentScope();
      if (o & 2048) {
        this.checkRedeclarationInScope(f, u, o, h), this.maybeExportDefined(f, u), f.declareFunctions.add(u);
        return;
      }
      super.declareName(u, o, h);
    }
    isRedeclaredInScope(u, o, h) {
      if (super.isRedeclaredInScope(u, o, h)) return !0;
      if (h & 2048 && !u.declareFunctions.has(o)) {
        let f = u.names.get(o);
        return (f & 4) > 0 || (f & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(u) {
      this.scopeStack[0].declareFunctions.has(u.name) || super.checkLocalExport(u);
    }
  }, LE = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), ue = C`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: u }) => `Cannot overwrite reserved type ${u}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: u, enumName: o }) => `Boolean enum members need to be initialized. Use either \`${u} = true,\` or \`${u} = false,\` in enum \`${o}\`.`, EnumDuplicateMemberName: ({ memberName: u, enumName: o }) => `Enum member names need to be unique, but the name \`${u}\` has already been used before in enum \`${o}\`.`, EnumInconsistentMemberValues: ({ enumName: u }) => `Enum \`${u}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: u, enumName: o }) => `Enum type \`${u}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${o}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: u }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${u}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: u, memberName: o, explicitType: h }) => `Enum \`${u}\` has type \`${h}\`, so the initializer of \`${o}\` needs to be a ${h} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: u, memberName: o }) => `Symbol enum members cannot be initialized. Use \`${o},\` in enum \`${u}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: u, memberName: o }) => `The enum member initializer for \`${o}\` needs to be a literal (either a boolean, number, or string) in enum \`${u}\`.`, EnumInvalidMemberName: ({ enumName: u, memberName: o, suggestion: h }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${o}\`, consider using \`${h}\`, in enum \`${u}\`.`, EnumNumberMemberNotInitialized: ({ enumName: u, memberName: o }) => `Number enum members need to be initialized, e.g. \`${o} = 1\` in enum \`${u}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: u }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${u}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: u }) => `Unexpected reserved type ${u}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: u, suggestion: o }) => `\`declare export ${u}\` is not supported. Use \`${o}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
  function _E(u) {
    return u.type === "DeclareExportAllDeclaration" || u.type === "DeclareExportDeclaration" && (!u.declaration || u.declaration.type !== "TypeAlias" && u.declaration.type !== "InterfaceDeclaration");
  }
  function Kg(u) {
    return u.importKind === "type" || u.importKind === "typeof";
  }
  var RE = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
  function qE(u, o) {
    let h = [], f = [];
    for (let O = 0; O < u.length; O++) (o(u[O], O, u) ? h : f).push(u[O]);
    return [h, f];
  }
  var jE = /\*?\s*@((?:no)?flow)\b/, XE = (u) => class extends u {
    constructor(...o) {
      super(...o), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return ME;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    finishToken(o, h) {
      o !== 134 && o !== 13 && o !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(o, h);
    }
    addComment(o) {
      if (this.flowPragma === void 0) {
        let h = jE.exec(o.value);
        if (h) if (h[1] === "flow") this.flowPragma = "flow";
        else if (h[1] === "noflow") this.flowPragma = "noflow";
        else throw new Error("Unexpected flow pragma");
      }
      super.addComment(o);
    }
    flowParseTypeInitialiser(o) {
      let h = this.state.inType;
      this.state.inType = !0, this.expect(o || 14);
      let f = this.flowParseType();
      return this.state.inType = h, f;
    }
    flowParsePredicate() {
      let o = this.startNode(), h = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > h.index + 1 && this.raise(ue.UnexpectedSpaceBetweenModuloChecks, h), this.eat(10) ? (o.value = super.parseExpression(), this.expect(11), this.finishNode(o, "DeclaredPredicate")) : this.finishNode(o, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let o = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let h = null, f = null;
      return this.match(54) ? (this.state.inType = o, f = this.flowParsePredicate()) : (h = this.flowParseType(), this.state.inType = o, this.match(54) && (f = this.flowParsePredicate())), [h, f];
    }
    flowParseDeclareClass(o) {
      return this.next(), this.flowParseInterfaceish(o, !0), this.finishNode(o, "DeclareClass");
    }
    flowParseDeclareFunction(o) {
      this.next();
      let h = o.id = this.parseIdentifier(), f = this.startNode(), O = this.startNode();
      this.match(47) ? f.typeParameters = this.flowParseTypeParameterDeclaration() : f.typeParameters = null, this.expect(10);
      let D = this.flowParseFunctionTypeParams();
      return f.params = D.params, f.rest = D.rest, f.this = D._this, this.expect(11), [f.returnType, o.predicate] = this.flowParseTypeAndPredicateInitialiser(), O.typeAnnotation = this.finishNode(f, "FunctionTypeAnnotation"), h.typeAnnotation = this.finishNode(O, "TypeAnnotation"), this.resetEndLocation(h), this.semicolon(), this.scope.declareName(o.id.name, 2048, o.id.loc.start), this.finishNode(o, "DeclareFunction");
    }
    flowParseDeclare(o, h) {
      if (this.match(80)) return this.flowParseDeclareClass(o);
      if (this.match(68)) return this.flowParseDeclareFunction(o);
      if (this.match(74)) return this.flowParseDeclareVariable(o);
      if (this.eatContextual(127)) return this.match(16) ? this.flowParseDeclareModuleExports(o) : (h && this.raise(ue.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(o));
      if (this.isContextual(130)) return this.flowParseDeclareTypeAlias(o);
      if (this.isContextual(131)) return this.flowParseDeclareOpaqueType(o);
      if (this.isContextual(129)) return this.flowParseDeclareInterface(o);
      if (this.match(82)) return this.flowParseDeclareExportDeclaration(o, h);
      this.unexpected();
    }
    flowParseDeclareVariable(o) {
      return this.next(), o.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(o.id.name, 5, o.id.loc.start), this.semicolon(), this.finishNode(o, "DeclareVariable");
    }
    flowParseDeclareModule(o) {
      this.scope.enter(0), this.match(134) ? o.id = super.parseExprAtom() : o.id = this.parseIdentifier();
      let h = o.body = this.startNode(), f = h.body = [];
      for (this.expect(5); !this.match(8); ) {
        let S = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(ue.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(S)) : (this.expectContextual(125, ue.UnsupportedStatementInDeclareModule), S = this.flowParseDeclare(S, !0)), f.push(S);
      }
      this.scope.exit(), this.expect(8), this.finishNode(h, "BlockStatement");
      let O = null, D = !1;
      return f.forEach((S) => {
        _E(S) ? (O === "CommonJS" && this.raise(ue.AmbiguousDeclareModuleKind, S), O = "ES") : S.type === "DeclareModuleExports" && (D && this.raise(ue.DuplicateDeclareModuleExports, S), O === "ES" && this.raise(ue.AmbiguousDeclareModuleKind, S), O = "CommonJS", D = !0);
      }), o.kind = O || "CommonJS", this.finishNode(o, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(o, h) {
      if (this.expect(82), this.eat(65)) return this.match(68) || this.match(80) ? o.declaration = this.flowParseDeclare(this.startNode()) : (o.declaration = this.flowParseType(), this.semicolon()), o.default = !0, this.finishNode(o, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !h) {
        let f = this.state.value;
        throw this.raise(ue.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: f, suggestion: RE[f] });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) return o.declaration = this.flowParseDeclare(this.startNode()), o.default = !1, this.finishNode(o, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) return o = this.parseExport(o, null), o.type === "ExportNamedDeclaration" ? (o.default = !1, delete o.exportKind, this.castNodeTo(o, "DeclareExportDeclaration")) : this.castNodeTo(o, "DeclareExportAllDeclaration");
      this.unexpected();
    }
    flowParseDeclareModuleExports(o) {
      return this.next(), this.expectContextual(111), o.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(o, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(o) {
      this.next();
      let h = this.flowParseTypeAlias(o);
      return this.castNodeTo(h, "DeclareTypeAlias"), h;
    }
    flowParseDeclareOpaqueType(o) {
      this.next();
      let h = this.flowParseOpaqueType(o, !0);
      return this.castNodeTo(h, "DeclareOpaqueType"), h;
    }
    flowParseDeclareInterface(o) {
      return this.next(), this.flowParseInterfaceish(o, !1), this.finishNode(o, "DeclareInterface");
    }
    flowParseInterfaceish(o, h) {
      if (o.id = this.flowParseRestrictedIdentifier(!h, !0), this.scope.declareName(o.id.name, h ? 17 : 8201, o.id.loc.start), this.match(47) ? o.typeParameters = this.flowParseTypeParameterDeclaration() : o.typeParameters = null, o.extends = [], this.eat(81)) do
        o.extends.push(this.flowParseInterfaceExtends());
      while (!h && this.eat(12));
      if (h) {
        if (o.implements = [], o.mixins = [], this.eatContextual(117)) do
          o.mixins.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
        if (this.eatContextual(113)) do
          o.implements.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      }
      o.body = this.flowParseObjectType({ allowStatic: h, allowExact: !1, allowSpread: !1, allowProto: h, allowInexact: !1 });
    }
    flowParseInterfaceExtends() {
      let o = this.startNode();
      return o.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? o.typeParameters = this.flowParseTypeParameterInstantiation() : o.typeParameters = null, this.finishNode(o, "InterfaceExtends");
    }
    flowParseInterface(o) {
      return this.flowParseInterfaceish(o, !1), this.finishNode(o, "InterfaceDeclaration");
    }
    checkNotUnderscore(o) {
      o === "_" && this.raise(ue.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(o, h, f) {
      LE.has(o) && this.raise(f ? ue.AssignReservedType : ue.UnexpectedReservedType, h, { reservedType: o });
    }
    flowParseRestrictedIdentifier(o, h) {
      return this.checkReservedType(this.state.value, this.state.startLoc, h), this.parseIdentifier(o);
    }
    flowParseTypeAlias(o) {
      return o.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(o.id.name, 8201, o.id.loc.start), this.match(47) ? o.typeParameters = this.flowParseTypeParameterDeclaration() : o.typeParameters = null, o.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(o, "TypeAlias");
    }
    flowParseOpaqueType(o, h) {
      return this.expectContextual(130), o.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(o.id.name, 8201, o.id.loc.start), this.match(47) ? o.typeParameters = this.flowParseTypeParameterDeclaration() : o.typeParameters = null, o.supertype = null, this.match(14) && (o.supertype = this.flowParseTypeInitialiser(14)), o.impltype = null, h || (o.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(o, "OpaqueType");
    }
    flowParseTypeParameter(o = !1) {
      let h = this.state.startLoc, f = this.startNode(), O = this.flowParseVariance(), D = this.flowParseTypeAnnotatableIdentifier();
      return f.name = D.name, f.variance = O, f.bound = D.typeAnnotation, this.match(29) ? (this.eat(29), f.default = this.flowParseType()) : o && this.raise(ue.MissingTypeParamDefault, h), this.finishNode(f, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let o = this.state.inType, h = this.startNode();
      h.params = [], this.state.inType = !0, this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let f = !1;
      do {
        let O = this.flowParseTypeParameter(f);
        h.params.push(O), O.default && (f = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = o, this.finishNode(h, "TypeParameterDeclaration");
    }
    flowInTopLevelContext(o) {
      if (this.curContext() !== V.brace) {
        let h = this.state.context;
        this.state.context = [h[0]];
        try {
          return o();
        } finally {
          this.state.context = h;
        }
      } else return o();
    }
    flowParseTypeParameterInstantiationInExpression() {
      if (this.reScan_lt() === 47) return this.flowParseTypeParameterInstantiation();
    }
    flowParseTypeParameterInstantiation() {
      let o = this.startNode(), h = this.state.inType;
      return this.state.inType = !0, o.params = [], this.flowInTopLevelContext(() => {
        this.expect(47);
        let f = this.state.noAnonFunctionType;
        for (this.state.noAnonFunctionType = !1; !this.match(48); ) o.params.push(this.flowParseType()), this.match(48) || this.expect(12);
        this.state.noAnonFunctionType = f;
      }), this.state.inType = h, !this.state.inType && this.curContext() === V.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(o, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      if (this.reScan_lt() !== 47) return;
      let o = this.startNode(), h = this.state.inType;
      for (o.params = [], this.state.inType = !0, this.expect(47); !this.match(48); ) o.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = h, this.finishNode(o, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let o = this.startNode();
      if (this.expectContextual(129), o.extends = [], this.eat(81)) do
        o.extends.push(this.flowParseInterfaceExtends());
      while (this.eat(12));
      return o.body = this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !1, allowProto: !1, allowInexact: !1 }), this.finishNode(o, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(o, h, f) {
      return o.static = h, this.lookahead().type === 14 ? (o.id = this.flowParseObjectPropertyKey(), o.key = this.flowParseTypeInitialiser()) : (o.id = null, o.key = this.flowParseType()), this.expect(3), o.value = this.flowParseTypeInitialiser(), o.variance = f, this.finishNode(o, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(o, h) {
      return o.static = h, o.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (o.method = !0, o.optional = !1, o.value = this.flowParseObjectTypeMethodish(this.startNodeAt(o.loc.start))) : (o.method = !1, this.eat(17) && (o.optional = !0), o.value = this.flowParseTypeInitialiser()), this.finishNode(o, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(o) {
      for (o.params = [], o.rest = null, o.typeParameters = null, o.this = null, this.match(47) && (o.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (o.this = this.flowParseFunctionTypeParam(!0), o.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) o.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (o.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), o.returnType = this.flowParseTypeInitialiser(), this.finishNode(o, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(o, h) {
      let f = this.startNode();
      return o.static = h, o.value = this.flowParseObjectTypeMethodish(f), this.finishNode(o, "ObjectTypeCallProperty");
    }
    flowParseObjectType({ allowStatic: o, allowExact: h, allowSpread: f, allowProto: O, allowInexact: D }) {
      let S = this.state.inType;
      this.state.inType = !0;
      let A = this.startNode();
      A.callProperties = [], A.properties = [], A.indexers = [], A.internalSlots = [];
      let P, E, M = !1;
      for (h && this.match(6) ? (this.expect(6), P = 9, E = !0) : (this.expect(5), P = 8, E = !1), A.exact = E; !this.match(P); ) {
        let H = !1, ie = null, ye = null, Ye = this.startNode();
        if (O && this.isContextual(118)) {
          let We = this.lookahead();
          We.type !== 14 && We.type !== 17 && (this.next(), ie = this.state.startLoc, o = !1);
        }
        if (o && this.isContextual(106)) {
          let We = this.lookahead();
          We.type !== 14 && We.type !== 17 && (this.next(), H = !0);
        }
        let Te = this.flowParseVariance();
        if (this.eat(0)) ie != null && this.unexpected(ie), this.eat(0) ? (Te && this.unexpected(Te.loc.start), A.internalSlots.push(this.flowParseObjectTypeInternalSlot(Ye, H))) : A.indexers.push(this.flowParseObjectTypeIndexer(Ye, H, Te));
        else if (this.match(10) || this.match(47)) ie != null && this.unexpected(ie), Te && this.unexpected(Te.loc.start), A.callProperties.push(this.flowParseObjectTypeCallProperty(Ye, H));
        else {
          let We = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let jh = this.lookahead();
            Vg(jh.type) && (We = this.state.value, this.next());
          }
          let rr = this.flowParseObjectTypeProperty(Ye, H, ie, Te, We, f, D != null ? D : !E);
          rr === null ? (M = !0, ye = this.state.lastTokStartLoc) : A.properties.push(rr);
        }
        this.flowObjectTypeSemicolon(), ye && !this.match(8) && !this.match(9) && this.raise(ue.UnexpectedExplicitInexactInObject, ye);
      }
      this.expect(P), f && (A.inexact = M);
      let Z = this.finishNode(A, "ObjectTypeAnnotation");
      return this.state.inType = S, Z;
    }
    flowParseObjectTypeProperty(o, h, f, O, D, S, A) {
      if (this.eat(21)) return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (S ? A || this.raise(ue.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(ue.InexactInsideNonObject, this.state.lastTokStartLoc), O && this.raise(ue.InexactVariance, O), null) : (S || this.raise(ue.UnexpectedSpreadType, this.state.lastTokStartLoc), f != null && this.unexpected(f), O && this.raise(ue.SpreadVariance, O), o.argument = this.flowParseType(), this.finishNode(o, "ObjectTypeSpreadProperty"));
      {
        o.key = this.flowParseObjectPropertyKey(), o.static = h, o.proto = f != null, o.kind = D;
        let P = !1;
        return this.match(47) || this.match(10) ? (o.method = !0, f != null && this.unexpected(f), O && this.unexpected(O.loc.start), o.value = this.flowParseObjectTypeMethodish(this.startNodeAt(o.loc.start)), (D === "get" || D === "set") && this.flowCheckGetterSetterParams(o), !S && o.key.name === "constructor" && o.value.this && this.raise(ue.ThisParamBannedInConstructor, o.value.this)) : (D !== "init" && this.unexpected(), o.method = !1, this.eat(17) && (P = !0), o.value = this.flowParseTypeInitialiser(), o.variance = O), o.optional = P, this.finishNode(o, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(o) {
      let h = o.kind === "get" ? 0 : 1, f = o.value.params.length + (o.value.rest ? 1 : 0);
      o.value.this && this.raise(o.kind === "get" ? ue.GetterMayNotHaveThisParam : ue.SetterMayNotHaveThisParam, o.value.this), f !== h && this.raise(o.kind === "get" ? b.BadGetterArity : b.BadSetterArity, o), o.kind === "set" && o.value.rest && this.raise(b.BadSetterRestParameter, o);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(o, h) {
      o != null || (o = this.state.startLoc);
      let f = h || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let O = this.startNodeAt(o);
        O.qualification = f, O.id = this.flowParseRestrictedIdentifier(!0), f = this.finishNode(O, "QualifiedTypeIdentifier");
      }
      return f;
    }
    flowParseGenericType(o, h) {
      let f = this.startNodeAt(o);
      return f.typeParameters = null, f.id = this.flowParseQualifiedTypeIdentifier(o, h), this.match(47) && (f.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(f, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let o = this.startNode();
      return this.expect(87), o.argument = this.flowParsePrimaryType(), this.finishNode(o, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let o = this.startNode();
      for (o.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (o.types.push(this.flowParseType()), !this.match(3)); ) this.expect(12);
      return this.expect(3), this.finishNode(o, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(o) {
      let h = null, f = !1, O = null, D = this.startNode(), S = this.lookahead(), A = this.state.type === 78;
      return S.type === 14 || S.type === 17 ? (A && !o && this.raise(ue.ThisParamMustBeFirst, D), h = this.parseIdentifier(A), this.eat(17) && (f = !0, A && this.raise(ue.ThisParamMayNotBeOptional, D)), O = this.flowParseTypeInitialiser()) : O = this.flowParseType(), D.name = h, D.optional = f, D.typeAnnotation = O, this.finishNode(D, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(o) {
      let h = this.startNodeAt(o.loc.start);
      return h.name = null, h.optional = !1, h.typeAnnotation = o, this.finishNode(h, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(o = []) {
      let h = null, f = null;
      for (this.match(78) && (f = this.flowParseFunctionTypeParam(!0), f.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) o.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (h = this.flowParseFunctionTypeParam(!1)), { params: o, rest: h, _this: f };
    }
    flowIdentToTypeAnnotation(o, h, f) {
      switch (f.name) {
        case "any":
          return this.finishNode(h, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(h, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(h, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(h, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(h, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(h, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(h, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(f.name), this.flowParseGenericType(o, f);
      }
    }
    flowParsePrimaryType() {
      let o = this.state.startLoc, h = this.startNode(), f, O, D = !1, S = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !0, allowProto: !1, allowInexact: !0 });
        case 6:
          return this.flowParseObjectType({ allowStatic: !1, allowExact: !0, allowSpread: !0, allowProto: !1, allowInexact: !1 });
        case 0:
          return this.state.noAnonFunctionType = !1, O = this.flowParseTupleType(), this.state.noAnonFunctionType = S, O;
        case 47: {
          let A = this.startNode();
          return A.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), f = this.flowParseFunctionTypeParams(), A.params = f.params, A.rest = f.rest, A.this = f._this, this.expect(11), this.expect(19), A.returnType = this.flowParseType(), this.finishNode(A, "FunctionTypeAnnotation");
        }
        case 10: {
          let A = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21)) if (xe(this.state.type) || this.match(78)) {
            let P = this.lookahead().type;
            D = P !== 17 && P !== 14;
          } else D = !0;
          if (D) {
            if (this.state.noAnonFunctionType = !1, O = this.flowParseType(), this.state.noAnonFunctionType = S, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) return this.expect(11), O;
            this.eat(12);
          }
          return O ? f = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(O)]) : f = this.flowParseFunctionTypeParams(), A.params = f.params, A.rest = f.rest, A.this = f._this, this.expect(11), this.expect(19), A.returnType = this.flowParseType(), A.typeParameters = null, this.finishNode(A, "FunctionTypeAnnotation");
        }
        case 134:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return h.value = this.match(85), this.next(), this.finishNode(h, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(135)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", h);
            if (this.match(136)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", h);
            throw this.raise(ue.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 135:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 136:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(h, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(h, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(h, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(h, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (Ph(this.state.type)) {
            let A = ti(this.state.type);
            return this.next(), super.createIdentifier(h, A);
          } else if (xe(this.state.type)) return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(o, h, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let o = this.state.startLoc, h = this.flowParsePrimaryType(), f = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let O = this.startNodeAt(o), D = this.eat(18);
        f = f || D, this.expect(0), !D && this.match(3) ? (O.elementType = h, this.next(), h = this.finishNode(O, "ArrayTypeAnnotation")) : (O.objectType = h, O.indexType = this.flowParseType(), this.expect(3), f ? (O.optional = D, h = this.finishNode(O, "OptionalIndexedAccessType")) : h = this.finishNode(O, "IndexedAccessType"));
      }
      return h;
    }
    flowParsePrefixType() {
      let o = this.startNode();
      return this.eat(17) ? (o.typeAnnotation = this.flowParsePrefixType(), this.finishNode(o, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let o = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let h = this.startNodeAt(o.loc.start);
        return h.params = [this.reinterpretTypeAsFunctionTypeParam(o)], h.rest = null, h.this = null, h.returnType = this.flowParseType(), h.typeParameters = null, this.finishNode(h, "FunctionTypeAnnotation");
      }
      return o;
    }
    flowParseIntersectionType() {
      let o = this.startNode();
      this.eat(45);
      let h = this.flowParseAnonFunctionWithoutParens();
      for (o.types = [h]; this.eat(45); ) o.types.push(this.flowParseAnonFunctionWithoutParens());
      return o.types.length === 1 ? h : this.finishNode(o, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let o = this.startNode();
      this.eat(43);
      let h = this.flowParseIntersectionType();
      for (o.types = [h]; this.eat(43); ) o.types.push(this.flowParseIntersectionType());
      return o.types.length === 1 ? h : this.finishNode(o, "UnionTypeAnnotation");
    }
    flowParseType() {
      let o = this.state.inType;
      this.state.inType = !0;
      let h = this.flowParseUnionType();
      return this.state.inType = o, h;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let o = this.state.startLoc, h = this.parseIdentifier();
        return this.flowParseGenericType(o, h);
      } else return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let o = this.startNode();
      return o.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(o, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(o) {
      let h = o ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (h.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(h)), h;
    }
    typeCastToParameter(o) {
      return o.expression.typeAnnotation = o.typeAnnotation, this.resetEndLocation(o.expression, o.typeAnnotation.loc.end), o.expression;
    }
    flowParseVariance() {
      let o = null;
      return this.match(53) ? (o = this.startNode(), this.state.value === "+" ? o.kind = "plus" : o.kind = "minus", this.next(), this.finishNode(o, "Variance")) : o;
    }
    parseFunctionBody(o, h, f = !1) {
      if (h) {
        this.forwardNoArrowParamsConversionAt(o, () => super.parseFunctionBody(o, !0, f));
        return;
      }
      super.parseFunctionBody(o, !1, f);
    }
    parseFunctionBodyAndFinish(o, h, f = !1) {
      if (this.match(14)) {
        let O = this.startNode();
        [O.typeAnnotation, o.predicate] = this.flowParseTypeAndPredicateInitialiser(), o.returnType = O.typeAnnotation ? this.finishNode(O, "TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(o, h, f);
    }
    parseStatementLike(o) {
      if (this.state.strict && this.isContextual(129)) {
        let f = this.lookahead();
        if (Fr(f.type)) {
          let O = this.startNode();
          return this.next(), this.flowParseInterface(O);
        }
      } else if (this.isContextual(126)) {
        let f = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(f);
      }
      let h = super.parseStatementLike(o);
      return this.flowPragma === void 0 && !this.isValidDirective(h) && (this.flowPragma = null), h;
    }
    parseExpressionStatement(o, h, f) {
      if (h.type === "Identifier") {
        if (h.name === "declare") {
          if (this.match(80) || xe(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(o);
        } else if (xe(this.state.type)) {
          if (h.name === "interface") return this.flowParseInterface(o);
          if (h.name === "type") return this.flowParseTypeAlias(o);
          if (h.name === "opaque") return this.flowParseOpaqueType(o, !1);
        }
      }
      return super.parseExpressionStatement(o, h, f);
    }
    shouldParseExportDeclaration() {
      let { type: o } = this.state;
      return o === 126 || zg(o) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let { type: o } = this.state;
      return o === 126 || zg(o) ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.isContextual(126)) {
        let o = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(o);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(o, h, f) {
      if (!this.match(17)) return o;
      if (this.state.maybeInArrowParameters) {
        let Z = this.lookaheadCharCode();
        if (Z === 44 || Z === 61 || Z === 58 || Z === 41) return this.setOptionalParametersError(f), o;
      }
      this.expect(17);
      let O = this.state.clone(), D = this.state.noArrowAt, S = this.startNodeAt(h), { consequent: A, failed: P } = this.tryParseConditionalConsequent(), [E, M] = this.getArrowLikeExpressions(A);
      if (P || M.length > 0) {
        let Z = [...D];
        if (M.length > 0) {
          this.state = O, this.state.noArrowAt = Z;
          for (let H = 0; H < M.length; H++) Z.push(M[H].start);
          ({ consequent: A, failed: P } = this.tryParseConditionalConsequent()), [E, M] = this.getArrowLikeExpressions(A);
        }
        P && E.length > 1 && this.raise(ue.AmbiguousConditionalArrow, O.startLoc), P && E.length === 1 && (this.state = O, Z.push(E[0].start), this.state.noArrowAt = Z, { consequent: A, failed: P } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(A, !0), this.state.noArrowAt = D, this.expect(14), S.test = o, S.consequent = A, S.alternate = this.forwardNoArrowParamsConversionAt(S, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(S, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let o = this.parseMaybeAssignAllowIn(), h = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), { consequent: o, failed: h };
    }
    getArrowLikeExpressions(o, h) {
      let f = [o], O = [];
      for (; f.length !== 0; ) {
        let D = f.pop();
        D.type === "ArrowFunctionExpression" && D.body.type !== "BlockStatement" ? (D.typeParameters || !D.returnType ? this.finishArrowValidation(D) : O.push(D), f.push(D.body)) : D.type === "ConditionalExpression" && (f.push(D.consequent), f.push(D.alternate));
      }
      return h ? (O.forEach((D) => this.finishArrowValidation(D)), [O, []]) : qE(O, (D) => D.params.every((S) => this.isAssignable(S, !0)));
    }
    finishArrowValidation(o) {
      var h;
      this.toAssignableList(o.params, (h = o.extra) == null ? void 0 : h.trailingCommaLoc, !1), this.scope.enter(518), super.checkParams(o, !1, !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(o, h) {
      let f;
      return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(o.start)) ? (this.state.noArrowParamsConversionAt.push(this.state.start), f = h(), this.state.noArrowParamsConversionAt.pop()) : f = h(), f;
    }
    parseParenItem(o, h) {
      let f = super.parseParenItem(o, h);
      if (this.eat(17) && (f.optional = !0, this.resetEndLocation(o)), this.match(14)) {
        let O = this.startNodeAt(h);
        return O.expression = f, O.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(O, "TypeCastExpression");
      }
      return f;
    }
    assertModuleNodeAllowed(o) {
      o.type === "ImportDeclaration" && (o.importKind === "type" || o.importKind === "typeof") || o.type === "ExportNamedDeclaration" && o.exportKind === "type" || o.type === "ExportAllDeclaration" && o.exportKind === "type" || super.assertModuleNodeAllowed(o);
    }
    parseExportDeclaration(o) {
      if (this.isContextual(130)) {
        o.exportKind = "type";
        let h = this.startNode();
        return this.next(), this.match(5) ? (o.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(o), null) : this.flowParseTypeAlias(h);
      } else if (this.isContextual(131)) {
        o.exportKind = "type";
        let h = this.startNode();
        return this.next(), this.flowParseOpaqueType(h, !1);
      } else if (this.isContextual(129)) {
        o.exportKind = "type";
        let h = this.startNode();
        return this.next(), this.flowParseInterface(h);
      } else if (this.isContextual(126)) {
        o.exportKind = "value";
        let h = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(h);
      } else return super.parseExportDeclaration(o);
    }
    eatExportStar(o) {
      return super.eatExportStar(o) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (o.exportKind = "type", this.next(), this.next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(o) {
      let { startLoc: h } = this.state, f = super.maybeParseExportNamespaceSpecifier(o);
      return f && o.exportKind === "type" && this.unexpected(h), f;
    }
    parseClassId(o, h, f) {
      super.parseClassId(o, h, f), this.match(47) && (o.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(o, h, f) {
      let { startLoc: O } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(o, h)) return;
        h.declare = !0;
      }
      super.parseClassMember(o, h, f), h.declare && (h.type !== "ClassProperty" && h.type !== "ClassPrivateProperty" && h.type !== "PropertyDefinition" ? this.raise(ue.DeclareClassElement, O) : h.value && this.raise(ue.DeclareClassFieldInitializer, h.value));
    }
    isIterator(o) {
      return o === "iterator" || o === "asyncIterator";
    }
    readIterator() {
      let o = super.readWord1(), h = "@@" + o;
      (!this.isIterator(o) || !this.state.inType) && this.raise(b.InvalidIdentifier, this.state.curPosition(), { identifierName: h }), this.finishToken(132, h);
    }
    getTokenFromCode(o) {
      let h = this.input.charCodeAt(this.state.pos + 1);
      o === 123 && h === 124 ? this.finishOp(6, 2) : this.state.inType && (o === 62 || o === 60) ? this.finishOp(o === 62 ? 48 : 47, 1) : this.state.inType && o === 63 ? h === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : QE(o, h, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(o);
    }
    isAssignable(o, h) {
      return o.type === "TypeCastExpression" ? this.isAssignable(o.expression, h) : super.isAssignable(o, h);
    }
    toAssignable(o, h = !1) {
      !h && o.type === "AssignmentExpression" && o.left.type === "TypeCastExpression" && (o.left = this.typeCastToParameter(o.left)), super.toAssignable(o, h);
    }
    toAssignableList(o, h, f) {
      for (let O = 0; O < o.length; O++) {
        let D = o[O];
        (D == null ? void 0 : D.type) === "TypeCastExpression" && (o[O] = this.typeCastToParameter(D));
      }
      super.toAssignableList(o, h, f);
    }
    toReferencedList(o, h) {
      for (let O = 0; O < o.length; O++) {
        var f;
        let D = o[O];
        D && D.type === "TypeCastExpression" && !((f = D.extra) != null && f.parenthesized) && (o.length > 1 || !h) && this.raise(ue.TypeCastInPattern, D.typeAnnotation);
      }
      return o;
    }
    parseArrayLike(o, h, f, O) {
      let D = super.parseArrayLike(o, h, f, O);
      return h && !this.state.maybeInArrowParameters && this.toReferencedList(D.elements), D;
    }
    isValidLVal(o, h, f) {
      return o === "TypeCastExpression" || super.isValidLVal(o, h, f);
    }
    parseClassProperty(o) {
      return this.match(14) && (o.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(o);
    }
    parseClassPrivateProperty(o) {
      return this.match(14) && (o.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(o);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(o) {
      return !this.match(14) && super.isNonstaticConstructor(o);
    }
    pushClassMethod(o, h, f, O, D, S) {
      if (h.variance && this.unexpected(h.variance.loc.start), delete h.variance, this.match(47) && (h.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(o, h, f, O, D, S), h.params && D) {
        let A = h.params;
        A.length > 0 && this.isThisParam(A[0]) && this.raise(ue.ThisParamBannedInConstructor, h);
      } else if (h.type === "MethodDefinition" && D && h.value.params) {
        let A = h.value.params;
        A.length > 0 && this.isThisParam(A[0]) && this.raise(ue.ThisParamBannedInConstructor, h);
      }
    }
    pushClassPrivateMethod(o, h, f, O) {
      h.variance && this.unexpected(h.variance.loc.start), delete h.variance, this.match(47) && (h.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(o, h, f, O);
    }
    parseClassSuper(o) {
      if (super.parseClassSuper(o), o.superClass && (this.match(47) || this.match(51)) && (o.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression()), this.isContextual(113)) {
        this.next();
        let h = o.implements = [];
        do {
          let f = this.startNode();
          f.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? f.typeParameters = this.flowParseTypeParameterInstantiation() : f.typeParameters = null, h.push(this.finishNode(f, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(o) {
      super.checkGetterSetterParams(o);
      let h = this.getObjectOrClassMethodParams(o);
      if (h.length > 0) {
        let f = h[0];
        this.isThisParam(f) && o.kind === "get" ? this.raise(ue.GetterMayNotHaveThisParam, f) : this.isThisParam(f) && this.raise(ue.SetterMayNotHaveThisParam, f);
      }
    }
    parsePropertyNamePrefixOperator(o) {
      o.variance = this.flowParseVariance();
    }
    parseObjPropValue(o, h, f, O, D, S, A) {
      o.variance && this.unexpected(o.variance.loc.start), delete o.variance;
      let P;
      this.match(47) && !S && (P = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let E = super.parseObjPropValue(o, h, f, O, D, S, A);
      return P && ((E.value || E).typeParameters = P), E;
    }
    parseFunctionParamType(o) {
      return this.eat(17) && (o.type !== "Identifier" && this.raise(ue.PatternIsOptional, o), this.isThisParam(o) && this.raise(ue.ThisParamMayNotBeOptional, o), o.optional = !0), this.match(14) ? o.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(o) && this.raise(ue.ThisParamAnnotationRequired, o), this.match(29) && this.isThisParam(o) && this.raise(ue.ThisParamNoDefault, o), this.resetEndLocation(o), o;
    }
    parseMaybeDefault(o, h) {
      let f = super.parseMaybeDefault(o, h);
      return f.type === "AssignmentPattern" && f.typeAnnotation && f.right.start < f.typeAnnotation.start && this.raise(ue.TypeBeforeInitializer, f.typeAnnotation), f;
    }
    checkImportReflection(o) {
      super.checkImportReflection(o), o.module && o.importKind !== "value" && this.raise(ue.ImportReflectionHasImportType, o.specifiers[0].loc.start);
    }
    parseImportSpecifierLocal(o, h, f) {
      h.local = Kg(o) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), o.specifiers.push(this.finishImportSpecifier(h, f));
    }
    isPotentialImportPhase(o) {
      if (super.isPotentialImportPhase(o)) return !0;
      if (this.isContextual(130)) {
        if (!o) return !0;
        let h = this.lookaheadCharCode();
        return h === 123 || h === 42;
      }
      return !o && this.isContextual(87);
    }
    applyImportPhase(o, h, f, O) {
      if (super.applyImportPhase(o, h, f, O), h) {
        if (!f && this.match(65)) return;
        o.exportKind = f === "type" ? f : "value";
      } else f === "type" && this.match(55) && this.unexpected(), o.importKind = f === "type" || f === "typeof" ? f : "value";
    }
    parseImportSpecifier(o, h, f, O, D) {
      let S = o.imported, A = null;
      S.type === "Identifier" && (S.name === "type" ? A = "type" : S.name === "typeof" && (A = "typeof"));
      let P = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let M = this.parseIdentifier(!0);
        A !== null && !Fr(this.state.type) ? (o.imported = M, o.importKind = A, o.local = this.cloneIdentifier(M)) : (o.imported = S, o.importKind = null, o.local = this.parseIdentifier());
      } else {
        if (A !== null && Fr(this.state.type)) o.imported = this.parseIdentifier(!0), o.importKind = A;
        else {
          if (h) throw this.raise(b.ImportBindingIsString, o, { importName: S.value });
          o.imported = S, o.importKind = null;
        }
        this.eatContextual(93) ? o.local = this.parseIdentifier() : (P = !0, o.local = this.cloneIdentifier(o.imported));
      }
      let E = Kg(o);
      return f && E && this.raise(ue.ImportTypeShorthandOnlyInPureImport, o), (f || E) && this.checkReservedType(o.local.name, o.local.loc.start, !0), P && !f && !E && this.checkReservedWord(o.local.name, o.loc.start, !0, !0), this.finishImportSpecifier(o, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(o, h) {
      let f = o.kind;
      f !== "get" && f !== "set" && this.match(47) && (o.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(o, h);
    }
    parseVarId(o, h) {
      super.parseVarId(o, h), this.match(14) && (o.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(o.id));
    }
    parseAsyncArrowFromCallExpression(o, h) {
      if (this.match(14)) {
        let f = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, o.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = f;
      }
      return super.parseAsyncArrowFromCallExpression(o, h);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(o, h) {
      var f;
      let O = null, D;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (O = this.state.clone(), D = this.tryParse(() => super.parseMaybeAssign(o, h), O), !D.error) return D.node;
        let { context: P } = this.state, E = P[P.length - 1];
        (E === V.j_oTag || E === V.j_expr) && P.pop();
      }
      if ((f = D) != null && f.error || this.match(47)) {
        var S, A;
        O = O || this.state.clone();
        let P, E = this.tryParse((Z) => {
          var H;
          P = this.flowParseTypeParameterDeclaration();
          let ie = this.forwardNoArrowParamsConversionAt(P, () => {
            let Ye = super.parseMaybeAssign(o, h);
            return this.resetStartLocationFromNode(Ye, P), Ye;
          });
          (H = ie.extra) != null && H.parenthesized && Z();
          let ye = this.maybeUnwrapTypeCastExpression(ie);
          return ye.type !== "ArrowFunctionExpression" && Z(), ye.typeParameters = P, this.resetStartLocationFromNode(ye, P), ie;
        }, O), M = null;
        if (E.node && this.maybeUnwrapTypeCastExpression(E.node).type === "ArrowFunctionExpression") {
          if (!E.error && !E.aborted) return E.node.async && this.raise(ue.UnexpectedTypeParameterBeforeAsyncArrowFunction, P), E.node;
          M = E.node;
        }
        if ((S = D) != null && S.node) return this.state = D.failState, D.node;
        if (M) return this.state = E.failState, M;
        throw (A = D) != null && A.thrown ? D.error : E.thrown ? E.error : this.raise(ue.UnexpectedTokenAfterTypeParameter, P);
      }
      return super.parseMaybeAssign(o, h);
    }
    parseArrow(o) {
      if (this.match(14)) {
        let h = this.tryParse(() => {
          let f = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let O = this.startNode();
          return [O.typeAnnotation, o.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = f, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), O;
        });
        if (h.thrown) return null;
        h.error && (this.state = h.failState), o.returnType = h.node.typeAnnotation ? this.finishNode(h.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(o);
    }
    shouldParseArrow(o) {
      return this.match(14) || super.shouldParseArrow(o);
    }
    setArrowFunctionParameters(o, h) {
      this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(o.start)) ? o.params = h : super.setArrowFunctionParameters(o, h);
    }
    checkParams(o, h, f, O = !0) {
      if (!(f && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(o.start)))) {
        for (let D = 0; D < o.params.length; D++) this.isThisParam(o.params[D]) && D > 0 && this.raise(ue.ThisParamMustBeFirst, o.params[D]);
        super.checkParams(o, h, f, O);
      }
    }
    parseParenAndDistinguishExpression(o) {
      return super.parseParenAndDistinguishExpression(o && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
    }
    parseSubscripts(o, h, f) {
      if (o.type === "Identifier" && o.name === "async" && this.state.noArrowAt.includes(h.index)) {
        this.next();
        let O = this.startNodeAt(h);
        O.callee = o, O.arguments = super.parseCallExpressionArguments(11), o = this.finishNode(O, "CallExpression");
      } else if (o.type === "Identifier" && o.name === "async" && this.match(47)) {
        let O = this.state.clone(), D = this.tryParse((A) => this.parseAsyncArrowWithTypeParameters(h) || A(), O);
        if (!D.error && !D.aborted) return D.node;
        let S = this.tryParse(() => super.parseSubscripts(o, h, f), O);
        if (S.node && !S.error) return S.node;
        if (D.node) return this.state = D.failState, D.node;
        if (S.node) return this.state = S.failState, S.node;
        throw D.error || S.error;
      }
      return super.parseSubscripts(o, h, f);
    }
    parseSubscript(o, h, f, O) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (O.optionalChainMember = !0, f) return O.stop = !0, o;
        this.next();
        let D = this.startNodeAt(h);
        return D.callee = o, D.typeArguments = this.flowParseTypeParameterInstantiationInExpression(), this.expect(10), D.arguments = this.parseCallExpressionArguments(11), D.optional = !0, this.finishCallExpression(D, !0);
      } else if (!f && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
        let D = this.startNodeAt(h);
        D.callee = o;
        let S = this.tryParse(() => (D.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), D.arguments = super.parseCallExpressionArguments(11), O.optionalChainMember && (D.optional = !1), this.finishCallExpression(D, O.optionalChainMember)));
        if (S.node) return S.error && (this.state = S.failState), S.node;
      }
      return super.parseSubscript(o, h, f, O);
    }
    parseNewCallee(o) {
      super.parseNewCallee(o);
      let h = null;
      this.shouldParseTypes() && this.match(47) && (h = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), o.typeArguments = h;
    }
    parseAsyncArrowWithTypeParameters(o) {
      let h = this.startNodeAt(o);
      if (this.parseFunctionParams(h, !1), !!this.parseArrow(h)) return super.parseArrowExpression(h, void 0, !0);
    }
    readToken_mult_modulo(o) {
      let h = this.input.charCodeAt(this.state.pos + 1);
      if (o === 42 && h === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(o);
    }
    readToken_pipe_amp(o) {
      let h = this.input.charCodeAt(this.state.pos + 1);
      if (o === 124 && h === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(o);
    }
    parseTopLevel(o, h) {
      let f = super.parseTopLevel(o, h);
      return this.state.hasFlowComment && this.raise(ue.UnterminatedFlowComment, this.state.curPosition()), f;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment) throw this.raise(ue.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let o = this.skipFlowComment();
        o && (this.state.pos += o, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let { pos: o } = this.state, h = 2;
      for (; [32, 9].includes(this.input.charCodeAt(o + h)); ) h++;
      let f = this.input.charCodeAt(h + o), O = this.input.charCodeAt(h + o + 1);
      return f === 58 && O === 58 ? h + 2 : this.input.slice(h + o, h + o + 12) === "flow-include" ? h + 12 : f === 58 && O !== 58 ? h : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1) throw this.raise(b.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(o, { enumName: h, memberName: f }) {
      this.raise(ue.EnumBooleanMemberNotInitialized, o, { memberName: f, enumName: h });
    }
    flowEnumErrorInvalidMemberInitializer(o, h) {
      return this.raise(h.explicitType ? h.explicitType === "symbol" ? ue.EnumInvalidMemberInitializerSymbolType : ue.EnumInvalidMemberInitializerPrimaryType : ue.EnumInvalidMemberInitializerUnknownType, o, h);
    }
    flowEnumErrorNumberMemberNotInitialized(o, h) {
      this.raise(ue.EnumNumberMemberNotInitialized, o, h);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(o, h) {
      this.raise(ue.EnumStringMemberInconsistentlyInitialized, o, h);
    }
    flowEnumMemberInit() {
      let o = this.state.startLoc, h = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 135: {
          let f = this.parseNumericLiteral(this.state.value);
          return h() ? { type: "number", loc: f.loc.start, value: f } : { type: "invalid", loc: o };
        }
        case 134: {
          let f = this.parseStringLiteral(this.state.value);
          return h() ? { type: "string", loc: f.loc.start, value: f } : { type: "invalid", loc: o };
        }
        case 85:
        case 86: {
          let f = this.parseBooleanLiteral(this.match(85));
          return h() ? { type: "boolean", loc: f.loc.start, value: f } : { type: "invalid", loc: o };
        }
        default:
          return { type: "invalid", loc: o };
      }
    }
    flowEnumMemberRaw() {
      let o = this.state.startLoc, h = this.parseIdentifier(!0), f = this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: o };
      return { id: h, init: f };
    }
    flowEnumCheckExplicitTypeMismatch(o, h, f) {
      let { explicitType: O } = h;
      O !== null && O !== f && this.flowEnumErrorInvalidMemberInitializer(o, h);
    }
    flowEnumMembers({ enumName: o, explicitType: h }) {
      let f = /* @__PURE__ */ new Set(), O = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }, D = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          D = !0;
          break;
        }
        let S = this.startNode(), { id: A, init: P } = this.flowEnumMemberRaw(), E = A.name;
        if (E === "") continue;
        /^[a-z]/.test(E) && this.raise(ue.EnumInvalidMemberName, A, { memberName: E, suggestion: E[0].toUpperCase() + E.slice(1), enumName: o }), f.has(E) && this.raise(ue.EnumDuplicateMemberName, A, { memberName: E, enumName: o }), f.add(E);
        let M = { enumName: o, explicitType: h, memberName: E };
        switch (S.id = A, P.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(P.loc, M, "boolean"), S.init = P.value, O.booleanMembers.push(this.finishNode(S, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(P.loc, M, "number"), S.init = P.value, O.numberMembers.push(this.finishNode(S, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(P.loc, M, "string"), S.init = P.value, O.stringMembers.push(this.finishNode(S, "EnumStringMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(P.loc, M);
          case "none":
            switch (h) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(P.loc, M);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(P.loc, M);
                break;
              default:
                O.defaultedMembers.push(this.finishNode(S, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return { members: O, hasUnknownMembers: D };
    }
    flowEnumStringMembers(o, h, { enumName: f }) {
      if (o.length === 0) return h;
      if (h.length === 0) return o;
      if (h.length > o.length) {
        for (let O of o) this.flowEnumErrorStringMemberInconsistentlyInitialized(O, { enumName: f });
        return h;
      } else {
        for (let O of h) this.flowEnumErrorStringMemberInconsistentlyInitialized(O, { enumName: f });
        return o;
      }
    }
    flowEnumParseExplicitType({ enumName: o }) {
      if (!this.eatContextual(102)) return null;
      if (!xe(this.state.type)) throw this.raise(ue.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: o });
      let { value: h } = this.state;
      return this.next(), h !== "boolean" && h !== "number" && h !== "string" && h !== "symbol" && this.raise(ue.EnumInvalidExplicitType, this.state.startLoc, { enumName: o, invalidEnumType: h }), h;
    }
    flowEnumBody(o, h) {
      let f = h.name, O = h.loc.start, D = this.flowEnumParseExplicitType({ enumName: f });
      this.expect(5);
      let { members: S, hasUnknownMembers: A } = this.flowEnumMembers({ enumName: f, explicitType: D });
      switch (o.hasUnknownMembers = A, D) {
        case "boolean":
          return o.explicitType = !0, o.members = S.booleanMembers, this.expect(8), this.finishNode(o, "EnumBooleanBody");
        case "number":
          return o.explicitType = !0, o.members = S.numberMembers, this.expect(8), this.finishNode(o, "EnumNumberBody");
        case "string":
          return o.explicitType = !0, o.members = this.flowEnumStringMembers(S.stringMembers, S.defaultedMembers, { enumName: f }), this.expect(8), this.finishNode(o, "EnumStringBody");
        case "symbol":
          return o.members = S.defaultedMembers, this.expect(8), this.finishNode(o, "EnumSymbolBody");
        default: {
          let P = () => (o.members = [], this.expect(8), this.finishNode(o, "EnumStringBody"));
          o.explicitType = !1;
          let E = S.booleanMembers.length, M = S.numberMembers.length, Z = S.stringMembers.length, H = S.defaultedMembers.length;
          if (!E && !M && !Z && !H) return P();
          if (!E && !M) return o.members = this.flowEnumStringMembers(S.stringMembers, S.defaultedMembers, { enumName: f }), this.expect(8), this.finishNode(o, "EnumStringBody");
          if (!M && !Z && E >= H) {
            for (let ie of S.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(ie.loc.start, { enumName: f, memberName: ie.id.name });
            return o.members = S.booleanMembers, this.expect(8), this.finishNode(o, "EnumBooleanBody");
          } else if (!E && !Z && M >= H) {
            for (let ie of S.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(ie.loc.start, { enumName: f, memberName: ie.id.name });
            return o.members = S.numberMembers, this.expect(8), this.finishNode(o, "EnumNumberBody");
          } else return this.raise(ue.EnumInconsistentMemberValues, O, { enumName: f }), P();
        }
      }
    }
    flowParseEnumDeclaration(o) {
      let h = this.parseIdentifier();
      return o.id = h, o.body = this.flowEnumBody(this.startNode(), h), this.finishNode(o, "EnumDeclaration");
    }
    jsxParseOpeningElementAfterName(o) {
      return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (o.typeArguments = this.flowParseTypeParameterInstantiationInExpression()), super.jsxParseOpeningElementAfterName(o);
    }
    isLookaheadToken_lt() {
      let o = this.nextTokenStart();
      if (this.input.charCodeAt(o) === 60) {
        let h = this.input.charCodeAt(o + 1);
        return h !== 60 && h !== 61;
      }
      return !1;
    }
    reScan_lt_gt() {
      let { type: o } = this.state;
      o === 47 ? (this.state.pos -= 1, this.readToken_lt()) : o === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let { type: o } = this.state;
      return o === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : o;
    }
    maybeUnwrapTypeCastExpression(o) {
      return o.type === "TypeCastExpression" ? o.expression : o;
    }
  }, ZE = /\r\n|[\r\n\u2028\u2029]/, Nl = new RegExp(ZE.source, "g");
  function Pn(u) {
    switch (u) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  function ey(u, o, h) {
    for (let f = o; f < h; f++) if (Pn(u.charCodeAt(f))) return !0;
    return !1;
  }
  var Nh = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Mh = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  function VE(u) {
    switch (u) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  var Ri = C`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: u }) => `Expected corresponding JSX closing tag for <${u}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: u, HTMLEntity: o }) => `Unexpected token \`${u}\`. Did you mean \`${o}\` or \`{'${u}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
  function ri(u) {
    return u ? u.type === "JSXOpeningFragment" || u.type === "JSXClosingFragment" : !1;
  }
  function Fn(u) {
    if (u.type === "JSXIdentifier") return u.name;
    if (u.type === "JSXNamespacedName") return u.namespace.name + ":" + u.name.name;
    if (u.type === "JSXMemberExpression") return Fn(u.object) + "." + Fn(u.property);
    throw new Error("Node had unexpected type: " + u.type);
  }
  var zE = (u) => class extends u {
    jsxReadToken() {
      let o = "", h = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length) throw this.raise(Ri.UnterminatedJsxContent, this.state.startLoc);
        let f = this.input.charCodeAt(this.state.pos);
        switch (f) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              f === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(f);
              return;
            }
            o += this.input.slice(h, this.state.pos), this.finishToken(142, o);
            return;
          case 38:
            o += this.input.slice(h, this.state.pos), o += this.jsxReadEntity(), h = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            Pn(f) ? (o += this.input.slice(h, this.state.pos), o += this.jsxReadNewLine(!0), h = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(o) {
      let h = this.input.charCodeAt(this.state.pos), f;
      return ++this.state.pos, h === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, f = o ? `
` : `\r
`) : f = String.fromCharCode(h), ++this.state.curLine, this.state.lineStart = this.state.pos, f;
    }
    jsxReadString(o) {
      let h = "", f = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length) throw this.raise(b.UnterminatedString, this.state.startLoc);
        let O = this.input.charCodeAt(this.state.pos);
        if (O === o) break;
        O === 38 ? (h += this.input.slice(f, this.state.pos), h += this.jsxReadEntity(), f = this.state.pos) : Pn(O) ? (h += this.input.slice(f, this.state.pos), h += this.jsxReadNewLine(!1), f = this.state.pos) : ++this.state.pos;
      }
      h += this.input.slice(f, this.state.pos++), this.finishToken(134, h);
    }
    jsxReadEntity() {
      let o = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let h = 10;
        this.codePointAtPos(this.state.pos) === 120 && (h = 16, ++this.state.pos);
        let f = this.readInt(h, void 0, !1, "bail");
        if (f !== null && this.codePointAtPos(this.state.pos) === 59) return ++this.state.pos, String.fromCodePoint(f);
      } else {
        let h = 0, f = !1;
        for (; h++ < 10 && this.state.pos < this.length && !(f = this.codePointAtPos(this.state.pos) === 59); ) ++this.state.pos;
        if (f) {
          this.input.slice(o, this.state.pos);
          let O;
          ++this.state.pos;
        }
      }
      return this.state.pos = o, "&";
    }
    jsxReadWord() {
      let o, h = this.state.pos;
      do
        o = this.input.charCodeAt(++this.state.pos);
      while (kn(o) || o === 45);
      this.finishToken(141, this.input.slice(h, this.state.pos));
    }
    jsxParseIdentifier() {
      let o = this.startNode();
      return this.match(141) ? o.name = this.state.value : Ph(this.state.type) ? o.name = ti(this.state.type) : this.unexpected(), this.next(), this.finishNode(o, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let o = this.state.startLoc, h = this.jsxParseIdentifier();
      if (!this.eat(14)) return h;
      let f = this.startNodeAt(o);
      return f.namespace = h, f.name = this.jsxParseIdentifier(), this.finishNode(f, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let o = this.state.startLoc, h = this.jsxParseNamespacedName();
      if (h.type === "JSXNamespacedName") return h;
      for (; this.eat(16); ) {
        let f = this.startNodeAt(o);
        f.object = h, f.property = this.jsxParseIdentifier(), h = this.finishNode(f, "JSXMemberExpression");
      }
      return h;
    }
    jsxParseAttributeValue() {
      let o;
      switch (this.state.type) {
        case 5:
          return o = this.startNode(), this.setContext(V.brace), this.next(), o = this.jsxParseExpressionContainer(o, V.j_oTag), o.expression.type === "JSXEmptyExpression" && this.raise(Ri.AttributeIsEmpty, o), o;
        case 143:
        case 134:
          return this.parseExprAtom();
        default:
          throw this.raise(Ri.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let o = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(o, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(o) {
      return this.next(), o.expression = this.parseExpression(), this.setContext(V.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(o, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(o, h) {
      if (this.match(8)) o.expression = this.jsxParseEmptyExpression();
      else {
        let f = this.parseExpression();
        o.expression = f;
      }
      return this.setContext(h), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(o, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let o = this.startNode();
      return this.match(5) ? (this.setContext(V.brace), this.next(), this.expect(21), o.argument = this.parseMaybeAssignAllowIn(), this.setContext(V.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(o, "JSXSpreadAttribute")) : (o.name = this.jsxParseNamespacedName(), o.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(o, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(o) {
      let h = this.startNodeAt(o);
      return this.eat(144) ? this.finishNode(h, "JSXOpeningFragment") : (h.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(h));
    }
    jsxParseOpeningElementAfterName(o) {
      let h = [];
      for (; !this.match(56) && !this.match(144); ) h.push(this.jsxParseAttribute());
      return o.attributes = h, o.selfClosing = this.eat(56), this.expect(144), this.finishNode(o, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(o) {
      let h = this.startNodeAt(o);
      return this.eat(144) ? this.finishNode(h, "JSXClosingFragment") : (h.name = this.jsxParseElementName(), this.expect(144), this.finishNode(h, "JSXClosingElement"));
    }
    jsxParseElementAt(o) {
      let h = this.startNodeAt(o), f = [], O = this.jsxParseOpeningElementAt(o), D = null;
      if (!O.selfClosing) {
        e: for (; ; ) switch (this.state.type) {
          case 143:
            if (o = this.state.startLoc, this.next(), this.eat(56)) {
              D = this.jsxParseClosingElementAt(o);
              break e;
            }
            f.push(this.jsxParseElementAt(o));
            break;
          case 142:
            f.push(this.parseLiteral(this.state.value, "JSXText"));
            break;
          case 5: {
            let S = this.startNode();
            this.setContext(V.brace), this.next(), this.match(21) ? f.push(this.jsxParseSpreadChild(S)) : f.push(this.jsxParseExpressionContainer(S, V.j_expr));
            break;
          }
          default:
            this.unexpected();
        }
        ri(O) && !ri(D) && D !== null ? this.raise(Ri.MissingClosingTagFragment, D) : !ri(O) && ri(D) ? this.raise(Ri.MissingClosingTagElement, D, { openingTagName: Fn(O.name) }) : !ri(O) && !ri(D) && Fn(D.name) !== Fn(O.name) && this.raise(Ri.MissingClosingTagElement, D, { openingTagName: Fn(O.name) });
      }
      if (ri(O) ? (h.openingFragment = O, h.closingFragment = D) : (h.openingElement = O, h.closingElement = D), h.children = f, this.match(47)) throw this.raise(Ri.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return ri(O) ? this.finishNode(h, "JSXFragment") : this.finishNode(h, "JSXElement");
    }
    jsxParseElement() {
      let o = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(o);
    }
    setContext(o) {
      let { context: h } = this.state;
      h[h.length - 1] = o;
    }
    parseExprAtom(o) {
      return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(143), this.jsxParseElement()) : super.parseExprAtom(o);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(o) {
      let h = this.curContext();
      if (h === V.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (h === V.j_oTag || h === V.j_cTag) {
        if (bs(o)) {
          this.jsxReadWord();
          return;
        }
        if (o === 62) {
          ++this.state.pos, this.finishToken(144);
          return;
        }
        if ((o === 34 || o === 39) && h === V.j_oTag) {
          this.jsxReadString(o);
          return;
        }
      }
      if (o === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(143);
        return;
      }
      super.getTokenFromCode(o);
    }
    updateContext(o) {
      let { context: h, type: f } = this.state;
      if (f === 56 && o === 143) h.splice(-2, 2, V.j_cTag), this.state.canStartJSXElement = !1;
      else if (f === 143) h.push(V.j_oTag);
      else if (f === 144) {
        let O = h[h.length - 1];
        O === V.j_oTag && o === 56 || O === V.j_cTag ? (h.pop(), this.state.canStartJSXElement = h[h.length - 1] === V.j_expr) : (this.setContext(V.j_expr), this.state.canStartJSXElement = !0);
      } else this.state.canStartJSXElement = yE(f);
    }
  }, UE = class extends Bh {
    constructor(...u) {
      super(...u), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, YE = class extends Ih {
    constructor(...u) {
      super(...u), this.importsStack = [];
    }
    createScope(u) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new UE(u);
    }
    enter(u) {
      u === 1024 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(u);
    }
    exit() {
      let u = super.exit();
      return u === 1024 && this.importsStack.pop(), u;
    }
    hasImport(u, o) {
      let h = this.importsStack.length;
      if (this.importsStack[h - 1].has(u)) return !0;
      if (!o && h > 1) {
        for (let f = 0; f < h - 1; f++) if (this.importsStack[f].has(u)) return !0;
      }
      return !1;
    }
    declareName(u, o, h) {
      if (o & 4096) {
        this.hasImport(u, !0) && this.parser.raise(b.VarRedeclaration, h, { identifierName: u }), this.importsStack[this.importsStack.length - 1].add(u);
        return;
      }
      let f = this.currentScope(), O = f.tsNames.get(u) || 0;
      if (o & 1024) {
        this.maybeExportDefined(f, u), f.tsNames.set(u, O | 16);
        return;
      }
      super.declareName(u, o, h), o & 2 && (o & 1 || (this.checkRedeclarationInScope(f, u, o, h), this.maybeExportDefined(f, u)), O = O | 1), o & 256 && (O = O | 2), o & 512 && (O = O | 4), o & 128 && (O = O | 8), O && f.tsNames.set(u, O);
    }
    isRedeclaredInScope(u, o, h) {
      let f = u.tsNames.get(o);
      if ((f & 2) > 0) {
        if (h & 256) {
          let O = !!(h & 512), D = (f & 4) > 0;
          return O !== D;
        }
        return !0;
      }
      return h & 128 && (f & 8) > 0 ? u.names.get(o) & 2 ? !!(h & 1) : !1 : h & 2 && (f & 1) > 0 ? !0 : super.isRedeclaredInScope(u, o, h);
    }
    checkLocalExport(u) {
      let { name: o } = u;
      if (this.hasImport(o)) return;
      let h = this.scopeStack.length;
      for (let f = h - 1; f >= 0; f--) {
        let O = this.scopeStack[f].tsNames.get(o);
        if ((O & 1) > 0 || (O & 16) > 0) return;
      }
      super.checkLocalExport(u);
    }
  }, WE = class {
    constructor() {
      this.stacks = [];
    }
    enter(u) {
      this.stacks.push(u);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function Ml(u, o) {
    return (u ? 2 : 0) | (o ? 1 : 0);
  }
  var GE = class {
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    sourceToOffsetPos(u) {
      return u + this.startIndex;
    }
    offsetToSourcePos(u) {
      return u - this.startIndex;
    }
    hasPlugin(u) {
      if (typeof u == "string") return this.plugins.has(u);
      {
        let [o, h] = u;
        if (!this.hasPlugin(o)) return !1;
        let f = this.plugins.get(o);
        for (let O of Object.keys(h)) if ((f == null ? void 0 : f[O]) !== h[O]) return !1;
        return !0;
      }
    }
    getPluginOption(u, o) {
      var h;
      return (h = this.plugins.get(u)) == null ? void 0 : h[o];
    }
  };
  function ty(u, o) {
    u.trailingComments === void 0 ? u.trailingComments = o : u.trailingComments.unshift(...o);
  }
  function HE(u, o) {
    u.leadingComments === void 0 ? u.leadingComments = o : u.leadingComments.unshift(...o);
  }
  function ja(u, o) {
    u.innerComments === void 0 ? u.innerComments = o : u.innerComments.unshift(...o);
  }
  function si(u, o, h) {
    let f = null, O = o.length;
    for (; f === null && O > 0; ) f = o[--O];
    f === null || f.start > h.start ? ja(u, h.comments) : ty(f, h.comments);
  }
  var JE = class extends GE {
    addComment(u) {
      this.filename && (u.loc.filename = this.filename);
      let { commentsLen: o } = this.state;
      this.comments.length !== o && (this.comments.length = o), this.comments.push(u), this.state.commentsLen++;
    }
    processComment(u) {
      let { commentStack: o } = this.state, h = o.length;
      if (h === 0) return;
      let f = h - 1, O = o[f];
      O.start === u.end && (O.leadingNode = u, f--);
      let { start: D } = u;
      for (; f >= 0; f--) {
        let S = o[f], A = S.end;
        if (A > D) S.containingNode = u, this.finalizeComment(S), o.splice(f, 1);
        else {
          A === D && (S.trailingNode = u);
          break;
        }
      }
    }
    finalizeComment(u) {
      var o;
      let { comments: h } = u;
      if (u.leadingNode !== null || u.trailingNode !== null) u.leadingNode !== null && ty(u.leadingNode, h), u.trailingNode !== null && HE(u.trailingNode, h);
      else {
        let { containingNode: f, start: O } = u;
        if (this.input.charCodeAt(this.offsetToSourcePos(O) - 1) === 44) switch (f.type) {
          case "ObjectExpression":
          case "ObjectPattern":
          case "RecordExpression":
            si(f, f.properties, u);
            break;
          case "CallExpression":
          case "OptionalCallExpression":
            si(f, f.arguments, u);
            break;
          case "ImportExpression":
            si(f, [f.source, (o = f.options) != null ? o : null], u);
            break;
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
          case "ObjectMethod":
          case "ClassMethod":
          case "ClassPrivateMethod":
            si(f, f.params, u);
            break;
          case "ArrayExpression":
          case "ArrayPattern":
          case "TupleExpression":
            si(f, f.elements, u);
            break;
          case "ExportNamedDeclaration":
          case "ImportDeclaration":
            si(f, f.specifiers, u);
            break;
          case "TSEnumDeclaration":
            si(f, f.members, u);
            break;
          case "TSEnumBody":
            si(f, f.members, u);
            break;
          default:
            ja(f, h);
        }
        else ja(f, h);
      }
    }
    finalizeRemainingComments() {
      let { commentStack: u } = this.state;
      for (let o = u.length - 1; o >= 0; o--) this.finalizeComment(u[o]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(u) {
      let { commentStack: o } = this.state, { length: h } = o;
      if (h === 0) return;
      let f = o[h - 1];
      f.leadingNode === u && (f.leadingNode = null);
    }
    takeSurroundingComments(u, o, h) {
      let { commentStack: f } = this.state, O = f.length;
      if (O === 0) return;
      let D = O - 1;
      for (; D >= 0; D--) {
        let S = f[D], A = S.end;
        if (S.start === h) S.leadingNode = u;
        else if (A === o) S.trailingNode = u;
        else if (A < o) break;
      }
    }
  }, KE = class GD {
    constructor() {
      this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [V.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(o) {
      o ? this.flags |= 1 : this.flags &= -2;
    }
    init({ strictMode: o, sourceType: h, startIndex: f, startLine: O, startColumn: D }) {
      this.strict = o === !1 ? !1 : o === !0 ? !0 : h === "module", this.startIndex = f, this.curLine = O, this.lineStart = -D, this.startLoc = this.endLoc = new r(O, D, f);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(o) {
      o ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(o) {
      o ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(o) {
      o ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(o) {
      o ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(o) {
      o ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(o) {
      o ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(o) {
      o ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(o) {
      o ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(o) {
      o ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(o) {
      o ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(o) {
      o ? this.flags |= 2048 : this.flags &= -2049;
    }
    get hasTopLevelAwait() {
      return (this.flags & 4096) > 0;
    }
    set hasTopLevelAwait(o) {
      o ? this.flags |= 4096 : this.flags &= -4097;
    }
    curPosition() {
      return new r(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    }
    clone() {
      let o = new GD();
      return o.flags = this.flags, o.startIndex = this.startIndex, o.curLine = this.curLine, o.lineStart = this.lineStart, o.startLoc = this.startLoc, o.endLoc = this.endLoc, o.errors = this.errors.slice(), o.potentialArrowAt = this.potentialArrowAt, o.noArrowAt = this.noArrowAt.slice(), o.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), o.topicContext = this.topicContext, o.labels = this.labels.slice(), o.commentsLen = this.commentsLen, o.commentStack = this.commentStack.slice(), o.pos = this.pos, o.type = this.type, o.value = this.value, o.start = this.start, o.end = this.end, o.lastTokEndLoc = this.lastTokEndLoc, o.lastTokStartLoc = this.lastTokStartLoc, o.context = this.context.slice(), o.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, o.strictErrors = this.strictErrors, o.tokensLength = this.tokensLength, o;
    }
  }, eT = function(u) {
    return u >= 48 && u <= 57;
  }, ry = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, Ll = { bin: (u) => u === 48 || u === 49, oct: (u) => u >= 48 && u <= 55, dec: (u) => u >= 48 && u <= 57, hex: (u) => u >= 48 && u <= 57 || u >= 65 && u <= 70 || u >= 97 && u <= 102 };
  function sy(u, o, h, f, O, D) {
    let S = h, A = f, P = O, E = "", M = null, Z = h, { length: H } = o;
    for (; ; ) {
      if (h >= H) {
        D.unterminated(S, A, P), E += o.slice(Z, h);
        break;
      }
      let ie = o.charCodeAt(h);
      if (tT(u, ie, o, h)) {
        E += o.slice(Z, h);
        break;
      }
      if (ie === 92) {
        E += o.slice(Z, h);
        let ye = rT(o, h, f, O, u === "template", D);
        ye.ch === null && !M ? M = { pos: h, lineStart: f, curLine: O } : E += ye.ch, { pos: h, lineStart: f, curLine: O } = ye, Z = h;
      } else ie === 8232 || ie === 8233 ? (++h, ++O, f = h) : ie === 10 || ie === 13 ? u === "template" ? (E += o.slice(Z, h) + `
`, ++h, ie === 13 && o.charCodeAt(h) === 10 && ++h, ++O, Z = f = h) : D.unterminated(S, A, P) : ++h;
    }
    return { pos: h, str: E, firstInvalidLoc: M, lineStart: f, curLine: O, containsInvalid: !!M };
  }
  function tT(u, o, h, f) {
    return u === "template" ? o === 96 || o === 36 && h.charCodeAt(f + 1) === 123 : o === (u === "double" ? 34 : 39);
  }
  function rT(u, o, h, f, O, D) {
    let S = !O;
    o++;
    let A = (E) => ({ pos: o, ch: E, lineStart: h, curLine: f }), P = u.charCodeAt(o++);
    switch (P) {
      case 110:
        return A(`
`);
      case 114:
        return A("\r");
      case 120: {
        let E;
        return { code: E, pos: o } = Lh(u, o, h, f, 2, !1, S, D), A(E === null ? null : String.fromCharCode(E));
      }
      case 117: {
        let E;
        return { code: E, pos: o } = ny(u, o, h, f, S, D), A(E === null ? null : String.fromCodePoint(E));
      }
      case 116:
        return A("	");
      case 98:
        return A("\b");
      case 118:
        return A("\v");
      case 102:
        return A("\f");
      case 13:
        u.charCodeAt(o) === 10 && ++o;
      case 10:
        h = o, ++f;
      case 8232:
      case 8233:
        return A("");
      case 56:
      case 57:
        if (O) return A(null);
        D.strictNumericEscape(o - 1, h, f);
      default:
        if (P >= 48 && P <= 55) {
          let E = o - 1, M = /^[0-7]+/.exec(u.slice(E, o + 2))[0], Z = parseInt(M, 8);
          Z > 255 && (M = M.slice(0, -1), Z = parseInt(M, 8)), o += M.length - 1;
          let H = u.charCodeAt(o);
          if (M !== "0" || H === 56 || H === 57) {
            if (O) return A(null);
            D.strictNumericEscape(E, h, f);
          }
          return A(String.fromCharCode(Z));
        }
        return A(String.fromCharCode(P));
    }
  }
  function Lh(u, o, h, f, O, D, S, A) {
    let P = o, E;
    return { n: E, pos: o } = iy(u, o, h, f, 16, O, D, !1, A, !S), E === null && (S ? A.invalidEscapeSequence(P, h, f) : o = P - 1), { code: E, pos: o };
  }
  function iy(u, o, h, f, O, D, S, A, P, E) {
    let M = o, Z = O === 16 ? ry.hex : ry.decBinOct, H = O === 16 ? Ll.hex : O === 10 ? Ll.dec : O === 8 ? Ll.oct : Ll.bin, ie = !1, ye = 0;
    for (let Ye = 0, Te = D != null ? D : 1 / 0; Ye < Te; ++Ye) {
      let We = u.charCodeAt(o), rr;
      if (We === 95 && A !== "bail") {
        let jh = u.charCodeAt(o - 1), Xh = u.charCodeAt(o + 1);
        if (A) {
          if (Number.isNaN(Xh) || !H(Xh) || Z.has(jh) || Z.has(Xh)) {
            if (E) return { n: null, pos: o };
            P.unexpectedNumericSeparator(o, h, f);
          }
        } else {
          if (E) return { n: null, pos: o };
          P.numericSeparatorInEscapeSequence(o, h, f);
        }
        ++o;
        continue;
      }
      if (We >= 97 ? rr = We - 97 + 10 : We >= 65 ? rr = We - 65 + 10 : eT(We) ? rr = We - 48 : rr = 1 / 0, rr >= O) {
        if (rr <= 9 && E) return { n: null, pos: o };
        if (rr <= 9 && P.invalidDigit(o, h, f, O)) rr = 0;
        else if (S) rr = 0, ie = !0;
        else break;
      }
      ++o, ye = ye * O + rr;
    }
    return o === M || D != null && o - M !== D || ie ? { n: null, pos: o } : { n: ye, pos: o };
  }
  function ny(u, o, h, f, O, D) {
    let S = u.charCodeAt(o), A;
    if (S === 123) {
      if (++o, { code: A, pos: o } = Lh(u, o, h, f, u.indexOf("}", o) - o, !0, O, D), ++o, A !== null && A > 1114111) if (O) D.invalidCodePoint(o, h, f);
      else return { code: null, pos: o };
    } else ({ code: A, pos: o } = Lh(u, o, h, f, 4, !1, O, D));
    return { code: A, pos: o };
  }
  function Xa(u, o, h) {
    return new r(h, u - o, u);
  }
  var sT = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), ii = class {
    constructor(u) {
      let o = u.startIndex || 0;
      this.type = u.type, this.value = u.value, this.start = o + u.start, this.end = o + u.end, this.loc = new s(u.startLoc, u.endLoc);
    }
  }, iT = class extends JE {
    constructor(u, o) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (h, f, O, D) => this.optionFlags & 2048 ? (this.raise(b.InvalidDigit, Xa(h, f, O), { radix: D }), !0) : !1, numericSeparatorInEscapeSequence: this.errorBuilder(b.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(b.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(b.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(b.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (h, f, O) => {
        this.recordStrictModeErrors(b.StrictNumericEscape, Xa(h, f, O));
      }, unterminated: (h, f, O) => {
        throw this.raise(b.UnterminatedString, Xa(h - 1, f, O));
      } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(b.StrictNumericEscape), unterminated: (h, f, O) => {
        throw this.raise(b.UnterminatedTemplate, Xa(h, f, O));
      } }), this.state = new KE(), this.state.init(u), this.input = o, this.length = o.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(u) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(u), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.optionFlags & 256 && this.pushToken(new ii(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(u) {
      return this.match(u) ? (this.next(), !0) : !1;
    }
    match(u) {
      return this.state.type === u;
    }
    createLookaheadState(u) {
      return { pos: u.pos, value: null, type: u.type, start: u.start, end: u.end, context: [this.curContext()], inType: u.inType, startLoc: u.startLoc, lastTokEndLoc: u.lastTokEndLoc, curLine: u.curLine, lineStart: u.lineStart, curPosition: u.curPosition };
    }
    lookahead() {
      let u = this.state;
      this.state = this.createLookaheadState(u), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let o = this.state;
      return this.state = u, o;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(u) {
      return Nh.lastIndex = u, Nh.test(this.input) ? Nh.lastIndex : u;
    }
    lookaheadCharCode() {
      return this.lookaheadCharCodeSince(this.state.pos);
    }
    lookaheadCharCodeSince(u) {
      return this.input.charCodeAt(this.nextTokenStartSince(u));
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(u) {
      return Mh.lastIndex = u, Mh.test(this.input) ? Mh.lastIndex : u;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(u) {
      let o = this.input.charCodeAt(u);
      if ((o & 64512) === 55296 && ++u < this.input.length) {
        let h = this.input.charCodeAt(u);
        (h & 64512) === 56320 && (o = 65536 + ((o & 1023) << 10) + (h & 1023));
      }
      return o;
    }
    setStrict(u) {
      this.state.strict = u, u && (this.state.strictErrors.forEach(([o, h]) => this.raise(o, h)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
        this.finishToken(140);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(u) {
      let o;
      this.isLookahead || (o = this.state.curPosition());
      let h = this.state.pos, f = this.input.indexOf(u, h + 2);
      if (f === -1) throw this.raise(b.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = f + u.length, Nl.lastIndex = h + 2; Nl.test(this.input) && Nl.lastIndex <= f; ) ++this.state.curLine, this.state.lineStart = Nl.lastIndex;
      if (this.isLookahead) return;
      let O = { type: "CommentBlock", value: this.input.slice(h + 2, f), start: this.sourceToOffsetPos(h), end: this.sourceToOffsetPos(f + u.length), loc: new s(o, this.state.curPosition()) };
      return this.optionFlags & 256 && this.pushToken(O), O;
    }
    skipLineComment(u) {
      let o = this.state.pos, h;
      this.isLookahead || (h = this.state.curPosition());
      let f = this.input.charCodeAt(this.state.pos += u);
      if (this.state.pos < this.length) for (; !Pn(f) && ++this.state.pos < this.length; ) f = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let O = this.state.pos, D = { type: "CommentLine", value: this.input.slice(o + u, O), start: this.sourceToOffsetPos(o), end: this.sourceToOffsetPos(O), loc: new s(h, this.state.curPosition()) };
      return this.optionFlags & 256 && this.pushToken(D), D;
    }
    skipSpace() {
      let u = this.state.pos, o = this.optionFlags & 4096 ? [] : null;
      e: for (; this.state.pos < this.length; ) {
        let h = this.input.charCodeAt(this.state.pos);
        switch (h) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let f = this.skipBlockComment("*/");
                f !== void 0 && (this.addComment(f), o == null || o.push(f));
                break;
              }
              case 47: {
                let f = this.skipLineComment(2);
                f !== void 0 && (this.addComment(f), o == null || o.push(f));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (VE(h)) ++this.state.pos;
            else if (h === 45 && !this.inModule && this.optionFlags & 8192) {
              let f = this.state.pos;
              if (this.input.charCodeAt(f + 1) === 45 && this.input.charCodeAt(f + 2) === 62 && (u === 0 || this.state.lineStart > u)) {
                let O = this.skipLineComment(3);
                O !== void 0 && (this.addComment(O), o == null || o.push(O));
              } else break e;
            } else if (h === 60 && !this.inModule && this.optionFlags & 8192) {
              let f = this.state.pos;
              if (this.input.charCodeAt(f + 1) === 33 && this.input.charCodeAt(f + 2) === 45 && this.input.charCodeAt(f + 3) === 45) {
                let O = this.skipLineComment(4);
                O !== void 0 && (this.addComment(O), o == null || o.push(O));
              } else break e;
            } else break e;
        }
      }
      if ((o == null ? void 0 : o.length) > 0) {
        let h = this.state.pos, f = { start: this.sourceToOffsetPos(u), end: this.sourceToOffsetPos(h), comments: o, leadingNode: null, trailingNode: null, containingNode: null };
        this.state.commentStack.push(f);
      }
    }
    finishToken(u, o) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let h = this.state.type;
      this.state.type = u, this.state.value = o, this.isLookahead || this.updateContext(h);
    }
    replaceToken(u) {
      this.state.type = u, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) return;
      let u = this.state.pos + 1, o = this.codePointAtPos(u);
      if (o >= 48 && o <= 57) throw this.raise(b.UnexpectedDigitAfterHash, this.state.curPosition());
      if (o === 123 || o === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar") throw this.raise(o === 123 ? b.RecordExpressionHashIncorrectStartSyntaxType : b.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
        this.state.pos += 2, o === 123 ? this.finishToken(7) : this.finishToken(1);
      } else bs(o) ? (++this.state.pos, this.finishToken(139, this.readWord1(o))) : o === 92 ? (++this.state.pos, this.finishToken(139, this.readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let u = this.input.charCodeAt(this.state.pos + 1);
      if (u >= 48 && u <= 57) {
        this.readNumber(!0);
        return;
      }
      u === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let u = this.input.charCodeAt(this.state.pos + 1);
      if (u !== 33) return !1;
      let o = this.state.pos;
      for (this.state.pos += 1; !Pn(u) && ++this.state.pos < this.length; ) u = this.input.charCodeAt(this.state.pos);
      let h = this.input.slice(o + 2, this.state.pos);
      return this.finishToken(28, h), !0;
    }
    readToken_mult_modulo(u) {
      let o = u === 42 ? 55 : 54, h = 1, f = this.input.charCodeAt(this.state.pos + 1);
      u === 42 && f === 42 && (h++, f = this.input.charCodeAt(this.state.pos + 2), o = 57), f === 61 && !this.state.inType && (h++, o = u === 37 ? 33 : 30), this.finishOp(o, h);
    }
    readToken_pipe_amp(u) {
      let o = this.input.charCodeAt(this.state.pos + 1);
      if (o === u) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(u === 124 ? 41 : 42, 2);
        return;
      }
      if (u === 124) {
        if (o === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && o === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(b.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && o === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(b.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (o === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(u === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let u = this.input.charCodeAt(this.state.pos + 1);
      u === 61 && !this.state.inType ? this.finishOp(32, 2) : u === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(u) {
      let o = this.input.charCodeAt(this.state.pos + 1);
      if (o === u) {
        this.finishOp(34, 2);
        return;
      }
      o === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let { pos: u } = this.state, o = this.input.charCodeAt(u + 1);
      if (o === 60) {
        if (this.input.charCodeAt(u + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (o === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let { pos: u } = this.state, o = this.input.charCodeAt(u + 1);
      if (o === 62) {
        let h = this.input.charCodeAt(u + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(u + h) === 61) {
          this.finishOp(30, h + 1);
          return;
        }
        this.finishOp(52, h);
        return;
      }
      if (o === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(u) {
      let o = this.input.charCodeAt(this.state.pos + 1);
      if (o === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (u === 61 && o === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(u === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let u = this.input.charCodeAt(this.state.pos + 1), o = this.input.charCodeAt(this.state.pos + 2);
      u === 63 ? o === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : u === 46 && !(o >= 48 && o <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(u) {
      switch (u) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(b.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(b.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let o = this.input.charCodeAt(this.state.pos + 1);
          if (o === 120 || o === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (o === 111 || o === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (o === 98 || o === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(u);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(u);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(u);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(u);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(u);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (bs(u)) {
            this.readWord(u);
            return;
          }
      }
      throw this.raise(b.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(u) });
    }
    finishOp(u, o) {
      let h = this.input.slice(this.state.pos, this.state.pos + o);
      this.state.pos += o, this.finishToken(u, h);
    }
    readRegexp() {
      let u = this.state.startLoc, o = this.state.start + 1, h, f, { pos: O } = this.state;
      for (; ; ++O) {
        if (O >= this.length) throw this.raise(b.UnterminatedRegExp, i(u, 1));
        let P = this.input.charCodeAt(O);
        if (Pn(P)) throw this.raise(b.UnterminatedRegExp, i(u, 1));
        if (h) h = !1;
        else {
          if (P === 91) f = !0;
          else if (P === 93 && f) f = !1;
          else if (P === 47 && !f) break;
          h = P === 92;
        }
      }
      let D = this.input.slice(o, O);
      ++O;
      let S = "", A = () => i(u, O + 2 - o);
      for (; O < this.length; ) {
        let P = this.codePointAtPos(O), E = String.fromCharCode(P);
        if (sT.has(P)) P === 118 ? S.includes("u") && this.raise(b.IncompatibleRegExpUVFlags, A()) : P === 117 && S.includes("v") && this.raise(b.IncompatibleRegExpUVFlags, A()), S.includes(E) && this.raise(b.DuplicateRegExpFlags, A());
        else if (kn(P) || P === 92) this.raise(b.MalformedRegExpFlags, A());
        else break;
        ++O, S += E;
      }
      this.state.pos = O, this.finishToken(138, { pattern: D, flags: S });
    }
    readInt(u, o, h = !1, f = !0) {
      let { n: O, pos: D } = iy(this.input, this.state.pos, this.state.lineStart, this.state.curLine, u, o, h, f, this.errorHandlers_readInt, !1);
      return this.state.pos = D, O;
    }
    readRadixNumber(u) {
      let o = this.state.pos, h = this.state.curPosition(), f = !1;
      this.state.pos += 2;
      let O = this.readInt(u);
      O == null && this.raise(b.InvalidDigit, i(h, 2), { radix: u });
      let D = this.input.charCodeAt(this.state.pos);
      if (D === 110) ++this.state.pos, f = !0;
      else if (D === 109) throw this.raise(b.InvalidDecimal, h);
      if (bs(this.codePointAtPos(this.state.pos))) throw this.raise(b.NumberIdentifier, this.state.curPosition());
      if (f) {
        let S = this.input.slice(o, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(136, S);
        return;
      }
      this.finishToken(135, O);
    }
    readNumber(u) {
      let o = this.state.pos, h = this.state.curPosition(), f = !1, O = !1, D = !1, S = !1;
      !u && this.readInt(10) === null && this.raise(b.InvalidNumber, this.state.curPosition());
      let A = this.state.pos - o >= 2 && this.input.charCodeAt(o) === 48;
      if (A) {
        let H = this.input.slice(o, this.state.pos);
        if (this.recordStrictModeErrors(b.StrictOctalLiteral, h), !this.state.strict) {
          let ie = H.indexOf("_");
          ie > 0 && this.raise(b.ZeroDigitNumericSeparator, i(h, ie));
        }
        S = A && !/[89]/.test(H);
      }
      let P = this.input.charCodeAt(this.state.pos);
      if (P === 46 && !S && (++this.state.pos, this.readInt(10), f = !0, P = this.input.charCodeAt(this.state.pos)), (P === 69 || P === 101) && !S && (P = this.input.charCodeAt(++this.state.pos), (P === 43 || P === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(b.InvalidOrMissingExponent, h), f = !0, D = !0, P = this.input.charCodeAt(this.state.pos)), P === 110 && ((f || A) && this.raise(b.InvalidBigIntLiteral, h), ++this.state.pos, O = !0), P === 109) {
        this.expectPlugin("decimal", this.state.curPosition()), (D || A) && this.raise(b.InvalidDecimal, h), ++this.state.pos;
        var E = !0;
      }
      if (bs(this.codePointAtPos(this.state.pos))) throw this.raise(b.NumberIdentifier, this.state.curPosition());
      let M = this.input.slice(o, this.state.pos).replace(/[_mn]/g, "");
      if (O) {
        this.finishToken(136, M);
        return;
      }
      if (E) {
        this.finishToken(137, M);
        return;
      }
      let Z = S ? parseInt(M, 8) : parseFloat(M);
      this.finishToken(135, Z);
    }
    readCodePoint(u) {
      let { code: o, pos: h } = ny(this.input, this.state.pos, this.state.lineStart, this.state.curLine, u, this.errorHandlers_readCodePoint);
      return this.state.pos = h, o;
    }
    readString(u) {
      let { str: o, pos: h, curLine: f, lineStart: O } = sy(u === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = h + 1, this.state.lineStart = O, this.state.curLine = f, this.finishToken(134, o);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let u = this.input[this.state.pos], { str: o, firstInvalidLoc: h, pos: f, curLine: O, lineStart: D } = sy("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = f + 1, this.state.lineStart = D, this.state.curLine = O, h && (this.state.firstInvalidTemplateEscapePos = new r(h.curLine, h.pos - h.lineStart, this.sourceToOffsetPos(h.pos))), this.input.codePointAt(f) === 96 ? this.finishToken(24, h ? null : u + o + "`") : (this.state.pos++, this.finishToken(25, h ? null : u + o + "${"));
    }
    recordStrictModeErrors(u, o) {
      let h = o.index;
      this.state.strict && !this.state.strictErrors.has(h) ? this.raise(u, o) : this.state.strictErrors.set(h, [u, o]);
    }
    readWord1(u) {
      this.state.containsEsc = !1;
      let o = "", h = this.state.pos, f = this.state.pos;
      for (u !== void 0 && (this.state.pos += u <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let O = this.codePointAtPos(this.state.pos);
        if (kn(O)) this.state.pos += O <= 65535 ? 1 : 2;
        else if (O === 92) {
          this.state.containsEsc = !0, o += this.input.slice(f, this.state.pos);
          let D = this.state.curPosition(), S = this.state.pos === h ? bs : kn;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(b.MissingUnicodeEscape, this.state.curPosition()), f = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let A = this.readCodePoint(!0);
          A !== null && (S(A) || this.raise(b.EscapedCharNotAnIdentifier, D), o += String.fromCodePoint(A)), f = this.state.pos;
        } else break;
      }
      return o + this.input.slice(f, this.state.pos);
    }
    readWord(u) {
      let o = this.readWord1(u), h = ft.get(o);
      h !== void 0 ? this.finishToken(h, ti(h)) : this.finishToken(132, o);
    }
    checkKeywordEscapes() {
      let { type: u } = this.state;
      Ph(u) && this.state.containsEsc && this.raise(b.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: ti(u) });
    }
    raise(u, o, h = {}) {
      let f = o instanceof r ? o : o.loc.start, O = u(f, h);
      if (!(this.optionFlags & 2048)) throw O;
      return this.isLookahead || this.state.errors.push(O), O;
    }
    raiseOverwrite(u, o, h = {}) {
      let f = o instanceof r ? o : o.loc.start, O = f.index, D = this.state.errors;
      for (let S = D.length - 1; S >= 0; S--) {
        let A = D[S];
        if (A.loc.index === O) return D[S] = u(f, h);
        if (A.loc.index < O) break;
      }
      return this.raise(u, o, h);
    }
    updateContext(u) {
    }
    unexpected(u, o) {
      throw this.raise(b.UnexpectedToken, u != null ? u : this.state.startLoc, { expected: o ? ti(o) : null });
    }
    expectPlugin(u, o) {
      if (this.hasPlugin(u)) return !0;
      throw this.raise(b.MissingPlugin, o != null ? o : this.state.startLoc, { missingPlugin: [u] });
    }
    expectOnePlugin(u) {
      if (!u.some((o) => this.hasPlugin(o))) throw this.raise(b.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: u });
    }
    errorBuilder(u) {
      return (o, h, f) => {
        this.raise(u, Xa(o, h, f));
      };
    }
  }, nT = class {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, aT = class {
    constructor(u) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = u;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new nT());
    }
    exit() {
      let u = this.stack.pop(), o = this.current();
      for (let [h, f] of Array.from(u.undefinedPrivateNames)) o ? o.undefinedPrivateNames.has(h) || o.undefinedPrivateNames.set(h, f) : this.parser.raise(b.InvalidPrivateFieldResolution, f, { identifierName: h });
    }
    declarePrivateName(u, o, h) {
      let { privateNames: f, loneAccessors: O, undefinedPrivateNames: D } = this.current(), S = f.has(u);
      if (o & 3) {
        let A = S && O.get(u);
        if (A) {
          let P = A & 4, E = o & 4, M = A & 3, Z = o & 3;
          S = M === Z || P !== E, S || O.delete(u);
        } else S || O.set(u, o);
      }
      S && this.parser.raise(b.PrivateNameRedeclaration, h, { identifierName: u }), f.add(u), D.delete(u);
    }
    usePrivateName(u, o) {
      let h;
      for (h of this.stack) if (h.privateNames.has(u)) return;
      h ? h.undefinedPrivateNames.set(u, o) : this.parser.raise(b.InvalidPrivateFieldResolution, o, { identifierName: u });
    }
  }, _l = class {
    constructor(u = 0) {
      this.type = u;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, ay = class extends _l {
    constructor(u) {
      super(u), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(u, o) {
      let h = o.index;
      this.declarationErrors.set(h, [u, o]);
    }
    clearDeclarationError(u) {
      this.declarationErrors.delete(u);
    }
    iterateErrors(u) {
      this.declarationErrors.forEach(u);
    }
  }, oT = class {
    constructor(u) {
      this.parser = void 0, this.stack = [new _l()], this.parser = u;
    }
    enter(u) {
      this.stack.push(u);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(u, o) {
      let h = o.loc.start, { stack: f } = this, O = f.length - 1, D = f[O];
      for (; !D.isCertainlyParameterDeclaration(); ) {
        if (D.canBeArrowParameterDeclaration()) D.recordDeclarationError(u, h);
        else return;
        D = f[--O];
      }
      this.parser.raise(u, h);
    }
    recordArrowParameterBindingError(u, o) {
      let { stack: h } = this, f = h[h.length - 1], O = o.loc.start;
      if (f.isCertainlyParameterDeclaration()) this.parser.raise(u, O);
      else if (f.canBeArrowParameterDeclaration()) f.recordDeclarationError(u, O);
      else return;
    }
    recordAsyncArrowParametersError(u) {
      let { stack: o } = this, h = o.length - 1, f = o[h];
      for (; f.canBeArrowParameterDeclaration(); ) f.type === 2 && f.recordDeclarationError(b.AwaitBindingIdentifier, u), f = o[--h];
    }
    validateAsPattern() {
      let { stack: u } = this, o = u[u.length - 1];
      o.canBeArrowParameterDeclaration() && o.iterateErrors(([h, f]) => {
        this.parser.raise(h, f);
        let O = u.length - 2, D = u[O];
        for (; D.canBeArrowParameterDeclaration(); ) D.clearDeclarationError(f.index), D = u[--O];
      });
    }
  };
  function lT() {
    return new _l(3);
  }
  function uT() {
    return new ay(1);
  }
  function cT() {
    return new ay(2);
  }
  function oy() {
    return new _l();
  }
  var hT = class extends iT {
    addExtra(u, o, h, f = !0) {
      if (!u) return;
      let { extra: O } = u;
      O == null && (O = {}, u.extra = O), f ? O[o] = h : Object.defineProperty(O, o, { enumerable: f, value: h });
    }
    isContextual(u) {
      return this.state.type === u && !this.state.containsEsc;
    }
    isUnparsedContextual(u, o) {
      if (this.input.startsWith(o, u)) {
        let h = this.input.charCodeAt(u + o.length);
        return !(kn(h) || (h & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(u) {
      let o = this.nextTokenStart();
      return this.isUnparsedContextual(o, u);
    }
    eatContextual(u) {
      return this.isContextual(u) ? (this.next(), !0) : !1;
    }
    expectContextual(u, o) {
      if (!this.eatContextual(u)) {
        if (o != null) throw this.raise(o, this.state.startLoc);
        this.unexpected(null, u);
      }
    }
    canInsertSemicolon() {
      return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return ey(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    }
    hasFollowingLineBreak() {
      return ey(this.input, this.state.end, this.nextTokenStart());
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(u = !0) {
      (u ? this.isLineTerminator() : this.eat(13)) || this.raise(b.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(u, o) {
      this.eat(u) || this.unexpected(o, u);
    }
    tryParse(u, o = this.state.clone()) {
      let h = { node: null };
      try {
        let f = u((O = null) => {
          throw h.node = O, h;
        });
        if (this.state.errors.length > o.errors.length) {
          let O = this.state;
          return this.state = o, this.state.tokensLength = O.tokensLength, { node: f, error: O.errors[o.errors.length], thrown: !1, aborted: !1, failState: O };
        }
        return { node: f, error: null, thrown: !1, aborted: !1, failState: null };
      } catch (f) {
        let O = this.state;
        if (this.state = o, f instanceof SyntaxError) return { node: null, error: f, thrown: !0, aborted: !1, failState: O };
        if (f === h) return { node: h.node, error: null, thrown: !1, aborted: !0, failState: O };
        throw f;
      }
    }
    checkExpressionErrors(u, o) {
      if (!u) return !1;
      let { shorthandAssignLoc: h, doubleProtoLoc: f, privateKeyLoc: O, optionalParametersLoc: D } = u, S = !!h || !!f || !!D || !!O;
      if (!o) return S;
      h != null && this.raise(b.InvalidCoverInitializedName, h), f != null && this.raise(b.DuplicateProto, f), O != null && this.raise(b.UnexpectedPrivateField, O), D != null && this.unexpected(D);
    }
    isLiteralPropertyName() {
      return Vg(this.state.type);
    }
    isPrivateName(u) {
      return u.type === "PrivateName";
    }
    getPrivateNameSV(u) {
      return u.id.name;
    }
    hasPropertyAsPrivateName(u) {
      return (u.type === "MemberExpression" || u.type === "OptionalMemberExpression") && this.isPrivateName(u.property);
    }
    isObjectProperty(u) {
      return u.type === "ObjectProperty";
    }
    isObjectMethod(u) {
      return u.type === "ObjectMethod";
    }
    initializeScopes(u = this.options.sourceType === "module") {
      let o = this.state.labels;
      this.state.labels = [];
      let h = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let f = this.inModule;
      this.inModule = u;
      let O = this.scope, D = this.getScopeHandler();
      this.scope = new D(this, u);
      let S = this.prodParam;
      this.prodParam = new WE();
      let A = this.classScope;
      this.classScope = new aT(this);
      let P = this.expressionScope;
      return this.expressionScope = new oT(this), () => {
        this.state.labels = o, this.exportedIdentifiers = h, this.inModule = f, this.scope = O, this.prodParam = S, this.classScope = A, this.expressionScope = P;
      };
    }
    enterInitialScopes() {
      let u = 0;
      (this.inModule || this.optionFlags & 1) && (u |= 2), this.optionFlags & 32 && (u |= 1), this.optionFlags & 2 && (u |= 4);
      let o = 1;
      this.optionFlags & 4 && (o |= 512), this.scope.enter(o), this.prodParam.enter(u);
    }
    checkDestructuringPrivate(u) {
      let { privateKeyLoc: o } = u;
      o !== null && this.expectPlugin("destructuringPrivate", o);
    }
  }, Rl = class {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, ql = class {
    constructor(u, o, h) {
      this.type = "", this.start = o, this.end = 0, this.loc = new s(h), (u == null ? void 0 : u.optionFlags) & 128 && (this.range = [o, 0]), u != null && u.filename && (this.loc.filename = u.filename);
    }
  }, _h = ql.prototype;
  _h.__clone = function() {
    let u = new ql(void 0, this.start, this.loc.start), o = Object.keys(this);
    for (let h = 0, f = o.length; h < f; h++) {
      let O = o[h];
      O !== "leadingComments" && O !== "trailingComments" && O !== "innerComments" && (u[O] = this[O]);
    }
    return u;
  };
  var pT = class extends hT {
    startNode() {
      let u = this.state.startLoc;
      return new ql(this, u.index, u);
    }
    startNodeAt(u) {
      return new ql(this, u.index, u);
    }
    startNodeAtNode(u) {
      return this.startNodeAt(u.loc.start);
    }
    finishNode(u, o) {
      return this.finishNodeAt(u, o, this.state.lastTokEndLoc);
    }
    finishNodeAt(u, o, h) {
      return u.type = o, u.end = h.index, u.loc.end = h, this.optionFlags & 128 && (u.range[1] = h.index), this.optionFlags & 4096 && this.processComment(u), u;
    }
    resetStartLocation(u, o) {
      u.start = o.index, u.loc.start = o, this.optionFlags & 128 && (u.range[0] = o.index);
    }
    resetEndLocation(u, o = this.state.lastTokEndLoc) {
      u.end = o.index, u.loc.end = o, this.optionFlags & 128 && (u.range[1] = o.index);
    }
    resetStartLocationFromNode(u, o) {
      this.resetStartLocation(u, o.loc.start);
    }
    castNodeTo(u, o) {
      return u.type = o, u;
    }
    cloneIdentifier(u) {
      let { type: o, start: h, end: f, loc: O, range: D, name: S } = u, A = Object.create(_h);
      return A.type = o, A.start = h, A.end = f, A.loc = O, A.range = D, A.name = S, u.extra && (A.extra = u.extra), A;
    }
    cloneStringLiteral(u) {
      let { type: o, start: h, end: f, loc: O, range: D, extra: S } = u, A = Object.create(_h);
      return A.type = o, A.start = h, A.end = f, A.loc = O, A.range = D, A.extra = S, A.value = u.value, A;
    }
  }, ly = (u) => u.type === "ParenthesizedExpression" ? ly(u.expression) : u, dT = class extends pT {
    toAssignable(u, o = !1) {
      var h, f;
      let O;
      switch ((u.type === "ParenthesizedExpression" || (h = u.extra) != null && h.parenthesized) && (O = ly(u), o ? O.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(b.InvalidParenthesizedAssignment, u) : O.type !== "MemberExpression" && !this.isOptionalMemberExpression(O) && this.raise(b.InvalidParenthesizedAssignment, u) : this.raise(b.InvalidParenthesizedAssignment, u)), u.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          this.castNodeTo(u, "ObjectPattern");
          for (let S = 0, A = u.properties.length, P = A - 1; S < A; S++) {
            var D;
            let E = u.properties[S], M = S === P;
            this.toAssignableObjectExpressionProp(E, M, o), M && E.type === "RestElement" && (D = u.extra) != null && D.trailingCommaLoc && this.raise(b.RestTrailingComma, u.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let { key: S, value: A } = u;
          this.isPrivateName(S) && this.classScope.usePrivateName(this.getPrivateNameSV(S), S.loc.start), this.toAssignable(A, o);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          this.castNodeTo(u, "ArrayPattern"), this.toAssignableList(u.elements, (f = u.extra) == null ? void 0 : f.trailingCommaLoc, o);
          break;
        case "AssignmentExpression":
          u.operator !== "=" && this.raise(b.MissingEqInAssignment, u.left.loc.end), this.castNodeTo(u, "AssignmentPattern"), delete u.operator, this.toAssignable(u.left, o);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(O, o);
          break;
      }
    }
    toAssignableObjectExpressionProp(u, o, h) {
      if (u.type === "ObjectMethod") this.raise(u.kind === "get" || u.kind === "set" ? b.PatternHasAccessor : b.PatternHasMethod, u.key);
      else if (u.type === "SpreadElement") {
        this.castNodeTo(u, "RestElement");
        let f = u.argument;
        this.checkToRestConversion(f, !1), this.toAssignable(f, h), o || this.raise(b.RestTrailingComma, u);
      } else this.toAssignable(u, h);
    }
    toAssignableList(u, o, h) {
      let f = u.length - 1;
      for (let O = 0; O <= f; O++) {
        let D = u[O];
        D && (this.toAssignableListItem(u, O, h), D.type === "RestElement" && (O < f ? this.raise(b.RestTrailingComma, D) : o && this.raise(b.RestTrailingComma, o)));
      }
    }
    toAssignableListItem(u, o, h) {
      let f = u[o];
      if (f.type === "SpreadElement") {
        this.castNodeTo(f, "RestElement");
        let O = f.argument;
        this.checkToRestConversion(O, !0), this.toAssignable(O, h);
      } else this.toAssignable(f, h);
    }
    isAssignable(u, o) {
      switch (u.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let h = u.properties.length - 1;
          return u.properties.every((f, O) => f.type !== "ObjectMethod" && (O === h || f.type !== "SpreadElement") && this.isAssignable(f));
        }
        case "ObjectProperty":
          return this.isAssignable(u.value);
        case "SpreadElement":
          return this.isAssignable(u.argument);
        case "ArrayExpression":
          return u.elements.every((h) => h === null || this.isAssignable(h));
        case "AssignmentExpression":
          return u.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(u.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !o;
        default:
          return !1;
      }
    }
    toReferencedList(u, o) {
      return u;
    }
    toReferencedListDeep(u, o) {
      this.toReferencedList(u, o);
      for (let h of u) (h == null ? void 0 : h.type) === "ArrayExpression" && this.toReferencedListDeep(h.elements);
    }
    parseSpread(u) {
      let o = this.startNode();
      return this.next(), o.argument = this.parseMaybeAssignAllowIn(u, void 0), this.finishNode(o, "SpreadElement");
    }
    parseRestBinding() {
      let u = this.startNode();
      return this.next(), u.argument = this.parseBindingAtom(), this.finishNode(u, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let u = this.startNode();
          return this.next(), u.elements = this.parseBindingList(3, 93, 1), this.finishNode(u, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(u, o, h) {
      let f = h & 1, O = [], D = !0;
      for (; !this.eat(u); ) if (D ? D = !1 : this.expect(12), f && this.match(12)) O.push(null);
      else {
        if (this.eat(u)) break;
        if (this.match(21)) {
          let S = this.parseRestBinding();
          if ((this.hasPlugin("flow") || h & 2) && (S = this.parseFunctionParamType(S)), O.push(S), !this.checkCommaAfterRest(o)) {
            this.expect(u);
            break;
          }
        } else {
          let S = [];
          if (h & 2) for (this.match(26) && this.hasPlugin("decorators") && this.raise(b.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); ) S.push(this.parseDecorator());
          O.push(this.parseBindingElement(h, S));
        }
      }
      return O;
    }
    parseBindingRestProperty(u) {
      return this.next(), u.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(u, "RestElement");
    }
    parseBindingProperty() {
      let { type: u, startLoc: o } = this.state;
      if (u === 21) return this.parseBindingRestProperty(this.startNode());
      let h = this.startNode();
      return u === 139 ? (this.expectPlugin("destructuringPrivate", o), this.classScope.usePrivateName(this.state.value, o), h.key = this.parsePrivateName()) : this.parsePropertyName(h), h.method = !1, this.parseObjPropValue(h, o, !1, !1, !0, !1);
    }
    parseBindingElement(u, o) {
      let h = this.parseMaybeDefault();
      return (this.hasPlugin("flow") || u & 2) && this.parseFunctionParamType(h), o.length && (h.decorators = o, this.resetStartLocationFromNode(h, o[0])), this.parseMaybeDefault(h.loc.start, h);
    }
    parseFunctionParamType(u) {
      return u;
    }
    parseMaybeDefault(u, o) {
      if (u != null || (u = this.state.startLoc), o = o != null ? o : this.parseBindingAtom(), !this.eat(29)) return o;
      let h = this.startNodeAt(u);
      return h.left = o, h.right = this.parseMaybeAssignAllowIn(), this.finishNode(h, "AssignmentPattern");
    }
    isValidLVal(u, o, h) {
      switch (u) {
        case "AssignmentPattern":
          return "left";
        case "RestElement":
          return "argument";
        case "ObjectProperty":
          return "value";
        case "ParenthesizedExpression":
          return "expression";
        case "ArrayPattern":
          return "elements";
        case "ObjectPattern":
          return "properties";
      }
      return !1;
    }
    isOptionalMemberExpression(u) {
      return u.type === "OptionalMemberExpression";
    }
    checkLVal(u, o, h = 64, f = !1, O = !1, D = !1) {
      var S;
      let A = u.type;
      if (this.isObjectMethod(u)) return;
      let P = this.isOptionalMemberExpression(u);
      if (P || A === "MemberExpression") {
        P && (this.expectPlugin("optionalChainingAssign", u.loc.start), o.type !== "AssignmentExpression" && this.raise(b.InvalidLhsOptionalChaining, u, { ancestor: o })), h !== 64 && this.raise(b.InvalidPropertyBindingPattern, u);
        return;
      }
      if (A === "Identifier") {
        this.checkIdentifier(u, h, O);
        let { name: ye } = u;
        f && (f.has(ye) ? this.raise(b.ParamDupe, u) : f.add(ye));
        return;
      }
      let E = this.isValidLVal(A, !(D || (S = u.extra) != null && S.parenthesized) && o.type === "AssignmentExpression", h);
      if (E === !0) return;
      if (E === !1) {
        let ye = h === 64 ? b.InvalidLhs : b.InvalidLhsBinding;
        this.raise(ye, u, { ancestor: o });
        return;
      }
      let M, Z;
      typeof E == "string" ? (M = E, Z = A === "ParenthesizedExpression") : [M, Z] = E;
      let H = A === "ArrayPattern" || A === "ObjectPattern" ? { type: A } : o, ie = u[M];
      if (Array.isArray(ie)) for (let ye of ie) ye && this.checkLVal(ye, H, h, f, O, Z);
      else ie && this.checkLVal(ie, H, h, f, O, Z);
    }
    checkIdentifier(u, o, h = !1) {
      this.state.strict && (h ? Jg(u.name, this.inModule) : Hg(u.name)) && (o === 64 ? this.raise(b.StrictEvalArguments, u, { referenceName: u.name }) : this.raise(b.StrictEvalArgumentsBinding, u, { bindingName: u.name })), o & 8192 && u.name === "let" && this.raise(b.LetInLexicalBinding, u), o & 64 || this.declareNameFromIdentifier(u, o);
    }
    declareNameFromIdentifier(u, o) {
      this.scope.declareName(u.name, o, u.loc.start);
    }
    checkToRestConversion(u, o) {
      switch (u.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(u.expression, o);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (o) break;
        default:
          this.raise(b.InvalidRestAssignmentPattern, u);
      }
    }
    checkCommaAfterRest(u) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === u ? b.RestTrailingComma : b.ElementAfterRest, this.state.startLoc), !0) : !1;
    }
  };
  function fT(u) {
    if (u == null) throw new Error(`Unexpected ${u} value.`);
    return u;
  }
  function uy(u) {
    if (!u) throw new Error("Assert fail");
  }
  var se = C`typescript`({ AbstractMethodHasImplementation: ({ methodName: u }) => `Method '${u}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: u }) => `Property '${u}' cannot have an initializer because it is marked abstract.`, AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: u }) => `'declare' is not allowed in ${u}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: u }) => `Accessibility modifier already seen: '${u}'.`, DuplicateModifier: ({ modifier: u }) => `Duplicate modifier: '${u}'.`, EmptyHeritageClauseType: ({ token: u }) => `'${u}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: u }) => `'${u[0]}' modifier cannot be used with '${u[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: u }) => `Index signatures cannot have an accessibility modifier ('${u}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidHeritageClauseType: ({ token: u }) => `'${u}' list can only include identifiers or qualified-names with optional type arguments.`, InvalidModifierOnAwaitUsingDeclaration: (u) => `'${u}' modifier cannot appear on an await using declaration.`, InvalidModifierOnTypeMember: ({ modifier: u }) => `'${u}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: u }) => `'${u}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: u }) => `'${u}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifierOnUsingDeclaration: (u) => `'${u}' modifier cannot appear on a using declaration.`, InvalidModifiersOrder: ({ orderedModifiers: u }) => `'${u[0]}' modifier must precede '${u[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifier: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: u }) => `Private elements cannot have an accessibility modifier ('${u}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: u }) => `Single type parameter ${u} should have a trailing comma. Example usage: <${u},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: u }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${u}.`, UsingDeclarationInAmbientContext: (u) => `'${u}' declarations are not allowed in ambient contexts.` });
  function mT(u) {
    switch (u) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  function cy(u) {
    return u === "private" || u === "public" || u === "protected";
  }
  function gT(u) {
    return u === "in" || u === "out";
  }
  var yT = (u) => class extends u {
    constructor(...o) {
      super(...o), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: se.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: se.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: se.InvalidModifierOnTypeParameter });
    }
    getScopeHandler() {
      return YE;
    }
    tsIsIdentifier() {
      return xe(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
    }
    tsNextTokenOnSameLineAndCanFollowModifier() {
      return this.next(), this.hasPrecedingLineBreak() ? !1 : this.tsTokenCanFollowModifier();
    }
    tsNextTokenCanFollowModifier() {
      return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
    }
    tsParseModifier(o, h, f) {
      if (!xe(this.state.type) && this.state.type !== 58 && this.state.type !== 75) return;
      let O = this.state.value;
      if (o.includes(O)) {
        if (f && this.match(106) || h && this.tsIsStartOfStaticBlocks()) return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return O;
      }
    }
    tsParseModifiers({ allowedModifiers: o, disallowedModifiers: h, stopOnStartOfClassStaticBlock: f, errorTemplate: O = se.InvalidModifierOnTypeMember }, D) {
      let S = (P, E, M, Z) => {
        E === M && D[Z] && this.raise(se.InvalidModifiersOrder, P, { orderedModifiers: [M, Z] });
      }, A = (P, E, M, Z) => {
        (D[M] && E === Z || D[Z] && E === M) && this.raise(se.IncompatibleModifiers, P, { modifiers: [M, Z] });
      };
      for (; ; ) {
        let { startLoc: P } = this.state, E = this.tsParseModifier(o.concat(h != null ? h : []), f, D.static);
        if (!E) break;
        cy(E) ? D.accessibility ? this.raise(se.DuplicateAccessibilityModifier, P, { modifier: E }) : (S(P, E, E, "override"), S(P, E, E, "static"), S(P, E, E, "readonly"), D.accessibility = E) : gT(E) ? (D[E] && this.raise(se.DuplicateModifier, P, { modifier: E }), D[E] = !0, S(P, E, "in", "out")) : (hasOwnProperty.call(D, E) ? this.raise(se.DuplicateModifier, P, { modifier: E }) : (S(P, E, "static", "readonly"), S(P, E, "static", "override"), S(P, E, "override", "readonly"), S(P, E, "abstract", "override"), A(P, E, "declare", "override"), A(P, E, "static", "abstract")), D[E] = !0), h != null && h.includes(E) && this.raise(O, P, { modifier: E });
      }
    }
    tsIsListTerminator(o) {
      switch (o) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(o, h) {
      let f = [];
      for (; !this.tsIsListTerminator(o); ) f.push(h());
      return f;
    }
    tsParseDelimitedList(o, h, f) {
      return fT(this.tsParseDelimitedListWorker(o, h, !0, f));
    }
    tsParseDelimitedListWorker(o, h, f, O) {
      let D = [], S = -1;
      for (; !this.tsIsListTerminator(o); ) {
        S = -1;
        let A = h();
        if (A == null) return;
        if (D.push(A), this.eat(12)) {
          S = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(o)) break;
        f && this.expect(12);
        return;
      }
      return O && (O.value = S), D;
    }
    tsParseBracketedList(o, h, f, O, D) {
      O || (f ? this.expect(0) : this.expect(47));
      let S = this.tsParseDelimitedList(o, h, D);
      return f ? this.expect(3) : this.expect(48), S;
    }
    tsParseImportType() {
      let o = this.startNode();
      return this.expect(83), this.expect(10), this.match(134) ? o.argument = this.parseStringLiteral(this.state.value) : (this.raise(se.UnsupportedImportTypeArgument, this.state.startLoc), o.argument = super.parseExprAtom()), this.eat(12) ? o.options = this.tsParseImportTypeOptions() : o.options = null, this.expect(11), this.eat(16) && (o.qualifier = this.tsParseEntityName(3)), this.match(47) && (o.typeParameters = this.tsParseTypeArguments()), this.finishNode(o, "TSImportType");
    }
    tsParseImportTypeOptions() {
      let o = this.startNode();
      this.expect(5);
      let h = this.startNode();
      return this.isContextual(76) ? (h.method = !1, h.key = this.parseIdentifier(!0), h.computed = !1, h.shorthand = !1) : this.unexpected(null, 76), this.expect(14), h.value = this.tsParseImportTypeWithPropertyValue(), o.properties = [this.finishObjectProperty(h)], this.expect(8), this.finishNode(o, "ObjectExpression");
    }
    tsParseImportTypeWithPropertyValue() {
      let o = this.startNode(), h = [];
      for (this.expect(5); !this.match(8); ) {
        let f = this.state.type;
        xe(f) || f === 134 ? h.push(super.parsePropertyDefinition(null)) : this.unexpected(), this.eat(12);
      }
      return o.properties = h, this.next(), this.finishNode(o, "ObjectExpression");
    }
    tsParseEntityName(o) {
      let h;
      if (o & 1 && this.match(78)) if (o & 2) h = this.parseIdentifier(!0);
      else {
        let f = this.startNode();
        this.next(), h = this.finishNode(f, "ThisExpression");
      }
      else h = this.parseIdentifier(!!(o & 1));
      for (; this.eat(16); ) {
        let f = this.startNodeAtNode(h);
        f.left = h, f.right = this.parseIdentifier(!!(o & 1)), h = this.finishNode(f, "TSQualifiedName");
      }
      return h;
    }
    tsParseTypeReference() {
      let o = this.startNode();
      return o.typeName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (o.typeParameters = this.tsParseTypeArguments()), this.finishNode(o, "TSTypeReference");
    }
    tsParseThisTypePredicate(o) {
      this.next();
      let h = this.startNodeAtNode(o);
      return h.parameterName = o, h.typeAnnotation = this.tsParseTypeAnnotation(!1), h.asserts = !1, this.finishNode(h, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let o = this.startNode();
      return this.next(), this.finishNode(o, "TSThisType");
    }
    tsParseTypeQuery() {
      let o = this.startNode();
      return this.expect(87), this.match(83) ? o.exprName = this.tsParseImportType() : o.exprName = this.tsParseEntityName(3), !this.hasPrecedingLineBreak() && this.match(47) && (o.typeParameters = this.tsParseTypeArguments()), this.finishNode(o, "TSTypeQuery");
    }
    tsParseTypeParameter(o) {
      let h = this.startNode();
      return o(h), h.name = this.tsParseTypeParameterName(), h.constraint = this.tsEatThenParseType(81), h.default = this.tsEatThenParseType(29), this.finishNode(h, "TSTypeParameter");
    }
    tsTryParseTypeParameters(o) {
      if (this.match(47)) return this.tsParseTypeParameters(o);
    }
    tsParseTypeParameters(o) {
      let h = this.startNode();
      this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let f = { value: -1 };
      return h.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, o), !1, !0, f), h.params.length === 0 && this.raise(se.EmptyTypeParameters, h), f.value !== -1 && this.addExtra(h, "trailingComma", f.value), this.finishNode(h, "TSTypeParameterDeclaration");
    }
    tsFillSignature(o, h) {
      let f = o === 19, O = "parameters", D = "typeAnnotation";
      h.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), h[O] = this.tsParseBindingListForSignature(), f ? h[D] = this.tsParseTypeOrTypePredicateAnnotation(o) : this.match(o) && (h[D] = this.tsParseTypeOrTypePredicateAnnotation(o));
    }
    tsParseBindingListForSignature() {
      let o = super.parseBindingList(11, 41, 2);
      for (let h of o) {
        let { type: f } = h;
        (f === "AssignmentPattern" || f === "TSParameterProperty") && this.raise(se.UnsupportedSignatureParameterKind, h, { type: f });
      }
      return o;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(o, h) {
      return this.tsFillSignature(14, h), this.tsParseTypeMemberSemicolon(), this.finishNode(h, o);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), xe(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(o) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) return;
      this.expect(0);
      let h = this.parseIdentifier();
      h.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(h), this.expect(3), o.parameters = [h];
      let f = this.tsTryParseTypeAnnotation();
      return f && (o.typeAnnotation = f), this.tsParseTypeMemberSemicolon(), this.finishNode(o, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(o, h) {
      if (this.eat(17) && (o.optional = !0), this.match(10) || this.match(47)) {
        h && this.raise(se.ReadonlyForMethodSignature, o);
        let f = o;
        f.kind && this.match(47) && this.raise(se.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, f), this.tsParseTypeMemberSemicolon();
        let O = "parameters", D = "typeAnnotation";
        if (f.kind === "get") f[O].length > 0 && (this.raise(b.BadGetterArity, this.state.curPosition()), this.isThisParam(f[O][0]) && this.raise(se.AccessorCannotDeclareThisParameter, this.state.curPosition()));
        else if (f.kind === "set") {
          if (f[O].length !== 1) this.raise(b.BadSetterArity, this.state.curPosition());
          else {
            let S = f[O][0];
            this.isThisParam(S) && this.raise(se.AccessorCannotDeclareThisParameter, this.state.curPosition()), S.type === "Identifier" && S.optional && this.raise(se.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), S.type === "RestElement" && this.raise(se.SetAccessorCannotHaveRestParameter, this.state.curPosition());
          }
          f[D] && this.raise(se.SetAccessorCannotHaveReturnType, f[D]);
        } else f.kind = "method";
        return this.finishNode(f, "TSMethodSignature");
      } else {
        let f = o;
        h && (f.readonly = !0);
        let O = this.tsTryParseTypeAnnotation();
        return O && (f.typeAnnotation = O), this.tsParseTypeMemberSemicolon(), this.finishNode(f, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let o = this.startNode();
      if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", o);
      if (this.match(77)) {
        let f = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", o) : (o.key = this.createIdentifier(f, "new"), this.tsParsePropertyOrMethodSignature(o, !1));
      }
      return this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, o), this.tsTryParseIndexSignature(o) || (super.parsePropertyName(o), !o.computed && o.key.type === "Identifier" && (o.key.name === "get" || o.key.name === "set") && this.tsTokenCanFollowModifier() && (o.kind = o.key.name, super.parsePropertyName(o), !this.match(10) && !this.match(47) && this.unexpected(null, 10)), this.tsParsePropertyOrMethodSignature(o, !!o.readonly));
    }
    tsParseTypeLiteral() {
      let o = this.startNode();
      return o.members = this.tsParseObjectTypeMembers(), this.finishNode(o, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let o = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), o;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedType() {
      let o = this.startNode();
      this.expect(5), this.match(53) ? (o.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (o.readonly = !0), this.expect(0);
      {
        let h = this.startNode();
        h.name = this.tsParseTypeParameterName(), h.constraint = this.tsExpectThenParseType(58), o.typeParameter = this.finishNode(h, "TSTypeParameter");
      }
      return o.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (o.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (o.optional = !0), o.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(o, "TSMappedType");
    }
    tsParseTupleType() {
      let o = this.startNode();
      o.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let h = !1;
      return o.elementTypes.forEach((f) => {
        let { type: O } = f;
        h && O !== "TSRestType" && O !== "TSOptionalType" && !(O === "TSNamedTupleMember" && f.optional) && this.raise(se.OptionalTypeBeforeRequired, f), h || (h = O === "TSNamedTupleMember" && f.optional || O === "TSOptionalType");
      }), this.finishNode(o, "TSTupleType");
    }
    tsParseTupleElementType() {
      let o = this.state.startLoc, h = this.eat(21), { startLoc: f } = this.state, O, D, S, A, P = Fr(this.state.type) ? this.lookaheadCharCode() : null;
      if (P === 58) O = !0, S = !1, D = this.parseIdentifier(!0), this.expect(14), A = this.tsParseType();
      else if (P === 63) {
        S = !0;
        let E = this.state.value, M = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (O = !0, D = this.createIdentifier(this.startNodeAt(f), E), this.expect(17), this.expect(14), A = this.tsParseType()) : (O = !1, A = M, this.expect(17));
      } else A = this.tsParseType(), S = this.eat(17), O = this.eat(14);
      if (O) {
        let E;
        D ? (E = this.startNodeAt(f), E.optional = S, E.label = D, E.elementType = A, this.eat(17) && (E.optional = !0, this.raise(se.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (E = this.startNodeAt(f), E.optional = S, this.raise(se.InvalidTupleMemberLabel, A), E.label = A, E.elementType = this.tsParseType()), A = this.finishNode(E, "TSNamedTupleMember");
      } else if (S) {
        let E = this.startNodeAt(f);
        E.typeAnnotation = A, A = this.finishNode(E, "TSOptionalType");
      }
      if (h) {
        let E = this.startNodeAt(o);
        E.typeAnnotation = A, A = this.finishNode(E, "TSRestType");
      }
      return A;
    }
    tsParseParenthesizedType() {
      let o = this.startNode();
      return this.expect(10), o.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(o, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(o, h) {
      let f = this.startNode();
      return o === "TSConstructorType" && (f.abstract = !!h, h && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, f)), this.finishNode(f, o);
    }
    tsParseLiteralTypeNode() {
      let o = this.startNode();
      switch (this.state.type) {
        case 135:
        case 136:
        case 134:
        case 85:
        case 86:
          o.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(o, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      {
        let o = this.startNode();
        return o.literal = super.parseTemplate(!1), this.finishNode(o, "TSLiteralType");
      }
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let o = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(o) : o;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 134:
        case 135:
        case 136:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let o = this.startNode(), h = this.lookahead();
            return h.type !== 135 && h.type !== 136 && this.unexpected(), o.literal = this.parseMaybeUnary(), this.finishNode(o, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let { type: o } = this.state;
          if (xe(o) || o === 88 || o === 84) {
            let h = o === 88 ? "TSVoidKeyword" : o === 84 ? "TSNullKeyword" : mT(this.state.value);
            if (h !== void 0 && this.lookaheadCharCode() !== 46) {
              let f = this.startNode();
              return this.next(), this.finishNode(f, h);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let { startLoc: o } = this.state, h = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); ) if (this.match(3)) {
        let f = this.startNodeAt(o);
        f.elementType = h, this.expect(3), h = this.finishNode(f, "TSArrayType");
      } else {
        let f = this.startNodeAt(o);
        f.objectType = h, f.indexType = this.tsParseType(), this.expect(3), h = this.finishNode(f, "TSIndexedAccessType");
      }
      return h;
    }
    tsParseTypeOperator() {
      let o = this.startNode(), h = this.state.value;
      return this.next(), o.operator = h, o.typeAnnotation = this.tsParseTypeOperatorOrHigher(), h === "readonly" && this.tsCheckTypeAnnotationForReadOnly(o), this.finishNode(o, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(o) {
      switch (o.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(se.UnexpectedReadonly, o);
      }
    }
    tsParseInferType() {
      let o = this.startNode();
      this.expectContextual(115);
      let h = this.startNode();
      return h.name = this.tsParseTypeParameterName(), h.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), o.typeParameter = this.finishNode(h, "TSTypeParameter"), this.finishNode(o, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let o = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return o;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return SE(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(o, h, f) {
      let O = this.startNode(), D = this.eat(f), S = [];
      do
        S.push(h());
      while (this.eat(f));
      return S.length === 1 && !D ? S[0] : (O.types = S, this.finishNode(O, o));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (xe(this.state.type) || this.match(78)) return this.next(), !0;
      if (this.match(5)) {
        let { errors: o } = this.state, h = o.length;
        try {
          return this.parseObjectLike(8, !0), o.length === h;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let { errors: o } = this.state, h = o.length;
        try {
          return super.parseBindingList(3, 93, 1), o.length === h;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(o) {
      return this.tsInType(() => {
        let h = this.startNode();
        this.expect(o);
        let f = this.startNode(), O = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (O && this.match(78)) {
          let A = this.tsParseThisTypeOrThisTypePredicate();
          return A.type === "TSThisType" ? (f.parameterName = A, f.asserts = !0, f.typeAnnotation = null, A = this.finishNode(f, "TSTypePredicate")) : (this.resetStartLocationFromNode(A, f), A.asserts = !0), h.typeAnnotation = A, this.finishNode(h, "TSTypeAnnotation");
        }
        let D = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!D) return O ? (f.parameterName = this.parseIdentifier(), f.asserts = O, f.typeAnnotation = null, h.typeAnnotation = this.finishNode(f, "TSTypePredicate"), this.finishNode(h, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, h);
        let S = this.tsParseTypeAnnotation(!1);
        return f.parameterName = D, f.typeAnnotation = S, f.asserts = O, h.typeAnnotation = this.finishNode(f, "TSTypePredicate"), this.finishNode(h, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14)) return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let o = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return this.next(), o;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109) return !1;
      let o = this.state.containsEsc;
      return this.next(), !xe(this.state.type) && !this.match(78) ? !1 : (o && this.raise(b.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" }), !0);
    }
    tsParseTypeAnnotation(o = !0, h = this.startNode()) {
      return this.tsInType(() => {
        o && this.expect(14), h.typeAnnotation = this.tsParseType();
      }), this.finishNode(h, "TSTypeAnnotation");
    }
    tsParseType() {
      uy(this.state.inType);
      let o = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return o;
      let h = this.startNodeAtNode(o);
      return h.checkType = o, h.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), h.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), h.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(h, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.isLookaheadContextual("new");
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(se.ReservedTypeAssertion, this.state.startLoc);
      let o = this.startNode();
      return o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), o.expression = this.parseMaybeUnary(), this.finishNode(o, "TSTypeAssertion");
    }
    tsParseHeritageClause(o) {
      let h = this.state.startLoc, f = this.tsParseDelimitedList("HeritageClauseElement", () => {
        {
          let O = this.startNode();
          return O.expression = this.tsParseEntityName(3), this.match(47) && (O.typeParameters = this.tsParseTypeArguments()), this.finishNode(O, "TSExpressionWithTypeArguments");
        }
      });
      return f.length || this.raise(se.EmptyHeritageClauseType, h, { token: o }), f;
    }
    tsParseInterfaceDeclaration(o, h = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), h.declare && (o.declare = !0), xe(this.state.type) ? (o.id = this.parseIdentifier(), this.checkIdentifier(o.id, 130)) : (o.id = null, this.raise(se.MissingInterfaceName, this.state.startLoc)), o.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (o.extends = this.tsParseHeritageClause("extends"));
      let f = this.startNode();
      return f.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), o.body = this.finishNode(f, "TSInterfaceBody"), this.finishNode(o, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(o) {
      return o.id = this.parseIdentifier(), this.checkIdentifier(o.id, 2), o.typeAnnotation = this.tsInType(() => {
        if (o.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookaheadCharCode() !== 46) {
          let h = this.startNode();
          return this.next(), this.finishNode(h, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(o, "TSTypeAliasDeclaration");
    }
    tsInTopLevelContext(o) {
      if (this.curContext() !== V.brace) {
        let h = this.state.context;
        this.state.context = [h[0]];
        try {
          return o();
        } finally {
          this.state.context = h;
        }
      } else return o();
    }
    tsInType(o) {
      let h = this.state.inType;
      this.state.inType = !0;
      try {
        return o();
      } finally {
        this.state.inType = h;
      }
    }
    tsInDisallowConditionalTypesContext(o) {
      let h = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return o();
      } finally {
        this.state.inDisallowConditionalTypesContext = h;
      }
    }
    tsInAllowConditionalTypesContext(o) {
      let h = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return o();
      } finally {
        this.state.inDisallowConditionalTypesContext = h;
      }
    }
    tsEatThenParseType(o) {
      if (this.match(o)) return this.tsNextThenParseType();
    }
    tsExpectThenParseType(o) {
      return this.tsInType(() => (this.expect(o), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let o = this.startNode();
      return o.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (o.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(o, "TSEnumMember");
    }
    tsParseEnumDeclaration(o, h = {}) {
      return h.const && (o.const = !0), h.declare && (o.declare = !0), this.expectContextual(126), o.id = this.parseIdentifier(), this.checkIdentifier(o.id, o.const ? 8971 : 8459), this.expect(5), o.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(o, "TSEnumDeclaration");
    }
    tsParseEnumBody() {
      let o = this.startNode();
      return this.expect(5), o.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(o, "TSEnumBody");
    }
    tsParseModuleBlock() {
      let o = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(o.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(o, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(o, h = !1) {
      if (o.id = this.parseIdentifier(), h || this.checkIdentifier(o.id, 1024), this.eat(16)) {
        let f = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(f, !0), o.body = f;
      } else this.scope.enter(1024), this.prodParam.enter(0), o.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(o, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(o) {
      return this.isContextual(112) ? (o.kind = "global", o.global = !0, o.id = this.parseIdentifier()) : this.match(134) ? (o.kind = "module", o.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(1024), this.prodParam.enter(0), o.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(o, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(o, h, f) {
      o.isExport = f || !1, o.id = h || this.parseIdentifier(), this.checkIdentifier(o.id, 4096), this.expect(29);
      let O = this.tsParseModuleReference();
      return o.importKind === "type" && O.type !== "TSExternalModuleReference" && this.raise(se.ImportAliasHasImportType, O), o.moduleReference = O, this.semicolon(), this.finishNode(o, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
    }
    tsParseExternalModuleReference() {
      let o = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), o.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(o, "TSExternalModuleReference");
    }
    tsLookAhead(o) {
      let h = this.state.clone(), f = o();
      return this.state = h, f;
    }
    tsTryParseAndCatch(o) {
      let h = this.tryParse((f) => o() || f());
      if (!(h.aborted || !h.node)) return h.error && (this.state = h.failState), h.node;
    }
    tsTryParse(o) {
      let h = this.state.clone(), f = o();
      if (f !== void 0 && f !== !1) return f;
      this.state = h;
    }
    tsTryParseDeclare(o) {
      if (this.isLineTerminator()) return;
      let h = this.state.type;
      return this.tsInAmbientContext(() => {
        switch (h) {
          case 68:
            return o.declare = !0, super.parseFunctionStatement(o, !1, !1);
          case 80:
            return o.declare = !0, this.parseClass(o, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(o, { declare: !0 });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(o);
          case 100:
            if (this.state.containsEsc) return;
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (o.declare = !0, this.parseVarStatement(o, this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(o, { const: !0, declare: !0 }));
          case 107:
            if (this.hasPlugin("explicitResourceManagement") && this.isUsing()) return this.raise(se.InvalidModifierOnUsingDeclaration, this.state.startLoc, "declare"), o.declare = !0, this.parseVarStatement(o, "using", !0);
            break;
          case 96:
            if (this.hasPlugin("explicitResourceManagement") && this.isAwaitUsing()) return this.raise(se.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, "declare"), o.declare = !0, this.next(), this.parseVarStatement(o, "await using", !0);
            break;
          case 129: {
            let f = this.tsParseInterfaceDeclaration(o, { declare: !0 });
            if (f) return f;
          }
          default:
            if (xe(h)) return this.tsParseDeclaration(o, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(o, h, f) {
      switch (h.name) {
        case "declare": {
          let O = this.tsTryParseDeclare(o);
          return O && (O.declare = !0), O;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(1024), this.prodParam.enter(0);
            let O = o;
            return O.kind = "global", o.global = !0, O.id = h, O.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(O, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(o, h.name, !1, f);
      }
    }
    tsParseDeclaration(o, h, f, O) {
      switch (h) {
        case "abstract":
          if (this.tsCheckLineTerminator(f) && (this.match(80) || xe(this.state.type))) return this.tsParseAbstractDeclaration(o, O);
          break;
        case "module":
          if (this.tsCheckLineTerminator(f)) {
            if (this.match(134)) return this.tsParseAmbientExternalModuleDeclaration(o);
            if (xe(this.state.type)) return o.kind = "module", this.tsParseModuleOrNamespaceDeclaration(o);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(f) && xe(this.state.type)) return o.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(o);
          break;
        case "type":
          if (this.tsCheckLineTerminator(f) && xe(this.state.type)) return this.tsParseTypeAliasDeclaration(o);
          break;
      }
    }
    tsCheckLineTerminator(o) {
      return o ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(o) {
      if (!this.match(47)) return;
      let h = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let f = this.tsTryParseAndCatch(() => {
        let O = this.startNodeAt(o);
        return O.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(O), O.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), O;
      });
      if (this.state.maybeInArrowParameters = h, !!f) return super.parseArrowExpression(f, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47) return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let o = this.startNode();
      return o.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), o.params.length === 0 ? this.raise(se.EmptyTypeArguments, o) : !this.state.inType && this.curContext() === V.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(o, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return wE(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseBindingElement(o, h) {
      let f = h.length ? h[0].loc.start : this.state.startLoc, O = {};
      this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, O);
      let D = O.accessibility, S = O.override, A = O.readonly;
      !(o & 4) && (D || A || S) && this.raise(se.UnexpectedParameterModifier, f);
      let P = this.parseMaybeDefault();
      o & 2 && this.parseFunctionParamType(P);
      let E = this.parseMaybeDefault(P.loc.start, P);
      if (D || A || S) {
        let M = this.startNodeAt(f);
        return h.length && (M.decorators = h), D && (M.accessibility = D), A && (M.readonly = A), S && (M.override = S), E.type !== "Identifier" && E.type !== "AssignmentPattern" && this.raise(se.UnsupportedParameterPropertyKind, M), M.parameter = E, this.finishNode(M, "TSParameterProperty");
      }
      return h.length && (P.decorators = h), E;
    }
    isSimpleParameter(o) {
      return o.type === "TSParameterProperty" && super.isSimpleParameter(o.parameter) || super.isSimpleParameter(o);
    }
    tsDisallowOptionalPattern(o) {
      for (let h of o.params) h.type !== "Identifier" && h.optional && !this.state.isAmbientContext && this.raise(se.PatternIsOptional, h);
    }
    setArrowFunctionParameters(o, h, f) {
      super.setArrowFunctionParameters(o, h, f), this.tsDisallowOptionalPattern(o);
    }
    parseFunctionBodyAndFinish(o, h, f = !1) {
      this.match(14) && (o.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let O = h === "FunctionDeclaration" ? "TSDeclareFunction" : h === "ClassMethod" || h === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return O && !this.match(5) && this.isLineTerminator() ? this.finishNode(o, O) : O === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(se.DeclareFunctionHasImplementation, o), o.declare) ? super.parseFunctionBodyAndFinish(o, O, f) : (this.tsDisallowOptionalPattern(o), super.parseFunctionBodyAndFinish(o, h, f));
    }
    registerFunctionStatementId(o) {
      !o.body && o.id ? this.checkIdentifier(o.id, 1024) : super.registerFunctionStatementId(o);
    }
    tsCheckForInvalidTypeCasts(o) {
      o.forEach((h) => {
        (h == null ? void 0 : h.type) === "TSTypeCastExpression" && this.raise(se.UnexpectedTypeAnnotation, h.typeAnnotation);
      });
    }
    toReferencedList(o, h) {
      return this.tsCheckForInvalidTypeCasts(o), o;
    }
    parseArrayLike(o, h, f, O) {
      let D = super.parseArrayLike(o, h, f, O);
      return D.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(D.elements), D;
    }
    parseSubscript(o, h, f, O) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let S = this.startNodeAt(h);
        return S.expression = o, this.finishNode(S, "TSNonNullExpression");
      }
      let D = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (f) return O.stop = !0, o;
        O.optionalChainMember = D = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let S, A = this.tsTryParseAndCatch(() => {
          if (!f && this.atPossibleAsyncArrow(o)) {
            let Z = this.tsTryParseGenericAsyncArrowFunction(h);
            if (Z) return Z;
          }
          let P = this.tsParseTypeArgumentsInExpression();
          if (!P) return;
          if (D && !this.match(10)) {
            S = this.state.curPosition();
            return;
          }
          if (Il(this.state.type)) {
            let Z = super.parseTaggedTemplateExpression(o, h, O);
            return Z.typeParameters = P, Z;
          }
          if (!f && this.eat(10)) {
            let Z = this.startNodeAt(h);
            return Z.callee = o, Z.arguments = this.parseCallExpressionArguments(11), this.tsCheckForInvalidTypeCasts(Z.arguments), Z.typeParameters = P, O.optionalChainMember && (Z.optional = D), this.finishCallExpression(Z, O.optionalChainMember);
          }
          let E = this.state.type;
          if (E === 48 || E === 52 || E !== 10 && qa(E) && !this.hasPrecedingLineBreak()) return;
          let M = this.startNodeAt(h);
          return M.expression = o, M.typeParameters = P, this.finishNode(M, "TSInstantiationExpression");
        });
        if (S && this.unexpected(S, 10), A) return A.type === "TSInstantiationExpression" && ((this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(se.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), !this.match(16) && !this.match(18) && (A.expression = super.stopParseSubscript(o, O))), A;
      }
      return super.parseSubscript(o, h, f, O);
    }
    parseNewCallee(o) {
      var h;
      super.parseNewCallee(o);
      let { callee: f } = o;
      f.type === "TSInstantiationExpression" && !((h = f.extra) != null && h.parenthesized) && (o.typeParameters = f.typeParameters, o.callee = f.expression);
    }
    parseExprOp(o, h, f) {
      let O;
      if (Bl(58) > f && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (O = this.isContextual(120)))) {
        let D = this.startNodeAt(h);
        return D.expression = o, D.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (O && this.raise(b.UnexpectedKeyword, this.state.startLoc, { keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(D, O ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(D, h, f);
      }
      return super.parseExprOp(o, h, f);
    }
    checkReservedWord(o, h, f, O) {
      this.state.isAmbientContext || super.checkReservedWord(o, h, f, O);
    }
    checkImportReflection(o) {
      super.checkImportReflection(o), o.module && o.importKind !== "value" && this.raise(se.ImportReflectionHasImportType, o.specifiers[0].loc.start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(o) {
      if (super.isPotentialImportPhase(o)) return !0;
      if (this.isContextual(130)) {
        let h = this.lookaheadCharCode();
        return o ? h === 123 || h === 42 : h !== 61;
      }
      return !o && this.isContextual(87);
    }
    applyImportPhase(o, h, f, O) {
      super.applyImportPhase(o, h, f, O), h ? o.exportKind = f === "type" ? "type" : "value" : o.importKind = f === "type" || f === "typeof" ? f : "value";
    }
    parseImport(o) {
      if (this.match(134)) return o.importKind = "value", super.parseImport(o);
      let h;
      if (xe(this.state.type) && this.lookaheadCharCode() === 61) return o.importKind = "value", this.tsParseImportEqualsDeclaration(o);
      if (this.isContextual(130)) {
        let f = this.parseMaybeImportPhase(o, !1);
        if (this.lookaheadCharCode() === 61) return this.tsParseImportEqualsDeclaration(o, f);
        h = super.parseImportSpecifiersAndAfter(o, f);
      } else h = super.parseImport(o);
      return h.importKind === "type" && h.specifiers.length > 1 && h.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(se.TypeImportCannotSpecifyDefaultAndNamed, h), h;
    }
    parseExport(o, h) {
      if (this.match(83)) {
        let f = o;
        this.next();
        let O = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? O = this.parseMaybeImportPhase(f, !1) : f.importKind = "value", this.tsParseImportEqualsDeclaration(f, O, !0);
      } else if (this.eat(29)) {
        let f = o;
        return f.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(f, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let f = o;
        return this.expectContextual(128), f.id = this.parseIdentifier(), this.semicolon(), this.finishNode(f, "TSNamespaceExportDeclaration");
      } else return super.parseExport(o, h);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.isLookaheadContextual("class");
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let o = this.startNode();
        return this.next(), o.abstract = !0, this.parseClass(o, !0, !0);
      }
      if (this.match(129)) {
        let o = this.tsParseInterfaceDeclaration(this.startNode());
        if (o) return o;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(o, h, f = !1) {
      let { isAmbientContext: O } = this.state, D = super.parseVarStatement(o, h, f || O);
      if (!O) return D;
      if (!o.declare && (h === "using" || h === "await using")) return this.raiseOverwrite(se.UsingDeclarationInAmbientContext, o, h), D;
      for (let { id: S, init: A } of D.declarations) A && (h === "var" || h === "let" || S.typeAnnotation ? this.raise(se.InitializerNotAllowedInAmbientContext, A) : xT(A, this.hasPlugin("estree")) || this.raise(se.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, A));
      return D;
    }
    parseStatementContent(o, h) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let f = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(f, { const: !0 });
      }
      if (this.isContextual(126)) return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let f = this.tsParseInterfaceDeclaration(this.startNode());
        if (f) return f;
      }
      return super.parseStatementContent(o, h);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(o, h) {
      return h.some((f) => cy(f) ? o.accessibility === f : !!o[f]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(o, h, f) {
      let O = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({ allowedModifiers: O, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: !0, errorTemplate: se.InvalidModifierOnTypeParameterPositions }, h);
      let D = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(h, O) && this.raise(se.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(o, h)) : this.parseClassMemberWithIsStatic(o, h, f, !!h.static);
      };
      h.declare ? this.tsInAmbientContext(D) : D();
    }
    parseClassMemberWithIsStatic(o, h, f, O) {
      let D = this.tsTryParseIndexSignature(h);
      if (D) {
        o.body.push(D), h.abstract && this.raise(se.IndexSignatureHasAbstract, h), h.accessibility && this.raise(se.IndexSignatureHasAccessibility, h, { modifier: h.accessibility }), h.declare && this.raise(se.IndexSignatureHasDeclare, h), h.override && this.raise(se.IndexSignatureHasOverride, h);
        return;
      }
      !this.state.inAbstractClass && h.abstract && this.raise(se.NonAbstractClassHasAbstractMethod, h), h.override && (f.hadSuperClass || this.raise(se.OverrideNotInSubClass, h)), super.parseClassMemberWithIsStatic(o, h, f, O);
    }
    parsePostMemberNameModifiers(o) {
      this.eat(17) && (o.optional = !0), o.readonly && this.match(10) && this.raise(se.ClassMethodHasReadonly, o), o.declare && this.match(10) && this.raise(se.ClassMethodHasDeclare, o);
    }
    parseExpressionStatement(o, h, f) {
      return (h.type === "Identifier" ? this.tsParseExpressionStatement(o, h, f) : void 0) || super.parseExpressionStatement(o, h, f);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(o, h, f) {
      if (!this.match(17)) return o;
      if (this.state.maybeInArrowParameters) {
        let O = this.lookaheadCharCode();
        if (O === 44 || O === 61 || O === 58 || O === 41) return this.setOptionalParametersError(f), o;
      }
      return super.parseConditional(o, h, f);
    }
    parseParenItem(o, h) {
      let f = super.parseParenItem(o, h);
      if (this.eat(17) && (f.optional = !0, this.resetEndLocation(o)), this.match(14)) {
        let O = this.startNodeAt(h);
        return O.expression = o, O.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(O, "TSTypeCastExpression");
      }
      return o;
    }
    parseExportDeclaration(o) {
      if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(o));
      let h = this.state.startLoc, f = this.eatContextual(125);
      if (f && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(se.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let O = xe(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(o);
      return O ? ((O.type === "TSInterfaceDeclaration" || O.type === "TSTypeAliasDeclaration" || f) && (o.exportKind = "type"), f && O.type !== "TSImportEqualsDeclaration" && (this.resetStartLocation(O, h), O.declare = !0), O) : null;
    }
    parseClassId(o, h, f, O) {
      if ((!h || f) && this.isContextual(113)) return;
      super.parseClassId(o, h, f, o.declare ? 1024 : 8331);
      let D = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      D && (o.typeParameters = D);
    }
    parseClassPropertyAnnotation(o) {
      o.optional || (this.eat(35) ? o.definite = !0 : this.eat(17) && (o.optional = !0));
      let h = this.tsTryParseTypeAnnotation();
      h && (o.typeAnnotation = h);
    }
    parseClassProperty(o) {
      if (this.parseClassPropertyAnnotation(o), this.state.isAmbientContext && !(o.readonly && !o.typeAnnotation) && this.match(29) && this.raise(se.DeclareClassFieldHasInitializer, this.state.startLoc), o.abstract && this.match(29)) {
        let { key: h } = o;
        this.raise(se.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: h.type === "Identifier" && !o.computed ? h.name : `[${this.input.slice(this.offsetToSourcePos(h.start), this.offsetToSourcePos(h.end))}]` });
      }
      return super.parseClassProperty(o);
    }
    parseClassPrivateProperty(o) {
      return o.abstract && this.raise(se.PrivateElementHasAbstract, o), o.accessibility && this.raise(se.PrivateElementHasAccessibility, o, { modifier: o.accessibility }), this.parseClassPropertyAnnotation(o), super.parseClassPrivateProperty(o);
    }
    parseClassAccessorProperty(o) {
      return this.parseClassPropertyAnnotation(o), o.optional && this.raise(se.AccessorCannotBeOptional, o), super.parseClassAccessorProperty(o);
    }
    pushClassMethod(o, h, f, O, D, S) {
      let A = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      A && D && this.raise(se.ConstructorHasTypeParameters, A);
      let { declare: P = !1, kind: E } = h;
      P && (E === "get" || E === "set") && this.raise(se.DeclareAccessor, h, { kind: E }), A && (h.typeParameters = A), super.pushClassMethod(o, h, f, O, D, S);
    }
    pushClassPrivateMethod(o, h, f, O) {
      let D = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      D && (h.typeParameters = D), super.pushClassPrivateMethod(o, h, f, O);
    }
    declareClassPrivateMethodInScope(o, h) {
      o.type !== "TSDeclareMethod" && (o.type === "MethodDefinition" && o.value.body == null || super.declareClassPrivateMethodInScope(o, h));
    }
    parseClassSuper(o) {
      super.parseClassSuper(o), o.superClass && (this.match(47) || this.match(51)) && (o.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (o.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(o, h, f, O, D, S, A) {
      let P = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return P && (o.typeParameters = P), super.parseObjPropValue(o, h, f, O, D, S, A);
    }
    parseFunctionParams(o, h) {
      let f = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      f && (o.typeParameters = f), super.parseFunctionParams(o, h);
    }
    parseVarId(o, h) {
      super.parseVarId(o, h), o.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (o.definite = !0);
      let f = this.tsTryParseTypeAnnotation();
      f && (o.id.typeAnnotation = f, this.resetEndLocation(o.id));
    }
    parseAsyncArrowFromCallExpression(o, h) {
      return this.match(14) && (o.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(o, h);
    }
    parseMaybeAssign(o, h) {
      var f, O, D, S, A;
      let P, E, M;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (P = this.state.clone(), E = this.tryParse(() => super.parseMaybeAssign(o, h), P), !E.error) return E.node;
        let { context: ie } = this.state, ye = ie[ie.length - 1];
        (ye === V.j_oTag || ye === V.j_expr) && ie.pop();
      }
      if (!((f = E) != null && f.error) && !this.match(47)) return super.parseMaybeAssign(o, h);
      (!P || P === this.state) && (P = this.state.clone());
      let Z, H = this.tryParse((ie) => {
        var ye, Ye;
        Z = this.tsParseTypeParameters(this.tsParseConstModifier);
        let Te = super.parseMaybeAssign(o, h);
        return (Te.type !== "ArrowFunctionExpression" || (ye = Te.extra) != null && ye.parenthesized) && ie(), ((Ye = Z) == null ? void 0 : Ye.params.length) !== 0 && this.resetStartLocationFromNode(Te, Z), Te.typeParameters = Z, Te;
      }, P);
      if (!H.error && !H.aborted) return Z && this.reportReservedArrowTypeParam(Z), H.node;
      if (!E && (uy(!this.hasPlugin("jsx")), M = this.tryParse(() => super.parseMaybeAssign(o, h), P), !M.error)) return M.node;
      if ((O = E) != null && O.node) return this.state = E.failState, E.node;
      if (H.node) return this.state = H.failState, Z && this.reportReservedArrowTypeParam(Z), H.node;
      if ((D = M) != null && D.node) return this.state = M.failState, M.node;
      throw ((S = E) == null ? void 0 : S.error) || H.error || ((A = M) == null ? void 0 : A.error);
    }
    reportReservedArrowTypeParam(o) {
      var h;
      o.params.length === 1 && !o.params[0].constraint && !((h = o.extra) != null && h.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(se.ReservedArrowTypeParam, o);
    }
    parseMaybeUnary(o, h) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(o, h);
    }
    parseArrow(o) {
      if (this.match(14)) {
        let h = this.tryParse((f) => {
          let O = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && f(), O;
        });
        if (h.aborted) return;
        h.thrown || (h.error && (this.state = h.failState), o.returnType = h.node);
      }
      return super.parseArrow(o);
    }
    parseFunctionParamType(o) {
      this.eat(17) && (o.optional = !0);
      let h = this.tsTryParseTypeAnnotation();
      return h && (o.typeAnnotation = h), this.resetEndLocation(o), o;
    }
    isAssignable(o, h) {
      switch (o.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(o.expression, h);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(o, h);
      }
    }
    toAssignable(o, h = !1) {
      switch (o.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(o, h);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          h ? this.expressionScope.recordArrowParameterBindingError(se.UnexpectedTypeCastInParameter, o) : this.raise(se.UnexpectedTypeCastInParameter, o), this.toAssignable(o.expression, h);
          break;
        case "AssignmentExpression":
          !h && o.left.type === "TSTypeCastExpression" && (o.left = this.typeCastToParameter(o.left));
        default:
          super.toAssignable(o, h);
      }
    }
    toAssignableParenthesizedExpression(o, h) {
      switch (o.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(o.expression, h);
          break;
        default:
          super.toAssignable(o, h);
      }
    }
    checkToRestConversion(o, h) {
      switch (o.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(o.expression, !1);
          break;
        default:
          super.checkToRestConversion(o, h);
      }
    }
    isValidLVal(o, h, f) {
      switch (o) {
        case "TSTypeCastExpression":
          return !0;
        case "TSParameterProperty":
          return "parameter";
        case "TSNonNullExpression":
          return "expression";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
          return (f !== 64 || !h) && ["expression", !0];
        default:
          return super.isValidLVal(o, h, f);
      }
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(o, h) {
      if (this.match(47) || this.match(51)) {
        let f = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let O = super.parseMaybeDecoratorArguments(o, h);
          return O.typeParameters = f, O;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(o, h);
    }
    checkCommaAfterRest(o) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === o ? (this.next(), !1) : super.checkCommaAfterRest(o);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(o, h) {
      let f = super.parseMaybeDefault(o, h);
      return f.type === "AssignmentPattern" && f.typeAnnotation && f.right.start < f.typeAnnotation.start && this.raise(se.TypeAnnotationAfterAssign, f.typeAnnotation), f;
    }
    getTokenFromCode(o) {
      if (this.state.inType) {
        if (o === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (o === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(o);
    }
    reScan_lt_gt() {
      let { type: o } = this.state;
      o === 47 ? (this.state.pos -= 1, this.readToken_lt()) : o === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let { type: o } = this.state;
      return o === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : o;
    }
    toAssignableListItem(o, h, f) {
      let O = o[h];
      O.type === "TSTypeCastExpression" && (o[h] = this.typeCastToParameter(O)), super.toAssignableListItem(o, h, f);
    }
    typeCastToParameter(o) {
      return o.expression.typeAnnotation = o.typeAnnotation, this.resetEndLocation(o.expression, o.typeAnnotation.loc.end), o.expression;
    }
    shouldParseArrow(o) {
      return this.match(14) ? o.every((h) => this.isAssignable(h, !0)) : super.shouldParseArrow(o);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(o) {
      if (this.match(47) || this.match(51)) {
        let h = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        h && (o.typeParameters = h);
      }
      return super.jsxParseOpeningElementAfterName(o);
    }
    getGetterSetterExpectedParamCount(o) {
      let h = super.getGetterSetterExpectedParamCount(o), f = this.getObjectOrClassMethodParams(o)[0];
      return f && this.isThisParam(f) ? h + 1 : h;
    }
    parseCatchClauseParam() {
      let o = super.parseCatchClauseParam(), h = this.tsTryParseTypeAnnotation();
      return h && (o.typeAnnotation = h, this.resetEndLocation(o)), o;
    }
    tsInAmbientContext(o) {
      let { isAmbientContext: h, strict: f } = this.state;
      this.state.isAmbientContext = !0, this.state.strict = !1;
      try {
        return o();
      } finally {
        this.state.isAmbientContext = h, this.state.strict = f;
      }
    }
    parseClass(o, h, f) {
      let O = this.state.inAbstractClass;
      this.state.inAbstractClass = !!o.abstract;
      try {
        return super.parseClass(o, h, f);
      } finally {
        this.state.inAbstractClass = O;
      }
    }
    tsParseAbstractDeclaration(o, h) {
      if (this.match(80)) return o.abstract = !0, this.maybeTakeDecorators(h, this.parseClass(o, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak()) return o.abstract = !0, this.raise(se.NonClassMethodPropertyHasAbstractModifier, o), this.tsParseInterfaceDeclaration(o);
      } else this.unexpected(null, 80);
    }
    parseMethod(o, h, f, O, D, S, A) {
      let P = super.parseMethod(o, h, f, O, D, S, A);
      if ((P.abstract || P.type === "TSAbstractMethodDefinition") && (this.hasPlugin("estree") ? P.value : P).body) {
        let { key: E } = P;
        this.raise(se.AbstractMethodHasImplementation, P, { methodName: E.type === "Identifier" && !P.computed ? E.name : `[${this.input.slice(this.offsetToSourcePos(E.start), this.offsetToSourcePos(E.end))}]` });
      }
      return P;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(o, h, f, O) {
      return !h && O ? (this.parseTypeOnlyImportExportSpecifier(o, !1, f), this.finishNode(o, "ExportSpecifier")) : (o.exportKind = "value", super.parseExportSpecifier(o, h, f, O));
    }
    parseImportSpecifier(o, h, f, O, D) {
      return !h && O ? (this.parseTypeOnlyImportExportSpecifier(o, !0, f), this.finishNode(o, "ImportSpecifier")) : (o.importKind = "value", super.parseImportSpecifier(o, h, f, O, f ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(o, h, f) {
      let O = h ? "imported" : "local", D = h ? "local" : "exported", S = o[O], A, P = !1, E = !0, M = S.loc.start;
      if (this.isContextual(93)) {
        let H = this.parseIdentifier();
        if (this.isContextual(93)) {
          let ie = this.parseIdentifier();
          Fr(this.state.type) ? (P = !0, S = H, A = h ? this.parseIdentifier() : this.parseModuleExportName(), E = !1) : (A = ie, E = !1);
        } else Fr(this.state.type) ? (E = !1, A = h ? this.parseIdentifier() : this.parseModuleExportName()) : (P = !0, S = H);
      } else Fr(this.state.type) && (P = !0, h ? (S = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(S.name, S.loc.start, !0, !0)) : S = this.parseModuleExportName());
      P && f && this.raise(h ? se.TypeModifierIsUsedInTypeImports : se.TypeModifierIsUsedInTypeExports, M), o[O] = S, o[D] = A;
      let Z = h ? "importKind" : "exportKind";
      o[Z] = P ? "type" : "value", E && this.eatContextual(93) && (o[D] = h ? this.parseIdentifier() : this.parseModuleExportName()), o[D] || (o[D] = this.cloneIdentifier(o[O])), h && this.checkIdentifier(o[D], P ? 4098 : 4096);
    }
    fillOptionalPropertiesForTSESLint(o) {
      switch (o.type) {
        case "ExpressionStatement":
          o.directive != null || (o.directive = void 0);
          return;
        case "RestElement":
          o.value = void 0;
        case "Identifier":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "ObjectPattern":
          o.decorators != null || (o.decorators = []), o.optional != null || (o.optional = !1), o.typeAnnotation != null || (o.typeAnnotation = void 0);
          return;
        case "TSParameterProperty":
          o.accessibility != null || (o.accessibility = void 0), o.decorators != null || (o.decorators = []), o.override != null || (o.override = !1), o.readonly != null || (o.readonly = !1), o.static != null || (o.static = !1);
          return;
        case "TSEmptyBodyFunctionExpression":
          o.body = null;
        case "TSDeclareFunction":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
          o.declare != null || (o.declare = !1), o.returnType != null || (o.returnType = void 0), o.typeParameters != null || (o.typeParameters = void 0);
          return;
        case "Property":
          o.optional != null || (o.optional = !1);
          return;
        case "TSMethodSignature":
        case "TSPropertySignature":
          o.optional != null || (o.optional = !1);
        case "TSIndexSignature":
          o.accessibility != null || (o.accessibility = void 0), o.readonly != null || (o.readonly = !1), o.static != null || (o.static = !1);
          return;
        case "TSAbstractPropertyDefinition":
        case "PropertyDefinition":
        case "TSAbstractAccessorProperty":
        case "AccessorProperty":
          o.declare != null || (o.declare = !1), o.definite != null || (o.definite = !1), o.readonly != null || (o.readonly = !1), o.typeAnnotation != null || (o.typeAnnotation = void 0);
        case "TSAbstractMethodDefinition":
        case "MethodDefinition":
          o.accessibility != null || (o.accessibility = void 0), o.decorators != null || (o.decorators = []), o.override != null || (o.override = !1), o.optional != null || (o.optional = !1);
          return;
        case "ClassExpression":
          o.id != null || (o.id = null);
        case "ClassDeclaration":
          o.abstract != null || (o.abstract = !1), o.declare != null || (o.declare = !1), o.decorators != null || (o.decorators = []), o.implements != null || (o.implements = []), o.superTypeArguments != null || (o.superTypeArguments = void 0), o.typeParameters != null || (o.typeParameters = void 0);
          return;
        case "TSTypeAliasDeclaration":
        case "VariableDeclaration":
          o.declare != null || (o.declare = !1);
          return;
        case "VariableDeclarator":
          o.definite != null || (o.definite = !1);
          return;
        case "TSEnumDeclaration":
          o.const != null || (o.const = !1), o.declare != null || (o.declare = !1);
          return;
        case "TSEnumMember":
          o.computed != null || (o.computed = !1);
          return;
        case "TSImportType":
          o.qualifier != null || (o.qualifier = null), o.options != null || (o.options = null);
          return;
        case "TSInterfaceDeclaration":
          o.declare != null || (o.declare = !1), o.extends != null || (o.extends = []);
          return;
        case "TSModuleDeclaration":
          o.declare != null || (o.declare = !1), o.global != null || (o.global = o.kind === "global");
          return;
        case "TSTypeParameter":
          o.const != null || (o.const = !1), o.in != null || (o.in = !1), o.out != null || (o.out = !1);
          return;
      }
    }
  };
  function OT(u) {
    if (u.type !== "MemberExpression") return !1;
    let { computed: o, property: h } = u;
    return o && h.type !== "StringLiteral" && (h.type !== "TemplateLiteral" || h.expressions.length > 0) ? !1 : py(u.object);
  }
  function xT(u, o) {
    var h;
    let { type: f } = u;
    if ((h = u.extra) != null && h.parenthesized) return !1;
    if (o) {
      if (f === "Literal") {
        let { value: O } = u;
        if (typeof O == "string" || typeof O == "boolean") return !0;
      }
    } else if (f === "StringLiteral" || f === "BooleanLiteral") return !0;
    return !!(hy(u, o) || DT(u, o) || f === "TemplateLiteral" && u.expressions.length === 0 || OT(u));
  }
  function hy(u, o) {
    return o ? u.type === "Literal" && (typeof u.value == "number" || "bigint" in u) : u.type === "NumericLiteral" || u.type === "BigIntLiteral";
  }
  function DT(u, o) {
    if (u.type === "UnaryExpression") {
      let { operator: h, argument: f } = u;
      if (h === "-" && hy(f, o)) return !0;
    }
    return !1;
  }
  function py(u) {
    return u.type === "Identifier" ? !0 : u.type !== "MemberExpression" || u.computed ? !1 : py(u.object);
  }
  var dy = C`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." }), bT = (u) => class extends u {
    parsePlaceholder(o) {
      if (this.match(133)) {
        let h = this.startNode();
        return this.next(), this.assertNoSpace(), h.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(h, o);
      }
    }
    finishPlaceholder(o, h) {
      let f = o;
      return (!f.expectedNode || !f.type) && (f = this.finishNode(f, "Placeholder")), f.expectedNode = h, f;
    }
    getTokenFromCode(o) {
      o === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(o);
    }
    parseExprAtom(o) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(o);
    }
    parseIdentifier(o) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(o);
    }
    checkReservedWord(o, h, f, O) {
      o !== void 0 && super.checkReservedWord(o, h, f, O);
    }
    cloneIdentifier(o) {
      let h = super.cloneIdentifier(o);
      return h.type === "Placeholder" && (h.expectedNode = o.expectedNode), h;
    }
    cloneStringLiteral(o) {
      return o.type === "Placeholder" ? this.cloneIdentifier(o) : super.cloneStringLiteral(o);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(o, h, f) {
      return o === "Placeholder" || super.isValidLVal(o, h, f);
    }
    toAssignable(o, h) {
      o && o.type === "Placeholder" && o.expectedNode === "Expression" ? o.expectedNode = "Pattern" : super.toAssignable(o, h);
    }
    chStartsBindingIdentifier(o, h) {
      if (super.chStartsBindingIdentifier(o, h)) return !0;
      let f = this.nextTokenStart();
      return this.input.charCodeAt(f) === 37 && this.input.charCodeAt(f + 1) === 37;
    }
    verifyBreakContinue(o, h) {
      o.label && o.label.type === "Placeholder" || super.verifyBreakContinue(o, h);
    }
    parseExpressionStatement(o, h) {
      var f;
      if (h.type !== "Placeholder" || (f = h.extra) != null && f.parenthesized) return super.parseExpressionStatement(o, h);
      if (this.match(14)) {
        let D = o;
        return D.label = this.finishPlaceholder(h, "Identifier"), this.next(), D.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(D, "LabeledStatement");
      }
      this.semicolon();
      let O = o;
      return O.name = h.name, this.finishPlaceholder(O, "Statement");
    }
    parseBlock(o, h, f) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(o, h, f);
    }
    parseFunctionId(o) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(o);
    }
    parseClass(o, h, f) {
      let O = h ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let D = this.state.strict, S = this.parsePlaceholder("Identifier");
      if (S) if (this.match(81) || this.match(133) || this.match(5)) o.id = S;
      else {
        if (f || !h) return o.id = null, o.body = this.finishPlaceholder(S, "ClassBody"), this.finishNode(o, O);
        throw this.raise(dy.ClassNameIsRequired, this.state.startLoc);
      }
      else this.parseClassId(o, h, f);
      return super.parseClassSuper(o), o.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!o.superClass, D), this.finishNode(o, O);
    }
    parseExport(o, h) {
      let f = this.parsePlaceholder("Identifier");
      if (!f) return super.parseExport(o, h);
      let O = o;
      if (!this.isContextual(98) && !this.match(12)) return O.specifiers = [], O.source = null, O.declaration = this.finishPlaceholder(f, "Declaration"), this.finishNode(O, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      let D = this.startNode();
      return D.exported = f, O.specifiers = [this.finishNode(D, "ExportDefaultSpecifier")], super.parseExport(O, h);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let o = this.nextTokenStart();
        if (this.isUnparsedContextual(o, "from") && this.input.startsWith(ti(133), this.nextTokenStartSince(o + 4))) return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(o, h) {
      var f;
      return (f = o.specifiers) != null && f.length ? !0 : super.maybeParseExportDefaultSpecifier(o, h);
    }
    checkExport(o) {
      let { specifiers: h } = o;
      h != null && h.length && (o.specifiers = h.filter((f) => f.exported.type === "Placeholder")), super.checkExport(o), o.specifiers = h;
    }
    parseImport(o) {
      let h = this.parsePlaceholder("Identifier");
      if (!h) return super.parseImport(o);
      if (o.specifiers = [], !this.isContextual(98) && !this.match(12)) return o.source = this.finishPlaceholder(h, "StringLiteral"), this.semicolon(), this.finishNode(o, "ImportDeclaration");
      let f = this.startNodeAtNode(h);
      return f.local = h, o.specifiers.push(this.finishNode(f, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(o) || this.parseNamedImportSpecifiers(o)), this.expectContextual(98), o.source = this.parseImportSource(), this.semicolon(), this.finishNode(o, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(dy.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, vT = (u) => class extends u {
    parseV8Intrinsic() {
      if (this.match(54)) {
        let o = this.state.startLoc, h = this.startNode();
        if (this.next(), xe(this.state.type)) {
          let f = this.parseIdentifierName(), O = this.createIdentifier(h, f);
          if (this.castNodeTo(O, "V8IntrinsicIdentifier"), this.match(10)) return O;
        }
        this.unexpected(o);
      }
    }
    parseExprAtom(o) {
      return this.parseV8Intrinsic() || super.parseExprAtom(o);
    }
  }, fy = ["minimal", "fsharp", "hack", "smart"], my = ["^^", "@@", "^", "%", "#"];
  function ST(u) {
    if (u.has("decorators")) {
      if (u.has("decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let f = u.get("decorators").decoratorsBeforeExport;
      if (f != null && typeof f != "boolean") throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let O = u.get("decorators").allowCallParenthesized;
      if (O != null && typeof O != "boolean") throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (u.has("flow") && u.has("typescript")) throw new Error("Cannot combine flow and typescript plugins.");
    if (u.has("placeholders") && u.has("v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (u.has("pipelineOperator")) {
      var o;
      let f = u.get("pipelineOperator").proposal;
      if (!fy.includes(f)) {
        let O = fy.map((D) => `"${D}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${O}.`);
      }
      if (f === "hack") {
        if (u.has("placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (u.has("v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let O = u.get("pipelineOperator").topicToken;
        if (!my.includes(O)) {
          let D = my.map((S) => `"${S}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${D}.`);
        }
        {
          var h;
          if (O === "#" && ((h = u.get("recordAndTuple")) == null ? void 0 : h.syntaxType) === "hash") throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", u.get("recordAndTuple")])}\`.`);
        }
      } else if (f === "smart" && ((o = u.get("recordAndTuple")) == null ? void 0 : o.syntaxType) === "hash") throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", u.get("recordAndTuple")])}\`.`);
    }
    if (u.has("moduleAttributes")) {
      if (u.has("deprecatedImportAssert") || u.has("importAssertions")) throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
      if (u.get("moduleAttributes").version !== "may-2020") throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (u.has("importAssertions") && u.has("deprecatedImportAssert")) throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
    if (!u.has("deprecatedImportAssert") && u.has("importAttributes") && u.get("importAttributes").deprecatedAssertSyntax && u.set("deprecatedImportAssert", {}), u.has("recordAndTuple")) {
      let f = u.get("recordAndTuple").syntaxType;
      if (f != null) {
        let O = ["hash", "bar"];
        if (!O.includes(f)) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + O.map((D) => `'${D}'`).join(", "));
      }
    }
    if (u.has("asyncDoExpressions") && !u.has("doExpressions")) {
      let f = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw f.missingPlugins = "doExpressions", f;
    }
    if (u.has("optionalChainingAssign") && u.get("optionalChainingAssign").version !== "2023-07") throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
  }
  var gy = { estree: _, jsx: zE, flow: XE, typescript: yT, v8intrinsic: vT, placeholders: bT }, wT = Object.keys(gy), AT = class extends dT {
    checkProto(u, o, h, f) {
      if (u.type === "SpreadElement" || this.isObjectMethod(u) || u.computed || u.shorthand) return h;
      let O = u.key;
      return (O.type === "Identifier" ? O.name : O.value) === "__proto__" ? o ? (this.raise(b.RecordNoProto, O), !0) : (h && (f ? f.doubleProtoLoc === null && (f.doubleProtoLoc = O.loc.start) : this.raise(b.DuplicateProto, O)), !0) : h;
    }
    shouldExitDescending(u, o) {
      return u.type === "ArrowFunctionExpression" && this.offsetToSourcePos(u.start) === o;
    }
    getExpression() {
      if (this.enterInitialScopes(), this.nextToken(), this.match(140)) throw this.raise(b.ParseExpressionEmptyInput, this.state.startLoc);
      let u = this.parseExpression();
      if (!this.match(140)) throw this.raise(b.ParseExpressionExpectsEOF, this.state.startLoc, { unexpected: this.input.codePointAt(this.state.start) });
      return this.finalizeRemainingComments(), u.comments = this.comments, u.errors = this.state.errors, this.optionFlags & 256 && (u.tokens = this.tokens), u;
    }
    parseExpression(u, o) {
      return u ? this.disallowInAnd(() => this.parseExpressionBase(o)) : this.allowInAnd(() => this.parseExpressionBase(o));
    }
    parseExpressionBase(u) {
      let o = this.state.startLoc, h = this.parseMaybeAssign(u);
      if (this.match(12)) {
        let f = this.startNodeAt(o);
        for (f.expressions = [h]; this.eat(12); ) f.expressions.push(this.parseMaybeAssign(u));
        return this.toReferencedList(f.expressions), this.finishNode(f, "SequenceExpression");
      }
      return h;
    }
    parseMaybeAssignDisallowIn(u, o) {
      return this.disallowInAnd(() => this.parseMaybeAssign(u, o));
    }
    parseMaybeAssignAllowIn(u, o) {
      return this.allowInAnd(() => this.parseMaybeAssign(u, o));
    }
    setOptionalParametersError(u) {
      u.optionalParametersLoc = this.state.startLoc;
    }
    parseMaybeAssign(u, o) {
      let h = this.state.startLoc, f = this.isContextual(108);
      if (f && this.prodParam.hasYield) {
        this.next();
        let A = this.parseYield(h);
        return o && (A = o.call(this, A, h)), A;
      }
      let O;
      u ? O = !1 : (u = new Rl(), O = !0);
      let { type: D } = this.state;
      (D === 10 || xe(D)) && (this.state.potentialArrowAt = this.state.start);
      let S = this.parseMaybeConditional(u);
      if (o && (S = o.call(this, S, h)), OE(this.state.type)) {
        let A = this.startNodeAt(h), P = this.state.value;
        if (A.operator = P, this.match(29)) {
          this.toAssignable(S, !0), A.left = S;
          let E = h.index;
          u.doubleProtoLoc != null && u.doubleProtoLoc.index >= E && (u.doubleProtoLoc = null), u.shorthandAssignLoc != null && u.shorthandAssignLoc.index >= E && (u.shorthandAssignLoc = null), u.privateKeyLoc != null && u.privateKeyLoc.index >= E && (this.checkDestructuringPrivate(u), u.privateKeyLoc = null);
        } else A.left = S;
        return this.next(), A.right = this.parseMaybeAssign(), this.checkLVal(S, this.finishNode(A, "AssignmentExpression")), A;
      } else O && this.checkExpressionErrors(u, !0);
      if (f) {
        let { type: A } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? qa(A) : qa(A) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier()) return this.raiseOverwrite(b.YieldNotInGeneratorFunction, h), this.parseYield(h);
      }
      return S;
    }
    parseMaybeConditional(u) {
      let o = this.state.startLoc, h = this.state.potentialArrowAt, f = this.parseExprOps(u);
      return this.shouldExitDescending(f, h) ? f : this.parseConditional(f, o, u);
    }
    parseConditional(u, o, h) {
      if (this.eat(17)) {
        let f = this.startNodeAt(o);
        return f.test = u, f.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), f.alternate = this.parseMaybeAssign(), this.finishNode(f, "ConditionalExpression");
      }
      return u;
    }
    parseMaybeUnaryOrPrivate(u) {
      return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(u);
    }
    parseExprOps(u) {
      let o = this.state.startLoc, h = this.state.potentialArrowAt, f = this.parseMaybeUnaryOrPrivate(u);
      return this.shouldExitDescending(f, h) ? f : this.parseExprOp(f, o, -1);
    }
    parseExprOp(u, o, h) {
      if (this.isPrivateName(u)) {
        let O = this.getPrivateNameSV(u);
        (h >= Bl(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(b.PrivateInExpectedIn, u, { identifierName: O }), this.classScope.usePrivateName(O, u.loc.start);
      }
      let f = this.state.type;
      if (DE(f) && (this.prodParam.hasIn || !this.match(58))) {
        let O = Bl(f);
        if (O > h) {
          if (f === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return u;
            this.checkPipelineAtInfixOperator(u, o);
          }
          let D = this.startNodeAt(o);
          D.left = u, D.operator = this.state.value;
          let S = f === 41 || f === 42, A = f === 40;
          if (A && (O = Bl(42)), this.next(), f === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait) throw this.raise(b.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          D.right = this.parseExprOpRightExpr(f, O);
          let P = this.finishNode(D, S || A ? "LogicalExpression" : "BinaryExpression"), E = this.state.type;
          if (A && (E === 41 || E === 42) || S && E === 40) throw this.raise(b.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(P, o, h);
        }
      }
      return u;
    }
    parseExprOpRightExpr(u, o) {
      let h = this.state.startLoc;
      switch (u) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(o));
          }
          if (this.getPluginOption("pipelineOperator", "proposal") === "smart") return this.withTopicBindingContext(() => {
            if (this.prodParam.hasYield && this.isContextual(108)) throw this.raise(b.PipeBodyIsTighter, this.state.startLoc);
            return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(u, o), h);
          });
        default:
          return this.parseExprOpBaseRightExpr(u, o);
      }
    }
    parseExprOpBaseRightExpr(u, o) {
      let h = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), h, AE(u) ? o - 1 : o);
    }
    parseHackPipeBody() {
      var u;
      let { startLoc: o } = this.state, h = this.parseMaybeAssign();
      return y.has(h.type) && !((u = h.extra) != null && u.parenthesized) && this.raise(b.PipeUnparenthesizedBody, o, { type: h.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(b.PipeTopicUnused, o), h;
    }
    checkExponentialAfterUnary(u) {
      this.match(57) && this.raise(b.UnexpectedTokenUnaryExponentiation, u.argument);
    }
    parseMaybeUnary(u, o) {
      let h = this.state.startLoc, f = this.isContextual(96);
      if (f && this.recordAwaitIfAllowed()) {
        this.next();
        let A = this.parseAwait(h);
        return o || this.checkExponentialAfterUnary(A), A;
      }
      let O = this.match(34), D = this.startNode();
      if (vE(this.state.type)) {
        D.operator = this.state.value, D.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let A = this.match(89);
        if (this.next(), D.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(u, !0), this.state.strict && A) {
          let P = D.argument;
          P.type === "Identifier" ? this.raise(b.StrictDelete, D) : this.hasPropertyAsPrivateName(P) && this.raise(b.DeletePrivateField, D);
        }
        if (!O) return o || this.checkExponentialAfterUnary(D), this.finishNode(D, "UnaryExpression");
      }
      let S = this.parseUpdate(D, O, u);
      if (f) {
        let { type: A } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? qa(A) : qa(A) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier()) return this.raiseOverwrite(b.AwaitNotInAsyncContext, h), this.parseAwait(h);
      }
      return S;
    }
    parseUpdate(u, o, h) {
      if (o) {
        let D = u;
        return this.checkLVal(D.argument, this.finishNode(D, "UpdateExpression")), u;
      }
      let f = this.state.startLoc, O = this.parseExprSubscripts(h);
      if (this.checkExpressionErrors(h, !1)) return O;
      for (; bE(this.state.type) && !this.canInsertSemicolon(); ) {
        let D = this.startNodeAt(f);
        D.operator = this.state.value, D.prefix = !1, D.argument = O, this.next(), this.checkLVal(O, O = this.finishNode(D, "UpdateExpression"));
      }
      return O;
    }
    parseExprSubscripts(u) {
      let o = this.state.startLoc, h = this.state.potentialArrowAt, f = this.parseExprAtom(u);
      return this.shouldExitDescending(f, h) ? f : this.parseSubscripts(f, o);
    }
    parseSubscripts(u, o, h) {
      let f = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(u), stop: !1 };
      do
        u = this.parseSubscript(u, o, h, f), f.maybeAsyncArrow = !1;
      while (!f.stop);
      return u;
    }
    parseSubscript(u, o, h, f) {
      let { type: O } = this.state;
      if (!h && O === 15) return this.parseBind(u, o, h, f);
      if (Il(O)) return this.parseTaggedTemplateExpression(u, o, f);
      let D = !1;
      if (O === 18) {
        if (h && (this.raise(b.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40)) return this.stopParseSubscript(u, f);
        f.optionalChainMember = D = !0, this.next();
      }
      if (!h && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(u, o, f, D);
      {
        let S = this.eat(0);
        return S || D || this.eat(16) ? this.parseMember(u, o, f, S, D) : this.stopParseSubscript(u, f);
      }
    }
    stopParseSubscript(u, o) {
      return o.stop = !0, u;
    }
    parseMember(u, o, h, f, O) {
      let D = this.startNodeAt(o);
      return D.object = u, D.computed = f, f ? (D.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (u.type === "Super" && this.raise(b.SuperPrivateField, o), this.classScope.usePrivateName(this.state.value, this.state.startLoc), D.property = this.parsePrivateName()) : D.property = this.parseIdentifier(!0), h.optionalChainMember ? (D.optional = O, this.finishNode(D, "OptionalMemberExpression")) : this.finishNode(D, "MemberExpression");
    }
    parseBind(u, o, h, f) {
      let O = this.startNodeAt(o);
      return O.object = u, this.next(), O.callee = this.parseNoCallExpr(), f.stop = !0, this.parseSubscripts(this.finishNode(O, "BindExpression"), o, h);
    }
    parseCoverCallAndAsyncArrowHead(u, o, h, f) {
      let O = this.state.maybeInArrowParameters, D = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let S = this.startNodeAt(o);
      S.callee = u;
      let { maybeAsyncArrow: A, optionalChainMember: P } = h;
      A && (this.expressionScope.enter(cT()), D = new Rl()), P && (S.optional = f), f ? S.arguments = this.parseCallExpressionArguments(11) : S.arguments = this.parseCallExpressionArguments(11, u.type !== "Super", S, D);
      let E = this.finishCallExpression(S, P);
      return A && this.shouldParseAsyncArrow() && !f ? (h.stop = !0, this.checkDestructuringPrivate(D), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), E = this.parseAsyncArrowFromCallExpression(this.startNodeAt(o), E)) : (A && (this.checkExpressionErrors(D, !0), this.expressionScope.exit()), this.toReferencedArguments(E)), this.state.maybeInArrowParameters = O, E;
    }
    toReferencedArguments(u, o) {
      this.toReferencedListDeep(u.arguments, o);
    }
    parseTaggedTemplateExpression(u, o, h) {
      let f = this.startNodeAt(o);
      return f.tag = u, f.quasi = this.parseTemplate(!0), h.optionalChainMember && this.raise(b.OptionalChainingNoTemplate, o), this.finishNode(f, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(u) {
      return u.type === "Identifier" && u.name === "async" && this.state.lastTokEndLoc.index === u.end && !this.canInsertSemicolon() && u.end - u.start === 5 && this.offsetToSourcePos(u.start) === this.state.potentialArrowAt;
    }
    finishCallExpression(u, o) {
      if (u.callee.type === "Import") if (u.arguments.length === 0 || u.arguments.length > 2) this.raise(b.ImportCallArity, u);
      else for (let h of u.arguments) h.type === "SpreadElement" && this.raise(b.ImportCallSpreadArgument, h);
      return this.finishNode(u, o ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(u, o, h, f) {
      let O = [], D = !0, S = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(u); ) {
        if (D) D = !1;
        else if (this.expect(12), this.match(u)) {
          h && this.addTrailingCommaExtraToNode(h), this.next();
          break;
        }
        O.push(this.parseExprListItem(!1, f, o));
      }
      return this.state.inFSharpPipelineDirectBody = S, O;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(u, o) {
      var h;
      return this.resetPreviousNodeTrailingComments(o), this.expect(19), this.parseArrowExpression(u, o.arguments, !0, (h = o.extra) == null ? void 0 : h.trailingCommaLoc), o.innerComments && ja(u, o.innerComments), o.callee.trailingComments && ja(u, o.callee.trailingComments), u;
    }
    parseNoCallExpr() {
      let u = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), u, !0);
    }
    parseExprAtom(u) {
      let o, h = null, { type: f } = this.state;
      switch (f) {
        case 79:
          return this.parseSuper();
        case 83:
          return o = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaPropertyOrPhaseCall(o) : this.match(10) ? this.optionFlags & 512 ? this.parseImportCall(o) : this.finishNode(o, "Import") : (this.raise(b.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(o, "Import"));
        case 78:
          return o = this.startNode(), this.next(), this.finishNode(o, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 135:
          return this.parseNumericLiteral(this.state.value);
        case 136:
          return this.parseBigIntLiteral(this.state.value);
        case 134:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let O = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(O);
        }
        case 0:
          return this.parseArrayLike(3, !0, !1, u);
        case 5:
          return this.parseObjectLike(8, !1, !1, u);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          h = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(h, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          o = this.startNode(), this.next(), o.object = null;
          let O = o.callee = this.parseNoCallExpr();
          if (O.type === "MemberExpression") return this.finishNode(o, "BindExpression");
          throw this.raise(b.UnsupportedBind, O);
        }
        case 139:
          return this.raise(b.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let O = this.getPluginOption("pipelineOperator", "proposal");
          if (O) return this.parseTopicReference(O);
          this.unexpected();
          break;
        }
        case 47: {
          let O = this.input.codePointAt(this.nextTokenStart());
          bs(O) || O === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          {
            if (f === 137) return this.parseDecimalLiteral(this.state.value);
            if (f === 2 || f === 1) return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
            if (f === 6 || f === 7) return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
          }
          if (xe(f)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) return this.parseModuleExpression();
            let O = this.state.potentialArrowAt === this.state.start, D = this.state.containsEsc, S = this.parseIdentifier();
            if (!D && S.name === "async" && !this.canInsertSemicolon()) {
              let { type: A } = this.state;
              if (A === 68) return this.resetPreviousNodeTrailingComments(S), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(S));
              if (xe(A)) return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(S)) : S;
              if (A === 90) return this.resetPreviousNodeTrailingComments(S), this.parseDo(this.startNodeAtNode(S), !0);
            }
            return O && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(S), [S], !1)) : S;
          } else this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(u, o) {
      let h = this.getPluginOption("pipelineOperator", "proposal");
      if (h) return this.state.type = u, this.state.value = o, this.state.pos--, this.state.end--, this.state.endLoc = i(this.state.endLoc, -1), this.parseTopicReference(h);
      this.unexpected();
    }
    parseTopicReference(u) {
      let o = this.startNode(), h = this.state.startLoc, f = this.state.type;
      return this.next(), this.finishTopicReference(o, h, u, f);
    }
    finishTopicReference(u, o, h, f) {
      if (this.testTopicReferenceConfiguration(h, o, f)) return h === "hack" ? (this.topicReferenceIsAllowedInCurrentContext() || this.raise(b.PipeTopicUnbound, o), this.registerTopicReference(), this.finishNode(u, "TopicReference")) : (this.topicReferenceIsAllowedInCurrentContext() || this.raise(b.PrimaryTopicNotAllowed, o), this.registerTopicReference(), this.finishNode(u, "PipelinePrimaryTopicReference"));
      throw this.raise(b.PipeTopicUnconfiguredToken, o, { token: ti(f) });
    }
    testTopicReferenceConfiguration(u, o, h) {
      switch (u) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", { topicToken: ti(h) }]);
        case "smart":
          return h === 27;
        default:
          throw this.raise(b.PipeTopicRequiresHackPipes, o);
      }
    }
    parseAsyncArrowUnaryFunction(u) {
      this.prodParam.enter(Ml(!0, this.prodParam.hasYield));
      let o = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(b.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(u, o, !0);
    }
    parseDo(u, o) {
      this.expectPlugin("doExpressions"), o && this.expectPlugin("asyncDoExpressions"), u.async = o, this.next();
      let h = this.state.labels;
      return this.state.labels = [], o ? (this.prodParam.enter(2), u.body = this.parseBlock(), this.prodParam.exit()) : u.body = this.parseBlock(), this.state.labels = h, this.finishNode(u, "DoExpression");
    }
    parseSuper() {
      let u = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16) ? this.raise(b.SuperNotAllowed, u) : !this.scope.allowSuper && !(this.optionFlags & 16) && this.raise(b.UnexpectedSuper, u), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(b.UnsupportedSuper, u), this.finishNode(u, "Super");
    }
    parsePrivateName() {
      let u = this.startNode(), o = this.startNodeAt(i(this.state.startLoc, 1)), h = this.state.value;
      return this.next(), u.id = this.createIdentifier(o, h), this.finishNode(u, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let u = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let o = this.createIdentifier(this.startNodeAtNode(u), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(u, o, "sent");
      }
      return this.parseFunction(u);
    }
    parseMetaProperty(u, o, h) {
      u.meta = o;
      let f = this.state.containsEsc;
      return u.property = this.parseIdentifier(!0), (u.property.name !== h || f) && this.raise(b.UnsupportedMetaProperty, u.property, { target: o.name, onlyValidPropertyName: h }), this.finishNode(u, "MetaProperty");
    }
    parseImportMetaPropertyOrPhaseCall(u) {
      if (this.next(), this.isContextual(105) || this.isContextual(97)) {
        let o = this.isContextual(105);
        return this.expectPlugin(o ? "sourcePhaseImports" : "deferredImportEvaluation"), this.next(), u.phase = o ? "source" : "defer", this.parseImportCall(u);
      } else {
        let o = this.createIdentifierAt(this.startNodeAtNode(u), "import", this.state.lastTokStartLoc);
        return this.isContextual(101) && (this.inModule || this.raise(b.ImportMetaOutsideModule, o), this.sawUnambiguousESM = !0), this.parseMetaProperty(u, o, "meta");
      }
    }
    parseLiteralAtNode(u, o, h) {
      return this.addExtra(h, "rawValue", u), this.addExtra(h, "raw", this.input.slice(this.offsetToSourcePos(h.start), this.state.end)), h.value = u, this.next(), this.finishNode(h, o);
    }
    parseLiteral(u, o) {
      let h = this.startNode();
      return this.parseLiteralAtNode(u, o, h);
    }
    parseStringLiteral(u) {
      return this.parseLiteral(u, "StringLiteral");
    }
    parseNumericLiteral(u) {
      return this.parseLiteral(u, "NumericLiteral");
    }
    parseBigIntLiteral(u) {
      return this.parseLiteral(u, "BigIntLiteral");
    }
    parseDecimalLiteral(u) {
      return this.parseLiteral(u, "DecimalLiteral");
    }
    parseRegExpLiteral(u) {
      let o = this.startNode();
      return this.addExtra(o, "raw", this.input.slice(this.offsetToSourcePos(o.start), this.state.end)), o.pattern = u.pattern, o.flags = u.flags, this.next(), this.finishNode(o, "RegExpLiteral");
    }
    parseBooleanLiteral(u) {
      let o = this.startNode();
      return o.value = u, this.next(), this.finishNode(o, "BooleanLiteral");
    }
    parseNullLiteral() {
      let u = this.startNode();
      return this.next(), this.finishNode(u, "NullLiteral");
    }
    parseParenAndDistinguishExpression(u) {
      let o = this.state.startLoc, h;
      this.next(), this.expressionScope.enter(uT());
      let f = this.state.maybeInArrowParameters, O = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let D = this.state.startLoc, S = [], A = new Rl(), P = !0, E, M;
      for (; !this.match(11); ) {
        if (P) P = !1;
        else if (this.expect(12, A.optionalParametersLoc === null ? null : A.optionalParametersLoc), this.match(11)) {
          M = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let ie = this.state.startLoc;
          if (E = this.state.startLoc, S.push(this.parseParenItem(this.parseRestBinding(), ie)), !this.checkCommaAfterRest(41)) break;
        } else S.push(this.parseMaybeAssignAllowIn(A, this.parseParenItem));
      }
      let Z = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = f, this.state.inFSharpPipelineDirectBody = O;
      let H = this.startNodeAt(o);
      return u && this.shouldParseArrow(S) && (H = this.parseArrow(H)) ? (this.checkDestructuringPrivate(A), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(H, S, !1), H) : (this.expressionScope.exit(), S.length || this.unexpected(this.state.lastTokStartLoc), M && this.unexpected(M), E && this.unexpected(E), this.checkExpressionErrors(A, !0), this.toReferencedListDeep(S, !0), S.length > 1 ? (h = this.startNodeAt(D), h.expressions = S, this.finishNode(h, "SequenceExpression"), this.resetEndLocation(h, Z)) : h = S[0], this.wrapParenthesis(o, h));
    }
    wrapParenthesis(u, o) {
      if (!(this.optionFlags & 1024)) return this.addExtra(o, "parenthesized", !0), this.addExtra(o, "parenStart", u.index), this.takeSurroundingComments(o, u.index, this.state.lastTokEndLoc.index), o;
      let h = this.startNodeAt(u);
      return h.expression = o, this.finishNode(h, "ParenthesizedExpression");
    }
    shouldParseArrow(u) {
      return !this.canInsertSemicolon();
    }
    parseArrow(u) {
      if (this.eat(19)) return u;
    }
    parseParenItem(u, o) {
      return u;
    }
    parseNewOrNewTarget() {
      let u = this.startNode();
      if (this.next(), this.match(16)) {
        let o = this.createIdentifier(this.startNodeAtNode(u), "new");
        this.next();
        let h = this.parseMetaProperty(u, o, "target");
        return this.scope.allowNewTarget || this.raise(b.UnexpectedNewTarget, h), h;
      }
      return this.parseNew(u);
    }
    parseNew(u) {
      if (this.parseNewCallee(u), this.eat(10)) {
        let o = this.parseExprList(11);
        this.toReferencedList(o), u.arguments = o;
      } else u.arguments = [];
      return this.finishNode(u, "NewExpression");
    }
    parseNewCallee(u) {
      let o = this.match(83), h = this.parseNoCallExpr();
      u.callee = h, o && (h.type === "Import" || h.type === "ImportExpression") && this.raise(b.ImportCallNotNewExpression, h);
    }
    parseTemplateElement(u) {
      let { start: o, startLoc: h, end: f, value: O } = this.state, D = o + 1, S = this.startNodeAt(i(h, 1));
      O === null && (u || this.raise(b.InvalidEscapeSequenceTemplate, i(this.state.firstInvalidTemplateEscapePos, 1)));
      let A = this.match(24), P = A ? -1 : -2, E = f + P;
      S.value = { raw: this.input.slice(D, E).replace(/\r\n?/g, `
`), cooked: O === null ? null : O.slice(1, P) }, S.tail = A, this.next();
      let M = this.finishNode(S, "TemplateElement");
      return this.resetEndLocation(M, i(this.state.lastTokEndLoc, P)), M;
    }
    parseTemplate(u) {
      let o = this.startNode(), h = this.parseTemplateElement(u), f = [h], O = [];
      for (; !h.tail; ) O.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), f.push(h = this.parseTemplateElement(u));
      return o.expressions = O, o.quasis = f, this.finishNode(o, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(u, o, h, f) {
      h && this.expectPlugin("recordAndTuple");
      let O = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let D = !1, S = !0, A = this.startNode();
      for (A.properties = [], this.next(); !this.match(u); ) {
        if (S) S = !1;
        else if (this.expect(12), this.match(u)) {
          this.addTrailingCommaExtraToNode(A);
          break;
        }
        let E;
        o ? E = this.parseBindingProperty() : (E = this.parsePropertyDefinition(f), D = this.checkProto(E, h, D, f)), h && !this.isObjectProperty(E) && E.type !== "SpreadElement" && this.raise(b.InvalidRecordProperty, E), E.shorthand && this.addExtra(E, "shorthand", !0), A.properties.push(E);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = O;
      let P = "ObjectExpression";
      return o ? P = "ObjectPattern" : h && (P = "RecordExpression"), this.finishNode(A, P);
    }
    addTrailingCommaExtraToNode(u) {
      this.addExtra(u, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(u, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(u) {
      return !u.computed && u.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(u) {
      let o = [];
      if (this.match(26)) for (this.hasPlugin("decorators") && this.raise(b.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); ) o.push(this.parseDecorator());
      let h = this.startNode(), f = !1, O = !1, D;
      if (this.match(21)) return o.length && this.unexpected(), this.parseSpread();
      o.length && (h.decorators = o, o = []), h.method = !1, u && (D = this.state.startLoc);
      let S = this.eat(55);
      this.parsePropertyNamePrefixOperator(h);
      let A = this.state.containsEsc;
      if (this.parsePropertyName(h, u), !S && !A && this.maybeAsyncOrAccessorProp(h)) {
        let { key: P } = h, E = P.name;
        E === "async" && !this.hasPrecedingLineBreak() && (f = !0, this.resetPreviousNodeTrailingComments(P), S = this.eat(55), this.parsePropertyName(h)), (E === "get" || E === "set") && (O = !0, this.resetPreviousNodeTrailingComments(P), h.kind = E, this.match(55) && (S = !0, this.raise(b.AccessorIsGenerator, this.state.curPosition(), { kind: E }), this.next()), this.parsePropertyName(h));
      }
      return this.parseObjPropValue(h, D, S, f, !1, O, u);
    }
    getGetterSetterExpectedParamCount(u) {
      return u.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(u) {
      return u.params;
    }
    checkGetterSetterParams(u) {
      var o;
      let h = this.getGetterSetterExpectedParamCount(u), f = this.getObjectOrClassMethodParams(u);
      f.length !== h && this.raise(u.kind === "get" ? b.BadGetterArity : b.BadSetterArity, u), u.kind === "set" && ((o = f[f.length - 1]) == null ? void 0 : o.type) === "RestElement" && this.raise(b.BadSetterRestParameter, u);
    }
    parseObjectMethod(u, o, h, f, O) {
      if (O) {
        let D = this.parseMethod(u, o, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(D), D;
      }
      if (h || o || this.match(10)) return f && this.unexpected(), u.kind = "method", u.method = !0, this.parseMethod(u, o, h, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(u, o, h, f) {
      if (u.shorthand = !1, this.eat(14)) return u.value = h ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(f), this.finishObjectProperty(u);
      if (!u.computed && u.key.type === "Identifier") {
        if (this.checkReservedWord(u.key.name, u.key.loc.start, !0, !1), h) u.value = this.parseMaybeDefault(o, this.cloneIdentifier(u.key));
        else if (this.match(29)) {
          let O = this.state.startLoc;
          f != null ? f.shorthandAssignLoc === null && (f.shorthandAssignLoc = O) : this.raise(b.InvalidCoverInitializedName, O), u.value = this.parseMaybeDefault(o, this.cloneIdentifier(u.key));
        } else u.value = this.cloneIdentifier(u.key);
        return u.shorthand = !0, this.finishObjectProperty(u);
      }
    }
    finishObjectProperty(u) {
      return this.finishNode(u, "ObjectProperty");
    }
    parseObjPropValue(u, o, h, f, O, D, S) {
      let A = this.parseObjectMethod(u, h, f, O, D) || this.parseObjectProperty(u, o, O, S);
      return A || this.unexpected(), A;
    }
    parsePropertyName(u, o) {
      if (this.eat(0)) u.computed = !0, u.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let { type: h, value: f } = this.state, O;
        if (Fr(h)) O = this.parseIdentifier(!0);
        else switch (h) {
          case 135:
            O = this.parseNumericLiteral(f);
            break;
          case 134:
            O = this.parseStringLiteral(f);
            break;
          case 136:
            O = this.parseBigIntLiteral(f);
            break;
          case 139: {
            let D = this.state.startLoc;
            o != null ? o.privateKeyLoc === null && (o.privateKeyLoc = D) : this.raise(b.UnexpectedPrivateField, D), O = this.parsePrivateName();
            break;
          }
          default:
            if (h === 137) {
              O = this.parseDecimalLiteral(f);
              break;
            }
            this.unexpected();
        }
        u.key = O, h !== 139 && (u.computed = !1);
      }
    }
    initFunction(u, o) {
      u.id = null, u.generator = !1, u.async = o;
    }
    parseMethod(u, o, h, f, O, D, S = !1) {
      this.initFunction(u, h), u.generator = o, this.scope.enter(530 | (S ? 576 : 0) | (O ? 32 : 0)), this.prodParam.enter(Ml(h, u.generator)), this.parseFunctionParams(u, f);
      let A = this.parseFunctionBodyAndFinish(u, D, !0);
      return this.prodParam.exit(), this.scope.exit(), A;
    }
    parseArrayLike(u, o, h, f) {
      h && this.expectPlugin("recordAndTuple");
      let O = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let D = this.startNode();
      return this.next(), D.elements = this.parseExprList(u, !h, f, D), this.state.inFSharpPipelineDirectBody = O, this.finishNode(D, h ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(u, o, h, f) {
      this.scope.enter(518);
      let O = Ml(h, !1);
      !this.match(5) && this.prodParam.hasIn && (O |= 8), this.prodParam.enter(O), this.initFunction(u, h);
      let D = this.state.maybeInArrowParameters;
      return o && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(u, o, f)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(u, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = D, this.finishNode(u, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(u, o, h) {
      this.toAssignableList(o, h, !1), u.params = o;
    }
    parseFunctionBodyAndFinish(u, o, h = !1) {
      return this.parseFunctionBody(u, !1, h), this.finishNode(u, o);
    }
    parseFunctionBody(u, o, h = !1) {
      let f = o && !this.match(5);
      if (this.expressionScope.enter(oy()), f) u.body = this.parseMaybeAssign(), this.checkParams(u, !1, o, !1);
      else {
        let O = this.state.strict, D = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), u.body = this.parseBlock(!0, !1, (S) => {
          let A = !this.isSimpleParamList(u.params);
          S && A && this.raise(b.IllegalLanguageModeDirective, (u.kind === "method" || u.kind === "constructor") && u.key ? u.key.loc.end : u);
          let P = !O && this.state.strict;
          this.checkParams(u, !this.state.strict && !o && !h && !A, o, P), this.state.strict && u.id && this.checkIdentifier(u.id, 65, P);
        }), this.prodParam.exit(), this.state.labels = D;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(u) {
      return u.type === "Identifier";
    }
    isSimpleParamList(u) {
      for (let o = 0, h = u.length; o < h; o++) if (!this.isSimpleParameter(u[o])) return !1;
      return !0;
    }
    checkParams(u, o, h, f = !0) {
      let O = !o && /* @__PURE__ */ new Set(), D = { type: "FormalParameters" };
      for (let S of u.params) this.checkLVal(S, D, 5, O, f);
    }
    parseExprList(u, o, h, f) {
      let O = [], D = !0;
      for (; !this.eat(u); ) {
        if (D) D = !1;
        else if (this.expect(12), this.match(u)) {
          f && this.addTrailingCommaExtraToNode(f), this.next();
          break;
        }
        O.push(this.parseExprListItem(o, h));
      }
      return O;
    }
    parseExprListItem(u, o, h) {
      let f;
      if (this.match(12)) u || this.raise(b.UnexpectedToken, this.state.curPosition(), { unexpected: "," }), f = null;
      else if (this.match(21)) {
        let O = this.state.startLoc;
        f = this.parseParenItem(this.parseSpread(o), O);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), h || this.raise(b.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let O = this.startNode();
        this.next(), f = this.finishNode(O, "ArgumentPlaceholder");
      } else f = this.parseMaybeAssignAllowIn(o, this.parseParenItem);
      return f;
    }
    parseIdentifier(u) {
      let o = this.startNode(), h = this.parseIdentifierName(u);
      return this.createIdentifier(o, h);
    }
    createIdentifier(u, o) {
      return u.name = o, u.loc.identifierName = o, this.finishNode(u, "Identifier");
    }
    createIdentifierAt(u, o, h) {
      return u.name = o, u.loc.identifierName = o, this.finishNodeAt(u, "Identifier", h);
    }
    parseIdentifierName(u) {
      let o, { startLoc: h, type: f } = this.state;
      Fr(f) ? o = this.state.value : this.unexpected();
      let O = tr(f);
      return u ? O && this.replaceToken(132) : this.checkReservedWord(o, h, O, !1), this.next(), o;
    }
    checkReservedWord(u, o, h, f) {
      if (!(u.length > 10 || !IE(u))) {
        if (h && $E(u)) {
          this.raise(b.UnexpectedKeyword, o, { keyword: u });
          return;
        }
        if ((this.state.strict ? f ? Jg : Gg : Wg)(u, this.inModule)) {
          this.raise(b.UnexpectedReservedWord, o, { reservedWord: u });
          return;
        } else if (u === "yield") {
          if (this.prodParam.hasYield) {
            this.raise(b.YieldBindingIdentifier, o);
            return;
          }
        } else if (u === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(b.AwaitBindingIdentifier, o);
            return;
          }
          if (this.scope.inStaticBlock) {
            this.raise(b.AwaitBindingIdentifierInStaticBlock, o);
            return;
          }
          this.expressionScope.recordAsyncArrowParametersError(o);
        } else if (u === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
          this.raise(b.ArgumentsInClass, o);
          return;
        }
      }
    }
    recordAwaitIfAllowed() {
      let u = this.prodParam.hasAwait;
      return u && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), u;
    }
    parseAwait(u) {
      let o = this.startNodeAt(u);
      return this.expressionScope.recordParameterInitializerError(b.AwaitExpressionFormalParameter, o), this.eat(55) && this.raise(b.ObsoleteAwaitStar, o), !this.scope.inFunction && !(this.optionFlags & 1) && (this.isAmbiguousPrefixOrIdentifier() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (o.argument = this.parseMaybeUnary(null, !0)), this.finishNode(o, "AwaitExpression");
    }
    isAmbiguousPrefixOrIdentifier() {
      if (this.hasPrecedingLineBreak()) return !0;
      let { type: u } = this.state;
      return u === 53 || u === 10 || u === 0 || Il(u) || u === 102 && !this.state.containsEsc || u === 138 || u === 56 || this.hasPlugin("v8intrinsic") && u === 54;
    }
    parseYield(u) {
      let o = this.startNodeAt(u);
      this.expressionScope.recordParameterInitializerError(b.YieldInParameter, o);
      let h = !1, f = null;
      if (!this.hasPrecedingLineBreak()) switch (h = this.eat(55), this.state.type) {
        case 13:
        case 140:
        case 8:
        case 11:
        case 3:
        case 9:
        case 14:
        case 12:
          if (!h) break;
        default:
          f = this.parseMaybeAssign();
      }
      return o.delegate = h, o.argument = f, this.finishNode(o, "YieldExpression");
    }
    parseImportCall(u) {
      if (this.next(), u.source = this.parseMaybeAssignAllowIn(), u.options = null, this.eat(12)) {
        if (this.match(11)) this.addTrailingCommaExtraToNode(u.source);
        else if (u.options = this.parseMaybeAssignAllowIn(), this.eat(12) && (this.addTrailingCommaExtraToNode(u.options), !this.match(11))) {
          do
            this.parseMaybeAssignAllowIn();
          while (this.eat(12) && !this.match(11));
          this.raise(b.ImportCallArity, u);
        }
      }
      return this.expect(11), this.finishNode(u, "ImportExpression");
    }
    checkPipelineAtInfixOperator(u, o) {
      this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && u.type === "SequenceExpression" && this.raise(b.PipelineHeadSequenceExpression, o);
    }
    parseSmartPipelineBodyInStyle(u, o) {
      if (this.isSimpleReference(u)) {
        let h = this.startNodeAt(o);
        return h.callee = u, this.finishNode(h, "PipelineBareFunction");
      } else {
        let h = this.startNodeAt(o);
        return this.checkSmartPipeTopicBodyEarlyErrors(o), h.expression = u, this.finishNode(h, "PipelineTopicExpression");
      }
    }
    isSimpleReference(u) {
      switch (u.type) {
        case "MemberExpression":
          return !u.computed && this.isSimpleReference(u.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(u) {
      if (this.match(19)) throw this.raise(b.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(b.PipelineTopicUnused, u);
    }
    withTopicBindingContext(u) {
      let o = this.state.topicContext;
      this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
      try {
        return u();
      } finally {
        this.state.topicContext = o;
      }
    }
    withSmartMixTopicForbiddingContext(u) {
      if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
        let o = this.state.topicContext;
        this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
        try {
          return u();
        } finally {
          this.state.topicContext = o;
        }
      } else return u();
    }
    withSoloAwaitPermittingContext(u) {
      let o = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return u();
      } finally {
        this.state.soloAwait = o;
      }
    }
    allowInAnd(u) {
      let o = this.prodParam.currentFlags();
      if (8 & ~o) {
        this.prodParam.enter(o | 8);
        try {
          return u();
        } finally {
          this.prodParam.exit();
        }
      }
      return u();
    }
    disallowInAnd(u) {
      let o = this.prodParam.currentFlags();
      if (8 & o) {
        this.prodParam.enter(o & -9);
        try {
          return u();
        } finally {
          this.prodParam.exit();
        }
      }
      return u();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(u) {
      let o = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let h = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let f = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), o, u);
      return this.state.inFSharpPipelineDirectBody = h, f;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let u = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let o = this.startNodeAt(this.state.endLoc);
      this.next();
      let h = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        u.body = this.parseProgram(o, 8, "module");
      } finally {
        h();
      }
      return this.finishNode(u, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(u) {
    }
  }, Rh = { kind: 1 }, CT = { kind: 2 }, ET = /[\uD800-\uDFFF]/u, qh = /in(?:stanceof)?/y;
  function TT(u, o, h) {
    for (let f = 0; f < u.length; f++) {
      let O = u[f], { type: D } = O;
      if (typeof D == "number") {
        {
          if (D === 139) {
            let { loc: S, start: A, value: P, end: E } = O, M = A + 1, Z = i(S.start, 1);
            u.splice(f, 1, new ii({ type: Ds(27), value: "#", start: A, end: M, startLoc: S.start, endLoc: Z }), new ii({ type: Ds(132), value: P, start: M, end: E, startLoc: Z, endLoc: S.end })), f++;
            continue;
          }
          if (Il(D)) {
            let { loc: S, start: A, value: P, end: E } = O, M = A + 1, Z = i(S.start, 1), H;
            o.charCodeAt(A - h) === 96 ? H = new ii({ type: Ds(22), value: "`", start: A, end: M, startLoc: S.start, endLoc: Z }) : H = new ii({ type: Ds(8), value: "}", start: A, end: M, startLoc: S.start, endLoc: Z });
            let ie, ye, Ye, Te;
            D === 24 ? (ye = E - 1, Ye = i(S.end, -1), ie = P === null ? null : P.slice(1, -1), Te = new ii({ type: Ds(22), value: "`", start: ye, end: E, startLoc: Ye, endLoc: S.end })) : (ye = E - 2, Ye = i(S.end, -2), ie = P === null ? null : P.slice(1, -2), Te = new ii({ type: Ds(23), value: "${", start: ye, end: E, startLoc: Ye, endLoc: S.end })), u.splice(f, 1, H, new ii({ type: Ds(20), value: ie, start: M, end: ye, startLoc: Z, endLoc: Ye }), Te), f += 2;
            continue;
          }
        }
        O.type = Ds(D);
      }
    }
    return u;
  }
  var kT = class extends AT {
    parseTopLevel(u, o) {
      return u.program = this.parseProgram(o), u.comments = this.comments, this.optionFlags & 256 && (u.tokens = TT(this.tokens, this.input, this.startIndex)), this.finishNode(u, "File");
    }
    parseProgram(u, o = 140, h = this.options.sourceType) {
      if (u.sourceType = h, u.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(u, !0, !0, o), this.inModule) {
        if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0) for (let [O, D] of Array.from(this.scope.undefinedExports)) this.raise(b.ModuleExportUndefined, D, { localName: O });
        this.addExtra(u, "topLevelAwait", this.state.hasTopLevelAwait);
      }
      let f;
      return o === 140 ? f = this.finishNode(u, "Program") : f = this.finishNodeAt(u, "Program", i(this.state.startLoc, -1)), f;
    }
    stmtToDirective(u) {
      let o = this.castNodeTo(u, "Directive"), h = this.castNodeTo(u.expression, "DirectiveLiteral"), f = h.value, O = this.input.slice(this.offsetToSourcePos(h.start), this.offsetToSourcePos(h.end)), D = h.value = O.slice(1, -1);
      return this.addExtra(h, "raw", O), this.addExtra(h, "rawValue", D), this.addExtra(h, "expressionValue", f), o.value = h, delete u.expression, o;
    }
    parseInterpreterDirective() {
      if (!this.match(28)) return null;
      let u = this.startNode();
      return u.value = this.state.value, this.next(), this.finishNode(u, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    isUsing() {
      if (!this.isContextual(107)) return !1;
      let u = this.nextTokenInLineStart(), o = this.codePointAtPos(u);
      return this.chStartsBindingIdentifier(o, u);
    }
    isForUsing() {
      if (!this.isContextual(107)) return !1;
      let u = this.nextTokenInLineStart(), o = this.codePointAtPos(u);
      if (this.isUnparsedContextual(u, "of")) {
        let h = this.lookaheadCharCodeSince(u + 2);
        if (h !== 61 && h !== 58 && h !== 59) return !1;
      }
      return this.chStartsBindingIdentifier(o, u) ? (this.expectPlugin("explicitResourceManagement"), !0) : !1;
    }
    isAwaitUsing() {
      if (!this.isContextual(96)) return !1;
      let u = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(u, "using")) {
        u = this.nextTokenInLineStartSince(u + 5);
        let o = this.codePointAtPos(u);
        if (this.chStartsBindingIdentifier(o, u)) return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    chStartsBindingIdentifier(u, o) {
      if (bs(u)) {
        if (qh.lastIndex = o, qh.test(this.input)) {
          let h = this.codePointAtPos(qh.lastIndex);
          if (!kn(h) && h !== 92) return !1;
        }
        return !0;
      } else return u === 92;
    }
    chStartsBindingPattern(u) {
      return u === 91 || u === 123;
    }
    hasFollowingBindingAtom() {
      let u = this.nextTokenStart(), o = this.codePointAtPos(u);
      return this.chStartsBindingPattern(o) || this.chStartsBindingIdentifier(o, u);
    }
    hasInLineFollowingBindingIdentifierOrBrace() {
      let u = this.nextTokenInLineStart(), o = this.codePointAtPos(u);
      return o === 123 || this.chStartsBindingIdentifier(o, u);
    }
    allowsUsing() {
      return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(u = !1) {
      let o = 0;
      return this.options.annexB && !this.state.strict && (o |= 4, u && (o |= 8)), this.parseStatementLike(o);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(u) {
      let o = null;
      return this.match(26) && (o = this.parseDecorators(!0)), this.parseStatementContent(u, o);
    }
    parseStatementContent(u, o) {
      let h = this.state.type, f = this.startNode(), O = !!(u & 2), D = !!(u & 4), S = u & 1;
      switch (h) {
        case 60:
          return this.parseBreakContinueStatement(f, !0);
        case 63:
          return this.parseBreakContinueStatement(f, !1);
        case 64:
          return this.parseDebuggerStatement(f);
        case 90:
          return this.parseDoWhileStatement(f);
        case 91:
          return this.parseForStatement(f);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return D || this.raise(this.state.strict ? b.StrictFunction : this.options.annexB ? b.SloppyFunctionAnnexB : b.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(f, !1, !O && D);
        case 80:
          return O || this.unexpected(), this.parseClass(this.maybeTakeDecorators(o, f), !0);
        case 69:
          return this.parseIfStatement(f);
        case 70:
          return this.parseReturnStatement(f);
        case 71:
          return this.parseSwitchStatement(f);
        case 72:
          return this.parseThrowStatement(f);
        case 73:
          return this.parseTryStatement(f);
        case 96:
          if (this.isAwaitUsing()) return this.allowsUsing() ? O ? this.recordAwaitIfAllowed() || this.raise(b.AwaitUsingNotInAsyncContext, f) : this.raise(b.UnexpectedLexicalDeclaration, f) : this.raise(b.UnexpectedUsingDeclaration, f), this.next(), this.parseVarStatement(f, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) break;
          return this.expectPlugin("explicitResourceManagement"), this.allowsUsing() ? O || this.raise(b.UnexpectedLexicalDeclaration, this.state.startLoc) : this.raise(b.UnexpectedUsingDeclaration, this.state.startLoc), this.parseVarStatement(f, "using");
        case 100: {
          if (this.state.containsEsc) break;
          let E = this.nextTokenStart(), M = this.codePointAtPos(E);
          if (M !== 91 && (!O && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(M, E) && M !== 123)) break;
        }
        case 75:
          O || this.raise(b.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let E = this.state.value;
          return this.parseVarStatement(f, E);
        }
        case 92:
          return this.parseWhileStatement(f);
        case 76:
          return this.parseWithStatement(f);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(f);
        case 83: {
          let E = this.lookaheadCharCode();
          if (E === 40 || E === 46) break;
        }
        case 82: {
          !(this.optionFlags & 8) && !S && this.raise(b.UnexpectedImportExport, this.state.startLoc), this.next();
          let E;
          return h === 83 ? E = this.parseImport(f) : E = this.parseExport(f, o), this.assertModuleNodeAllowed(E), E;
        }
        default:
          if (this.isAsyncFunction()) return O || this.raise(b.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(f, !0, !O && D);
      }
      let A = this.state.value, P = this.parseExpression();
      return xe(h) && P.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(f, A, P, u) : this.parseExpressionStatement(f, P, o);
    }
    assertModuleNodeAllowed(u) {
      !(this.optionFlags & 8) && !this.inModule && this.raise(b.ImportOutsideModule, u);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
    }
    maybeTakeDecorators(u, o, h) {
      if (u) {
        var f;
        (f = o.decorators) != null && f.length ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(b.DecoratorsBeforeAfterExport, o.decorators[0]), o.decorators.unshift(...u)) : o.decorators = u, this.resetStartLocationFromNode(o, u[0]), h && this.resetStartLocationFromNode(h, o);
      }
      return o;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(u) {
      let o = [];
      do
        o.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82)) u || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(b.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator()) throw this.raise(b.UnexpectedLeadingDecorator, this.state.startLoc);
      return o;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let u = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let o = this.state.startLoc, h;
        if (this.match(10)) {
          let f = this.state.startLoc;
          this.next(), h = this.parseExpression(), this.expect(11), h = this.wrapParenthesis(f, h);
          let O = this.state.startLoc;
          u.expression = this.parseMaybeDecoratorArguments(h, f), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && u.expression !== h && this.raise(b.DecoratorArgumentsOutsideParentheses, O);
        } else {
          for (h = this.parseIdentifier(!1); this.eat(16); ) {
            let f = this.startNodeAt(o);
            f.object = h, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), f.property = this.parsePrivateName()) : f.property = this.parseIdentifier(!0), f.computed = !1, h = this.finishNode(f, "MemberExpression");
          }
          u.expression = this.parseMaybeDecoratorArguments(h, o);
        }
      } else u.expression = this.parseExprSubscripts();
      return this.finishNode(u, "Decorator");
    }
    parseMaybeDecoratorArguments(u, o) {
      if (this.eat(10)) {
        let h = this.startNodeAt(o);
        return h.callee = u, h.arguments = this.parseCallExpressionArguments(11), this.toReferencedList(h.arguments), this.finishNode(h, "CallExpression");
      }
      return u;
    }
    parseBreakContinueStatement(u, o) {
      return this.next(), this.isLineTerminator() ? u.label = null : (u.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(u, o), this.finishNode(u, o ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(u, o) {
      let h;
      for (h = 0; h < this.state.labels.length; ++h) {
        let f = this.state.labels[h];
        if ((u.label == null || f.name === u.label.name) && (f.kind != null && (o || f.kind === 1) || u.label && o)) break;
      }
      if (h === this.state.labels.length) {
        let f = o ? "BreakStatement" : "ContinueStatement";
        this.raise(b.IllegalBreakContinue, u, { type: f });
      }
    }
    parseDebuggerStatement(u) {
      return this.next(), this.semicolon(), this.finishNode(u, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let u = this.parseExpression();
      return this.expect(11), u;
    }
    parseDoWhileStatement(u) {
      return this.next(), this.state.labels.push(Rh), u.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), u.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(u, "DoWhileStatement");
    }
    parseForStatement(u) {
      this.next(), this.state.labels.push(Rh);
      let o = null;
      if (this.isContextual(96) && this.recordAwaitIfAllowed() && (o = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10), this.match(13)) return o !== null && this.unexpected(o), this.parseFor(u, null);
      let h = this.isContextual(100);
      {
        let A = this.isAwaitUsing(), P = A || this.isForUsing(), E = h && this.hasFollowingBindingAtom() || P;
        if (this.match(74) || this.match(75) || E) {
          let M = this.startNode(), Z;
          A ? (Z = "await using", this.recordAwaitIfAllowed() || this.raise(b.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : Z = this.state.value, this.next(), this.parseVar(M, !0, Z);
          let H = this.finishNode(M, "VariableDeclaration"), ie = this.match(58);
          return ie && P && this.raise(b.ForInUsing, H), (ie || this.isContextual(102)) && H.declarations.length === 1 ? this.parseForIn(u, H, o) : (o !== null && this.unexpected(o), this.parseFor(u, H));
        }
      }
      let f = this.isContextual(95), O = new Rl(), D = this.parseExpression(!0, O), S = this.isContextual(102);
      if (S && (h && this.raise(b.ForOfLet, D), o === null && f && D.type === "Identifier" && this.raise(b.ForOfAsync, D)), S || this.match(58)) {
        this.checkDestructuringPrivate(O), this.toAssignable(D, !0);
        let A = S ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(D, { type: A }), this.parseForIn(u, D, o);
      } else this.checkExpressionErrors(O, !0);
      return o !== null && this.unexpected(o), this.parseFor(u, D);
    }
    parseFunctionStatement(u, o, h) {
      return this.next(), this.parseFunction(u, 1 | (h ? 2 : 0) | (o ? 8 : 0));
    }
    parseIfStatement(u) {
      return this.next(), u.test = this.parseHeaderExpression(), u.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), u.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(u, "IfStatement");
    }
    parseReturnStatement(u) {
      return this.prodParam.hasReturn || this.raise(b.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? u.argument = null : (u.argument = this.parseExpression(), this.semicolon()), this.finishNode(u, "ReturnStatement");
    }
    parseSwitchStatement(u) {
      this.next(), u.discriminant = this.parseHeaderExpression();
      let o = u.cases = [];
      this.expect(5), this.state.labels.push(CT), this.scope.enter(256);
      let h;
      for (let f; !this.match(8); ) if (this.match(61) || this.match(65)) {
        let O = this.match(61);
        h && this.finishNode(h, "SwitchCase"), o.push(h = this.startNode()), h.consequent = [], this.next(), O ? h.test = this.parseExpression() : (f && this.raise(b.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), f = !0, h.test = null), this.expect(14);
      } else h ? h.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), h && this.finishNode(h, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(u, "SwitchStatement");
    }
    parseThrowStatement(u) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(b.NewlineAfterThrow, this.state.lastTokEndLoc), u.argument = this.parseExpression(), this.semicolon(), this.finishNode(u, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let u = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && u.type === "Identifier" ? 8 : 0), this.checkLVal(u, { type: "CatchClause" }, 9), u;
    }
    parseTryStatement(u) {
      if (this.next(), u.block = this.parseBlock(), u.handler = null, this.match(62)) {
        let o = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), o.param = this.parseCatchClauseParam(), this.expect(11)) : (o.param = null, this.scope.enter(0)), o.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), u.handler = this.finishNode(o, "CatchClause");
      }
      return u.finalizer = this.eat(67) ? this.parseBlock() : null, !u.handler && !u.finalizer && this.raise(b.NoCatchOrFinally, u), this.finishNode(u, "TryStatement");
    }
    parseVarStatement(u, o, h = !1) {
      return this.next(), this.parseVar(u, !1, o, h), this.semicolon(), this.finishNode(u, "VariableDeclaration");
    }
    parseWhileStatement(u) {
      return this.next(), u.test = this.parseHeaderExpression(), this.state.labels.push(Rh), u.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(u, "WhileStatement");
    }
    parseWithStatement(u) {
      return this.state.strict && this.raise(b.StrictWith, this.state.startLoc), this.next(), u.object = this.parseHeaderExpression(), u.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(u, "WithStatement");
    }
    parseEmptyStatement(u) {
      return this.next(), this.finishNode(u, "EmptyStatement");
    }
    parseLabeledStatement(u, o, h, f) {
      for (let D of this.state.labels) D.name === o && this.raise(b.LabelRedeclaration, h, { labelName: o });
      let O = xE(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let D = this.state.labels.length - 1; D >= 0; D--) {
        let S = this.state.labels[D];
        if (S.statementStart === u.start) S.statementStart = this.sourceToOffsetPos(this.state.start), S.kind = O;
        else break;
      }
      return this.state.labels.push({ name: o, kind: O, statementStart: this.sourceToOffsetPos(this.state.start) }), u.body = f & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), u.label = h, this.finishNode(u, "LabeledStatement");
    }
    parseExpressionStatement(u, o, h) {
      return u.expression = o, this.semicolon(), this.finishNode(u, "ExpressionStatement");
    }
    parseBlock(u = !1, o = !0, h) {
      let f = this.startNode();
      return u && this.state.strictErrors.clear(), this.expect(5), o && this.scope.enter(0), this.parseBlockBody(f, u, !1, 8, h), o && this.scope.exit(), this.finishNode(f, "BlockStatement");
    }
    isValidDirective(u) {
      return u.type === "ExpressionStatement" && u.expression.type === "StringLiteral" && !u.expression.extra.parenthesized;
    }
    parseBlockBody(u, o, h, f, O) {
      let D = u.body = [], S = u.directives = [];
      this.parseBlockOrModuleBlockBody(D, o ? S : void 0, h, f, O);
    }
    parseBlockOrModuleBlockBody(u, o, h, f, O) {
      let D = this.state.strict, S = !1, A = !1;
      for (; !this.match(f); ) {
        let P = h ? this.parseModuleItem() : this.parseStatementListItem();
        if (o && !A) {
          if (this.isValidDirective(P)) {
            let E = this.stmtToDirective(P);
            o.push(E), !S && E.value.value === "use strict" && (S = !0, this.setStrict(!0));
            continue;
          }
          A = !0, this.state.strictErrors.clear();
        }
        u.push(P);
      }
      O == null || O.call(this, S), D || this.setStrict(!1), this.next();
    }
    parseFor(u, o) {
      return u.init = o, this.semicolon(!1), u.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), u.update = this.match(11) ? null : this.parseExpression(), this.expect(11), u.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(u, "ForStatement");
    }
    parseForIn(u, o, h) {
      let f = this.match(58);
      return this.next(), f ? h !== null && this.unexpected(h) : u.await = h !== null, o.type === "VariableDeclaration" && o.declarations[0].init != null && (!f || !this.options.annexB || this.state.strict || o.kind !== "var" || o.declarations[0].id.type !== "Identifier") && this.raise(b.ForInOfLoopInitializer, o, { type: f ? "ForInStatement" : "ForOfStatement" }), o.type === "AssignmentPattern" && this.raise(b.InvalidLhs, o, { ancestor: { type: "ForStatement" } }), u.left = o, u.right = f ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), u.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(u, f ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(u, o, h, f = !1) {
      let O = u.declarations = [];
      for (u.kind = h; ; ) {
        let D = this.startNode();
        if (this.parseVarId(D, h), D.init = this.eat(29) ? o ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, D.init === null && !f && (D.id.type !== "Identifier" && !(o && (this.match(58) || this.isContextual(102))) ? this.raise(b.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" }) : (h === "const" || h === "using" || h === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(b.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: h })), O.push(this.finishNode(D, "VariableDeclarator")), !this.eat(12)) break;
      }
      return u;
    }
    parseVarId(u, o) {
      let h = this.parseBindingAtom();
      (o === "using" || o === "await using") && (h.type === "ArrayPattern" || h.type === "ObjectPattern") && this.raise(b.UsingDeclarationHasBindingPattern, h.loc.start), this.checkLVal(h, { type: "VariableDeclarator" }, o === "var" ? 5 : 8201), u.id = h;
    }
    parseAsyncFunctionExpression(u) {
      return this.parseFunction(u, 8);
    }
    parseFunction(u, o = 0) {
      let h = o & 2, f = !!(o & 1), O = f && !(o & 4), D = !!(o & 8);
      this.initFunction(u, D), this.match(55) && (h && this.raise(b.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), u.generator = !0), f && (u.id = this.parseFunctionId(O));
      let S = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(514), this.prodParam.enter(Ml(D, u.generator)), f || (u.id = this.parseFunctionId()), this.parseFunctionParams(u, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(u, f ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), f && !h && this.registerFunctionStatementId(u), this.state.maybeInArrowParameters = S, u;
    }
    parseFunctionId(u) {
      return u || xe(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(u, o) {
      this.expect(10), this.expressionScope.enter(lT()), u.params = this.parseBindingList(11, 41, 2 | (o ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(u) {
      u.id && this.scope.declareName(u.id.name, !this.options.annexB || this.state.strict || u.generator || u.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, u.id.loc.start);
    }
    parseClass(u, o, h) {
      this.next();
      let f = this.state.strict;
      return this.state.strict = !0, this.parseClassId(u, o, h), this.parseClassSuper(u), u.body = this.parseClassBody(!!u.superClass, f), this.finishNode(u, o ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(u) {
      return u.type === "Identifier" && u.name === "constructor" || u.type === "StringLiteral" && u.value === "constructor";
    }
    isNonstaticConstructor(u) {
      return !u.computed && !u.static && this.nameIsConstructor(u.key);
    }
    parseClassBody(u, o) {
      this.classScope.enter();
      let h = { hadConstructor: !1, hadSuperClass: u }, f = [], O = this.startNode();
      if (O.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (f.length > 0) throw this.raise(b.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            f.push(this.parseDecorator());
            continue;
          }
          let D = this.startNode();
          f.length && (D.decorators = f, this.resetStartLocationFromNode(D, f[0]), f = []), this.parseClassMember(O, D, h), D.kind === "constructor" && D.decorators && D.decorators.length > 0 && this.raise(b.DecoratorConstructor, D);
        }
      }), this.state.strict = o, this.next(), f.length) throw this.raise(b.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(O, "ClassBody");
    }
    parseClassMemberFromModifier(u, o) {
      let h = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let f = o;
        return f.kind = "method", f.computed = !1, f.key = h, f.static = !1, this.pushClassMethod(u, f, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let f = o;
        return f.computed = !1, f.key = h, f.static = !1, u.body.push(this.parseClassProperty(f)), !0;
      }
      return this.resetPreviousNodeTrailingComments(h), !1;
    }
    parseClassMember(u, o, h) {
      let f = this.isContextual(106);
      if (f) {
        if (this.parseClassMemberFromModifier(u, o)) return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(u, o);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(u, o, h, f);
    }
    parseClassMemberWithIsStatic(u, o, h, f) {
      let O = o, D = o, S = o, A = o, P = o, E = O, M = O;
      if (o.static = f, this.parsePropertyNamePrefixOperator(o), this.eat(55)) {
        E.kind = "method";
        let Te = this.match(139);
        if (this.parseClassElementName(E), this.parsePostMemberNameModifiers(E), Te) {
          this.pushClassPrivateMethod(u, D, !0, !1);
          return;
        }
        this.isNonstaticConstructor(O) && this.raise(b.ConstructorIsGenerator, O.key), this.pushClassMethod(u, O, !0, !1, !1, !1);
        return;
      }
      let Z = !this.state.containsEsc && xe(this.state.type), H = this.parseClassElementName(o), ie = Z ? H.name : null, ye = this.isPrivateName(H), Ye = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(M), this.isClassMethod()) {
        if (E.kind = "method", ye) {
          this.pushClassPrivateMethod(u, D, !1, !1);
          return;
        }
        let Te = this.isNonstaticConstructor(O), We = !1;
        Te && (O.kind = "constructor", h.hadConstructor && !this.hasPlugin("typescript") && this.raise(b.DuplicateConstructor, H), Te && this.hasPlugin("typescript") && o.override && this.raise(b.OverrideOnConstructor, H), h.hadConstructor = !0, We = h.hadSuperClass), this.pushClassMethod(u, O, !1, !1, Te, We);
      } else if (this.isClassProperty()) ye ? this.pushClassPrivateProperty(u, A) : this.pushClassProperty(u, S);
      else if (ie === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(H);
        let Te = this.eat(55);
        M.optional && this.unexpected(Ye), E.kind = "method";
        let We = this.match(139);
        this.parseClassElementName(E), this.parsePostMemberNameModifiers(M), We ? this.pushClassPrivateMethod(u, D, Te, !0) : (this.isNonstaticConstructor(O) && this.raise(b.ConstructorIsAsync, O.key), this.pushClassMethod(u, O, Te, !0, !1, !1));
      } else if ((ie === "get" || ie === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(H), E.kind = ie;
        let Te = this.match(139);
        this.parseClassElementName(O), Te ? this.pushClassPrivateMethod(u, D, !1, !1) : (this.isNonstaticConstructor(O) && this.raise(b.ConstructorIsAccessor, O.key), this.pushClassMethod(u, O, !1, !1, !1, !1)), this.checkGetterSetterParams(O);
      } else if (ie === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(H);
        let Te = this.match(139);
        this.parseClassElementName(S), this.pushClassAccessorProperty(u, P, Te);
      } else this.isLineTerminator() ? ye ? this.pushClassPrivateProperty(u, A) : this.pushClassProperty(u, S) : this.unexpected();
    }
    parseClassElementName(u) {
      let { type: o, value: h } = this.state;
      if ((o === 132 || o === 134) && u.static && h === "prototype" && this.raise(b.StaticPrototype, this.state.startLoc), o === 139) {
        h === "constructor" && this.raise(b.ConstructorClassPrivateField, this.state.startLoc);
        let f = this.parsePrivateName();
        return u.key = f, f;
      }
      return this.parsePropertyName(u), u.key;
    }
    parseClassStaticBlock(u, o) {
      var h;
      this.scope.enter(720);
      let f = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let O = o.body = [];
      this.parseBlockOrModuleBlockBody(O, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = f, u.body.push(this.finishNode(o, "StaticBlock")), (h = o.decorators) != null && h.length && this.raise(b.DecoratorStaticBlock, o);
    }
    pushClassProperty(u, o) {
      !o.computed && this.nameIsConstructor(o.key) && this.raise(b.ConstructorClassField, o.key), u.body.push(this.parseClassProperty(o));
    }
    pushClassPrivateProperty(u, o) {
      let h = this.parseClassPrivateProperty(o);
      u.body.push(h), this.classScope.declarePrivateName(this.getPrivateNameSV(h.key), 0, h.key.loc.start);
    }
    pushClassAccessorProperty(u, o, h) {
      !h && !o.computed && this.nameIsConstructor(o.key) && this.raise(b.ConstructorClassField, o.key);
      let f = this.parseClassAccessorProperty(o);
      u.body.push(f), h && this.classScope.declarePrivateName(this.getPrivateNameSV(f.key), 0, f.key.loc.start);
    }
    pushClassMethod(u, o, h, f, O, D) {
      u.body.push(this.parseMethod(o, h, f, O, D, "ClassMethod", !0));
    }
    pushClassPrivateMethod(u, o, h, f) {
      let O = this.parseMethod(o, h, f, !1, !1, "ClassPrivateMethod", !0);
      u.body.push(O);
      let D = O.kind === "get" ? O.static ? 6 : 2 : O.kind === "set" ? O.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(O, D);
    }
    declareClassPrivateMethodInScope(u, o) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(u.key), o, u.key.loc.start);
    }
    parsePostMemberNameModifiers(u) {
    }
    parseClassPrivateProperty(u) {
      return this.parseInitializer(u), this.semicolon(), this.finishNode(u, "ClassPrivateProperty");
    }
    parseClassProperty(u) {
      return this.parseInitializer(u), this.semicolon(), this.finishNode(u, "ClassProperty");
    }
    parseClassAccessorProperty(u) {
      return this.parseInitializer(u), this.semicolon(), this.finishNode(u, "ClassAccessorProperty");
    }
    parseInitializer(u) {
      this.scope.enter(592), this.expressionScope.enter(oy()), this.prodParam.enter(0), u.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(u, o, h, f = 8331) {
      if (xe(this.state.type)) u.id = this.parseIdentifier(), o && this.declareNameFromIdentifier(u.id, f);
      else if (h || !o) u.id = null;
      else throw this.raise(b.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(u) {
      u.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(u, o) {
      let h = this.parseMaybeImportPhase(u, !0), f = this.maybeParseExportDefaultSpecifier(u, h), O = !f || this.eat(12), D = O && this.eatExportStar(u), S = D && this.maybeParseExportNamespaceSpecifier(u), A = O && (!S || this.eat(12)), P = f || D;
      if (D && !S) {
        if (f && this.unexpected(), o) throw this.raise(b.UnsupportedDecoratorExport, u);
        return this.parseExportFrom(u, !0), this.sawUnambiguousESM = !0, this.finishNode(u, "ExportAllDeclaration");
      }
      let E = this.maybeParseExportNamedSpecifiers(u);
      f && O && !D && !E && this.unexpected(null, 5), S && A && this.unexpected(null, 98);
      let M;
      if (P || E) {
        if (M = !1, o) throw this.raise(b.UnsupportedDecoratorExport, u);
        this.parseExportFrom(u, P);
      } else M = this.maybeParseExportDeclaration(u);
      if (P || E || M) {
        var Z;
        let H = u;
        if (this.checkExport(H, !0, !1, !!H.source), ((Z = H.declaration) == null ? void 0 : Z.type) === "ClassDeclaration") this.maybeTakeDecorators(o, H.declaration, H);
        else if (o) throw this.raise(b.UnsupportedDecoratorExport, u);
        return this.sawUnambiguousESM = !0, this.finishNode(H, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let H = u, ie = this.parseExportDefaultExpression();
        if (H.declaration = ie, ie.type === "ClassDeclaration") this.maybeTakeDecorators(o, ie, H);
        else if (o) throw this.raise(b.UnsupportedDecoratorExport, u);
        return this.checkExport(H, !0, !0), this.sawUnambiguousESM = !0, this.finishNode(H, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(u) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(u, o) {
      if (o || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", o == null ? void 0 : o.loc.start);
        let h = o || this.parseIdentifier(!0), f = this.startNodeAtNode(h);
        return f.exported = h, u.specifiers = [this.finishNode(f, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(u) {
      if (this.isContextual(93)) {
        var o;
        (o = u).specifiers != null || (o.specifiers = []);
        let h = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), h.exported = this.parseModuleExportName(), u.specifiers.push(this.finishNode(h, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(u) {
      if (this.match(5)) {
        let o = u;
        o.specifiers || (o.specifiers = []);
        let h = o.exportKind === "type";
        return o.specifiers.push(...this.parseExportSpecifiers(h)), o.source = null, this.hasPlugin("importAssertions") ? o.assertions = [] : o.attributes = [], o.declaration = null, !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(u) {
      return this.shouldParseExportDeclaration() ? (u.specifiers = [], u.source = null, this.hasPlugin("importAssertions") ? u.assertions = [] : u.attributes = [], u.declaration = this.parseExportDeclaration(u), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let u = this.nextTokenInLineStart();
      return this.isUnparsedContextual(u, "function");
    }
    parseExportDefaultExpression() {
      let u = this.startNode();
      if (this.match(68)) return this.next(), this.parseFunction(u, 5);
      if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(u, 13);
      if (this.match(80)) return this.parseClass(u, !0, !0);
      if (this.match(26)) return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(b.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet() || this.hasPlugin("explicitResourceManagement") && (this.isUsing() || this.isAwaitUsing())) throw this.raise(b.UnsupportedDefaultExport, this.state.startLoc);
      let o = this.parseMaybeAssignAllowIn();
      return this.semicolon(), o;
    }
    parseExportDeclaration(u) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let { type: u } = this.state;
      if (xe(u)) {
        if (u === 95 && !this.state.containsEsc || u === 100) return !1;
        if ((u === 130 || u === 129) && !this.state.containsEsc) {
          let f = this.nextTokenStart(), O = this.input.charCodeAt(f);
          if (O === 123 || this.chStartsBindingIdentifier(O, f) && !this.input.startsWith("from", f)) return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65)) return !1;
      let o = this.nextTokenStart(), h = this.isUnparsedContextual(o, "from");
      if (this.input.charCodeAt(o) === 44 || xe(this.state.type) && h) return !0;
      if (this.match(65) && h) {
        let f = this.input.charCodeAt(this.nextTokenStartSince(o + 4));
        return f === 34 || f === 39;
      }
      return !1;
    }
    parseExportFrom(u, o) {
      this.eatContextual(98) ? (u.source = this.parseImportSource(), this.checkExport(u), this.maybeParseImportAttributes(u), this.checkJSONModuleImport(u)) : o && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let { type: u } = this.state;
      if (u === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) return this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(b.DecoratorBeforeExport, this.state.startLoc), !0;
      if (this.hasPlugin("explicitResourceManagement")) {
        if (this.isUsing()) return this.raise(b.UsingDeclarationExport, this.state.startLoc), !0;
        if (this.isAwaitUsing()) return this.raise(b.UsingDeclarationExport, this.state.startLoc), !0;
      }
      return u === 74 || u === 75 || u === 68 || u === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(u, o, h, f) {
      if (o) {
        var O;
        if (h) {
          if (this.checkDuplicateExports(u, "default"), this.hasPlugin("exportDefaultFrom")) {
            var D;
            let S = u.declaration;
            S.type === "Identifier" && S.name === "from" && S.end - S.start === 4 && !((D = S.extra) != null && D.parenthesized) && this.raise(b.ExportDefaultFromAsIdentifier, S);
          }
        } else if ((O = u.specifiers) != null && O.length) for (let S of u.specifiers) {
          let { exported: A } = S, P = A.type === "Identifier" ? A.name : A.value;
          if (this.checkDuplicateExports(S, P), !f && S.local) {
            let { local: E } = S;
            E.type !== "Identifier" ? this.raise(b.ExportBindingIsString, S, { localName: E.value, exportName: P }) : (this.checkReservedWord(E.name, E.loc.start, !0, !1), this.scope.checkLocalExport(E));
          }
        }
        else if (u.declaration) {
          let S = u.declaration;
          if (S.type === "FunctionDeclaration" || S.type === "ClassDeclaration") {
            let { id: A } = S;
            if (!A) throw new Error("Assertion failure");
            this.checkDuplicateExports(u, A.name);
          } else if (S.type === "VariableDeclaration") for (let A of S.declarations) this.checkDeclaration(A.id);
        }
      }
    }
    checkDeclaration(u) {
      if (u.type === "Identifier") this.checkDuplicateExports(u, u.name);
      else if (u.type === "ObjectPattern") for (let o of u.properties) this.checkDeclaration(o);
      else if (u.type === "ArrayPattern") for (let o of u.elements) o && this.checkDeclaration(o);
      else u.type === "ObjectProperty" ? this.checkDeclaration(u.value) : u.type === "RestElement" ? this.checkDeclaration(u.argument) : u.type === "AssignmentPattern" && this.checkDeclaration(u.left);
    }
    checkDuplicateExports(u, o) {
      this.exportedIdentifiers.has(o) && (o === "default" ? this.raise(b.DuplicateDefaultExport, u) : this.raise(b.DuplicateExport, u, { exportName: o })), this.exportedIdentifiers.add(o);
    }
    parseExportSpecifiers(u) {
      let o = [], h = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (h) h = !1;
        else if (this.expect(12), this.eat(8)) break;
        let f = this.isContextual(130), O = this.match(134), D = this.startNode();
        D.local = this.parseModuleExportName(), o.push(this.parseExportSpecifier(D, O, u, f));
      }
      return o;
    }
    parseExportSpecifier(u, o, h, f) {
      return this.eatContextual(93) ? u.exported = this.parseModuleExportName() : o ? u.exported = this.cloneStringLiteral(u.local) : u.exported || (u.exported = this.cloneIdentifier(u.local)), this.finishNode(u, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(134)) {
        let u = this.parseStringLiteral(this.state.value), o = ET.exec(u.value);
        return o && this.raise(b.ModuleExportNameHasLoneSurrogate, u, { surrogateCharCode: o[0].charCodeAt(0) }), u;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(u) {
      return u.assertions != null ? u.assertions.some(({ key: o, value: h }) => h.value === "json" && (o.type === "Identifier" ? o.name === "type" : o.value === "type")) : !1;
    }
    checkImportReflection(u) {
      let { specifiers: o } = u, h = o.length === 1 ? o[0].type : null;
      if (u.phase === "source") h !== "ImportDefaultSpecifier" && this.raise(b.SourcePhaseImportRequiresDefault, o[0].loc.start);
      else if (u.phase === "defer") h !== "ImportNamespaceSpecifier" && this.raise(b.DeferImportRequiresNamespace, o[0].loc.start);
      else if (u.module) {
        var f;
        h !== "ImportDefaultSpecifier" && this.raise(b.ImportReflectionNotBinding, o[0].loc.start), ((f = u.assertions) == null ? void 0 : f.length) > 0 && this.raise(b.ImportReflectionHasAssertion, o[0].loc.start);
      }
    }
    checkJSONModuleImport(u) {
      if (this.isJSONModuleImport(u) && u.type !== "ExportAllDeclaration") {
        let { specifiers: o } = u;
        if (o != null) {
          let h = o.find((f) => {
            let O;
            if (f.type === "ExportSpecifier" ? O = f.local : f.type === "ImportSpecifier" && (O = f.imported), O !== void 0) return O.type === "Identifier" ? O.name !== "default" : O.value !== "default";
          });
          h !== void 0 && this.raise(b.ImportJSONBindingNotDefault, h.loc.start);
        }
      }
    }
    isPotentialImportPhase(u) {
      return u ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(u, o, h, f) {
      o || (h === "module" ? (this.expectPlugin("importReflection", f), u.module = !0) : this.hasPlugin("importReflection") && (u.module = !1), h === "source" ? (this.expectPlugin("sourcePhaseImports", f), u.phase = "source") : h === "defer" ? (this.expectPlugin("deferredImportEvaluation", f), u.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (u.phase = null));
    }
    parseMaybeImportPhase(u, o) {
      if (!this.isPotentialImportPhase(o)) return this.applyImportPhase(u, o, null), null;
      let h = this.startNode(), f = this.parseIdentifierName(!0), { type: O } = this.state;
      return (Fr(O) ? O !== 98 || this.lookaheadCharCode() === 102 : O !== 12) ? (this.applyImportPhase(u, o, f, h.loc.start), null) : (this.applyImportPhase(u, o, null), this.createIdentifier(h, f));
    }
    isPrecedingIdImportPhase(u) {
      let { type: o } = this.state;
      return xe(o) ? o !== 98 || this.lookaheadCharCode() === 102 : o !== 12;
    }
    parseImport(u) {
      return this.match(134) ? this.parseImportSourceAndAttributes(u) : this.parseImportSpecifiersAndAfter(u, this.parseMaybeImportPhase(u, !1));
    }
    parseImportSpecifiersAndAfter(u, o) {
      u.specifiers = [];
      let h = !this.maybeParseDefaultImportSpecifier(u, o) || this.eat(12), f = h && this.maybeParseStarImportSpecifier(u);
      return h && !f && this.parseNamedImportSpecifiers(u), this.expectContextual(98), this.parseImportSourceAndAttributes(u);
    }
    parseImportSourceAndAttributes(u) {
      return u.specifiers != null || (u.specifiers = []), u.source = this.parseImportSource(), this.maybeParseImportAttributes(u), this.checkImportReflection(u), this.checkJSONModuleImport(u), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(u, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(134) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(u, o, h) {
      o.local = this.parseIdentifier(), u.specifiers.push(this.finishImportSpecifier(o, h));
    }
    finishImportSpecifier(u, o, h = 8201) {
      return this.checkLVal(u.local, { type: o }, h), this.finishNode(u, o);
    }
    parseImportAttributes() {
      this.expect(5);
      let u = [], o = /* @__PURE__ */ new Set();
      do {
        if (this.match(8)) break;
        let h = this.startNode(), f = this.state.value;
        if (o.has(f) && this.raise(b.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: f }), o.add(f), this.match(134) ? h.key = this.parseStringLiteral(f) : h.key = this.parseIdentifier(!0), this.expect(14), !this.match(134)) throw this.raise(b.ModuleAttributeInvalidValue, this.state.startLoc);
        h.value = this.parseStringLiteral(this.state.value), u.push(this.finishNode(h, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), u;
    }
    parseModuleAttributes() {
      let u = [], o = /* @__PURE__ */ new Set();
      do {
        let h = this.startNode();
        if (h.key = this.parseIdentifier(!0), h.key.name !== "type" && this.raise(b.ModuleAttributeDifferentFromType, h.key), o.has(h.key.name) && this.raise(b.ModuleAttributesWithDuplicateKeys, h.key, { key: h.key.name }), o.add(h.key.name), this.expect(14), !this.match(134)) throw this.raise(b.ModuleAttributeInvalidValue, this.state.startLoc);
        h.value = this.parseStringLiteral(this.state.value), u.push(this.finishNode(h, "ImportAttribute"));
      } while (this.eat(12));
      return u;
    }
    maybeParseImportAttributes(u) {
      let o;
      var h = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) return;
        this.next(), this.hasPlugin("moduleAttributes") ? (o = this.parseModuleAttributes(), this.addExtra(u, "deprecatedWithLegacySyntax", !0)) : o = this.parseImportAttributes(), h = !0;
      } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions") && this.raise(b.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin("importAssertions") || this.addExtra(u, "deprecatedAssertSyntax", !0), this.next(), o = this.parseImportAttributes()) : o = [];
      !h && this.hasPlugin("importAssertions") ? u.assertions = o : u.attributes = o;
    }
    maybeParseDefaultImportSpecifier(u, o) {
      if (o) {
        let h = this.startNodeAtNode(o);
        return h.local = o, u.specifiers.push(this.finishImportSpecifier(h, "ImportDefaultSpecifier")), !0;
      } else if (Fr(this.state.type)) return this.parseImportSpecifierLocal(u, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(u) {
      if (this.match(55)) {
        let o = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(u, o, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(u) {
      let o = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (o) o = !1;
        else {
          if (this.eat(14)) throw this.raise(b.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let h = this.startNode(), f = this.match(134), O = this.isContextual(130);
        h.imported = this.parseModuleExportName();
        let D = this.parseImportSpecifier(h, f, u.importKind === "type" || u.importKind === "typeof", O, void 0);
        u.specifiers.push(D);
      }
    }
    parseImportSpecifier(u, o, h, f, O) {
      if (this.eatContextual(93)) u.local = this.parseIdentifier();
      else {
        let { imported: D } = u;
        if (o) throw this.raise(b.ImportBindingIsString, u, { importName: D.value });
        this.checkReservedWord(D.name, u.loc.start, !0, !0), u.local || (u.local = this.cloneIdentifier(D));
      }
      return this.finishImportSpecifier(u, "ImportSpecifier", O);
    }
    isThisParam(u) {
      return u.type === "Identifier" && u.name === "this";
    }
  }, yy = class extends kT {
    constructor(u, o, h) {
      u = Q(u), super(u, o), this.options = u, this.initializeScopes(), this.plugins = h, this.filename = u.sourceFilename, this.startIndex = u.startIndex;
      let f = 0;
      u.allowAwaitOutsideFunction && (f |= 1), u.allowReturnOutsideFunction && (f |= 2), u.allowImportExportEverywhere && (f |= 8), u.allowSuperOutsideMethod && (f |= 16), u.allowUndeclaredExports && (f |= 64), u.allowNewTargetOutsideFunction && (f |= 4), u.allowYieldOutsideFunction && (f |= 32), u.ranges && (f |= 128), u.tokens && (f |= 256), u.createImportExpressions && (f |= 512), u.createParenthesizedExpressions && (f |= 1024), u.errorRecovery && (f |= 2048), u.attachComment && (f |= 4096), u.annexB && (f |= 8192), this.optionFlags = f;
    }
    getScopeHandler() {
      return Ih;
    }
    parse() {
      this.enterInitialScopes();
      let u = this.startNode(), o = this.startNode();
      return this.nextToken(), u.errors = null, this.parseTopLevel(u, o), u.errors = this.state.errors, u.comments.length = this.state.commentsLen, u;
    }
  };
  function PT(u, o) {
    var h;
    if (((h = o) == null ? void 0 : h.sourceType) === "unambiguous") {
      o = Object.assign({}, o);
      try {
        o.sourceType = "module";
        let f = Za(o, u), O = f.parse();
        if (f.sawUnambiguousESM) return O;
        if (f.ambiguousScriptDifferentAst) try {
          return o.sourceType = "script", Za(o, u).parse();
        } catch {
        }
        else O.program.sourceType = "script";
        return O;
      } catch (f) {
        try {
          return o.sourceType = "script", Za(o, u).parse();
        } catch {
        }
        throw f;
      }
    } else return Za(o, u).parse();
  }
  function FT(u, o) {
    let h = Za(o, u);
    return h.options.strictMode && (h.state.strict = !0), h.getExpression();
  }
  function $T(u) {
    let o = {};
    for (let h of Object.keys(u)) o[h] = Ds(u[h]);
    return o;
  }
  var QT = $T(Ql);
  function Za(u, o) {
    let h = yy, f = /* @__PURE__ */ new Map();
    if (u != null && u.plugins) {
      for (let O of u.plugins) {
        let D, S;
        typeof O == "string" ? D = O : [D, S] = O, f.has(D) || f.set(D, S || {});
      }
      ST(f), h = BT(f);
    }
    return new h(u, o, f);
  }
  var Oy = /* @__PURE__ */ new Map();
  function BT(u) {
    let o = [];
    for (let O of wT) u.has(O) && o.push(O);
    let h = o.join("|"), f = Oy.get(h);
    if (!f) {
      f = yy;
      for (let O of o) f = gy[O](f);
      Oy.set(h, f);
    }
    return f;
  }
  t.parse = PT, t.parseExpression = FT, t.tokTypes = QT;
}), HD = {};
nm(HD, { parsers: () => tQ });
var JD = {};
nm(JD, { __babel_estree: () => Y3, __js_expression: () => yO, __ts_expression: () => OO, __vue_event_binding: () => mO, __vue_expression: () => yO, __vue_ts_event_binding: () => gO, __vue_ts_expression: () => OO, babel: () => mO, "babel-flow": () => u2, "babel-ts": () => gO });
var oO = YD(WD());
function KD(t) {
  return (e, r, s) => {
    let i = !!(s != null && s.backwards);
    if (r === !1) return !1;
    let { length: n } = e, a = r;
    for (; a >= 0 && a < n; ) {
      let l = e.charAt(a);
      if (t instanceof RegExp) {
        if (!t.test(l)) return a;
      } else if (!t.includes(l)) return a;
      i ? a-- : a++;
    }
    return a === -1 || a === n ? a : !1;
  };
}
var M$ = KD(" 	"), L$ = KD(/[^\n\r]/u);
function _$(t, e) {
  if (e === !1) return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r) if (t.charAt(r) === "*" && t.charAt(r + 1) === "/") return r + 2;
  }
  return e;
}
var R$ = _$;
function q$(t, e, r) {
  let s = !!(r != null && r.backwards);
  if (e === !1) return !1;
  let i = t.charAt(e);
  if (s) {
    if (t.charAt(e - 1) === "\r" && i === `
`) return e - 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return e - 1;
  } else {
    if (i === "\r" && t.charAt(e + 1) === `
`) return e + 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return e + 1;
  }
  return e;
}
var j$ = q$;
function X$(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? L$(t, e) : e;
}
var Z$ = X$;
function V$(t, e) {
  let r = null, s = e;
  for (; s !== r; ) r = s, s = M$(t, s), s = R$(t, s), s = Z$(t, s), s = j$(t, s);
  return s;
}
var z$ = V$;
function U$(t) {
  let e = [];
  for (let r of t) try {
    return r();
  } catch (s) {
    e.push(s);
  }
  throw Object.assign(new Error("All combinations failed"), { errors: e });
}
var Y$ = U$;
function W$(t) {
  if (!t.startsWith("#!")) return "";
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var e2 = W$, G$ = (t, e, r) => {
  if (!(t && e == null)) {
    if (e.findLast) return e.findLast(r);
    for (let s = e.length - 1; s >= 0; s--) {
      let i = e[s];
      if (r(i, s, e)) return i;
    }
  }
}, H$ = G$, J$ = (t, e, r) => {
  if (!(t && e == null)) return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, K$ = J$, e3 = new Proxy(() => {
}, { get: () => e3 });
function xr(t) {
  var a, l;
  var e, r, s;
  let i = (a = (e = t.range) == null ? void 0 : e[0]) != null ? a : t.start, n = (s = (l = (r = t.declaration) == null ? void 0 : r.decorators) != null ? l : t.decorators) == null ? void 0 : s[0];
  return n ? Math.min(xr(n), i) : i;
}
function Xt(t) {
  var r;
  var e;
  return (r = (e = t.range) == null ? void 0 : e[1]) != null ? r : t.end;
}
function t3(t) {
  let e = new Set(t);
  return (r) => e.has(r == null ? void 0 : r.type);
}
var am = t3;
function r3(t, e, r) {
  let s = t.originalText.slice(e, r);
  for (let i of t[Symbol.for("comments")]) {
    let n = xr(i);
    if (n > r) break;
    let a = Xt(i);
    if (a < e) continue;
    let l = a - n;
    s = s.slice(0, n - e) + " ".repeat(l) + s.slice(a - e);
  }
  return s;
}
var s3 = r3, i3 = am(["Block", "CommentBlock", "MultiLine"]), om = i3, n3 = am(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose", "Hashbang", "InterpreterDirective"]), a3 = n3, Jh = /* @__PURE__ */ new WeakMap();
function o3(t) {
  return Jh.has(t) || Jh.set(t, om(t) && t.value[0] === "*" && /@(?:type|satisfies)\b/u.test(t.value)), Jh.get(t);
}
var l3 = o3;
function u3(t) {
  if (!om(t)) return !1;
  let e = `*${t.value}*`.split(`
`);
  return e.length > 1 && e.every((r) => r.trimStart()[0] === "*");
}
var Kh = /* @__PURE__ */ new WeakMap();
function c3(t) {
  return Kh.has(t) || Kh.set(t, u3(t)), Kh.get(t);
}
var lO = c3;
function h3(t) {
  if (t.length < 2) return;
  let e;
  for (let r = t.length - 1; r >= 0; r--) {
    let s = t[r];
    if (e && Xt(s) === xr(e) && lO(s) && lO(e) && (t.splice(r + 1, 1), s.value += "*//*" + e.value, s.range = [xr(s), Xt(e)]), !a3(s) && !om(s)) throw new TypeError(`Unknown comment type: "${s.type}".`);
    e = s;
  }
}
var p3 = h3, Ua = null;
function Do(t) {
  if (Ua !== null && typeof Ua.property) {
    let e = Ua;
    return Ua = Do.prototype = null, e;
  }
  return Ua = Do.prototype = t != null ? t : /* @__PURE__ */ Object.create(null), new Do();
}
var d3 = 10;
for (let t = 0; t <= d3; t++) Do();
function f3(t) {
  return Do(t);
}
function m3(t, e = "type") {
  f3(t);
  function r(s) {
    let i = s[e], n = t[i];
    if (!Array.isArray(n)) throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: s });
    return n;
  }
  return r;
}
var g3 = m3, y3 = { ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "typeParameters", "typeArguments", "arguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["body", "test"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "typeParameters", "params", "predicate", "returnType", "body"], FunctionExpression: ["id", "typeParameters", "params", "returnType", "body"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "typeParameters", "typeArguments", "arguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["decorators", "key", "typeParameters", "params", "returnType", "body"], ObjectProperty: ["decorators", "key", "value"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["typeParameters", "params", "predicate", "returnType", "body"], ClassBody: ["body"], ClassExpression: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body", "superTypeArguments"], ClassDeclaration: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["imported", "local"], ImportExpression: ["source", "options"], MetaProperty: ["meta", "property"], ClassMethod: ["decorators", "key", "typeParameters", "params", "returnType", "body"], ObjectPattern: ["decorators", "properties", "typeAnnotation"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "typeParameters", "quasi", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "typeParameters", "typeArguments", "arguments"], ClassProperty: ["decorators", "variance", "key", "typeAnnotation", "value"], ClassAccessorProperty: ["decorators", "key", "typeAnnotation", "value"], ClassPrivateProperty: ["decorators", "variance", "key", "typeAnnotation", "value"], ClassPrivateMethod: ["decorators", "key", "typeParameters", "params", "returnType", "body"], PrivateName: ["id"], StaticBlock: ["body"], ImportAttribute: ["key", "value"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source", "attributes"], DeclareExportAllDeclaration: ["source", "attributes"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "this", "params", "rest", "returnType"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["variance", "id", "key", "value"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["qualification", "id"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "typeParameters", "typeArguments", "attributes"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["nameType", "typeAnnotation", "key", "constraint"], TSTemplateLiteralType: ["quasis", "types"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumBody: ["members"], TSEnumDeclaration: ["id", "body"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "options", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], AsConstExpression: ["expression"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ComponentDeclaration: ["id", "params", "body", "typeParameters", "rendersType"], ComponentParameter: ["name", "local"], ComponentTypeAnnotation: ["params", "rest", "typeParameters", "rendersType"], ComponentTypeParameter: ["name", "typeAnnotation"], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareComponent: ["id", "params", "rest", "typeParameters", "rendersType"], DeclareEnum: ["id", "body"], DeclareHook: ["id"], DeclareNamespace: ["id", "body"], EnumBigIntBody: ["members"], EnumBigIntMember: ["id", "init"], HookDeclaration: ["id", "params", "body", "typeParameters", "returnType"], HookTypeAnnotation: ["params", "returnType", "rest", "typeParameters"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGPipeExpression: ["left", "right", "arguments"], NGMicrosyntax: ["body"], NGMicrosyntaxAs: ["key", "alias"], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKey: [], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGRoot: ["node"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], SatisfiesExpression: ["expression", "typeAnnotation"], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [] }, O3 = g3(y3), x3 = O3;
function hd(t, e) {
  if (!(t !== null && typeof t == "object")) return t;
  if (Array.isArray(t)) {
    for (let s = 0; s < t.length; s++) t[s] = hd(t[s], e);
    return t;
  }
  let r = x3(t);
  for (let s = 0; s < r.length; s++) t[r[s]] = hd(t[r[s]], e);
  return e(t) || t;
}
var D3 = hd;
am(["RegExpLiteral", "BigIntLiteral", "NumericLiteral", "StringLiteral", "DirectiveLiteral", "Literal", "JSXText", "TemplateElement", "StringLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation"]);
function b3(t, e) {
  let { parser: r, text: s } = e, { comments: i } = t, n = r === "oxc" && e.oxcAstType === "ts";
  p3(i);
  let a;
  t = D3(t, (c) => {
    switch (c.type) {
      case "ParenthesizedExpression": {
        let { expression: p } = c, d = xr(c);
        if (p.type === "TypeCastExpression") return p.range = [d, Xt(c)], p;
        let m = !1;
        if (!n) {
          if (!a) {
            a = [];
            for (let g of i) l3(g) && a.push(Xt(g));
          }
          let y = H$(!1, a, (g) => g <= d);
          m = y && s.slice(y, d).trim().length === 0;
        }
        if (!m) return p.extra = { ...p.extra, parenthesized: !0 }, p;
        break;
      }
      case "LogicalExpression":
        if (t2(c)) return pd(c);
        break;
      case "TemplateLiteral":
        if (c.expressions.length !== c.quasis.length - 1) throw new Error("Malformed template literal.");
        break;
      case "TemplateElement":
        if (r === "flow" || r === "hermes" || r === "espree" || r === "typescript" || n) {
          let p = xr(c) + 1, d = Xt(c) - (c.tail ? 1 : 2);
          c.range = [p, d];
        }
        break;
      case "VariableDeclaration": {
        let p = K$(!1, c.declarations, -1);
        p != null && p.init && s[Xt(p)] !== ";" && (c.range = [xr(c), Xt(p)]);
        break;
      }
      case "TSParenthesizedType":
        return c.typeAnnotation;
      case "TSTypeParameter":
        uO(c);
        break;
      case "TopicReference":
        t.extra = { ...t.extra, __isUsingHackPipeline: !0 };
        break;
      case "TSUnionType":
      case "TSIntersectionType":
        if (c.types.length === 1) return c.types[0];
        break;
      case "TSMappedType":
        if (!c.constraint && !c.key) {
          let { name: p, constraint: d } = uO(c.typeParameter);
          c.constraint = d, c.key = p, delete c.typeParameter;
        }
        break;
      case "TSEnumDeclaration":
        if (!c.body) {
          let p = Xt(c.id), { members: d } = c, m = s3({ originalText: s, [Symbol.for("comments")]: i }, p, d[0] ? xr(d[0]) : Xt(c)), y = p + m.indexOf("{");
          c.body = { type: "TSEnumBody", members: d, range: [y, Xt(c)] }, delete c.members;
        }
        break;
      case "ImportExpression":
        r === "hermes" && c.attributes && !c.options && (c.options = c.attributes);
        break;
    }
  });
  let l = t.type === "File" ? t.program : t;
  return l.interpreter && (i.unshift(l.interpreter), delete l.interpreter), n && t.hashbang && (i.unshift(t.hashbang), delete t.hashbang), t.type === "Program" && (t.range = [0, s.length]), t;
}
function uO(t) {
  if (t.type === "TSTypeParameter" && typeof t.name == "string") {
    let e = xr(t);
    t.name = { type: "Identifier", name: t.name, range: [e, e + t.name.length] };
  }
  return t;
}
function t2(t) {
  return t.type === "LogicalExpression" && t.right.type === "LogicalExpression" && t.operator === t.right.operator;
}
function pd(t) {
  return t2(t) ? pd({ type: "LogicalExpression", operator: t.operator, left: pd({ type: "LogicalExpression", operator: t.operator, left: t.left, right: t.right.left, range: [xr(t.left), Xt(t.right.left)] }), right: t.right.right, range: [xr(t), Xt(t)] }) : t;
}
var v3 = b3;
function S3(t, e) {
  let r = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
var r2 = S3, cO = "Unexpected parseExpression() input: ";
function w3(t) {
  let { message: e, loc: r, reasonCode: s } = t;
  if (!r) return t;
  let { line: i, column: n } = r, a = t;
  (s === "MissingPlugin" || s === "MissingOneOfPlugins") && (e = "Unexpected token.", a = void 0);
  let l = ` (${i}:${n})`;
  return e.endsWith(l) && (e = e.slice(0, -l.length)), e.startsWith(cO) && (e = e.slice(cO.length)), r2(e, { loc: { start: { line: i, column: n + 1 } }, cause: a });
}
var s2 = w3, A3 = (t, e, r, s) => {
  if (!(t && e == null)) return e.replaceAll ? e.replaceAll(r, s) : r.global ? e.replace(r, s) : e.split(r).join(s);
}, Vl = A3, C3 = /\*\/$/, E3 = /^\/\*\*?/, T3 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, k3 = /(^|\s+)\/\/([^\n\r]*)/g, hO = /^(\r?\n)+/, P3 = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g, pO = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g, F3 = /(\r?\n|^) *\* ?/g, $3 = [];
function Q3(t) {
  let e = t.match(T3);
  return e ? e[0].trimStart() : "";
}
function B3(t) {
  let e = `
`;
  t = Vl(!1, t.replace(E3, "").replace(C3, ""), F3, "$1");
  let r = "";
  for (; r !== t; ) r = t, t = Vl(!1, t, P3, `${e}$1 $2${e}`);
  t = t.replace(hO, "").trimEnd();
  let s = /* @__PURE__ */ Object.create(null), i = Vl(!1, t, pO, "").replace(hO, "").trimEnd(), n;
  for (; n = pO.exec(t); ) {
    let a = Vl(!1, n[2], k3, "");
    if (typeof s[n[1]] == "string" || Array.isArray(s[n[1]])) {
      let l = s[n[1]];
      s[n[1]] = [...$3, ...Array.isArray(l) ? l : [l], a];
    } else s[n[1]] = a;
  }
  return { comments: i, pragmas: s };
}
var I3 = ["noformat", "noprettier"], N3 = ["format", "prettier"];
function i2(t) {
  let e = e2(t);
  e && (t = t.slice(e.length + 1));
  let r = Q3(t), { pragmas: s, comments: i } = B3(r);
  return { shebang: e, text: t, pragmas: s, comments: i };
}
function M3(t) {
  let { pragmas: e } = i2(t);
  return N3.some((r) => Object.prototype.hasOwnProperty.call(e, r));
}
function L3(t) {
  let { pragmas: e } = i2(t);
  return I3.some((r) => Object.prototype.hasOwnProperty.call(e, r));
}
function _3(t) {
  return t = typeof t == "function" ? { parse: t } : t, { astFormat: "estree", hasPragma: M3, hasIgnorePragma: L3, locStart: xr, locEnd: Xt, ...t };
}
var pl = _3, n2 = "module", a2 = "script";
function R3(t) {
  if (typeof t == "string") {
    if (t = t.toLowerCase(), /\.(?:mjs|mts)$/iu.test(t)) return n2;
    if (/\.(?:cjs|cts)$/iu.test(t)) return a2;
  }
}
function q3(t, e) {
  let { type: r = "JsExpressionRoot", rootMarker: s, text: i } = e, { tokens: n, comments: a } = t;
  return delete t.tokens, delete t.comments, { tokens: n, comments: a, type: r, node: t, range: [0, i.length], rootMarker: s };
}
var o2 = q3, Aa = (t) => pl(z3(t)), j3 = { sourceType: n2, allowImportExportEverywhere: !0, allowReturnOutsideFunction: !0, allowNewTargetOutsideFunction: !0, allowSuperOutsideMethod: !0, allowUndeclaredExports: !0, errorRecovery: !0, createParenthesizedExpressions: !0, createImportExpressions: !0, attachComment: !1, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", "decorators", "moduleBlocks", "asyncDoExpressions", "destructuringPrivate", "decoratorAutoAccessors", "explicitResourceManagement", "sourcePhaseImports", "deferredImportEvaluation", ["optionalChainingAssign", { version: "2023-07" }]], tokens: !1, ranges: !1 }, dO = "v8intrinsic", fO = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "fsharp" }]], Qs = (t, e = j3) => ({ ...e, plugins: [...e.plugins, ...t] }), X3 = /@(?:no)?flow\b/u;
function Z3(t, e) {
  if (e != null && e.endsWith(".js.flow")) return !0;
  let r = e2(t);
  r && (t = t.slice(r.length));
  let s = z$(t, 0);
  return s !== !1 && (t = t.slice(0, s)), X3.test(t);
}
function V3(t, e, r) {
  let s = t(e, r), i = s.errors.find((n) => !U3.has(n.reasonCode));
  if (i) throw i;
  return s;
}
function z3({ isExpression: t = !1, optionsCombinations: e }) {
  return (r, s = {}) => {
    var d;
    let { filepath: i } = s;
    if (typeof i != "string" && (i = void 0), (s.parser === "babel" || s.parser === "__babel_estree") && Z3(r, i)) return s.parser = "babel-flow", u2.parse(r, s);
    let n = e, a = (d = s.__babelSourceType) != null ? d : R3(i);
    a === a2 && (n = n.map((m) => ({ ...m, sourceType: a })));
    let l = /%[A-Z]/u.test(r);
    r.includes("|>") ? n = (l ? [...fO, dO] : fO).flatMap((m) => n.map((y) => Qs([m], y))) : l && (n = n.map((m) => Qs([dO], m)));
    let c = t ? oO.parseExpression : oO.parse, p;
    try {
      p = Y$(n.map((m) => () => V3(c, r, m)));
    } catch ({ errors: [m] }) {
      throw s2(m);
    }
    return t && (p = o2(p, { text: r, rootMarker: s.rootMarker })), v3(p, { text: r });
  };
}
var U3 = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "ForInOfLoopInitializer", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport", "ImportAttributesUseAssert", "DeclarationMissingInitializer"]), l2 = [Qs(["jsx"])], mO = Aa({ optionsCombinations: l2 }), gO = Aa({ optionsCombinations: [Qs(["jsx", "typescript"]), Qs(["typescript"])] }), yO = Aa({ isExpression: !0, optionsCombinations: [Qs(["jsx"])] }), OO = Aa({ isExpression: !0, optionsCombinations: [Qs(["typescript"])] }), u2 = Aa({ optionsCombinations: [Qs(["jsx", ["flow", { all: !0 }], "flowComments"])] }), Y3 = Aa({ optionsCombinations: l2.map((t) => Qs(["estree"], t)) }), c2 = {};
nm(c2, { json: () => H3, "json-stringify": () => eQ, json5: () => J3, jsonc: () => K3 });
var h2 = YD(WD());
function W3(t) {
  return Array.isArray(t) && t.length > 0;
}
var p2 = W3, d2 = { tokens: !1, ranges: !1, attachComment: !1, createParenthesizedExpressions: !0 };
function G3(t) {
  let e = (0, h2.parse)(t, d2), { program: r } = e;
  if (r.body.length === 0 && r.directives.length === 0 && !r.interpreter) return e;
}
function Gc(t, e = {}) {
  let { allowComments: r = !0, allowEmpty: s = !1 } = e, i;
  try {
    i = (0, h2.parseExpression)(t, d2);
  } catch (n) {
    if (s && n.code === "BABEL_PARSER_SYNTAX_ERROR" && n.reasonCode === "ParseExpressionEmptyInput") try {
      i = G3(t);
    } catch {
    }
    if (!i) throw s2(n);
  }
  if (!r && p2(i.comments)) throw ui(i.comments[0], "Comment");
  return i = o2(i, { type: "JsonRoot", text: t }), i.node.type === "File" ? delete i.node : Ln(i.node), i;
}
function ui(t, e) {
  let [r, s] = [t.loc.start, t.loc.end].map(({ line: i, column: n }) => ({ line: i, column: n + 1 }));
  return r2(`${e} is not allowed in JSON.`, { loc: { start: r, end: s } });
}
function Ln(t) {
  switch (t.type) {
    case "ArrayExpression":
      for (let e of t.elements) e !== null && Ln(e);
      return;
    case "ObjectExpression":
      for (let e of t.properties) Ln(e);
      return;
    case "ObjectProperty":
      if (t.computed) throw ui(t.key, "Computed key");
      if (t.shorthand) throw ui(t.key, "Shorthand property");
      t.key.type !== "Identifier" && Ln(t.key), Ln(t.value);
      return;
    case "UnaryExpression": {
      let { operator: e, argument: r } = t;
      if (e !== "+" && e !== "-") throw ui(t, `Operator '${t.operator}'`);
      if (r.type === "NumericLiteral" || r.type === "Identifier" && (r.name === "Infinity" || r.name === "NaN")) return;
      throw ui(r, `Operator '${e}' before '${r.type}'`);
    }
    case "Identifier":
      if (t.name !== "Infinity" && t.name !== "NaN" && t.name !== "undefined") throw ui(t, `Identifier '${t.name}'`);
      return;
    case "TemplateLiteral":
      if (p2(t.expressions)) throw ui(t.expressions[0], "'TemplateLiteral' with expression");
      for (let e of t.quasis) Ln(e);
      return;
    case "NullLiteral":
    case "BooleanLiteral":
    case "NumericLiteral":
    case "StringLiteral":
    case "TemplateElement":
      return;
    default:
      throw ui(t, `'${t.type}'`);
  }
}
var H3 = pl({ parse: (t) => Gc(t), hasPragma: () => !0, hasIgnorePragma: () => !1 }), J3 = pl((t) => Gc(t)), K3 = pl((t) => Gc(t, { allowEmpty: !0 })), eQ = pl({ parse: (t) => Gc(t, { allowComments: !1 }), astFormat: "estree-json" }), tQ = { ...JD, ...c2 }, f2 = HD, rQ = Object.defineProperty, m2 = (t) => {
  throw TypeError(t);
}, Hc = (t, e) => {
  for (var r in e) rQ(t, r, { get: e[r], enumerable: !0 });
}, g2 = (t, e, r) => e.has(t) || m2("Cannot " + r), ni = (t, e, r) => (g2(t, e, "read from private field"), e.get(t)), sQ = (t, e, r) => e.has(t) ? m2("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r), iQ = (t, e, r, s) => (g2(t, e, "write to private field"), e.set(t, r), r), y2 = {};
Hc(y2, { languages: () => D7, options: () => O7, printers: () => x7 });
var nQ = [{ name: "JavaScript", type: "programming", extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib", ".start.frag", ".end.frag", ".wxs"], tmScope: "source.js", aceMode: "javascript", aliases: ["js", "node"], codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell", "zx"], filenames: ["Jakefile", "start.frag", "end.frag"], parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], linguistLanguageId: 183 }, { name: "Flow", type: "programming", extensions: [".js.flow"], tmScope: "source.js", aceMode: "javascript", aliases: [], codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], filenames: [], parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], linguistLanguageId: 183 }, { name: "JSX", type: "programming", extensions: [".jsx"], tmScope: "source.js.jsx", aceMode: "javascript", aliases: void 0, codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", interpreters: void 0, filenames: void 0, parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], group: "JavaScript", linguistLanguageId: 183 }, { name: "TypeScript", type: "programming", extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", aliases: ["ts"], codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", interpreters: ["bun", "deno", "ts-node", "tsx"], parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"], linguistLanguageId: 378 }, { name: "TSX", type: "programming", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", group: "TypeScript", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"], linguistLanguageId: 94901924 }], O2 = {};
Hc(O2, { canAttachComment: () => m5, embed: () => r8, experimentalFeatures: () => u7, getCommentChildNodes: () => g5, getVisitorKeys: () => S2, handleComments: () => X2, insertPragma: () => g8, isBlockComment: () => Er, isGap: () => y5, massageAstNode: () => dB, print: () => l7, printComment: () => BB, willPrintOwnComments: () => rb });
var aQ = (t, e, r, s) => {
  if (!(t && e == null)) return e.replaceAll ? e.replaceAll(r, s) : r.global ? e.replace(r, s) : e.split(r).join(s);
}, xt = aQ, oQ = (t, e, r) => {
  if (!(t && e == null)) return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, Fe = oQ;
function lQ(t) {
  return t !== null && typeof t == "object";
}
var uQ = lQ;
function* cQ(t, e) {
  let { getVisitorKeys: r, filter: s = () => !0 } = e, i = (n) => uQ(n) && s(n);
  for (let n of r(t)) {
    let a = t[n];
    if (Array.isArray(a)) for (let l of a) i(l) && (yield l);
    else i(a) && (yield a);
  }
}
function* hQ(t, e) {
  let r = [t];
  for (let s = 0; s < r.length; s++) {
    let i = r[s];
    for (let n of cQ(i, e)) yield n, r.push(n);
  }
}
function pQ(t, { getVisitorKeys: e, predicate: r }) {
  for (let s of hQ(t, { getVisitorKeys: e })) if (r(s)) return !0;
  return !1;
}
var dQ = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function fQ(t) {
  return t === 12288 || t >= 65281 && t <= 65376 || t >= 65504 && t <= 65510;
}
function mQ(t) {
  return t >= 4352 && t <= 4447 || t === 8986 || t === 8987 || t === 9001 || t === 9002 || t >= 9193 && t <= 9196 || t === 9200 || t === 9203 || t === 9725 || t === 9726 || t === 9748 || t === 9749 || t >= 9776 && t <= 9783 || t >= 9800 && t <= 9811 || t === 9855 || t >= 9866 && t <= 9871 || t === 9875 || t === 9889 || t === 9898 || t === 9899 || t === 9917 || t === 9918 || t === 9924 || t === 9925 || t === 9934 || t === 9940 || t === 9962 || t === 9970 || t === 9971 || t === 9973 || t === 9978 || t === 9981 || t === 9989 || t === 9994 || t === 9995 || t === 10024 || t === 10060 || t === 10062 || t >= 10067 && t <= 10069 || t === 10071 || t >= 10133 && t <= 10135 || t === 10160 || t === 10175 || t === 11035 || t === 11036 || t === 11088 || t === 11093 || t >= 11904 && t <= 11929 || t >= 11931 && t <= 12019 || t >= 12032 && t <= 12245 || t >= 12272 && t <= 12287 || t >= 12289 && t <= 12350 || t >= 12353 && t <= 12438 || t >= 12441 && t <= 12543 || t >= 12549 && t <= 12591 || t >= 12593 && t <= 12686 || t >= 12688 && t <= 12773 || t >= 12783 && t <= 12830 || t >= 12832 && t <= 12871 || t >= 12880 && t <= 42124 || t >= 42128 && t <= 42182 || t >= 43360 && t <= 43388 || t >= 44032 && t <= 55203 || t >= 63744 && t <= 64255 || t >= 65040 && t <= 65049 || t >= 65072 && t <= 65106 || t >= 65108 && t <= 65126 || t >= 65128 && t <= 65131 || t >= 94176 && t <= 94180 || t === 94192 || t === 94193 || t >= 94208 && t <= 100343 || t >= 100352 && t <= 101589 || t >= 101631 && t <= 101640 || t >= 110576 && t <= 110579 || t >= 110581 && t <= 110587 || t === 110589 || t === 110590 || t >= 110592 && t <= 110882 || t === 110898 || t >= 110928 && t <= 110930 || t === 110933 || t >= 110948 && t <= 110951 || t >= 110960 && t <= 111355 || t >= 119552 && t <= 119638 || t >= 119648 && t <= 119670 || t === 126980 || t === 127183 || t === 127374 || t >= 127377 && t <= 127386 || t >= 127488 && t <= 127490 || t >= 127504 && t <= 127547 || t >= 127552 && t <= 127560 || t === 127568 || t === 127569 || t >= 127584 && t <= 127589 || t >= 127744 && t <= 127776 || t >= 127789 && t <= 127797 || t >= 127799 && t <= 127868 || t >= 127870 && t <= 127891 || t >= 127904 && t <= 127946 || t >= 127951 && t <= 127955 || t >= 127968 && t <= 127984 || t === 127988 || t >= 127992 && t <= 128062 || t === 128064 || t >= 128066 && t <= 128252 || t >= 128255 && t <= 128317 || t >= 128331 && t <= 128334 || t >= 128336 && t <= 128359 || t === 128378 || t === 128405 || t === 128406 || t === 128420 || t >= 128507 && t <= 128591 || t >= 128640 && t <= 128709 || t === 128716 || t >= 128720 && t <= 128722 || t >= 128725 && t <= 128727 || t >= 128732 && t <= 128735 || t === 128747 || t === 128748 || t >= 128756 && t <= 128764 || t >= 128992 && t <= 129003 || t === 129008 || t >= 129292 && t <= 129338 || t >= 129340 && t <= 129349 || t >= 129351 && t <= 129535 || t >= 129648 && t <= 129660 || t >= 129664 && t <= 129673 || t >= 129679 && t <= 129734 || t >= 129742 && t <= 129756 || t >= 129759 && t <= 129769 || t >= 129776 && t <= 129784 || t >= 131072 && t <= 196605 || t >= 196608 && t <= 262141;
}
var gQ = (t) => !(fQ(t) || mQ(t)), yQ = /[^\x20-\x7F]/u;
function OQ(t) {
  if (!t) return 0;
  if (!yQ.test(t)) return t.length;
  t = t.replace(dQ(), "  ");
  let e = 0;
  for (let r of t) {
    let s = r.codePointAt(0);
    s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (e += gQ(s) ? 1 : 2);
  }
  return e;
}
var aa = OQ;
function lm(t) {
  return (e, r, s) => {
    let i = !!(s != null && s.backwards);
    if (r === !1) return !1;
    let { length: n } = e, a = r;
    for (; a >= 0 && a < n; ) {
      let l = e.charAt(a);
      if (t instanceof RegExp) {
        if (!t.test(l)) return a;
      } else if (!t.includes(l)) return a;
      i ? a-- : a++;
    }
    return a === -1 || a === n ? a : !1;
  };
}
var oa = lm(" 	"), xQ = lm(",; 	"), DQ = lm(/[^\n\r]/u);
function bQ(t, e, r) {
  let s = !!(r != null && r.backwards);
  if (e === !1) return !1;
  let i = t.charAt(e);
  if (s) {
    if (t.charAt(e - 1) === "\r" && i === `
`) return e - 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return e - 1;
  } else {
    if (i === "\r" && t.charAt(e + 1) === `
`) return e + 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return e + 1;
  }
  return e;
}
var la = bQ;
function vQ(t, e, r = {}) {
  let s = oa(t, r.backwards ? e - 1 : e, r), i = la(t, s, r);
  return s !== i;
}
var cr = vQ;
function SQ(t, e) {
  if (e === !1) return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r) if (t.charAt(r) === "*" && t.charAt(r + 1) === "/") return r + 2;
  }
  return e;
}
var um = SQ;
function wQ(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? DQ(t, e) : e;
}
var cm = wQ;
function AQ(t, e) {
  let r = null, s = e;
  for (; s !== r; ) r = s, s = xQ(t, s), s = um(t, s), s = oa(t, s);
  return s = cm(t, s), s = la(t, s), s !== !1 && cr(t, s);
}
var hm = AQ;
function CQ(t) {
  return Array.isArray(t) && t.length > 0;
}
var Ee = CQ, x2 = new Proxy(() => {
}, { get: () => x2 }), pm = x2, zl = "'", xO = '"';
function EQ(t, e) {
  let r = e === !0 || e === zl ? zl : xO, s = r === zl ? xO : zl, i = 0, n = 0;
  for (let a of t) a === r ? i++ : a === s && n++;
  return i > n ? s : r;
}
var D2 = EQ;
function TQ(t, e, r) {
  let s = e === '"' ? "'" : '"', i = xt(!1, t, /\\(.)|(["'])/gsu, (n, a, l) => a === s ? a : l === e ? "\\" + l : l || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(a) ? a : "\\" + a));
  return e + i + e;
}
var kQ = TQ;
function PQ(t, e) {
  pm.ok(/^(?<quote>["']).*\k<quote>$/su.test(t));
  let r = t.slice(1, -1), s = e.parser === "json" || e.parser === "jsonc" || e.parser === "json5" && e.quoteProps === "preserve" && !e.singleQuote ? '"' : e.__isInHtmlAttribute ? "'" : D2(r, e.singleQuote);
  return t.charAt(0) === s ? t : kQ(r, s, !1);
}
var ua = PQ, b2 = (t) => Number.isInteger(t) && t >= 0;
function ke(t) {
  var a, l;
  var e, r, s;
  let i = (a = (e = t.range) == null ? void 0 : e[0]) != null ? a : t.start, n = (s = (l = (r = t.declaration) == null ? void 0 : r.decorators) != null ? l : t.decorators) == null ? void 0 : s[0];
  return n ? Math.min(ke(n), i) : i;
}
function De(t) {
  var r;
  var e;
  return (r = (e = t.range) == null ? void 0 : e[1]) != null ? r : t.end;
}
function Jc(t, e) {
  let r = ke(t);
  return b2(r) && r === ke(e);
}
function FQ(t, e) {
  let r = De(t);
  return b2(r) && r === De(e);
}
function $Q(t, e) {
  return Jc(t, e) && FQ(t, e);
}
var Ya = null;
function bo(t) {
  if (Ya !== null && typeof Ya.property) {
    let e = Ya;
    return Ya = bo.prototype = null, e;
  }
  return Ya = bo.prototype = t != null ? t : /* @__PURE__ */ Object.create(null), new bo();
}
var QQ = 10;
for (let t = 0; t <= QQ; t++) bo();
function BQ(t) {
  return bo(t);
}
function IQ(t, e = "type") {
  BQ(t);
  function r(s) {
    let i = s[e], n = t[i];
    if (!Array.isArray(n)) throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: s });
    return n;
  }
  return r;
}
var v2 = IQ, NQ = { ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "typeParameters", "typeArguments", "arguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["body", "test"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "typeParameters", "params", "predicate", "returnType", "body"], FunctionExpression: ["id", "typeParameters", "params", "returnType", "body"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "typeParameters", "typeArguments", "arguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["decorators", "key", "typeParameters", "params", "returnType", "body"], ObjectProperty: ["decorators", "key", "value"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["typeParameters", "params", "predicate", "returnType", "body"], ClassBody: ["body"], ClassExpression: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body", "superTypeArguments"], ClassDeclaration: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["imported", "local"], ImportExpression: ["source", "options"], MetaProperty: ["meta", "property"], ClassMethod: ["decorators", "key", "typeParameters", "params", "returnType", "body"], ObjectPattern: ["decorators", "properties", "typeAnnotation"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "typeParameters", "quasi", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "typeParameters", "typeArguments", "arguments"], ClassProperty: ["decorators", "variance", "key", "typeAnnotation", "value"], ClassAccessorProperty: ["decorators", "key", "typeAnnotation", "value"], ClassPrivateProperty: ["decorators", "variance", "key", "typeAnnotation", "value"], ClassPrivateMethod: ["decorators", "key", "typeParameters", "params", "returnType", "body"], PrivateName: ["id"], StaticBlock: ["body"], ImportAttribute: ["key", "value"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source", "attributes"], DeclareExportAllDeclaration: ["source", "attributes"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "this", "params", "rest", "returnType"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["variance", "id", "key", "value"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["qualification", "id"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "typeParameters", "typeArguments", "attributes"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["nameType", "typeAnnotation", "key", "constraint"], TSTemplateLiteralType: ["quasis", "types"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumBody: ["members"], TSEnumDeclaration: ["id", "body"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "options", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], AsConstExpression: ["expression"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ComponentDeclaration: ["id", "params", "body", "typeParameters", "rendersType"], ComponentParameter: ["name", "local"], ComponentTypeAnnotation: ["params", "rest", "typeParameters", "rendersType"], ComponentTypeParameter: ["name", "typeAnnotation"], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareComponent: ["id", "params", "rest", "typeParameters", "rendersType"], DeclareEnum: ["id", "body"], DeclareHook: ["id"], DeclareNamespace: ["id", "body"], EnumBigIntBody: ["members"], EnumBigIntMember: ["id", "init"], HookDeclaration: ["id", "params", "body", "typeParameters", "returnType"], HookTypeAnnotation: ["params", "returnType", "rest", "typeParameters"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGPipeExpression: ["left", "right", "arguments"], NGMicrosyntax: ["body"], NGMicrosyntaxAs: ["key", "alias"], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKey: [], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGRoot: ["node"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], SatisfiesExpression: ["expression", "typeAnnotation"], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [] }, MQ = v2(NQ), S2 = MQ;
function LQ(t) {
  let e = new Set(t);
  return (r) => e.has(r == null ? void 0 : r.type);
}
var Pe = LQ;
function _Q(t) {
  var r;
  var e;
  return (r = (e = t.extra) == null ? void 0 : e.raw) != null ? r : t.raw;
}
var Wt = _Q, RQ = Pe(["Block", "CommentBlock", "MultiLine"]), Er = RQ, qQ = Pe(["AnyTypeAnnotation", "ThisTypeAnnotation", "NumberTypeAnnotation", "VoidTypeAnnotation", "BooleanTypeAnnotation", "BigIntTypeAnnotation", "SymbolTypeAnnotation", "StringTypeAnnotation", "NeverTypeAnnotation", "UndefinedTypeAnnotation", "UnknownTypeAnnotation", "EmptyTypeAnnotation", "MixedTypeAnnotation"]), w2 = qQ, jQ = Pe(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose", "Hashbang", "InterpreterDirective"]), dl = jQ;
function XQ(t, e) {
  let r = e.split(".");
  for (let s = r.length - 1; s >= 0; s--) {
    let i = r[s];
    if (s === 0) return t.type === "Identifier" && t.name === i;
    if (t.type !== "MemberExpression" || t.optional || t.computed || t.property.type !== "Identifier" || t.property.name !== i) return !1;
    t = t.object;
  }
}
function ZQ(t, e) {
  return e.some((r) => XQ(t, r));
}
var VQ = ZQ;
function zQ({ type: t }) {
  return t.startsWith("TS") && t.endsWith("Keyword");
}
var A2 = zQ;
function dd(t, e) {
  return e(t) || pQ(t, { getVisitorKeys: S2, predicate: e });
}
function dm(t) {
  return t.type === "AssignmentExpression" || t.type === "BinaryExpression" || t.type === "LogicalExpression" || t.type === "NGPipeExpression" || t.type === "ConditionalExpression" || Ae(t) || Ve(t) || t.type === "SequenceExpression" || t.type === "TaggedTemplateExpression" || t.type === "BindExpression" || t.type === "UpdateExpression" && !t.prefix || ss(t) || t.type === "TSNonNullExpression" || t.type === "ChainExpression";
}
function UQ(t) {
  var e, r, s, i, n, a;
  return t.expressions ? t.expressions[0] : (a = (n = (i = (s = (r = (e = t.left) != null ? e : t.test) != null ? r : t.callee) != null ? s : t.object) != null ? i : t.tag) != null ? n : t.argument) != null ? a : t.expression;
}
function C2(t) {
  if (t.expressions) return ["expressions", 0];
  if (t.left) return ["left"];
  if (t.test) return ["test"];
  if (t.object) return ["object"];
  if (t.callee) return ["callee"];
  if (t.tag) return ["tag"];
  if (t.argument) return ["argument"];
  if (t.expression) return ["expression"];
  throw new Error("Unexpected node has no left side.");
}
var YQ = Pe(["ExportDefaultDeclaration", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "DeclareExportAllDeclaration"]), St = Pe(["ArrayExpression"]), Rr = Pe(["ObjectExpression"]);
function WQ(t) {
  return t.type === "LogicalExpression" && t.operator === "??";
}
function hs(t) {
  return t.type === "NumericLiteral" || t.type === "Literal" && typeof t.value == "number";
}
function GQ(t) {
  return t.type === "BooleanLiteral" || t.type === "Literal" && typeof t.value == "boolean";
}
function E2(t) {
  return t.type === "UnaryExpression" && (t.operator === "+" || t.operator === "-") && hs(t.argument);
}
function wt(t) {
  return !!(t && (t.type === "StringLiteral" || t.type === "Literal" && typeof t.value == "string"));
}
function T2(t) {
  return t.type === "RegExpLiteral" || t.type === "Literal" && !!t.regex;
}
var fm = Pe(["Literal", "BooleanLiteral", "BigIntLiteral", "DirectiveLiteral", "NullLiteral", "NumericLiteral", "RegExpLiteral", "StringLiteral"]), HQ = Pe(["Identifier", "ThisExpression", "Super", "PrivateName", "PrivateIdentifier"]), Si = Pe(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), No = Pe(["FunctionExpression", "ArrowFunctionExpression"]);
function JQ(t) {
  return t.type === "FunctionExpression" || t.type === "ArrowFunctionExpression" && t.body.type === "BlockStatement";
}
function ep(t) {
  return Ae(t) && t.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(t.callee.name);
}
var dt = Pe(["JSXElement", "JSXFragment"]);
function Kc(t) {
  return t.method && t.kind === "init" || t.kind === "get" || t.kind === "set";
}
function k2(t) {
  return (t.type === "ObjectTypeProperty" || t.type === "ObjectTypeInternalSlot") && !t.static && !t.method && t.kind !== "get" && t.kind !== "set" && t.value.type === "FunctionTypeAnnotation";
}
function KQ(t) {
  return (t.type === "TypeAnnotation" || t.type === "TSTypeAnnotation") && t.typeAnnotation.type === "FunctionTypeAnnotation" && !t.static && !Jc(t, t.typeAnnotation);
}
var Bs = Pe(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
function _n(t) {
  return Ve(t) || t.type === "BindExpression" && !!t.object;
}
var eB = Pe(["TSThisType", "NullLiteralTypeAnnotation", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType"]);
function mm(t) {
  return A2(t) || w2(t) || eB(t) || (t.type === "GenericTypeAnnotation" || t.type === "TSTypeReference") && !t.typeParameters && !t.typeArguments;
}
function tB(t) {
  return t.type === "Identifier" && (t.name === "beforeEach" || t.name === "beforeAll" || t.name === "afterEach" || t.name === "afterAll");
}
var rB = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
function sB(t) {
  return VQ(t, rB);
}
function eh(t, e) {
  if ((t == null ? void 0 : t.type) !== "CallExpression" || t.optional) return !1;
  let r = Tr(t);
  if (r.length === 1) {
    if (ep(t) && eh(e)) return No(r[0]);
    if (tB(t.callee)) return ep(r[0]);
  } else if ((r.length === 2 || r.length === 3) && (r[0].type === "TemplateLiteral" || wt(r[0])) && sB(t.callee)) return r[2] && !hs(r[2]) ? !1 : (r.length === 2 ? No(r[1]) : JQ(r[1]) && Pt(r[1]).length <= 1) || ep(r[1]);
  return !1;
}
var P2 = (t) => (e) => ((e == null ? void 0 : e.type) === "ChainExpression" && (e = e.expression), t(e)), Ae = P2(Pe(["CallExpression", "OptionalCallExpression"])), Ve = P2(Pe(["MemberExpression", "OptionalMemberExpression"]));
function DO(t, e = 5) {
  return F2(t, e) <= e;
}
function F2(t, e) {
  let r = 0;
  for (let s in t) {
    let i = t[s];
    if (i && typeof i == "object" && typeof i.type == "string" && (r++, r += F2(i, e - r)), r > e) return r;
  }
  return r;
}
var iB = 0.25;
function gm(t, e) {
  let { printWidth: r } = e;
  if (z(t)) return !1;
  let s = r * iB;
  if (t.type === "ThisExpression" || t.type === "Identifier" && t.name.length <= s || E2(t) && !z(t.argument)) return !0;
  let i = t.type === "Literal" && "regex" in t && t.regex.pattern || t.type === "RegExpLiteral" && t.pattern;
  return i ? i.length <= s : wt(t) ? ua(Wt(t), e).length <= s : t.type === "TemplateLiteral" ? t.expressions.length === 0 && t.quasis[0].value.raw.length <= s && !t.quasis[0].value.raw.includes(`
`) : t.type === "UnaryExpression" ? gm(t.argument, { printWidth: r }) : t.type === "CallExpression" && t.arguments.length === 0 && t.callee.type === "Identifier" ? t.callee.name.length <= s - 2 : fm(t);
}
function ls(t, e) {
  return dt(e) ? th(e) : z(e, te.Leading, (r) => cr(t, De(r)));
}
function bO(t) {
  return t.quasis.some((e) => e.value.raw.includes(`
`));
}
function $2(t, e) {
  return (t.type === "TemplateLiteral" && bO(t) || t.type === "TaggedTemplateExpression" && bO(t.quasi)) && !cr(e, ke(t), { backwards: !0 });
}
function Q2(t) {
  if (!z(t)) return !1;
  let e = Fe(!1, nn(t, te.Dangling), -1);
  return e && !Er(e);
}
function nB(t) {
  if (t.length <= 1) return !1;
  let e = 0;
  for (let r of t) if (No(r)) {
    if (e += 1, e > 1) return !0;
  } else if (Ae(r)) {
    for (let s of Tr(r)) if (No(s)) return !0;
  }
  return !1;
}
function B2(t) {
  let { node: e, parent: r, key: s } = t;
  return s === "callee" && Ae(e) && Ae(r) && r.arguments.length > 0 && e.arguments.length > r.arguments.length;
}
var aB = /* @__PURE__ */ new Set(["!", "-", "+", "~"]);
function Br(t, e = 2) {
  var s;
  if (e <= 0) return !1;
  if (t.type === "ChainExpression" || t.type === "TSNonNullExpression") return Br(t.expression, e);
  let r = (i) => Br(i, e - 1);
  if (T2(t)) return aa((s = t.pattern) != null ? s : t.regex.pattern) <= 5;
  if (fm(t) || HQ(t) || t.type === "ArgumentPlaceholder") return !0;
  if (t.type === "TemplateLiteral") return t.quasis.every((i) => !i.value.raw.includes(`
`)) && t.expressions.every(r);
  if (Rr(t)) return t.properties.every((i) => !i.computed && (i.shorthand || i.value && r(i.value)));
  if (St(t)) return t.elements.every((i) => i === null || r(i));
  if (ca(t)) {
    if (t.type === "ImportExpression" || Br(t.callee, e)) {
      let i = Tr(t);
      return i.length <= e && i.every(r);
    }
    return !1;
  }
  return Ve(t) ? Br(t.object, e) && Br(t.property, e) : t.type === "UnaryExpression" && aB.has(t.operator) || t.type === "UpdateExpression" ? Br(t.argument, e) : !1;
}
function oB(t) {
  return t;
}
function Ys(t, e = "es5") {
  return t.trailingComma === "es5" && e === "es5" || t.trailingComma === "all" && (e === "all" || e === "es5");
}
function Bt(t, e) {
  switch (t.type) {
    case "BinaryExpression":
    case "LogicalExpression":
    case "AssignmentExpression":
    case "NGPipeExpression":
      return Bt(t.left, e);
    case "MemberExpression":
    case "OptionalMemberExpression":
      return Bt(t.object, e);
    case "TaggedTemplateExpression":
      return t.tag.type === "FunctionExpression" ? !1 : Bt(t.tag, e);
    case "CallExpression":
    case "OptionalCallExpression":
      return t.callee.type === "FunctionExpression" ? !1 : Bt(t.callee, e);
    case "ConditionalExpression":
      return Bt(t.test, e);
    case "UpdateExpression":
      return !t.prefix && Bt(t.argument, e);
    case "BindExpression":
      return t.object && Bt(t.object, e);
    case "SequenceExpression":
      return Bt(t.expressions[0], e);
    case "ChainExpression":
    case "TSSatisfiesExpression":
    case "TSAsExpression":
    case "TSNonNullExpression":
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
      return Bt(t.expression, e);
    default:
      return e(t);
  }
}
var vO = { "==": !0, "!=": !0, "===": !0, "!==": !0 }, Ul = { "*": !0, "/": !0, "%": !0 }, fd = { ">>": !0, ">>>": !0, "<<": !0 };
function ym(t, e) {
  return !(Ju(e) !== Ju(t) || t === "**" || vO[t] && vO[e] || e === "%" && Ul[t] || t === "%" && Ul[e] || e !== t && Ul[e] && Ul[t] || fd[t] && fd[e]);
}
var lB = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((t, e) => t.map((r) => [r, e])));
function Ju(t) {
  return lB.get(t);
}
function uB(t) {
  return !!fd[t] || t === "|" || t === "^" || t === "&";
}
function cB(t) {
  var e;
  if (t.rest) return !0;
  let r = Pt(t);
  return ((e = Fe(!1, r, -1)) == null ? void 0 : e.type) === "RestElement";
}
var tp = /* @__PURE__ */ new WeakMap();
function Pt(t) {
  if (tp.has(t)) return tp.get(t);
  let e = [];
  return t.this && e.push(t.this), Array.isArray(t.parameters) ? e.push(...t.parameters) : Array.isArray(t.params) && e.push(...t.params), t.rest && e.push(t.rest), tp.set(t, e), e;
}
function hB(t, e) {
  let { node: r } = t, s = 0, i = (n) => e(n, s++);
  r.this && t.call(i, "this"), Array.isArray(r.parameters) ? t.each(i, "parameters") : Array.isArray(r.params) && t.each(i, "params"), r.rest && t.call(i, "rest");
}
var rp = /* @__PURE__ */ new WeakMap();
function Tr(t) {
  if (rp.has(t)) return rp.get(t);
  if (t.type === "ChainExpression") return Tr(t.expression);
  let e = t.arguments;
  return (t.type === "ImportExpression" || t.type === "TSImportType") && (e = [t.type === "ImportExpression" ? t.source : t.argument], t.options && e.push(t.options)), rp.set(t, e), e;
}
function Ku(t, e) {
  let { node: r } = t;
  if (r.type === "ChainExpression") return t.call(() => Ku(t, e), "expression");
  r.type === "ImportExpression" || r.type === "TSImportType" ? (t.call((s) => e(s, 0), r.type === "ImportExpression" ? "source" : "argument"), r.options && t.call((s) => e(s, 1), "options")) : t.each(e, "arguments");
}
function SO(t, e) {
  let r = [];
  if (t.type === "ChainExpression" && (t = t.expression, r.push("expression")), t.type === "ImportExpression" || t.type === "TSImportType") {
    if (e === 0 || e === (t.options ? -2 : -1)) return [...r, t.type === "ImportExpression" ? "source" : "argument"];
    if (t.options && (e === 1 || e === -1)) return [...r, "options"];
    throw new RangeError("Invalid argument index");
  }
  if (e < 0 && (e = t.arguments.length + e), e < 0 || e >= t.arguments.length) throw new RangeError("Invalid argument index");
  return [...r, "arguments", e];
}
function ec(t) {
  return t.value.trim() === "prettier-ignore" && !t.unignore;
}
function th(t) {
  return (t == null ? void 0 : t.prettierIgnore) || z(t, te.PrettierIgnore);
}
var te = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 }, I2 = (t, e) => {
  if (typeof t == "function" && (e = t, t = 0), t || e) return (r, s, i) => !(t & te.Leading && !r.leading || t & te.Trailing && !r.trailing || t & te.Dangling && (r.leading || r.trailing) || t & te.Block && !Er(r) || t & te.Line && !dl(r) || t & te.First && s !== 0 || t & te.Last && s !== i.length - 1 || t & te.PrettierIgnore && !ec(r) || e && !e(r));
};
function z(t, e, r) {
  if (!Ee(t == null ? void 0 : t.comments)) return !1;
  let s = I2(e, r);
  return s ? t.comments.some(s) : !0;
}
function nn(t, e, r) {
  if (!Array.isArray(t == null ? void 0 : t.comments)) return [];
  let s = I2(e, r);
  return s ? t.comments.filter(s) : t.comments;
}
var Ws = (t, { originalText: e }) => hm(e, De(t));
function ca(t) {
  return Ae(t) || t.type === "NewExpression" || t.type === "ImportExpression";
}
function Gs(t) {
  return t && (t.type === "ObjectProperty" || t.type === "Property" && !Kc(t));
}
var ss = Pe(["TSAsExpression", "TSSatisfiesExpression", "AsExpression", "AsConstExpression", "SatisfiesExpression"]), wi = Pe(["TSUnionType", "UnionTypeAnnotation"]), Om = Pe(["TSIntersectionType", "IntersectionTypeAnnotation"]), Ai = Pe(["TSConditionalType", "ConditionalTypeAnnotation"]), pB = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), $n = (t) => {
  for (let e of t.quasis) delete e.value;
};
function N2(t, e) {
  var r;
  if (t.type === "Program" && delete e.sourceType, (t.type === "BigIntLiteral" || t.type === "BigIntLiteralTypeAnnotation") && t.value && (e.value = t.value.toLowerCase()), (t.type === "BigIntLiteral" || t.type === "Literal") && t.bigint && (e.bigint = t.bigint.toLowerCase()), t.type === "EmptyStatement" || t.type === "JSXText" || t.type === "JSXExpressionContainer" && (t.expression.type === "Literal" || t.expression.type === "StringLiteral") && t.expression.value === " ") return null;
  if ((t.type === "Property" || t.type === "ObjectProperty" || t.type === "MethodDefinition" || t.type === "ClassProperty" || t.type === "ClassMethod" || t.type === "PropertyDefinition" || t.type === "TSDeclareMethod" || t.type === "TSPropertySignature" || t.type === "ObjectTypeProperty" || t.type === "ImportAttribute") && t.key && !t.computed) {
    let { key: i } = t;
    wt(i) || hs(i) ? e.key = String(i.value) : i.type === "Identifier" && (e.key = i.name);
  }
  if (t.type === "JSXElement" && t.openingElement.name.name === "style" && t.openingElement.attributes.some((i) => i.type === "JSXAttribute" && i.name.name === "jsx")) for (let { type: i, expression: n } of e.children) i === "JSXExpressionContainer" && n.type === "TemplateLiteral" && $n(n);
  t.type === "JSXAttribute" && t.name.name === "css" && t.value.type === "JSXExpressionContainer" && t.value.expression.type === "TemplateLiteral" && $n(e.value.expression), t.type === "JSXAttribute" && ((r = t.value) == null ? void 0 : r.type) === "Literal" && /["']|&quot;|&apos;/u.test(t.value.value) && (e.value.value = xt(!1, t.value.value, /["']|&quot;|&apos;/gu, '"'));
  let s = t.expression || t.callee;
  if (t.type === "Decorator" && s.type === "CallExpression" && s.callee.name === "Component" && s.arguments.length === 1) {
    let i = t.expression.arguments[0].properties;
    for (let [n, a] of e.expression.arguments[0].properties.entries()) switch (i[n].key.name) {
      case "styles":
        St(a.value) && $n(a.value.elements[0]);
        break;
      case "template":
        a.value.type === "TemplateLiteral" && $n(a.value);
        break;
    }
  }
  t.type === "TaggedTemplateExpression" && (t.tag.type === "MemberExpression" || t.tag.type === "Identifier" && (t.tag.name === "gql" || t.tag.name === "graphql" || t.tag.name === "css" || t.tag.name === "md" || t.tag.name === "markdown" || t.tag.name === "html") || t.tag.type === "CallExpression") && $n(e.quasi), t.type === "TemplateLiteral" && $n(e), t.type === "ChainExpression" && t.expression.type === "TSNonNullExpression" && (e.type = "TSNonNullExpression", e.expression.type = "ChainExpression");
}
N2.ignoredProperties = pB;
var dB = N2, Dn = "string", Is = "array", Ca = "cursor", bn = "indent", vn = "align", Sn = "trim", Ar = "group", Bi = "fill", us = "if-break", wn = "indent-if-break", An = "line-suffix", Ii = "line-suffix-boundary", Jt = "line", Hs = "label", Js = "break-parent", M2 = /* @__PURE__ */ new Set([Ca, bn, vn, Sn, Ar, Bi, us, wn, An, Ii, Jt, Hs, Js]);
function fB(t) {
  if (typeof t == "string") return Dn;
  if (Array.isArray(t)) return Is;
  if (!t) return;
  let { type: e } = t;
  if (M2.has(e)) return e;
}
var Ni = fB, mB = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function gB(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object") return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (Ni(t)) throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]") return `Unexpected doc '${r}'.`;
  let s = mB([...M2].map((i) => `'${i}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${s}.`;
}
var yB = class extends Error {
  constructor(r) {
    super(gB(r));
    vs(this, "name", "InvalidDocError");
    this.doc = r;
  }
}, Mo = yB, wO = {};
function OB(t, e, r, s) {
  let i = [t];
  for (; i.length > 0; ) {
    let n = i.pop();
    if (n === wO) {
      r(i.pop());
      continue;
    }
    r && i.push(n, wO);
    let a = Ni(n);
    if (!a) throw new Mo(n);
    if ((e == null ? void 0 : e(n)) !== !1) switch (a) {
      case Is:
      case Bi: {
        let l = a === Is ? n : n.parts;
        for (let c = l.length, p = c - 1; p >= 0; --p) i.push(l[p]);
        break;
      }
      case us:
        i.push(n.flatContents, n.breakContents);
        break;
      case Ar:
        if (s && n.expandedStates) for (let l = n.expandedStates.length, c = l - 1; c >= 0; --c) i.push(n.expandedStates[c]);
        else i.push(n.contents);
        break;
      case vn:
      case bn:
      case wn:
      case Hs:
      case An:
        i.push(n.contents);
        break;
      case Dn:
      case Ca:
      case Sn:
      case Ii:
      case Jt:
      case Js:
        break;
      default:
        throw new Mo(n);
    }
  }
}
var xm = OB;
function Ea(t, e) {
  if (typeof t == "string") return e(t);
  let r = /* @__PURE__ */ new Map();
  return s(t);
  function s(n) {
    if (r.has(n)) return r.get(n);
    let a = i(n);
    return r.set(n, a), a;
  }
  function i(n) {
    switch (Ni(n)) {
      case Is:
        return e(n.map(s));
      case Bi:
        return e({ ...n, parts: n.parts.map(s) });
      case us:
        return e({ ...n, breakContents: s(n.breakContents), flatContents: s(n.flatContents) });
      case Ar: {
        let { expandedStates: a, contents: l } = n;
        return a ? (a = a.map(s), l = a[0]) : l = s(l), e({ ...n, contents: l, expandedStates: a });
      }
      case vn:
      case bn:
      case wn:
      case Hs:
      case An:
        return e({ ...n, contents: s(n.contents) });
      case Dn:
      case Ca:
      case Sn:
      case Ii:
      case Jt:
      case Js:
        return e(n);
      default:
        throw new Mo(n);
    }
  }
}
function L2(t, e, r) {
  let s = r, i = !1;
  function n(a) {
    if (i) return !1;
    let l = e(a);
    l !== void 0 && (i = !0, s = l);
  }
  return xm(t, n), s;
}
function xB(t) {
  if (t.type === Ar && t.break || t.type === Jt && t.hard || t.type === Js) return !0;
}
function It(t) {
  return L2(t, xB, !1);
}
function AO(t) {
  if (t.length > 0) {
    let e = Fe(!1, t, -1);
    !e.expandedStates && !e.break && (e.break = "propagated");
  }
  return null;
}
function DB(t) {
  let e = /* @__PURE__ */ new Set(), r = [];
  function s(n) {
    if (n.type === Js && AO(r), n.type === Ar) {
      if (r.push(n), e.has(n)) return !1;
      e.add(n);
    }
  }
  function i(n) {
    n.type === Ar && r.pop().break && AO(r);
  }
  xm(t, s, i, !0);
}
function bB(t) {
  return t.type === Jt && !t.hard ? t.soft ? "" : " " : t.type === us ? t.flatContents : t;
}
function md(t) {
  return Ea(t, bB);
}
function vB(t) {
  switch (Ni(t)) {
    case Bi:
      if (t.parts.every((e) => e === "")) return "";
      break;
    case Ar:
      if (!t.contents && !t.id && !t.break && !t.expandedStates) return "";
      if (t.contents.type === Ar && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates) return t.contents;
      break;
    case vn:
    case bn:
    case wn:
    case An:
      if (!t.contents) return "";
      break;
    case us:
      if (!t.flatContents && !t.breakContents) return "";
      break;
    case Is: {
      let e = [];
      for (let r of t) {
        if (!r) continue;
        let [s, ...i] = Array.isArray(r) ? r : [r];
        typeof s == "string" && typeof Fe(!1, e, -1) == "string" ? e[e.length - 1] += s : e.push(s), e.push(...i);
      }
      return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
    }
    case Dn:
    case Ca:
    case Sn:
    case Ii:
    case Jt:
    case Hs:
    case Js:
      break;
    default:
      throw new Mo(t);
  }
  return t;
}
function Dm(t) {
  return Ea(t, (e) => vB(e));
}
function ln(t, e = j2) {
  return Ea(t, (r) => typeof r == "string" ? be(e, r.split(`
`)) : r);
}
function SB(t) {
  if (t.type === Jt) return !0;
}
function wB(t) {
  return L2(t, SB, !1);
}
function gd(t, e) {
  return t.type === Hs ? { ...t, contents: e(t.contents) } : e(t);
}
function AB(t) {
  let e = !0;
  return xm(t, (r) => {
    switch (Ni(r)) {
      case Dn:
        if (r === "") break;
      case Sn:
      case Ii:
      case Jt:
      case Js:
        return e = !1, !1;
    }
  }), e;
}
var CB = () => {
}, EB = CB;
function X(t) {
  return { type: bn, contents: t };
}
function ps(t, e) {
  return { type: vn, contents: e, n: t };
}
function I(t, e = {}) {
  return EB(e.expandedStates), { type: Ar, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function TB(t) {
  return ps(Number.NEGATIVE_INFINITY, t);
}
function _2(t) {
  return ps(-1, t);
}
function Yi(t, e) {
  return I(t[0], { ...e, expandedStates: t });
}
function R2(t) {
  return { type: Bi, parts: t };
}
function de(t, e = "", r = {}) {
  return { type: us, breakContents: t, flatContents: e, groupId: r.groupId };
}
function rh(t, e) {
  return { type: wn, contents: t, groupId: e.groupId, negate: e.negate };
}
function CO(t) {
  return { type: An, contents: t };
}
var Ns = { type: Ii }, ds = { type: Js }, q2 = { type: Jt, hard: !0 }, kB = { type: Jt, hard: !0, literal: !0 }, K = { type: Jt }, R = { type: Jt, soft: !0 }, q = [q2, ds], j2 = [kB, ds], Yl = { type: Ca };
function be(t, e) {
  let r = [];
  for (let s = 0; s < e.length; s++) s !== 0 && r.push(t), r.push(e[s]);
  return r;
}
function PB(t, e, r) {
  let s = t;
  if (e > 0) {
    for (let i = 0; i < Math.floor(e / r); ++i) s = X(s);
    s = ps(e % r, s), s = ps(Number.NEGATIVE_INFINITY, s);
  }
  return s;
}
function fl(t, e) {
  return t ? { type: Hs, label: t, contents: e } : e;
}
function FB(t) {
  if (!Er(t)) return !1;
  let e = `*${t.value}*`.split(`
`);
  return e.length > 1 && e.every((r) => r.trimStart()[0] === "*");
}
var sp = /* @__PURE__ */ new WeakMap();
function $B(t) {
  return sp.has(t) || sp.set(t, FB(t)), sp.get(t);
}
var QB = $B;
function BB(t, e) {
  let r = t.node;
  if (dl(r)) return e.originalText.slice(ke(r), De(r)).trimEnd();
  if (QB(r)) return IB(r);
  if (Er(r)) return ["/*", ln(r.value), "*/"];
  throw new Error("Not a comment: " + JSON.stringify(r));
}
function IB(t) {
  let e = t.value.split(`
`);
  return ["/*", be(q, e.map((r, s) => s === 0 ? r.trimEnd() : " " + (s < e.length - 1 ? r.trim() : r.trimStart()))), "*/"];
}
var X2 = {};
Hc(X2, { endOfLine: () => jB, ownLine: () => qB, remaining: () => XB });
function NB(t) {
  let e = t.type || t.kind || "(unknown type)", r = String(t.name || t.id && (typeof t.id == "object" ? t.id.name : t.id) || t.key && (typeof t.key == "object" ? t.key.name : t.key) || t.value && (typeof t.value == "object" ? "" : String(t.value)) || t.operator || "");
  return r.length > 20 && (r = r.slice(0, 19) + ""), e + (r ? " " + r : "");
}
function bm(t, e) {
  var r;
  ((r = t.comments) != null ? r : t.comments = []).push(e), e.printed = !1, e.nodeDescription = NB(t);
}
function Ft(t, e) {
  e.leading = !0, e.trailing = !1, bm(t, e);
}
function dr(t, e, r) {
  e.leading = !1, e.trailing = !1, r && (e.marker = r), bm(t, e);
}
function ze(t, e) {
  e.leading = !1, e.trailing = !0, bm(t, e);
}
function MB(t, e) {
  let r = null, s = e;
  for (; s !== r; ) r = s, s = oa(t, s), s = um(t, s), s = cm(t, s), s = la(t, s);
  return s;
}
var Ta = MB;
function LB(t, e) {
  let r = Ta(t, e);
  return r === !1 ? "" : t.charAt(r);
}
var qr = LB;
function _B(t, e, r) {
  for (let s = e; s < r; ++s) if (t.charAt(s) === `
`) return !0;
  return !1;
}
var fr = _B, ip = /* @__PURE__ */ new WeakMap();
function RB(t) {
  return ip.has(t) || ip.set(t, Er(t) && t.value[0] === "*" && /@(?:type|satisfies)\b/u.test(t.value)), ip.get(t);
}
var Z2 = RB, V2 = (t, e) => dl(t) || !fr(e, ke(t), De(t));
function qB(t) {
  return [K2, U2, G2, e5, VB, vm, Sm, z2, Y2, i5, r5, Am, J2, n5, W2, H2, wm, zB, p5, eb].some((e) => e(t));
}
function jB(t) {
  return [ZB, G2, U2, J2, vm, Sm, z2, Y2, H2, t5, s5, Am, l5, wm, c5, h5, d5, eb].some((e) => e(t));
}
function XB(t) {
  return [K2, vm, Sm, UB, KB, W2, Am, JB, HB, wm, u5].some((e) => e(t));
}
function Cn(t, e) {
  let r = (t.body || t.properties).find(({ type: s }) => s !== "EmptyStatement");
  r ? Ft(r, e) : dr(t, e);
}
function yd(t, e) {
  t.type === "BlockStatement" ? Cn(t, e) : Ft(t, e);
}
function ZB({ comment: t, followingNode: e }) {
  return e && Z2(t) ? (Ft(e, t), !0) : !1;
}
function vm({ comment: t, precedingNode: e, enclosingNode: r, followingNode: s, text: i }) {
  if ((r == null ? void 0 : r.type) !== "IfStatement" || !s) return !1;
  if (qr(i, De(t)) === ")") return ze(e, t), !0;
  if (e === r.consequent && s === r.alternate) {
    let n = Ta(i, De(r.consequent));
    if (ke(t) < n || r.alternate.type === "BlockStatement") return e.type === "BlockStatement" || V2(t, i) && !fr(i, ke(e), ke(t)) ? (ze(e, t), !0) : (dr(r, t), !0);
  }
  return s.type === "BlockStatement" ? (Cn(s, t), !0) : s.type === "IfStatement" ? (yd(s.consequent, t), !0) : r.consequent === s ? (Ft(s, t), !0) : !1;
}
function Sm({ comment: t, precedingNode: e, enclosingNode: r, followingNode: s, text: i }) {
  return (r == null ? void 0 : r.type) !== "WhileStatement" || !s ? !1 : qr(i, De(t)) === ")" ? (ze(e, t), !0) : s.type === "BlockStatement" ? (Cn(s, t), !0) : r.body === s ? (Ft(s, t), !0) : !1;
}
function z2({ comment: t, precedingNode: e, enclosingNode: r, followingNode: s }) {
  return (r == null ? void 0 : r.type) !== "TryStatement" && (r == null ? void 0 : r.type) !== "CatchClause" || !s ? !1 : r.type === "CatchClause" && e ? (ze(e, t), !0) : s.type === "BlockStatement" ? (Cn(s, t), !0) : s.type === "TryStatement" ? (yd(s.finalizer, t), !0) : s.type === "CatchClause" ? (yd(s.body, t), !0) : !1;
}
function VB({ comment: t, enclosingNode: e, followingNode: r }) {
  return Ve(e) && (r == null ? void 0 : r.type) === "Identifier" ? (Ft(e, t), !0) : !1;
}
function zB({ comment: t, enclosingNode: e, followingNode: r, options: s }) {
  return !s.experimentalTernaries || !((e == null ? void 0 : e.type) === "ConditionalExpression" || Ai(e)) ? !1 : (r == null ? void 0 : r.type) === "ConditionalExpression" || Ai(r) ? (dr(e, t), !0) : !1;
}
function U2({ comment: t, precedingNode: e, enclosingNode: r, followingNode: s, text: i, options: n }) {
  let a = e && !fr(i, De(e), ke(t));
  return (!e || !a) && ((r == null ? void 0 : r.type) === "ConditionalExpression" || Ai(r)) && s ? n.experimentalTernaries && r.alternate === s && !(Er(t) && !fr(n.originalText, ke(t), De(t))) ? (dr(r, t), !0) : (Ft(s, t), !0) : !1;
}
function UB({ comment: t, precedingNode: e, enclosingNode: r }) {
  return Gs(r) && r.shorthand && r.key === e && r.value.type === "AssignmentPattern" ? (ze(r.value.left, t), !0) : !1;
}
var YB = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
function Y2({ comment: t, precedingNode: e, enclosingNode: r, followingNode: s }) {
  if (YB.has(r == null ? void 0 : r.type)) {
    if (Ee(r.decorators) && (s == null ? void 0 : s.type) !== "Decorator") return ze(Fe(!1, r.decorators, -1), t), !0;
    if (r.body && s === r.body) return Cn(r.body, t), !0;
    if (s) {
      if (r.superClass && s === r.superClass && e && (e === r.id || e === r.typeParameters)) return ze(e, t), !0;
      for (let i of ["implements", "extends", "mixins"]) if (r[i] && s === r[i][0]) return e && (e === r.id || e === r.typeParameters || e === r.superClass) ? ze(e, t) : dr(r, t, i), !0;
    }
  }
  return !1;
}
var WB = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty", "TSParameterProperty"]);
function W2({ comment: t, precedingNode: e, enclosingNode: r, text: s }) {
  return r && e && qr(s, De(t)) === "(" && (r.type === "Property" || r.type === "TSDeclareMethod" || r.type === "TSAbstractMethodDefinition") && e.type === "Identifier" && r.key === e && qr(s, De(e)) !== ":" || (e == null ? void 0 : e.type) === "Decorator" && WB.has(r == null ? void 0 : r.type) && (dl(t) || t.placement === "ownLine") ? (ze(e, t), !0) : !1;
}
var GB = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
function HB({ comment: t, precedingNode: e, enclosingNode: r, text: s }) {
  return qr(s, De(t)) !== "(" ? !1 : e && GB.has(r == null ? void 0 : r.type) ? (ze(e, t), !0) : !1;
}
function JB({ comment: t, enclosingNode: e, text: r }) {
  if ((e == null ? void 0 : e.type) !== "ArrowFunctionExpression") return !1;
  let s = Ta(r, De(t));
  return s !== !1 && r.slice(s, s + 2) === "=>" ? (dr(e, t), !0) : !1;
}
function KB({ comment: t, enclosingNode: e, text: r }) {
  return qr(r, De(t)) !== ")" ? !1 : e && (tb(e) && Pt(e).length === 0 || ca(e) && Tr(e).length === 0) ? (dr(e, t), !0) : ((e == null ? void 0 : e.type) === "MethodDefinition" || (e == null ? void 0 : e.type) === "TSAbstractMethodDefinition") && Pt(e.value).length === 0 ? (dr(e.value, t), !0) : !1;
}
function e5({ comment: t, precedingNode: e, enclosingNode: r, followingNode: s, text: i }) {
  return (e == null ? void 0 : e.type) === "ComponentTypeParameter" && ((r == null ? void 0 : r.type) === "DeclareComponent" || (r == null ? void 0 : r.type) === "ComponentTypeAnnotation") && (s == null ? void 0 : s.type) !== "ComponentTypeParameter" || ((e == null ? void 0 : e.type) === "ComponentParameter" || (e == null ? void 0 : e.type) === "RestElement") && (r == null ? void 0 : r.type) === "ComponentDeclaration" && qr(i, De(t)) === ")" ? (ze(e, t), !0) : !1;
}
function G2({ comment: t, precedingNode: e, enclosingNode: r, followingNode: s, text: i }) {
  return (e == null ? void 0 : e.type) === "FunctionTypeParam" && (r == null ? void 0 : r.type) === "FunctionTypeAnnotation" && (s == null ? void 0 : s.type) !== "FunctionTypeParam" || ((e == null ? void 0 : e.type) === "Identifier" || (e == null ? void 0 : e.type) === "AssignmentPattern" || (e == null ? void 0 : e.type) === "ObjectPattern" || (e == null ? void 0 : e.type) === "ArrayPattern" || (e == null ? void 0 : e.type) === "RestElement" || (e == null ? void 0 : e.type) === "TSParameterProperty") && tb(r) && qr(i, De(t)) === ")" ? (ze(e, t), !0) : !Er(t) && ((r == null ? void 0 : r.type) === "FunctionDeclaration" || (r == null ? void 0 : r.type) === "FunctionExpression" || (r == null ? void 0 : r.type) === "ObjectMethod") && (s == null ? void 0 : s.type) === "BlockStatement" && r.body === s && Ta(i, De(t)) === ke(s) ? (Cn(s, t), !0) : !1;
}
function H2({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === "LabeledStatement" ? (Ft(e, t), !0) : !1;
}
function wm({ comment: t, enclosingNode: e }) {
  return ((e == null ? void 0 : e.type) === "ContinueStatement" || (e == null ? void 0 : e.type) === "BreakStatement") && !e.label ? (ze(e, t), !0) : !1;
}
function t5({ comment: t, precedingNode: e, enclosingNode: r }) {
  return Ae(r) && e && r.callee === e && r.arguments.length > 0 ? (Ft(r.arguments[0], t), !0) : !1;
}
function r5({ comment: t, precedingNode: e, enclosingNode: r, followingNode: s }) {
  return wi(r) ? (ec(t) && (s.prettierIgnore = !0, t.unignore = !0), e ? (ze(e, t), !0) : !1) : (wi(s) && ec(t) && (s.types[0].prettierIgnore = !0, t.unignore = !0), !1);
}
function s5({ comment: t, enclosingNode: e }) {
  return Gs(e) ? (Ft(e, t), !0) : !1;
}
function Am({ comment: t, enclosingNode: e, ast: r, isLastComment: s }) {
  var i;
  return ((i = r == null ? void 0 : r.body) == null ? void 0 : i.length) === 0 ? (s ? dr(r, t) : Ft(r, t), !0) : (e == null ? void 0 : e.type) === "Program" && e.body.length === 0 && !Ee(e.directives) ? (s ? dr(e, t) : Ft(e, t), !0) : !1;
}
function i5({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === "ForInStatement" || (e == null ? void 0 : e.type) === "ForOfStatement" ? (Ft(e, t), !0) : !1;
}
function J2({ comment: t, precedingNode: e, enclosingNode: r, text: s }) {
  if ((r == null ? void 0 : r.type) === "ImportSpecifier" || (r == null ? void 0 : r.type) === "ExportSpecifier") return Ft(r, t), !0;
  let i = (e == null ? void 0 : e.type) === "ImportSpecifier" && (r == null ? void 0 : r.type) === "ImportDeclaration", n = (e == null ? void 0 : e.type) === "ExportSpecifier" && (r == null ? void 0 : r.type) === "ExportNamedDeclaration";
  return (i || n) && cr(s, De(t)) ? (ze(e, t), !0) : !1;
}
function n5({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === "AssignmentPattern" ? (Ft(e, t), !0) : !1;
}
var a5 = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), o5 = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
function l5({ comment: t, enclosingNode: e, followingNode: r }) {
  return a5.has(e == null ? void 0 : e.type) && r && (o5.has(r.type) || Er(t)) ? (Ft(r, t), !0) : !1;
}
function u5({ comment: t, enclosingNode: e, followingNode: r, text: s }) {
  return !r && ((e == null ? void 0 : e.type) === "TSMethodSignature" || (e == null ? void 0 : e.type) === "TSDeclareFunction" || (e == null ? void 0 : e.type) === "TSAbstractMethodDefinition") && qr(s, De(t)) === ";" ? (ze(e, t), !0) : !1;
}
function K2({ comment: t, enclosingNode: e, followingNode: r }) {
  if (ec(t) && (e == null ? void 0 : e.type) === "TSMappedType" && r === e.key) return e.prettierIgnore = !0, t.unignore = !0, !0;
}
function eb({ comment: t, precedingNode: e, enclosingNode: r }) {
  if ((r == null ? void 0 : r.type) === "TSMappedType" && !e) return dr(r, t), !0;
}
function c5({ comment: t, enclosingNode: e, followingNode: r }) {
  return !e || e.type !== "SwitchCase" || e.test || !r || r !== e.consequent[0] ? !1 : (r.type === "BlockStatement" && dl(t) ? Cn(r, t) : dr(e, t), !0);
}
function h5({ comment: t, precedingNode: e, enclosingNode: r, followingNode: s }) {
  return wi(e) && ((r.type === "TSArrayType" || r.type === "ArrayTypeAnnotation") && !s || Om(r)) ? (ze(Fe(!1, e.types, -1), t), !0) : !1;
}
function p5({ comment: t, enclosingNode: e, precedingNode: r, followingNode: s }) {
  if (((e == null ? void 0 : e.type) === "ObjectPattern" || (e == null ? void 0 : e.type) === "ArrayPattern") && (s == null ? void 0 : s.type) === "TSTypeAnnotation") return r ? ze(r, t) : dr(e, t), !0;
}
function d5({ comment: t, precedingNode: e, enclosingNode: r, followingNode: s, text: i }) {
  return !s && (r == null ? void 0 : r.type) === "UnaryExpression" && ((e == null ? void 0 : e.type) === "LogicalExpression" || (e == null ? void 0 : e.type) === "BinaryExpression") && fr(i, ke(r.argument), ke(e.right)) && V2(t, i) && !fr(i, ke(e.right), ke(t)) ? (ze(e.right, t), !0) : !1;
}
var tb = Pe(["ArrowFunctionExpression", "FunctionExpression", "FunctionDeclaration", "ObjectMethod", "ClassMethod", "TSDeclareFunction", "TSCallSignatureDeclaration", "TSConstructSignatureDeclaration", "TSMethodSignature", "TSConstructorType", "TSFunctionType", "TSDeclareMethod"]), f5 = /* @__PURE__ */ new Set(["EmptyStatement", "TemplateElement", "TSEmptyBodyFunctionExpression", "ChainExpression"]);
function m5(t) {
  return !f5.has(t.type);
}
function g5(t, e) {
  var r;
  if ((e.parser === "typescript" || e.parser === "flow" || e.parser === "hermes" || e.parser === "acorn" || e.parser === "oxc" || e.parser === "oxc-ts" || e.parser === "espree" || e.parser === "meriyah" || e.parser === "__babel_estree") && t.type === "MethodDefinition" && ((r = t.value) == null ? void 0 : r.type) === "FunctionExpression" && Pt(t.value).length === 0 && !t.value.returnType && !Ee(t.value.typeParameters) && t.value.body) return [...t.decorators || [], t.key, t.value.body];
}
function rb(t) {
  let { node: e, parent: r } = t;
  return (dt(e) || r && (r.type === "JSXSpreadAttribute" || r.type === "JSXSpreadChild" || wi(r) || (r.type === "ClassDeclaration" || r.type === "ClassExpression") && r.superClass === e)) && (!th(e) || wi(r));
}
function y5(t, { parser: e }) {
  if (e === "flow" || e === "hermes" || e === "babel-flow") return t = xt(!1, t, /[\s(]/gu, ""), t === "" || t === "/*" || t === "/*::";
}
function O5(t) {
  switch (t) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
var jt = Symbol("MODE_BREAK"), Hr = Symbol("MODE_FLAT"), Vn = Symbol("cursor"), Od = Symbol("DOC_FILL_PRINTED_LENGTH");
function sb() {
  return { value: "", length: 0, queue: [] };
}
function x5(t, e) {
  return xd(t, { type: "indent" }, e);
}
function D5(t, e, r) {
  return e === Number.NEGATIVE_INFINITY ? t.root || sb() : e < 0 ? xd(t, { type: "dedent" }, r) : e ? e.type === "root" ? { ...t, root: t } : xd(t, { type: typeof e == "string" ? "stringAlign" : "numberAlign", n: e }, r) : t;
}
function xd(t, e, r) {
  let s = e.type === "dedent" ? t.queue.slice(0, -1) : [...t.queue, e], i = "", n = 0, a = 0, l = 0;
  for (let x of s) switch (x.type) {
    case "indent":
      d(), r.useTabs ? c(1) : p(r.tabWidth);
      break;
    case "stringAlign":
      d(), i += x.n, n += x.n.length;
      break;
    case "numberAlign":
      a += 1, l += x.n;
      break;
    default:
      throw new Error(`Unexpected type '${x.type}'`);
  }
  return y(), { ...t, value: i, length: n, queue: s };
  function c(x) {
    i += "	".repeat(x), n += r.tabWidth * x;
  }
  function p(x) {
    i += " ".repeat(x), n += x;
  }
  function d() {
    r.useTabs ? m() : y();
  }
  function m() {
    a > 0 && c(a), g();
  }
  function y() {
    l > 0 && p(l), g();
  }
  function g() {
    a = 0, l = 0;
  }
}
function Dd(t) {
  let e = 0, r = 0, s = t.length;
  e: for (; s--; ) {
    let i = t[s];
    if (i === Vn) {
      r++;
      continue;
    }
    for (let n = i.length - 1; n >= 0; n--) {
      let a = i[n];
      if (a === " " || a === "	") e++;
      else {
        t[s] = i.slice(0, n + 1);
        break e;
      }
    }
  }
  if (e > 0 || r > 0) for (t.length = s + 1; r-- > 0; ) t.push(Vn);
  return e;
}
function Wl(t, e, r, s, i, n) {
  var p;
  if (r === Number.POSITIVE_INFINITY) return !0;
  let a = e.length, l = [t], c = [];
  for (; r >= 0; ) {
    if (l.length === 0) {
      if (a === 0) return !0;
      l.push(e[--a]);
      continue;
    }
    let { mode: d, doc: m } = l.pop(), y = Ni(m);
    switch (y) {
      case Dn:
        c.push(m), r -= aa(m);
        break;
      case Is:
      case Bi: {
        let g = y === Is ? m : m.parts, x = (p = m[Od]) != null ? p : 0;
        for (let v = g.length - 1; v >= x; v--) l.push({ mode: d, doc: g[v] });
        break;
      }
      case bn:
      case vn:
      case wn:
      case Hs:
        l.push({ mode: d, doc: m.contents });
        break;
      case Sn:
        r += Dd(c);
        break;
      case Ar: {
        if (n && m.break) return !1;
        let g = m.break ? jt : d, x = m.expandedStates && g === jt ? Fe(!1, m.expandedStates, -1) : m.contents;
        l.push({ mode: g, doc: x });
        break;
      }
      case us: {
        let g = (m.groupId ? i[m.groupId] || Hr : d) === jt ? m.breakContents : m.flatContents;
        g && l.push({ mode: d, doc: g });
        break;
      }
      case Jt:
        if (d === jt || m.hard) return !0;
        m.soft || (c.push(" "), r--);
        break;
      case An:
        s = !0;
        break;
      case Ii:
        if (s) return !1;
        break;
    }
  }
  return !1;
}
function ib(t, e) {
  var y;
  let r = {}, s = e.printWidth, i = O5(e.endOfLine), n = 0, a = [{ ind: sb(), mode: jt, doc: t }], l = [], c = !1, p = [], d = 0;
  for (DB(t); a.length > 0; ) {
    let { ind: g, mode: x, doc: v } = a.pop();
    switch (Ni(v)) {
      case Dn: {
        let w = i !== `
` ? xt(!1, v, `
`, i) : v;
        l.push(w), a.length > 0 && (n += aa(w));
        break;
      }
      case Is:
        for (let w = v.length - 1; w >= 0; w--) a.push({ ind: g, mode: x, doc: v[w] });
        break;
      case Ca:
        if (d >= 2) throw new Error("There are too many 'cursor' in doc.");
        l.push(Vn), d++;
        break;
      case bn:
        a.push({ ind: x5(g, e), mode: x, doc: v.contents });
        break;
      case vn:
        a.push({ ind: D5(g, v.n, e), mode: x, doc: v.contents });
        break;
      case Sn:
        n -= Dd(l);
        break;
      case Ar:
        switch (x) {
          case Hr:
            if (!c) {
              a.push({ ind: g, mode: v.break ? jt : Hr, doc: v.contents });
              break;
            }
          case jt: {
            c = !1;
            let w = { ind: g, mode: Hr, doc: v.contents }, C = s - n, b = p.length > 0;
            if (!v.break && Wl(w, a, C, b, r)) a.push(w);
            else if (v.expandedStates) {
              let k = Fe(!1, v.expandedStates, -1);
              if (v.break) {
                a.push({ ind: g, mode: jt, doc: k });
                break;
              } else for (let Q = 1; Q < v.expandedStates.length + 1; Q++) if (Q >= v.expandedStates.length) {
                a.push({ ind: g, mode: jt, doc: k });
                break;
              } else {
                let F = v.expandedStates[Q], $ = { ind: g, mode: Hr, doc: F };
                if (Wl($, a, C, b, r)) {
                  a.push($);
                  break;
                }
              }
            } else a.push({ ind: g, mode: jt, doc: v.contents });
            break;
          }
        }
        v.id && (r[v.id] = Fe(!1, a, -1).mode);
        break;
      case Bi: {
        let w = s - n, C = (y = v[Od]) != null ? y : 0, { parts: b } = v, k = b.length - C;
        if (k === 0) break;
        let Q = b[C + 0], F = b[C + 1], $ = { ind: g, mode: Hr, doc: Q }, N = { ind: g, mode: jt, doc: Q }, _ = Wl($, [], w, p.length > 0, r, !0);
        if (k === 1) {
          _ ? a.push($) : a.push(N);
          break;
        }
        let W = { ind: g, mode: Hr, doc: F }, V = { ind: g, mode: jt, doc: F };
        if (k === 2) {
          _ ? a.push(W, $) : a.push(V, N);
          break;
        }
        let j = b[C + 2], B = { ind: g, mode: x, doc: { ...v, [Od]: C + 2 } };
        Wl({ ind: g, mode: Hr, doc: [Q, F, j] }, [], w, p.length > 0, r, !0) ? a.push(B, W, $) : _ ? a.push(B, V, $) : a.push(B, V, N);
        break;
      }
      case us:
      case wn: {
        let w = v.groupId ? r[v.groupId] : x;
        if (w === jt) {
          let C = v.type === us ? v.breakContents : v.negate ? v.contents : X(v.contents);
          C && a.push({ ind: g, mode: x, doc: C });
        }
        if (w === Hr) {
          let C = v.type === us ? v.flatContents : v.negate ? X(v.contents) : v.contents;
          C && a.push({ ind: g, mode: x, doc: C });
        }
        break;
      }
      case An:
        p.push({ ind: g, mode: x, doc: v.contents });
        break;
      case Ii:
        p.length > 0 && a.push({ ind: g, mode: x, doc: q2 });
        break;
      case Jt:
        switch (x) {
          case Hr:
            if (v.hard) c = !0;
            else {
              v.soft || (l.push(" "), n += 1);
              break;
            }
          case jt:
            if (p.length > 0) {
              a.push({ ind: g, mode: x, doc: v }, ...p.reverse()), p.length = 0;
              break;
            }
            v.literal ? g.root ? (l.push(i, g.root.value), n = g.root.length) : (l.push(i), n = 0) : (n -= Dd(l), l.push(i + g.value), n = g.length);
            break;
        }
        break;
      case Hs:
        a.push({ ind: g, mode: x, doc: v.contents });
        break;
      case Js:
        break;
      default:
        throw new Mo(v);
    }
    a.length === 0 && p.length > 0 && (a.push(...p.reverse()), p.length = 0);
  }
  let m = l.indexOf(Vn);
  if (m !== -1) {
    let g = l.indexOf(Vn, m + 1);
    if (g === -1) return { formatted: l.filter((C) => C !== Vn).join("") };
    let x = l.slice(0, m).join(""), v = l.slice(m + 1, g).join(""), w = l.slice(g + 1).join("");
    return { formatted: x + v + w, cursorNodeStart: x.length, cursorNodeText: v };
  }
  return { formatted: l.join("") };
}
function b5(t, e, r = 0) {
  let s = 0;
  for (let i = r; i < t.length; ++i) t[i] === "	" ? s = s + e - s % e : s++;
  return s;
}
var v5 = b5;
function S5(t, e) {
  let r = t.lastIndexOf(`
`);
  return r === -1 ? 0 : v5(t.slice(r + 1).match(/^[\t ]*/u)[0], e);
}
var w5 = S5;
function nb(t, e, r) {
  let { node: s } = t;
  if (s.type === "TemplateLiteral" && T5(t)) {
    let c = C5(t, e, r);
    if (c) return c;
  }
  let i = "expressions";
  s.type === "TSTemplateLiteralType" && (i = "types");
  let n = [], a = t.map(r, i);
  n.push(Ns, "`");
  let l = 0;
  return t.each(({ index: c, node: p }) => {
    if (n.push(r()), p.tail) return;
    let { tabWidth: d } = e, m = p.value.raw, y = m.includes(`
`) ? w5(m, d) : l;
    l = y;
    let g = a[c], x = s[i][c], v = fr(e.originalText, De(p), ke(s.quasis[c + 1]));
    if (!v) {
      let C = ib(g, { ...e, printWidth: Number.POSITIVE_INFINITY }).formatted;
      C.includes(`
`) ? v = !0 : g = C;
    }
    v && (z(x) || x.type === "Identifier" || Ve(x) || x.type === "ConditionalExpression" || x.type === "SequenceExpression" || ss(x) || Bs(x)) && (g = [X([R, g]), R]);
    let w = y === 0 && m.endsWith(`
`) ? ps(Number.NEGATIVE_INFINITY, g) : PB(g, y, d);
    n.push(I(["${", w, Ns, "}"]));
  }, "quasis"), n.push("`"), n;
}
function A5(t, e, r) {
  var l, c;
  let s = r("quasi"), { node: i } = t, n = "", a = nn(i.quasi, te.Leading)[0];
  return a && (fr(e.originalText, De((c = (l = i.typeArguments) != null ? l : i.typeParameters) != null ? c : i.tag), ke(a)) ? n = R : n = " "), fl(s.label && { tagged: !0, ...s.label }, [r("tag"), r(i.typeArguments ? "typeArguments" : "typeParameters"), n, Ns, s]);
}
function C5(t, e, r) {
  let { node: s } = t, i = s.quasis[0].value.raw.trim().split(/\s*\|\s*/u);
  if (i.length > 1 || i.some((n) => n.length > 0)) {
    e.__inJestEach = !0;
    let n = t.map(r, "expressions");
    e.__inJestEach = !1;
    let a = [], l = n.map((y) => "${" + ib(y, { ...e, printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" }).formatted + "}"), c = [{ hasLineBreak: !1, cells: [] }];
    for (let y = 1; y < s.quasis.length; y++) {
      let g = Fe(!1, c, -1), x = l[y - 1];
      g.cells.push(x), x.includes(`
`) && (g.hasLineBreak = !0), s.quasis[y].value.raw.includes(`
`) && c.push({ hasLineBreak: !1, cells: [] });
    }
    let p = Math.max(i.length, ...c.map((y) => y.cells.length)), d = Array.from({ length: p }).fill(0), m = [{ cells: i }, ...c.filter((y) => y.cells.length > 0)];
    for (let { cells: y } of m.filter((g) => !g.hasLineBreak)) for (let [g, x] of y.entries()) d[g] = Math.max(d[g], aa(x));
    return a.push(Ns, "`", X([q, be(q, m.map((y) => be(" | ", y.cells.map((g, x) => y.hasLineBreak ? g : g + " ".repeat(d[x] - aa(g))))))]), q, "`"), a;
  }
}
function E5(t, e) {
  let { node: r } = t, s = e();
  return z(r) && (s = I([X([R, s]), R])), ["${", s, Ns, "}"];
}
function Cm(t, e) {
  return t.map((r) => E5(r, e), "expressions");
}
function ab(t, e) {
  return Ea(t, (r) => typeof r == "string" ? e ? xt(!1, r, /(\\*)`/gu, "$1$1\\`") : ob(r) : r);
}
function ob(t) {
  return xt(!1, t, /([\\`]|\$\{)/gu, String.raw`\$1`);
}
function T5({ node: t, parent: e }) {
  let r = /^[fx]?(?:describe|it|test)$/u;
  return e.type === "TaggedTemplateExpression" && e.quasi === t && e.tag.type === "MemberExpression" && e.tag.property.type === "Identifier" && e.tag.property.name === "each" && (e.tag.object.type === "Identifier" && r.test(e.tag.object.name) || e.tag.object.type === "MemberExpression" && e.tag.object.property.type === "Identifier" && (e.tag.object.property.name === "only" || e.tag.object.property.name === "skip") && e.tag.object.object.type === "Identifier" && r.test(e.tag.object.object.name));
}
var bd = [(t, e) => t.type === "ObjectExpression" && e === "properties", (t, e) => t.type === "CallExpression" && t.callee.type === "Identifier" && t.callee.name === "Component" && e === "arguments", (t, e) => t.type === "Decorator" && e === "expression"];
function k5(t) {
  let e = (s) => s.type === "TemplateLiteral", r = (s, i) => Gs(s) && !s.computed && s.key.type === "Identifier" && s.key.name === "styles" && i === "value";
  return t.match(e, (s, i) => St(s) && i === "elements", r, ...bd) || t.match(e, r, ...bd);
}
function P5(t) {
  return t.match((e) => e.type === "TemplateLiteral", (e, r) => Gs(e) && !e.computed && e.key.type === "Identifier" && e.key.name === "template" && r === "value", ...bd);
}
function np(t, e) {
  return z(t, te.Block | te.Leading, ({ value: r }) => r === ` ${e} `);
}
function lb({ node: t, parent: e }, r) {
  return np(t, r) || F5(e) && np(e, r) || e.type === "ExpressionStatement" && np(e, r);
}
function F5(t) {
  return t.type === "AsConstExpression" || t.type === "TSAsExpression" && t.typeAnnotation.type === "TSTypeReference" && t.typeAnnotation.typeName.type === "Identifier" && t.typeAnnotation.typeName.name === "const";
}
async function $5(t, e, r) {
  let { node: s } = r, i = s.quasis.map((d) => d.value.raw), n = 0, a = i.reduce((d, m, y) => y === 0 ? m : d + "@prettier-placeholder-" + n++ + "-id" + m, ""), l = await t(a, { parser: "scss" }), c = Cm(r, e), p = Q5(l, c);
  if (!p) throw new Error("Couldn't insert all the expressions");
  return ["`", X([q, p]), R, "`"];
}
function Q5(t, e) {
  if (!Ee(e)) return t;
  let r = 0, s = Ea(Dm(t), (i) => typeof i != "string" || !i.includes("@prettier-placeholder") ? i : i.split(/@prettier-placeholder-(\d+)-id/u).map((n, a) => a % 2 === 0 ? ln(n) : (r++, e[n])));
  return e.length === r ? s : null;
}
function B5({ node: t, parent: e, grandparent: r }) {
  return r && t.quasis && e.type === "JSXExpressionContainer" && r.type === "JSXElement" && r.openingElement.name.name === "style" && r.openingElement.attributes.some((s) => s.type === "JSXAttribute" && s.name.name === "jsx") || (e == null ? void 0 : e.type) === "TaggedTemplateExpression" && e.tag.type === "Identifier" && e.tag.name === "css" || (e == null ? void 0 : e.type) === "TaggedTemplateExpression" && e.tag.type === "MemberExpression" && e.tag.object.name === "css" && (e.tag.property.name === "global" || e.tag.property.name === "resolve");
}
function Gl(t) {
  return t.type === "Identifier" && t.name === "styled";
}
function EO(t) {
  return /^[A-Z]/u.test(t.object.name) && t.property.name === "extend";
}
function I5({ parent: t }) {
  if (!t || t.type !== "TaggedTemplateExpression") return !1;
  let e = t.tag.type === "ParenthesizedExpression" ? t.tag.expression : t.tag;
  switch (e.type) {
    case "MemberExpression":
      return Gl(e.object) || EO(e);
    case "CallExpression":
      return Gl(e.callee) || e.callee.type === "MemberExpression" && (e.callee.object.type === "MemberExpression" && (Gl(e.callee.object.object) || EO(e.callee.object)) || e.callee.object.type === "CallExpression" && Gl(e.callee.object.callee));
    case "Identifier":
      return e.name === "css";
    default:
      return !1;
  }
}
function N5({ parent: t, grandparent: e }) {
  return (e == null ? void 0 : e.type) === "JSXAttribute" && t.type === "JSXExpressionContainer" && e.name.type === "JSXIdentifier" && e.name.name === "css";
}
function M5(t) {
  if (B5(t) || I5(t) || N5(t) || k5(t)) return $5;
}
var L5 = M5;
async function _5(t, e, r) {
  let { node: s } = r, i = s.quasis.length, n = Cm(r, e), a = [];
  for (let l = 0; l < i; l++) {
    let c = s.quasis[l], p = l === 0, d = l === i - 1, m = c.value.cooked, y = m.split(`
`), g = y.length, x = n[l], v = g > 2 && y[0].trim() === "" && y[1].trim() === "", w = g > 2 && y[g - 1].trim() === "" && y[g - 2].trim() === "", C = y.every((k) => /^\s*(?:#[^\n\r]*)?$/u.test(k));
    if (!d && /#[^\n\r]*$/u.test(y[g - 1])) return null;
    let b = null;
    C ? b = R5(y) : b = await t(m, { parser: "graphql" }), b ? (b = ab(b, !1), !p && v && a.push(""), a.push(b), !d && w && a.push("")) : !p && !d && v && a.push(""), x && a.push(x);
  }
  return ["`", X([q, be(q, a)]), q, "`"];
}
function R5(t) {
  let e = [], r = !1, s = t.map((i) => i.trim());
  for (let [i, n] of s.entries()) n !== "" && (s[i - 1] === "" && r ? e.push([q, n]) : e.push(n), r = !0);
  return e.length === 0 ? null : be(q, e);
}
function q5({ node: t, parent: e }) {
  return lb({ node: t, parent: e }, "GraphQL") || e && (e.type === "TaggedTemplateExpression" && (e.tag.type === "MemberExpression" && e.tag.object.name === "graphql" && e.tag.property.name === "experimental" || e.tag.type === "Identifier" && (e.tag.name === "gql" || e.tag.name === "graphql")) || e.type === "CallExpression" && e.callee.type === "Identifier" && e.callee.name === "graphql");
}
function j5(t) {
  if (q5(t)) return _5;
}
var X5 = j5, ap = 0;
async function ub(t, e, r, s, i) {
  let { node: n } = s, a = ap;
  ap = ap + 1 >>> 0;
  let l = (C) => `PRETTIER_HTML_PLACEHOLDER_${C}_${a}_IN_JS`, c = n.quasis.map((C, b, k) => b === k.length - 1 ? C.value.cooked : C.value.cooked + l(b)).join(""), p = Cm(s, r), d = new RegExp(l(String.raw`(\d+)`), "gu"), m = 0, y = await e(c, { parser: t, __onHtmlRoot(C) {
    m = C.children.length;
  } }), g = Ea(y, (C) => {
    if (typeof C != "string") return C;
    let b = [], k = C.split(d);
    for (let Q = 0; Q < k.length; Q++) {
      let F = k[Q];
      if (Q % 2 === 0) {
        F && (F = ob(F), i.__embeddedInHtml && (F = xt(!1, F, /<\/(?=script\b)/giu, String.raw`<\/`)), b.push(F));
        continue;
      }
      let $ = Number(F);
      b.push(p[$]);
    }
    return b;
  }), x = /^\s/u.test(c) ? " " : "", v = /\s$/u.test(c) ? " " : "", w = i.htmlWhitespaceSensitivity === "ignore" ? q : x && v ? K : null;
  return w ? I(["`", X([w, I(g)]), w, "`"]) : fl({ hug: !1 }, I(["`", x, m > 1 ? X(I(g)) : I(g), v, "`"]));
}
function Z5(t) {
  return lb(t, "HTML") || t.match((e) => e.type === "TemplateLiteral", (e, r) => e.type === "TaggedTemplateExpression" && e.tag.type === "Identifier" && e.tag.name === "html" && r === "quasi");
}
var V5 = ub.bind(void 0, "html"), z5 = ub.bind(void 0, "angular");
function U5(t) {
  if (Z5(t)) return V5;
  if (P5(t)) return z5;
}
var Y5 = U5;
async function W5(t, e, r) {
  let { node: s } = r, i = xt(!1, s.quasis[0].value.raw, /((?:\\\\)*)\\`/gu, (c, p) => "\\".repeat(p.length / 2) + "`"), n = G5(i), a = n !== "";
  a && (i = xt(!1, i, new RegExp(`^${n}`, "gmu"), ""));
  let l = ab(await t(i, { parser: "markdown", __inJsTemplate: !0 }), !0);
  return ["`", a ? X([R, l]) : [j2, TB(l)], R, "`"];
}
function G5(t) {
  let e = t.match(/^([^\S\n]*)\S/mu);
  return e === null ? "" : e[1];
}
function H5(t) {
  if (J5(t)) return W5;
}
function J5({ node: t, parent: e }) {
  return (e == null ? void 0 : e.type) === "TaggedTemplateExpression" && t.quasis.length === 1 && e.tag.type === "Identifier" && (e.tag.name === "md" || e.tag.name === "markdown");
}
var K5 = H5;
function e8(t) {
  let { node: e } = t;
  if (e.type !== "TemplateLiteral" || t8(e)) return;
  let r;
  for (let s of [L5, X5, Y5, K5]) if (r = s(t), !!r) return e.quasis.length === 1 && e.quasis[0].value.raw.trim() === "" ? "``" : async (...i) => {
    let n = await r(...i);
    return n && fl({ embed: !0, ...n.label }, n);
  };
}
function t8({ quasis: t }) {
  return t.some(({ value: { cooked: e } }) => e === null);
}
var r8 = e8, s8 = /\*\/$/, i8 = /^\/\*\*?/, cb = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, n8 = /(^|\s+)\/\/([^\n\r]*)/g, TO = /^(\r?\n)+/, a8 = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g, kO = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g, o8 = /(\r?\n|^) *\* ?/g, hb = [];
function l8(t) {
  let e = t.match(cb);
  return e ? e[0].trimStart() : "";
}
function u8(t) {
  let e = t.match(cb), r = e == null ? void 0 : e[0];
  return r == null ? t : t.slice(r.length);
}
function c8(t) {
  let e = `
`;
  t = xt(!1, t.replace(i8, "").replace(s8, ""), o8, "$1");
  let r = "";
  for (; r !== t; ) r = t, t = xt(!1, t, a8, `${e}$1 $2${e}`);
  t = t.replace(TO, "").trimEnd();
  let s = /* @__PURE__ */ Object.create(null), i = xt(!1, t, kO, "").replace(TO, "").trimEnd(), n;
  for (; n = kO.exec(t); ) {
    let a = xt(!1, n[2], n8, "");
    if (typeof s[n[1]] == "string" || Array.isArray(s[n[1]])) {
      let l = s[n[1]];
      s[n[1]] = [...hb, ...Array.isArray(l) ? l : [l], a];
    } else s[n[1]] = a;
  }
  return { comments: i, pragmas: s };
}
function h8({ comments: t = "", pragmas: e = {} }) {
  let r = `
`, s = "/**", i = " *", n = " */", a = Object.keys(e), l = a.flatMap((p) => PO(p, e[p])).map((p) => `${i} ${p}${r}`).join("");
  if (!t) {
    if (a.length === 0) return "";
    if (a.length === 1 && !Array.isArray(e[a[0]])) {
      let p = e[a[0]];
      return `${s} ${PO(a[0], p)[0]}${n}`;
    }
  }
  let c = t.split(r).map((p) => `${i} ${p}`).join(r) + r;
  return s + r + (t ? c : "") + (t && a.length > 0 ? i + r : "") + l + n;
}
function PO(t, e) {
  return [...hb, ...Array.isArray(e) ? e : [e]].map((r) => `@${t} ${r}`.trim());
}
var p8 = "format";
function d8(t) {
  if (!t.startsWith("#!")) return "";
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var f8 = d8;
function m8(t) {
  let e = f8(t);
  e && (t = t.slice(e.length + 1));
  let r = l8(t), { pragmas: s, comments: i } = c8(r);
  return { shebang: e, text: t, pragmas: s, comments: i };
}
function g8(t) {
  let { shebang: e, text: r, pragmas: s, comments: i } = m8(t), n = u8(r), a = h8({ pragmas: { [p8]: "", ...s }, comments: i.trimStart() });
  return (e ? `${e}
` : "") + a + (n.startsWith(`
`) ? `
` : `

`) + n;
}
function y8(t, e) {
  let { originalText: r, [Symbol.for("comments")]: s, locStart: i, locEnd: n, [Symbol.for("printedComments")]: a } = e, { node: l } = t, c = i(l), p = n(l);
  for (let d of s) i(d) >= c && n(d) <= p && a.add(d);
  return r.slice(c, p);
}
var O8 = y8;
function vd(t, e) {
  var r, s, i, n, a, l, c, p, d;
  if (t.isRoot) return !1;
  let { node: m, key: y, parent: g } = t;
  if (e.__isInHtmlInterpolation && !e.bracketSpacing && v8(m) && lo(t)) return !0;
  if (x8(m)) return !1;
  if (m.type === "Identifier") {
    if ((r = m.extra) != null && r.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(m.name) || y === "left" && (m.name === "async" && !g.await || m.name === "let") && g.type === "ForOfStatement") return !0;
    if (m.name === "let") {
      let x = (s = t.findAncestor((v) => v.type === "ForOfStatement")) == null ? void 0 : s.left;
      if (x && Bt(x, (v) => v === m)) return !0;
    }
    if (y === "object" && m.name === "let" && g.type === "MemberExpression" && g.computed && !g.optional) {
      let x = t.findAncestor((w) => w.type === "ExpressionStatement" || w.type === "ForStatement" || w.type === "ForInStatement"), v = x ? x.type === "ExpressionStatement" ? x.expression : x.type === "ForStatement" ? x.init : x.left : void 0;
      if (v && Bt(v, (w) => w === m)) return !0;
    }
    if (y === "expression") switch (m.name) {
      case "await":
      case "interface":
      case "module":
      case "using":
      case "yield":
      case "let":
      case "component":
      case "hook":
      case "type": {
        let x = t.findAncestor((v) => !ss(v));
        if (x !== g && x.type === "ExpressionStatement") return !0;
      }
    }
    return !1;
  }
  if (m.type === "ObjectExpression" || m.type === "FunctionExpression" || m.type === "ClassExpression" || m.type === "DoExpression") {
    let x = (i = t.findAncestor((v) => v.type === "ExpressionStatement")) == null ? void 0 : i.expression;
    if (x && Bt(x, (v) => v === m)) return !0;
  }
  if (m.type === "ObjectExpression") {
    let x = (n = t.findAncestor((v) => v.type === "ArrowFunctionExpression")) == null ? void 0 : n.body;
    if (x && x.type !== "SequenceExpression" && x.type !== "AssignmentExpression" && Bt(x, (v) => v === m)) return !0;
  }
  switch (g.type) {
    case "ParenthesizedExpression":
      return !1;
    case "ClassDeclaration":
    case "ClassExpression":
      if (y === "superClass" && (m.type === "ArrowFunctionExpression" || m.type === "AssignmentExpression" || m.type === "AwaitExpression" || m.type === "BinaryExpression" || m.type === "ConditionalExpression" || m.type === "LogicalExpression" || m.type === "NewExpression" || m.type === "ObjectExpression" || m.type === "SequenceExpression" || m.type === "TaggedTemplateExpression" || m.type === "UnaryExpression" || m.type === "UpdateExpression" || m.type === "YieldExpression" || m.type === "TSNonNullExpression" || m.type === "ClassExpression" && Ee(m.decorators))) return !0;
      break;
    case "ExportDefaultDeclaration":
      return pb(t, e) || m.type === "SequenceExpression";
    case "Decorator":
      if (y === "expression" && !w8(m)) return !0;
      break;
    case "TypeAnnotation":
      if (t.match(void 0, void 0, (x, v) => v === "returnType" && x.type === "ArrowFunctionExpression") && b8(m)) return !0;
      break;
    case "BinaryExpression":
      if (y === "left" && (g.operator === "in" || g.operator === "instanceof") && m.type === "UnaryExpression") return !0;
      break;
    case "VariableDeclarator":
      if (y === "init" && t.match(void 0, void 0, (x, v) => v === "declarations" && x.type === "VariableDeclaration", (x, v) => v === "left" && x.type === "ForInStatement")) return !0;
      break;
  }
  switch (m.type) {
    case "UpdateExpression":
      if (g.type === "UnaryExpression") return m.prefix && (m.operator === "++" && g.operator === "+" || m.operator === "--" && g.operator === "-");
    case "UnaryExpression":
      switch (g.type) {
        case "UnaryExpression":
          return m.operator === g.operator && (m.operator === "+" || m.operator === "-");
        case "BindExpression":
          return !0;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return y === "object";
        case "TaggedTemplateExpression":
          return !0;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return y === "callee";
        case "BinaryExpression":
          return y === "left" && g.operator === "**";
        case "TSNonNullExpression":
          return !0;
        default:
          return !1;
      }
    case "BinaryExpression":
      if (g.type === "UpdateExpression" || m.operator === "in" && D8(t)) return !0;
      if (m.operator === "|>" && (a = m.extra) != null && a.parenthesized) {
        let x = t.grandparent;
        if (x.type === "BinaryExpression" && x.operator === "|>") return !0;
      }
    case "TSTypeAssertion":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
    case "LogicalExpression":
      switch (g.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
          return !ss(m);
        case "ConditionalExpression":
          return ss(m) || WQ(m);
        case "CallExpression":
        case "NewExpression":
        case "OptionalCallExpression":
          return y === "callee";
        case "ClassExpression":
        case "ClassDeclaration":
          return y === "superClass";
        case "TSTypeAssertion":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "JSXSpreadAttribute":
        case "SpreadElement":
        case "BindExpression":
        case "AwaitExpression":
        case "TSNonNullExpression":
        case "UpdateExpression":
          return !0;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return y === "object";
        case "AssignmentExpression":
        case "AssignmentPattern":
          return y === "left" && (m.type === "TSTypeAssertion" || ss(m));
        case "LogicalExpression":
          if (m.type === "LogicalExpression") return g.operator !== m.operator;
        case "BinaryExpression": {
          let { operator: x, type: v } = m;
          if (!x && v !== "TSTypeAssertion") return !0;
          let w = Ju(x), C = g.operator, b = Ju(C);
          return b > w || y === "right" && b === w || b === w && !ym(C, x) ? !0 : b < w && x === "%" ? C === "+" || C === "-" : !!uB(C);
        }
        default:
          return !1;
      }
    case "SequenceExpression":
      return g.type !== "ForStatement";
    case "YieldExpression":
      if (g.type === "AwaitExpression" || g.type === "TSTypeAssertion") return !0;
    case "AwaitExpression":
      switch (g.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "SpreadElement":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "BindExpression":
          return !0;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return y === "object";
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return y === "callee";
        case "ConditionalExpression":
          return y === "test";
        case "BinaryExpression":
          return !(!m.argument && g.operator === "|>");
        default:
          return !1;
      }
    case "TSFunctionType":
      if (t.match((x) => x.type === "TSFunctionType", (x, v) => v === "typeAnnotation" && x.type === "TSTypeAnnotation", (x, v) => v === "returnType" && x.type === "ArrowFunctionExpression")) return !0;
    case "TSConditionalType":
    case "TSConstructorType":
    case "ConditionalTypeAnnotation":
      if (y === "extendsType" && Ai(m) && g.type === m.type || y === "checkType" && Ai(g)) return !0;
      if (y === "extendsType" && g.type === "TSConditionalType") {
        let { typeAnnotation: x } = m.returnType || m.typeAnnotation;
        if (x.type === "TSTypePredicate" && x.typeAnnotation && (x = x.typeAnnotation.typeAnnotation), x.type === "TSInferType" && x.typeParameter.constraint) return !0;
      }
    case "TSUnionType":
    case "TSIntersectionType":
      if ((wi(g) || Om(g)) && g.types.length > 1 && (!m.types || m.types.length > 1)) return !0;
    case "TSInferType":
      if (m.type === "TSInferType") {
        if (g.type === "TSRestType") return !1;
        if (y === "types" && (g.type === "TSUnionType" || g.type === "TSIntersectionType") && m.typeParameter.type === "TSTypeParameter" && m.typeParameter.constraint) return !0;
      }
    case "TSTypeOperator":
      return g.type === "TSArrayType" || g.type === "TSOptionalType" || g.type === "TSRestType" || y === "objectType" && g.type === "TSIndexedAccessType" || g.type === "TSTypeOperator" || g.type === "TSTypeAnnotation" && t.grandparent.type.startsWith("TSJSDoc");
    case "TSTypeQuery":
      return y === "objectType" && g.type === "TSIndexedAccessType" || y === "elementType" && g.type === "TSArrayType";
    case "TypeOperator":
      return g.type === "ArrayTypeAnnotation" || g.type === "NullableTypeAnnotation" || y === "objectType" && (g.type === "IndexedAccessType" || g.type === "OptionalIndexedAccessType") || g.type === "TypeOperator";
    case "TypeofTypeAnnotation":
      return y === "objectType" && (g.type === "IndexedAccessType" || g.type === "OptionalIndexedAccessType") || y === "elementType" && g.type === "ArrayTypeAnnotation";
    case "ArrayTypeAnnotation":
      return g.type === "NullableTypeAnnotation";
    case "IntersectionTypeAnnotation":
    case "UnionTypeAnnotation":
      return g.type === "TypeOperator" || g.type === "ArrayTypeAnnotation" || g.type === "NullableTypeAnnotation" || g.type === "IntersectionTypeAnnotation" || g.type === "UnionTypeAnnotation" || y === "objectType" && (g.type === "IndexedAccessType" || g.type === "OptionalIndexedAccessType");
    case "InferTypeAnnotation":
    case "NullableTypeAnnotation":
      return g.type === "ArrayTypeAnnotation" || y === "objectType" && (g.type === "IndexedAccessType" || g.type === "OptionalIndexedAccessType");
    case "ComponentTypeAnnotation":
    case "FunctionTypeAnnotation": {
      if (m.type === "ComponentTypeAnnotation" && (m.rendersType === null || m.rendersType === void 0)) return !1;
      if (t.match(void 0, (v, w) => w === "typeAnnotation" && v.type === "TypeAnnotation", (v, w) => w === "returnType" && v.type === "ArrowFunctionExpression") || t.match(void 0, (v, w) => w === "typeAnnotation" && v.type === "TypePredicate", (v, w) => w === "typeAnnotation" && v.type === "TypeAnnotation", (v, w) => w === "returnType" && v.type === "ArrowFunctionExpression")) return !0;
      let x = g.type === "NullableTypeAnnotation" ? t.grandparent : g;
      return x.type === "UnionTypeAnnotation" || x.type === "IntersectionTypeAnnotation" || x.type === "ArrayTypeAnnotation" || y === "objectType" && (x.type === "IndexedAccessType" || x.type === "OptionalIndexedAccessType") || y === "checkType" && g.type === "ConditionalTypeAnnotation" || y === "extendsType" && g.type === "ConditionalTypeAnnotation" && ((l = m.returnType) == null ? void 0 : l.type) === "InferTypeAnnotation" && ((c = m.returnType) == null ? void 0 : c.typeParameter.bound) || x.type === "NullableTypeAnnotation" || g.type === "FunctionTypeParam" && g.name === null && Pt(m).some((v) => {
        var w;
        return ((w = v.typeAnnotation) == null ? void 0 : w.type) === "NullableTypeAnnotation";
      });
    }
    case "OptionalIndexedAccessType":
      return y === "objectType" && g.type === "IndexedAccessType";
    case "StringLiteral":
    case "NumericLiteral":
    case "Literal":
      if (typeof m.value == "string" && g.type === "ExpressionStatement" && typeof g.directive != "string") {
        let x = t.grandparent;
        return x.type === "Program" || x.type === "BlockStatement";
      }
      return y === "object" && Ve(g) && hs(m);
    case "AssignmentExpression":
      return !((y === "init" || y === "update") && g.type === "ForStatement" || y === "expression" && m.left.type !== "ObjectPattern" && g.type === "ExpressionStatement" || y === "key" && g.type === "TSPropertySignature" || g.type === "AssignmentExpression" || y === "expressions" && g.type === "SequenceExpression" && t.match(void 0, void 0, (x, v) => (v === "init" || v === "update") && x.type === "ForStatement") || y === "value" && g.type === "Property" && t.match(void 0, void 0, (x, v) => v === "properties" && x.type === "ObjectPattern") || g.type === "NGChainedExpression" || y === "node" && g.type === "JsExpressionRoot");
    case "ConditionalExpression":
      switch (g.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "SpreadElement":
        case "BinaryExpression":
        case "LogicalExpression":
        case "NGPipeExpression":
        case "ExportDefaultDeclaration":
        case "AwaitExpression":
        case "JSXSpreadAttribute":
        case "TSTypeAssertion":
        case "TypeCastExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "TSNonNullExpression":
          return !0;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return y === "callee";
        case "ConditionalExpression":
          return e.experimentalTernaries ? !1 : y === "test";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return y === "object";
        default:
          return !1;
      }
    case "FunctionExpression":
      switch (g.type) {
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return y === "callee";
        case "TaggedTemplateExpression":
          return !0;
        default:
          return !1;
      }
    case "ArrowFunctionExpression":
      switch (g.type) {
        case "BinaryExpression":
          return g.operator !== "|>" || ((p = m.extra) == null ? void 0 : p.parenthesized);
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return y === "callee";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return y === "object";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "TSNonNullExpression":
        case "BindExpression":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "AwaitExpression":
        case "TSTypeAssertion":
          return !0;
        case "ConditionalExpression":
          return y === "test";
        default:
          return !1;
      }
    case "ClassExpression":
      switch (g.type) {
        case "NewExpression":
          return y === "callee";
        default:
          return !1;
      }
    case "OptionalMemberExpression":
    case "OptionalCallExpression":
    case "CallExpression":
    case "MemberExpression":
      if (S8(t)) return !0;
    case "TaggedTemplateExpression":
    case "TSNonNullExpression":
      if (y === "callee" && (g.type === "BindExpression" || g.type === "NewExpression")) {
        let x = m;
        for (; x; ) switch (x.type) {
          case "CallExpression":
          case "OptionalCallExpression":
            return !0;
          case "MemberExpression":
          case "OptionalMemberExpression":
          case "BindExpression":
            x = x.object;
            break;
          case "TaggedTemplateExpression":
            x = x.tag;
            break;
          case "TSNonNullExpression":
            x = x.expression;
            break;
          default:
            return !1;
        }
      }
      return !1;
    case "BindExpression":
      return y === "callee" && (g.type === "BindExpression" || g.type === "NewExpression") || y === "object" && Ve(g);
    case "NGPipeExpression":
      return !(g.type === "NGRoot" || g.type === "NGMicrosyntaxExpression" || g.type === "ObjectProperty" && !((d = m.extra) != null && d.parenthesized) || St(g) || y === "arguments" && Ae(g) || y === "right" && g.type === "NGPipeExpression" || y === "property" && g.type === "MemberExpression" || g.type === "AssignmentExpression");
    case "JSXFragment":
    case "JSXElement":
      return y === "callee" || y === "left" && g.type === "BinaryExpression" && g.operator === "<" || !St(g) && g.type !== "ArrowFunctionExpression" && g.type !== "AssignmentExpression" && g.type !== "AssignmentPattern" && g.type !== "BinaryExpression" && g.type !== "NewExpression" && g.type !== "ConditionalExpression" && g.type !== "ExpressionStatement" && g.type !== "JsExpressionRoot" && g.type !== "JSXAttribute" && g.type !== "JSXElement" && g.type !== "JSXExpressionContainer" && g.type !== "JSXFragment" && g.type !== "LogicalExpression" && !Ae(g) && !Gs(g) && g.type !== "ReturnStatement" && g.type !== "ThrowStatement" && g.type !== "TypeCastExpression" && g.type !== "VariableDeclarator" && g.type !== "YieldExpression";
    case "TSInstantiationExpression":
      return y === "object" && Ve(g);
  }
  return !1;
}
var x8 = Pe(["BlockStatement", "BreakStatement", "ComponentDeclaration", "ClassBody", "ClassDeclaration", "ClassMethod", "ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ContinueStatement", "DebuggerStatement", "DeclareComponent", "DeclareClass", "DeclareExportAllDeclaration", "DeclareExportDeclaration", "DeclareFunction", "DeclareHook", "DeclareInterface", "DeclareModule", "DeclareModuleExports", "DeclareNamespace", "DeclareVariable", "DeclareEnum", "DoWhileStatement", "EnumDeclaration", "ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExpressionStatement", "ForInStatement", "ForOfStatement", "ForStatement", "FunctionDeclaration", "HookDeclaration", "IfStatement", "ImportDeclaration", "InterfaceDeclaration", "LabeledStatement", "MethodDefinition", "ReturnStatement", "SwitchStatement", "ThrowStatement", "TryStatement", "TSDeclareFunction", "TSEnumDeclaration", "TSImportEqualsDeclaration", "TSInterfaceDeclaration", "TSModuleDeclaration", "TSNamespaceExportDeclaration", "TypeAlias", "VariableDeclaration", "WhileStatement", "WithStatement"]);
function D8(t) {
  let e = 0, { node: r } = t;
  for (; r; ) {
    let s = t.getParentNode(e++);
    if ((s == null ? void 0 : s.type) === "ForStatement" && s.init === r) return !0;
    r = s;
  }
  return !1;
}
function b8(t) {
  return dd(t, (e) => e.type === "ObjectTypeAnnotation" && dd(e, (r) => r.type === "FunctionTypeAnnotation"));
}
function v8(t) {
  return Rr(t);
}
function lo(t) {
  let { parent: e, key: r } = t;
  switch (e.type) {
    case "NGPipeExpression":
      if (r === "arguments" && t.isLast) return t.callParent(lo);
      break;
    case "ObjectProperty":
      if (r === "value") return t.callParent(() => t.key === "properties" && t.isLast);
      break;
    case "BinaryExpression":
    case "LogicalExpression":
      if (r === "right") return t.callParent(lo);
      break;
    case "ConditionalExpression":
      if (r === "alternate") return t.callParent(lo);
      break;
    case "UnaryExpression":
      if (e.prefix) return t.callParent(lo);
      break;
  }
  return !1;
}
function pb(t, e) {
  let { node: r, parent: s } = t;
  return r.type === "FunctionExpression" || r.type === "ClassExpression" ? s.type === "ExportDefaultDeclaration" || !vd(t, e) : !dm(r) || s.type !== "ExportDefaultDeclaration" && vd(t, e) ? !1 : t.call(() => pb(t, e), ...C2(r));
}
function S8(t) {
  return !!(t.match(void 0, (e, r) => r === "expression" && e.type === "ChainExpression", (e, r) => r === "tag" && e.type === "TaggedTemplateExpression") || t.match((e) => e.type === "OptionalCallExpression" || e.type === "OptionalMemberExpression", (e, r) => r === "tag" && e.type === "TaggedTemplateExpression") || t.match((e) => e.type === "OptionalCallExpression" || e.type === "OptionalMemberExpression", (e, r) => r === "expression" && e.type === "TSNonNullExpression", (e, r) => r === "tag" && e.type === "TaggedTemplateExpression") || t.match(void 0, (e, r) => r === "expression" && e.type === "ChainExpression", (e, r) => r === "expression" && e.type === "TSNonNullExpression", (e, r) => r === "tag" && e.type === "TaggedTemplateExpression") || t.match(void 0, (e, r) => r === "expression" && e.type === "TSNonNullExpression", (e, r) => r === "expression" && e.type === "ChainExpression", (e, r) => r === "tag" && e.type === "TaggedTemplateExpression") || t.match((e) => e.type === "OptionalMemberExpression" || e.type === "OptionalCallExpression", (e, r) => r === "object" && e.type === "MemberExpression" || r === "callee" && (e.type === "CallExpression" || e.type === "NewExpression")) || t.match((e) => e.type === "OptionalMemberExpression" || e.type === "OptionalCallExpression", (e, r) => r === "expression" && e.type === "TSNonNullExpression", (e, r) => r === "object" && e.type === "MemberExpression" || r === "callee" && e.type === "CallExpression") || t.match((e) => e.type === "CallExpression" || e.type === "MemberExpression", (e, r) => r === "expression" && e.type === "ChainExpression") && (t.match(void 0, void 0, (e, r) => r === "callee" && (e.type === "CallExpression" && !e.optional || e.type === "NewExpression") || r === "object" && e.type === "MemberExpression" && !e.optional) || t.match(void 0, void 0, (e, r) => r === "expression" && e.type === "TSNonNullExpression", (e, r) => r === "object" && e.type === "MemberExpression" || r === "callee" && e.type === "CallExpression")) || t.match((e) => e.type === "CallExpression" || e.type === "MemberExpression", (e, r) => r === "expression" && e.type === "TSNonNullExpression", (e, r) => r === "expression" && e.type === "ChainExpression", (e, r) => r === "object" && e.type === "MemberExpression" || r === "callee" && e.type === "CallExpression"));
}
function Sd(t) {
  return t.type === "Identifier" ? !0 : Ve(t) ? !t.computed && !t.optional && t.property.type === "Identifier" && Sd(t.object) : !1;
}
function w8(t) {
  return t.type === "ChainExpression" && (t = t.expression), Sd(t) || Ae(t) && !t.optional && Sd(t.callee);
}
var En = vd;
function A8(t, e) {
  let r = e - 1;
  r = oa(t, r, { backwards: !0 }), r = la(t, r, { backwards: !0 }), r = oa(t, r, { backwards: !0 });
  let s = la(t, r, { backwards: !0 });
  return r !== s;
}
var C8 = A8, E8 = () => !0;
function Em(t, e) {
  let r = t.node;
  return r.printed = !0, e.printer.printComment(t, e);
}
function T8(t, e) {
  var r;
  let s = t.node, i = [Em(t, e)], { printer: n, originalText: a, locStart: l, locEnd: c } = e;
  if ((r = n.isBlockComment) != null && r.call(n, s)) {
    let d = cr(a, c(s)) ? cr(a, l(s), { backwards: !0 }) ? q : K : " ";
    i.push(d);
  } else i.push(q);
  let p = la(a, oa(a, c(s)));
  return p !== !1 && cr(a, p) && i.push(q), i;
}
function k8(t, e, r) {
  var s;
  let i = t.node, n = Em(t, e), { printer: a, originalText: l, locStart: c } = e, p = (s = a.isBlockComment) == null ? void 0 : s.call(a, i);
  if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || cr(l, c(i), { backwards: !0 })) {
    let d = C8(l, c(i));
    return { doc: CO([q, d ? q : "", n]), isBlock: p, hasLineSuffix: !0 };
  }
  return !p || r != null && r.hasLineSuffix ? { doc: [CO([" ", n]), ds], isBlock: p, hasLineSuffix: !0 } : { doc: [" ", n], isBlock: p, hasLineSuffix: !1 };
}
function Le(t, e, r = {}) {
  let { node: s } = t;
  if (!Ee(s == null ? void 0 : s.comments)) return "";
  let { indent: i = !1, marker: n, filter: a = E8 } = r, l = [];
  if (t.each(({ node: p }) => {
    p.leading || p.trailing || p.marker !== n || !a(p) || l.push(Em(t, e));
  }, "comments"), l.length === 0) return "";
  let c = be(q, l);
  return i ? X([q, c]) : c;
}
function db(t, e) {
  let r = t.node;
  if (!r) return {};
  let s = e[Symbol.for("printedComments")];
  if ((r.comments || []).filter((l) => !s.has(l)).length === 0) return { leading: "", trailing: "" };
  let i = [], n = [], a;
  return t.each(() => {
    let l = t.node;
    if (s != null && s.has(l)) return;
    let { leading: c, trailing: p } = l;
    c ? i.push(T8(t, e)) : p && (a = k8(t, e, a), n.push(a.doc));
  }, "comments"), { leading: i, trailing: n };
}
function _r(t, e, r) {
  let { leading: s, trailing: i } = db(t, r);
  return !s && !i ? e : gd(e, (n) => [s, n, i]);
}
var P8 = class extends Error {
  constructor(r, s, i = "type") {
    super(`Unexpected ${s} node ${i}: ${JSON.stringify(r[i])}.`);
    vs(this, "name", "UnexpectedNodeError");
    this.node = r;
  }
}, ka = P8;
function F8(t) {
  if (typeof t != "string") throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var $r, $8 = class {
  constructor(e) {
    sQ(this, $r), iQ(this, $r, new Set(e));
  }
  getLeadingWhitespaceCount(e) {
    let r = ni(this, $r), s = 0;
    for (let i = 0; i < e.length && r.has(e.charAt(i)); i++) s++;
    return s;
  }
  getTrailingWhitespaceCount(e) {
    let r = ni(this, $r), s = 0;
    for (let i = e.length - 1; i >= 0 && r.has(e.charAt(i)); i--) s++;
    return s;
  }
  getLeadingWhitespace(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(0, r);
  }
  getTrailingWhitespace(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(e.length - r);
  }
  hasLeadingWhitespace(e) {
    return ni(this, $r).has(e.charAt(0));
  }
  hasTrailingWhitespace(e) {
    return ni(this, $r).has(Fe(!1, e, -1));
  }
  trimStart(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(r);
  }
  trimEnd(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(0, e.length - r);
  }
  trim(e) {
    return this.trimEnd(this.trimStart(e));
  }
  split(e, r = !1) {
    let s = `[${F8([...ni(this, $r)].join(""))}]+`, i = new RegExp(r ? `(${s})` : s, "u");
    return e.split(i);
  }
  hasWhitespaceCharacter(e) {
    let r = ni(this, $r);
    return Array.prototype.some.call(e, (s) => r.has(s));
  }
  hasNonWhitespaceCharacter(e) {
    let r = ni(this, $r);
    return Array.prototype.some.call(e, (s) => !r.has(s));
  }
  isWhitespaceOnly(e) {
    let r = ni(this, $r);
    return Array.prototype.every.call(e, (s) => r.has(s));
  }
};
$r = /* @__PURE__ */ new WeakMap();
var Q8 = $8, Pu = new Q8(` 
\r	`), op = (t) => t === "" || t === K || t === q || t === R;
function B8(t, e, r) {
  var s, i, n, a, l;
  let { node: c } = t;
  if (c.type === "JSXElement" && G8(c)) return [r("openingElement"), r("closingElement")];
  let p = c.type === "JSXElement" ? r("openingElement") : r("openingFragment"), d = c.type === "JSXElement" ? r("closingElement") : r("closingFragment");
  if (c.children.length === 1 && c.children[0].type === "JSXExpressionContainer" && (c.children[0].expression.type === "TemplateLiteral" || c.children[0].expression.type === "TaggedTemplateExpression")) return [p, ...t.map(r, "children"), d];
  c.children = c.children.map((_) => H8(_) ? { type: "JSXText", value: " ", raw: " " } : _);
  let m = c.children.some(dt), y = c.children.filter((_) => _.type === "JSXExpressionContainer").length > 1, g = c.type === "JSXElement" && c.openingElement.attributes.length > 1, x = It(p) || m || g || y, v = t.parent.rootMarker === "mdx", w = e.singleQuote ? "{' '}" : '{" "}', C = v ? K : de([w, R], " "), b = ((i = (s = c.openingElement) == null ? void 0 : s.name) == null ? void 0 : i.name) === "fbt", k = I8(t, e, r, C, b), Q = c.children.some((_) => Lo(_));
  for (let _ = k.length - 2; _ >= 0; _--) {
    let W = k[_] === "" && k[_ + 1] === "", V = k[_] === q && k[_ + 1] === "" && k[_ + 2] === q, j = (k[_] === R || k[_] === q) && k[_ + 1] === "" && k[_ + 2] === C, B = k[_] === C && k[_ + 1] === "" && (k[_ + 2] === R || k[_ + 2] === q), U = k[_] === C && k[_ + 1] === "" && k[_ + 2] === C, oe = k[_] === R && k[_ + 1] === "" && k[_ + 2] === q || k[_] === q && k[_ + 1] === "" && k[_ + 2] === R;
    V && Q || W || j || U || oe ? k.splice(_, 2) : B && k.splice(_ + 1, 2);
  }
  for (; k.length > 0 && op(Fe(!1, k, -1)); ) k.pop();
  for (; k.length > 1 && op(k[0]) && op(k[1]); ) k.shift(), k.shift();
  let F = [""];
  for (let [_, W] of k.entries()) {
    if (W === C) {
      if (_ === 1 && AB(k[_ - 1])) {
        if (k.length === 2) {
          F.push([F.pop(), w]);
          continue;
        }
        F.push([w, q], "");
        continue;
      } else if (_ === k.length - 1) {
        F.push([F.pop(), w]);
        continue;
      } else if (k[_ - 1] === "" && k[_ - 2] === q) {
        F.push([F.pop(), w]);
        continue;
      }
    }
    _ % 2 === 0 ? F.push([F.pop(), W]) : F.push(W, ""), It(W) && (x = !0);
  }
  let $ = Q ? R2(F) : I(F, { shouldBreak: !0 });
  if (((n = e.cursorNode) == null ? void 0 : n.type) === "JSXText" && c.children.includes(e.cursorNode) ? $ = [Yl, $, Yl] : ((a = e.nodeBeforeCursor) == null ? void 0 : a.type) === "JSXText" && c.children.includes(e.nodeBeforeCursor) ? $ = [Yl, $] : ((l = e.nodeAfterCursor) == null ? void 0 : l.type) === "JSXText" && c.children.includes(e.nodeAfterCursor) && ($ = [$, Yl]), v) return $;
  let N = I([p, X([q, $]), q, d]);
  return x ? N : Yi([I([p, ...k, d]), N]);
}
function I8(t, e, r, s, i) {
  let n = "", a = [n];
  function l(p) {
    n = p, a.push([a.pop(), p]);
  }
  function c(p) {
    p !== "" && (n = p, a.push(p, ""));
  }
  return t.each(({ node: p, next: d }) => {
    if (p.type === "JSXText") {
      let m = Wt(p);
      if (Lo(p)) {
        let y = Pu.split(m, !0);
        y[0] === "" && (y.shift(), /\n/u.test(y[0]) ? c($O(i, y[1], p, d)) : c(s), y.shift());
        let g;
        if (Fe(!1, y, -1) === "" && (y.pop(), g = y.pop()), y.length === 0) return;
        for (let [x, v] of y.entries()) x % 2 === 1 ? c(K) : l(v);
        g !== void 0 ? /\n/u.test(g) ? c($O(i, n, p, d)) : c(s) : c(FO(i, n, p, d));
      } else /\n/u.test(m) ? m.match(/\n/gu).length > 1 && c(q) : c(s);
    } else {
      let m = r();
      if (l(m), d && Lo(d)) {
        let y = Pu.trim(Wt(d)), [g] = Pu.split(y);
        c(FO(i, g, p, d));
      } else c(q);
    }
  }, "children"), a;
}
function FO(t, e, r, s) {
  return t ? "" : r.type === "JSXElement" && !r.closingElement || (s == null ? void 0 : s.type) === "JSXElement" && !s.closingElement ? e.length === 1 ? R : q : R;
}
function $O(t, e, r, s) {
  return t ? q : e.length === 1 ? r.type === "JSXElement" && !r.closingElement || (s == null ? void 0 : s.type) === "JSXElement" && !s.closingElement ? q : R : q;
}
var N8 = /* @__PURE__ */ new Set(["ArrayExpression", "JSXAttribute", "JSXElement", "JSXExpressionContainer", "JSXFragment", "ExpressionStatement", "CallExpression", "OptionalCallExpression", "ConditionalExpression", "JsExpressionRoot"]);
function M8(t, e, r) {
  let { parent: s } = t;
  if (N8.has(s.type)) return e;
  let i = L8(t), n = En(t, r);
  return I([n ? "" : de("("), X([R, e]), R, n ? "" : de(")")], { shouldBreak: i });
}
function L8(t) {
  return t.match(void 0, (e) => e.type === "ArrowFunctionExpression", Ae) && (t.match(void 0, void 0, void 0, (e) => e.type === "JSXExpressionContainer") || t.match(void 0, void 0, void 0, (e) => e.type === "ChainExpression", (e) => e.type === "JSXExpressionContainer"));
}
function _8(t, e, r) {
  let { node: s } = t, i = [];
  if (i.push(r("name")), s.value) {
    let n;
    if (wt(s.value)) {
      let a = Wt(s.value), l = xt(!1, xt(!1, a.slice(1, -1), "&apos;", "'"), "&quot;", '"'), c = D2(l, e.jsxSingleQuote);
      l = c === '"' ? xt(!1, l, '"', "&quot;") : xt(!1, l, "'", "&apos;"), n = t.call(() => _r(t, ln(c + l + c), e), "value");
    } else n = r("value");
    i.push("=", n);
  }
  return i;
}
function R8(t, e, r) {
  let { node: s } = t, i = (n, a) => n.type === "JSXEmptyExpression" || !z(n) && (St(n) || Rr(n) || n.type === "ArrowFunctionExpression" || n.type === "AwaitExpression" && (i(n.argument, n) || n.argument.type === "JSXElement") || Ae(n) || n.type === "ChainExpression" && Ae(n.expression) || n.type === "FunctionExpression" || n.type === "TemplateLiteral" || n.type === "TaggedTemplateExpression" || n.type === "DoExpression" || dt(a) && (n.type === "ConditionalExpression" || Bs(n)));
  return i(s.expression, t.parent) ? I(["{", r("expression"), Ns, "}"]) : I(["{", X([R, r("expression")]), R, Ns, "}"]);
}
function q8(t, e, r) {
  var s, i;
  let { node: n } = t, a = z(n.name) || z(n.typeParameters) || z(n.typeArguments);
  if (n.selfClosing && n.attributes.length === 0 && !a) return ["<", r("name"), n.typeArguments ? r("typeArguments") : r("typeParameters"), " />"];
  if (((s = n.attributes) == null ? void 0 : s.length) === 1 && wt(n.attributes[0].value) && !n.attributes[0].value.value.includes(`
`) && !a && !z(n.attributes[0])) return I(["<", r("name"), n.typeArguments ? r("typeArguments") : r("typeParameters"), " ", ...t.map(r, "attributes"), n.selfClosing ? " />" : ">"]);
  let l = (i = n.attributes) == null ? void 0 : i.some((p) => wt(p.value) && p.value.value.includes(`
`)), c = e.singleAttributePerLine && n.attributes.length > 1 ? q : K;
  return I(["<", r("name"), n.typeArguments ? r("typeArguments") : r("typeParameters"), X(t.map(() => [c, r()], "attributes")), ...j8(n, e, a)], { shouldBreak: l });
}
function j8(t, e, r) {
  return t.selfClosing ? [K, "/>"] : X8(t, e, r) ? [">"] : [R, ">"];
}
function X8(t, e, r) {
  let s = t.attributes.length > 0 && z(Fe(!1, t.attributes, -1), te.Trailing);
  return t.attributes.length === 0 && !r || (e.bracketSameLine || e.jsxBracketSameLine) && (!r || t.attributes.length > 0) && !s;
}
function Z8(t, e, r) {
  let { node: s } = t, i = [];
  i.push("</");
  let n = r("name");
  return z(s.name, te.Leading | te.Line) ? i.push(X([q, n]), q) : z(s.name, te.Leading | te.Block) ? i.push(" ", n) : i.push(n), i.push(">"), i;
}
function V8(t, e) {
  let { node: r } = t, s = z(r), i = z(r, te.Line), n = r.type === "JSXOpeningFragment";
  return [n ? "<" : "</", X([i ? q : s && !n ? " " : "", Le(t, e)]), i ? q : "", ">"];
}
function z8(t, e, r) {
  let s = _r(t, B8(t, e, r), e);
  return M8(t, s, e);
}
function U8(t, e) {
  let { node: r } = t, s = z(r, te.Line);
  return [Le(t, e, { indent: s }), s ? q : ""];
}
function Y8(t, e, r) {
  let { node: s } = t;
  return ["{", t.call(({ node: i }) => {
    let n = ["...", r()];
    return !z(i) || !rb(t) ? n : [X([R, _r(t, n, e)]), R];
  }, s.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
}
function W8(t, e, r) {
  let { node: s } = t;
  if (s.type.startsWith("JSX")) switch (s.type) {
    case "JSXAttribute":
      return _8(t, e, r);
    case "JSXIdentifier":
      return s.name;
    case "JSXNamespacedName":
      return be(":", [r("namespace"), r("name")]);
    case "JSXMemberExpression":
      return be(".", [r("object"), r("property")]);
    case "JSXSpreadAttribute":
    case "JSXSpreadChild":
      return Y8(t, e, r);
    case "JSXExpressionContainer":
      return R8(t, e, r);
    case "JSXFragment":
    case "JSXElement":
      return z8(t, e, r);
    case "JSXOpeningElement":
      return q8(t, e, r);
    case "JSXClosingElement":
      return Z8(t, e, r);
    case "JSXOpeningFragment":
    case "JSXClosingFragment":
      return V8(t, e);
    case "JSXEmptyExpression":
      return U8(t, e);
    case "JSXText":
      throw new Error("JSXText should be handled by JSXElement");
    default:
      throw new ka(s, "JSX");
  }
}
function G8(t) {
  if (t.children.length === 0) return !0;
  if (t.children.length > 1) return !1;
  let e = t.children[0];
  return e.type === "JSXText" && !Lo(e);
}
function Lo(t) {
  return t.type === "JSXText" && (Pu.hasNonWhitespaceCharacter(Wt(t)) || !/\n/u.test(Wt(t)));
}
function H8(t) {
  return t.type === "JSXExpressionContainer" && wt(t.expression) && t.expression.value === " " && !z(t.expression);
}
function J8(t) {
  let { node: e, parent: r } = t;
  if (!dt(e) || !dt(r)) return !1;
  let { index: s, siblings: i } = t, n;
  for (let a = s; a > 0; a--) {
    let l = i[a - 1];
    if (!(l.type === "JSXText" && !Lo(l))) {
      n = l;
      break;
    }
  }
  return (n == null ? void 0 : n.type) === "JSXExpressionContainer" && n.expression.type === "JSXEmptyExpression" && th(n.expression);
}
function K8(t) {
  return th(t.node) || J8(t);
}
var fb = K8, e4 = 0;
function mb(t, e, r) {
  var s;
  let { node: i, parent: n, grandparent: a, key: l } = t, c = l !== "body" && (n.type === "IfStatement" || n.type === "WhileStatement" || n.type === "SwitchStatement" || n.type === "DoWhileStatement"), p = i.operator === "|>" && ((s = t.root.extra) == null ? void 0 : s.__isUsingHackPipeline), d = wd(t, e, r, !1, c);
  if (c) return d;
  if (p) return I(d);
  if (Ae(n) && n.callee === i || n.type === "UnaryExpression" || Ve(n) && !n.computed) return I([X([R, ...d]), R]);
  let m = n.type === "ReturnStatement" || n.type === "ThrowStatement" || n.type === "JSXExpressionContainer" && a.type === "JSXAttribute" || i.operator !== "|" && n.type === "JsExpressionRoot" || i.type !== "NGPipeExpression" && (n.type === "NGRoot" && e.parser === "__ng_binding" || n.type === "NGMicrosyntaxExpression" && a.type === "NGMicrosyntax" && a.body.length === 1) || i === n.body && n.type === "ArrowFunctionExpression" || i !== n.body && n.type === "ForStatement" || n.type === "ConditionalExpression" && a.type !== "ReturnStatement" && a.type !== "ThrowStatement" && !Ae(a) || n.type === "TemplateLiteral", y = n.type === "AssignmentExpression" || n.type === "VariableDeclarator" || n.type === "ClassProperty" || n.type === "PropertyDefinition" || n.type === "TSAbstractPropertyDefinition" || n.type === "ClassPrivateProperty" || Gs(n), g = Bs(i.left) && ym(i.operator, i.left.operator);
  if (m || _o(i) && !g || !_o(i) && y) return I(d);
  if (d.length === 0) return "";
  let x = dt(i.right), v = d.findIndex((F) => typeof F != "string" && !Array.isArray(F) && F.type === Ar), w = d.slice(0, v === -1 ? 1 : v + 1), C = d.slice(w.length, x ? -1 : void 0), b = Symbol("logicalChain-" + ++e4), k = I([...w, X(C)], { id: b });
  if (!x) return k;
  let Q = Fe(!1, d, -1);
  return I([k, rh(Q, { groupId: b })]);
}
function wd(t, e, r, s, i) {
  var n;
  let { node: a } = t;
  if (!Bs(a)) return [I(r())];
  let l = [];
  ym(a.operator, a.left.operator) ? l = t.call((w) => wd(w, e, r, !0, i), "left") : l.push(I(r("left")));
  let c = _o(a), p = (a.operator === "|>" || a.type === "NGPipeExpression" || t4(t, e)) && !ls(e.originalText, a.right), d = !z(a.right, te.Leading, Z2) && ls(e.originalText, a.right), m = a.type === "NGPipeExpression" ? "|" : a.operator, y = a.type === "NGPipeExpression" && a.arguments.length > 0 ? I(X([R, ": ", be([K, ": "], t.map(() => ps(2, I(r())), "arguments"))])) : "", g;
  if (c) g = [m, ls(e.originalText, a.right) ? X([K, r("right"), y]) : [" ", r("right"), y]];
  else {
    let w = m === "|>" && ((n = t.root.extra) != null && n.__isUsingHackPipeline) ? t.call((C) => wd(C, e, r, !0, i), "right") : r("right");
    if (e.experimentalOperatorPosition === "start") {
      let C = "";
      if (d) switch (Ni(w)) {
        case Is:
          C = w.splice(0, 1)[0];
          break;
        case Hs:
          C = w.contents.splice(0, 1)[0];
          break;
      }
      g = [K, C, m, " ", w, y];
    } else g = [p ? K : "", m, p ? " " : K, w, y];
  }
  let { parent: x } = t, v = z(a.left, te.Trailing | te.Line);
  if ((v || !(i && a.type === "LogicalExpression") && x.type !== a.type && a.left.type !== a.type && a.right.type !== a.type) && (g = I(g, { shouldBreak: v })), e.experimentalOperatorPosition === "start" ? l.push(c || d ? " " : "", g) : l.push(p ? "" : " ", g), s && z(a)) {
    let w = Dm(_r(t, l, e));
    return w.type === Bi ? w.parts : Array.isArray(w) ? w : [w];
  }
  return l;
}
function _o(t) {
  return t.type !== "LogicalExpression" ? !1 : !!(Rr(t.right) && t.right.properties.length > 0 || St(t.right) && t.right.elements.length > 0 || dt(t.right));
}
var QO = (t) => t.type === "BinaryExpression" && t.operator === "|";
function t4(t, e) {
  return (e.parser === "__vue_expression" || e.parser === "__vue_ts_expression") && QO(t.node) && !t.hasAncestor((r) => !QO(r) && r.type !== "JsExpressionRoot");
}
function r4(t, e, r) {
  let { node: s } = t;
  if (s.type.startsWith("NG")) switch (s.type) {
    case "NGRoot":
      return [r("node"), z(s.node) ? " //" + nn(s.node)[0].value.trimEnd() : ""];
    case "NGPipeExpression":
      return mb(t, e, r);
    case "NGChainedExpression":
      return I(be([";", K], t.map(() => n4(t) ? r() : ["(", r(), ")"], "expressions")));
    case "NGEmptyExpression":
      return "";
    case "NGMicrosyntax":
      return t.map(() => [t.isFirst ? "" : BO(t) ? " " : [";", K], r()], "body");
    case "NGMicrosyntaxKey":
      return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/iu.test(s.name) ? s.name : JSON.stringify(s.name);
    case "NGMicrosyntaxExpression":
      return [r("expression"), s.alias === null ? "" : [" as ", r("alias")]];
    case "NGMicrosyntaxKeyedExpression": {
      let { index: i, parent: n } = t, a = BO(t) || s4(t) || (i === 1 && (s.key.name === "then" || s.key.name === "else" || s.key.name === "as") || i === 2 && (s.key.name === "else" && n.body[i - 1].type === "NGMicrosyntaxKeyedExpression" && n.body[i - 1].key.name === "then" || s.key.name === "track")) && n.body[0].type === "NGMicrosyntaxExpression";
      return [r("key"), a ? " " : ": ", r("expression")];
    }
    case "NGMicrosyntaxLet":
      return ["let ", r("key"), s.value === null ? "" : [" = ", r("value")]];
    case "NGMicrosyntaxAs":
      return [r("key"), " as ", r("alias")];
    default:
      throw new ka(s, "Angular");
  }
}
function BO({ node: t, index: e }) {
  return t.type === "NGMicrosyntaxKeyedExpression" && t.key.name === "of" && e === 1;
}
function s4(t) {
  let { node: e } = t;
  return t.parent.body[1].key.name === "of" && e.type === "NGMicrosyntaxKeyedExpression" && e.key.name === "track" && e.key.type === "NGMicrosyntaxKey";
}
var i4 = Pe(["CallExpression", "OptionalCallExpression", "AssignmentExpression"]);
function n4({ node: t }) {
  return dd(t, i4);
}
function gb(t, e, r) {
  let { node: s } = t;
  return I([be(K, t.map(r, "decorators")), yb(s, e) ? q : K]);
}
function a4(t, e, r) {
  return Ob(t.node) ? [be(q, t.map(r, "declaration", "decorators")), q] : "";
}
function o4(t, e, r) {
  let { node: s, parent: i } = t, { decorators: n } = s;
  if (!Ee(n) || Ob(i) || fb(t)) return "";
  let a = s.type === "ClassExpression" || s.type === "ClassDeclaration" || yb(s, e);
  return [t.key === "declaration" && YQ(i) ? q : a ? ds : "", be(K, t.map(r, "decorators")), K];
}
function yb(t, e) {
  return t.decorators.some((r) => cr(e.originalText, De(r)));
}
function Ob(t) {
  var e;
  if (t.type !== "ExportDefaultDeclaration" && t.type !== "ExportNamedDeclaration" && t.type !== "DeclareExportDeclaration") return !1;
  let r = (e = t.declaration) == null ? void 0 : e.decorators;
  return Ee(r) && Jc(t, r[0]);
}
var tc = class extends Error {
  constructor() {
    super(...arguments);
    vs(this, "name", "ArgExpansionBailout");
  }
};
function l4(t, e, r) {
  let { node: s } = t, i = Tr(s);
  if (i.length === 0) return ["(", Le(t, e), ")"];
  let n = i.length - 1;
  if (h4(i)) {
    let m = ["("];
    return Ku(t, (y, g) => {
      m.push(r()), g !== n && m.push(", ");
    }), m.push(")"), m;
  }
  let a = !1, l = [];
  Ku(t, ({ node: m }, y) => {
    let g = r();
    y === n || (Ws(m, e) ? (a = !0, g = [g, ",", q, q]) : g = [g, ",", K]), l.push(g);
  });
  let c = !e.parser.startsWith("__ng_") && s.type !== "ImportExpression" && s.type !== "TSImportType" && Ys(e, "all") ? "," : "";
  if (s.type === "TSImportType" && i.length === 1 && (i[0].type === "TSLiteralType" && wt(i[0].literal) || wt(i[0])) && !z(i[0])) return I(["(", ...l, de(c), ")"]);
  function p() {
    return I(["(", X([K, ...l]), c, K, ")"], { shouldBreak: !0 });
  }
  if (a || t.parent.type !== "Decorator" && nB(i)) return p();
  if (c4(i)) {
    let m = l.slice(1);
    if (m.some(It)) return p();
    let y;
    try {
      y = r(SO(s, 0), { expandFirstArg: !0 });
    } catch (g) {
      if (g instanceof tc) return p();
      throw g;
    }
    return It(y) ? [ds, Yi([["(", I(y, { shouldBreak: !0 }), ", ", ...m, ")"], p()])] : Yi([["(", y, ", ", ...m, ")"], ["(", I(y, { shouldBreak: !0 }), ", ", ...m, ")"], p()]);
  }
  if (u4(i, l, e)) {
    let m = l.slice(0, -1);
    if (m.some(It)) return p();
    let y;
    try {
      y = r(SO(s, -1), { expandLastArg: !0 });
    } catch (g) {
      if (g instanceof tc) return p();
      throw g;
    }
    return It(y) ? [ds, Yi([["(", ...m, I(y, { shouldBreak: !0 }), ")"], p()])] : Yi([["(", ...m, y, ")"], ["(", ...m, I(y, { shouldBreak: !0 }), ")"], p()]);
  }
  let d = ["(", X([R, ...l]), de(c), R, ")"];
  return B2(t) ? d : I(d, { shouldBreak: l.some(It) || a });
}
function vo(t, e = !1) {
  return Rr(t) && (t.properties.length > 0 || z(t)) || St(t) && (t.elements.length > 0 || z(t)) || t.type === "TSTypeAssertion" && vo(t.expression) || ss(t) && vo(t.expression) || t.type === "FunctionExpression" || t.type === "ArrowFunctionExpression" && (!t.returnType || !t.returnType.typeAnnotation || t.returnType.typeAnnotation.type !== "TSTypeReference" || p4(t.body)) && (t.body.type === "BlockStatement" || t.body.type === "ArrowFunctionExpression" && vo(t.body, !0) || Rr(t.body) || St(t.body) || !e && (Ae(t.body) || t.body.type === "ConditionalExpression") || dt(t.body)) || t.type === "DoExpression" || t.type === "ModuleExpression";
}
function u4(t, e, r) {
  var s, i;
  let n = Fe(!1, t, -1);
  if (t.length === 1) {
    let l = Fe(!1, e, -1);
    if ((s = l.label) != null && s.embed && ((i = l.label) == null ? void 0 : i.hug) !== !1) return !0;
  }
  let a = Fe(!1, t, -2);
  return !z(n, te.Leading) && !z(n, te.Trailing) && vo(n) && (!a || a.type !== n.type) && (t.length !== 2 || a.type !== "ArrowFunctionExpression" || !St(n)) && !(t.length > 1 && Zb(n, r));
}
function c4(t) {
  if (t.length !== 2) return !1;
  let [e, r] = t;
  return e.type === "ModuleExpression" && d4(r) ? !0 : !z(e) && (e.type === "FunctionExpression" || e.type === "ArrowFunctionExpression" && e.body.type === "BlockStatement") && r.type !== "FunctionExpression" && r.type !== "ArrowFunctionExpression" && r.type !== "ConditionalExpression" && xb(r) && !vo(r);
}
function xb(t) {
  var e;
  if (t.type === "ParenthesizedExpression") return xb(t.expression);
  if (ss(t) || t.type === "TypeCastExpression") {
    let { typeAnnotation: r } = t;
    if (r.type === "TypeAnnotation" && (r = r.typeAnnotation), r.type === "TSArrayType" && (r = r.elementType, r.type === "TSArrayType" && (r = r.elementType)), r.type === "GenericTypeAnnotation" || r.type === "TSTypeReference") {
      let s = (e = r.typeArguments) != null ? e : r.typeParameters;
      (s == null ? void 0 : s.params.length) === 1 && (r = s.params[0]);
    }
    return mm(r) && Br(t.expression, 1);
  }
  return ca(t) && Tr(t).length > 1 ? !1 : Bs(t) ? Br(t.left, 1) && Br(t.right, 1) : T2(t) || Br(t);
}
function h4(t) {
  return t.length === 2 ? IO(t, 0) : t.length === 3 ? t[0].type === "Identifier" && IO(t, 1) : !1;
}
function IO(t, e) {
  let r = t[e], s = t[e + 1];
  return r.type === "ArrowFunctionExpression" && Pt(r).length === 0 && r.body.type === "BlockStatement" && s.type === "ArrayExpression" && !t.some((i) => z(i));
}
function p4(t) {
  return t.type === "BlockStatement" && (t.body.some((e) => e.type !== "EmptyStatement") || z(t, te.Dangling));
}
function d4(t) {
  if (!(t.type === "ObjectExpression" && t.properties.length === 1)) return !1;
  let [e] = t.properties;
  return Gs(e) ? !e.computed && (e.key.type === "Identifier" && e.key.name === "type" || wt(e.key) && e.key.value === "type") && wt(e.value) && e.value.value === "module" : !1;
}
var rc = l4, f4 = (t) => ((t.type === "ChainExpression" || t.type === "TSNonNullExpression") && (t = t.expression), Ae(t) && Tr(t).length > 0);
function m4(t, e, r) {
  var s;
  let i = r("object"), n = Db(t, e, r), { node: a } = t, l = t.findAncestor((d) => !(Ve(d) || d.type === "TSNonNullExpression")), c = t.findAncestor((d) => !(d.type === "ChainExpression" || d.type === "TSNonNullExpression")), p = l && (l.type === "NewExpression" || l.type === "BindExpression" || l.type === "AssignmentExpression" && l.left.type !== "Identifier") || a.computed || a.object.type === "Identifier" && a.property.type === "Identifier" && !Ve(c) || (c.type === "AssignmentExpression" || c.type === "VariableDeclarator") && (f4(a.object) || ((s = i.label) == null ? void 0 : s.memberChain));
  return fl(i.label, [i, p ? n : I(X([R, n]))]);
}
function Db(t, e, r) {
  let s = r("property"), { node: i } = t, n = Nt(t);
  return i.computed ? !i.property || hs(i.property) ? [n, "[", s, "]"] : I([n, "[", X([R, s]), R, "]"]) : [n, ".", s];
}
function bb(t, e, r) {
  if (t.node.type === "ChainExpression") return t.call(() => bb(t, e, r), "expression");
  let s = (t.parent.type === "ChainExpression" ? t.grandparent : t.parent).type === "ExpressionStatement", i = [];
  function n(U) {
    let { originalText: oe } = e, he = Ta(oe, De(U));
    return oe.charAt(he) === ")" ? he !== !1 && hm(oe, he + 1) : Ws(U, e);
  }
  function a() {
    let { node: U } = t;
    if (U.type === "ChainExpression") return t.call(a, "expression");
    if (Ae(U) && (_n(U.callee) || Ae(U.callee))) {
      let oe = n(U);
      i.unshift({ node: U, hasTrailingEmptyLine: oe, printed: [_r(t, [Nt(t), un(t, e, r), rc(t, e, r)], e), oe ? q : ""] }), t.call(a, "callee");
    } else _n(U) ? (i.unshift({ node: U, needsParens: En(t, e), printed: _r(t, Ve(U) ? Db(t, e, r) : jb(t, e, r), e) }), t.call(a, "object")) : U.type === "TSNonNullExpression" ? (i.unshift({ node: U, printed: _r(t, "!", e) }), t.call(a, "expression")) : i.unshift({ node: U, printed: r() });
  }
  let { node: l } = t;
  i.unshift({ node: l, printed: [Nt(t), un(t, e, r), rc(t, e, r)] }), l.callee && t.call(a, "callee");
  let c = [], p = [i[0]], d = 1;
  for (; d < i.length && (i[d].node.type === "TSNonNullExpression" || Ae(i[d].node) || Ve(i[d].node) && i[d].node.computed && hs(i[d].node.property)); ++d) p.push(i[d]);
  if (!Ae(i[0].node)) for (; d + 1 < i.length && _n(i[d].node) && _n(i[d + 1].node); ++d) p.push(i[d]);
  c.push(p), p = [];
  let m = !1;
  for (; d < i.length; ++d) {
    if (m && _n(i[d].node)) {
      if (i[d].node.computed && hs(i[d].node.property)) {
        p.push(i[d]);
        continue;
      }
      c.push(p), p = [], m = !1;
    }
    (Ae(i[d].node) || i[d].node.type === "ImportExpression") && (m = !0), p.push(i[d]), z(i[d].node, te.Trailing) && (c.push(p), p = [], m = !1);
  }
  p.length > 0 && c.push(p);
  function y(U) {
    return /^[A-Z]|^[$_]+$/u.test(U);
  }
  function g(U) {
    return U.length <= e.tabWidth;
  }
  function x(U) {
    var oe;
    let he = (oe = U[1][0]) == null ? void 0 : oe.node.computed;
    if (U[0].length === 1) {
      let $e = U[0][0].node;
      return $e.type === "ThisExpression" || $e.type === "Identifier" && (y($e.name) || s && g($e.name) || he);
    }
    let Re = Fe(!1, U[0], -1).node;
    return Ve(Re) && Re.property.type === "Identifier" && (y(Re.property.name) || he);
  }
  let v = c.length >= 2 && !z(c[1][0].node) && x(c);
  function w(U) {
    let oe = U.map((he) => he.printed);
    return U.length > 0 && Fe(!1, U, -1).needsParens ? ["(", ...oe, ")"] : oe;
  }
  function C(U) {
    return U.length === 0 ? "" : X([q, be(q, U.map(w))]);
  }
  let b = c.map(w), k = b, Q = v ? 3 : 2, F = c.flat(), $ = F.slice(1, -1).some((U) => z(U.node, te.Leading)) || F.slice(0, -1).some((U) => z(U.node, te.Trailing)) || c[Q] && z(c[Q][0].node, te.Leading);
  if (c.length <= Q && !$ && !c.some((U) => Fe(!1, U, -1).hasTrailingEmptyLine)) return B2(t) ? k : I(k);
  let N = Fe(!1, c[v ? 1 : 0], -1).node, _ = !Ae(N) && n(N), W = [w(c[0]), v ? c.slice(1, 2).map(w) : "", _ ? q : "", C(c.slice(v ? 2 : 1))], V = i.map(({ node: U }) => U).filter(Ae);
  function j() {
    let U = Fe(!1, Fe(!1, c, -1), -1).node, oe = Fe(!1, b, -1);
    return Ae(U) && It(oe) && V.slice(0, -1).some((he) => he.arguments.some(No));
  }
  let B;
  return $ || V.length > 2 && V.some((U) => !U.arguments.every((oe) => Br(oe))) || b.slice(0, -1).some(It) || j() ? B = I(W) : B = [It(k) || _ ? ds : "", Yi([k, W])], fl({ memberChain: !0 }, B);
}
var g4 = bb;
function vb(t, e, r) {
  var s;
  let { node: i } = t, n = i.type === "NewExpression", a = i.type === "ImportExpression", l = Nt(t), c = Tr(i), p = c.length === 1 && $2(c[0], e.originalText);
  if (p || y4(t) || eh(i, t.parent)) {
    let m = [];
    if (Ku(t, () => {
      m.push(r());
    }), !(p && (s = m[0].label) != null && s.embed)) return [n ? "new " : "", NO(t, r), l, un(t, e, r), "(", be(", ", m), ")"];
  }
  if (!a && !n && _n(i.callee) && !t.call((m) => En(m, e), "callee", ...i.callee.type === "ChainExpression" ? ["expression"] : [])) return g4(t, e, r);
  let d = [n ? "new " : "", NO(t, r), l, un(t, e, r), rc(t, e, r)];
  return a || Ae(i.callee) ? I(d) : d;
}
function NO(t, e) {
  let { node: r } = t;
  return r.type === "ImportExpression" ? `import${r.phase ? `.${r.phase}` : ""}` : e("callee");
}
function y4(t) {
  let { node: e } = t;
  if (e.type !== "CallExpression" || e.optional || e.callee.type !== "Identifier") return !1;
  let r = Tr(e);
  return e.callee.name === "require" ? r.length === 1 && wt(r[0]) || r.length > 1 : e.callee.name === "define" && t.parent.type === "ExpressionStatement" ? r.length === 1 || r.length === 2 && r[0].type === "ArrayExpression" || r.length === 3 && wt(r[0]) && r[1].type === "ArrayExpression" : !1;
}
function ml(t, e, r, s, i, n) {
  let a = D4(t, e, r, s, n), l = n ? r(n, { assignmentLayout: a }) : "";
  switch (a) {
    case "break-after-operator":
      return I([I(s), i, I(X([K, l]))]);
    case "never-break-after-operator":
      return I([I(s), i, " ", l]);
    case "fluid": {
      let c = Symbol("assignment");
      return I([I(s), i, I(X(K), { id: c }), Ns, rh(l, { groupId: c })]);
    }
    case "break-lhs":
      return I([s, i, " ", I(l)]);
    case "chain":
      return [I(s), i, K, l];
    case "chain-tail":
      return [I(s), i, X([K, l])];
    case "chain-tail-arrow-chain":
      return [I(s), i, l];
    case "only-left":
      return s;
  }
}
function O4(t, e, r) {
  let { node: s } = t;
  return ml(t, e, r, r("left"), [" ", s.operator], "right");
}
function x4(t, e, r) {
  return ml(t, e, r, r("id"), " =", "init");
}
function D4(t, e, r, s, i) {
  let { node: n } = t, a = n[i];
  if (!a) return "only-left";
  let l = !Fu(a);
  if (t.match(Fu, Sb, (d) => !l || d.type !== "ExpressionStatement" && d.type !== "VariableDeclaration")) return l ? a.type === "ArrowFunctionExpression" && a.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
  if (!l && Fu(a.right) || ls(e.originalText, a)) return "break-after-operator";
  if (n.type === "ImportAttribute" || a.type === "CallExpression" && a.callee.name === "require" || e.parser === "json5" || e.parser === "jsonc" || e.parser === "json") return "never-break-after-operator";
  let c = wB(s);
  if (v4(n) || C4(n) || wb(n) && c) return "break-lhs";
  let p = T4(n, s, e);
  return t.call(() => b4(t, e, r, p), i) ? "break-after-operator" : S4(n) ? "break-lhs" : !c && (p || a.type === "TemplateLiteral" || a.type === "TaggedTemplateExpression" || GQ(a) || hs(a) || a.type === "ClassExpression") ? "never-break-after-operator" : "fluid";
}
function b4(t, e, r, s) {
  let i = t.node;
  if (Bs(i) && !_o(i)) return !0;
  switch (i.type) {
    case "StringLiteralTypeAnnotation":
    case "SequenceExpression":
      return !0;
    case "TSConditionalType":
    case "ConditionalTypeAnnotation":
      if (!e.experimentalTernaries && !F4(i)) break;
      return !0;
    case "ConditionalExpression": {
      if (!e.experimentalTernaries) {
        let { test: p } = i;
        return Bs(p) && !_o(p);
      }
      let { consequent: l, alternate: c } = i;
      return l.type === "ConditionalExpression" || c.type === "ConditionalExpression";
    }
    case "ClassExpression":
      return Ee(i.decorators);
  }
  if (s) return !1;
  let n = i, a = [];
  for (; ; ) if (n.type === "UnaryExpression" || n.type === "AwaitExpression" || n.type === "YieldExpression" && n.argument !== null) n = n.argument, a.push("argument");
  else if (n.type === "TSNonNullExpression") n = n.expression, a.push("expression");
  else break;
  return !!(wt(n) || t.call(() => Ab(t, e, r), ...a));
}
function v4(t) {
  if (Sb(t)) {
    let e = t.left || t.id;
    return e.type === "ObjectPattern" && e.properties.length > 2 && e.properties.some((r) => {
      var s;
      return Gs(r) && (!r.shorthand || ((s = r.value) == null ? void 0 : s.type) === "AssignmentPattern");
    });
  }
  return !1;
}
function Fu(t) {
  return t.type === "AssignmentExpression";
}
function Sb(t) {
  return Fu(t) || t.type === "VariableDeclarator";
}
function S4(t) {
  let e = A4(t);
  if (Ee(e)) {
    let r = t.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
    if (e.length > 1 && e.some((s) => s[r] || s.default)) return !0;
  }
  return !1;
}
var w4 = Pe(["TSTypeAliasDeclaration", "TypeAlias"]);
function A4(t) {
  var e;
  if (w4(t)) return (e = t.typeParameters) == null ? void 0 : e.params;
}
function C4(t) {
  if (t.type !== "VariableDeclarator") return !1;
  let { typeAnnotation: e } = t.id;
  if (!e || !e.typeAnnotation) return !1;
  let r = MO(e.typeAnnotation);
  return Ee(r) && r.length > 1 && r.some((s) => Ee(MO(s)) || s.type === "TSConditionalType");
}
function wb(t) {
  var e;
  return t.type === "VariableDeclarator" && ((e = t.init) == null ? void 0 : e.type) === "ArrowFunctionExpression";
}
var E4 = Pe(["TSTypeReference", "GenericTypeAnnotation"]);
function MO(t) {
  var r;
  var e;
  if (E4(t)) return (e = (r = t.typeArguments) != null ? r : t.typeParameters) == null ? void 0 : e.params;
}
function Ab(t, e, r, s = !1) {
  var i;
  let { node: n } = t, a = () => Ab(t, e, r, !0);
  if (n.type === "ChainExpression" || n.type === "TSNonNullExpression") return t.call(a, "expression");
  if (Ae(n)) {
    if ((i = vb(t, e, r).label) != null && i.memberChain) return !1;
    let l = Tr(n);
    return !(l.length === 0 || l.length === 1 && gm(l[0], e)) || k4(n, r) ? !1 : t.call(a, "callee");
  }
  return Ve(n) ? t.call(a, "object") : s && (n.type === "Identifier" || n.type === "ThisExpression");
}
function T4(t, e, r) {
  return Gs(t) ? (e = Dm(e), typeof e == "string" && aa(e) < r.tabWidth + 3) : !1;
}
function k4(t, e) {
  let r = P4(t);
  if (Ee(r)) {
    if (r.length > 1) return !0;
    if (r.length === 1) {
      let i = r[0];
      if (wi(i) || Om(i) || i.type === "TSTypeLiteral" || i.type === "ObjectTypeAnnotation") return !0;
    }
    let s = t.typeParameters ? "typeParameters" : "typeArguments";
    if (It(e(s))) return !0;
  }
  return !1;
}
function P4(t) {
  var r;
  var e;
  return (e = (r = t.typeParameters) != null ? r : t.typeArguments) == null ? void 0 : e.params;
}
function F4(t) {
  function e(r) {
    var s;
    switch (r.type) {
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "TSFunctionType":
        return !!r.typeParameters;
      case "TSTypeReference":
        return !!((s = r.typeArguments) != null ? s : r.typeParameters);
      default:
        return !1;
    }
  }
  return e(t.checkType) || e(t.extendsType);
}
function Tn(t, e, r, s, i) {
  let n = t.node, a = Pt(n), l = i ? un(t, e, r) : "";
  if (a.length === 0) return [l, "(", Le(t, e, { filter: (g) => qr(e.originalText, De(g)) === ")" }), ")"];
  let { parent: c } = t, p = eh(c), d = Cb(n), m = [];
  if (hB(t, (g, x) => {
    let v = x === a.length - 1;
    v && n.rest && m.push("..."), m.push(r()), !v && (m.push(","), p || d ? m.push(" ") : Ws(a[x], e) ? m.push(q, q) : m.push(K));
  }), s && !Q4(t)) {
    if (It(l) || It(m)) throw new tc();
    return I([md(l), "(", md(m), ")"]);
  }
  let y = a.every((g) => !Ee(g.decorators));
  return d && y ? [l, "(", ...m, ")"] : p ? [l, "(", ...m, ")"] : (k2(c) || KQ(c) || c.type === "TypeAlias" || c.type === "UnionTypeAnnotation" || c.type === "IntersectionTypeAnnotation" || c.type === "FunctionTypeAnnotation" && c.returnType === n) && a.length === 1 && a[0].name === null && n.this !== a[0] && a[0].typeAnnotation && n.typeParameters === null && mm(a[0].typeAnnotation) && !n.rest ? e.arrowParens === "always" || n.type === "HookTypeAnnotation" ? ["(", ...m, ")"] : m : [l, "(", X([R, ...m]), de(!cB(n) && Ys(e, "all") ? "," : ""), R, ")"];
}
function Cb(t) {
  if (!t) return !1;
  let e = Pt(t);
  if (e.length !== 1) return !1;
  let [r] = e;
  return !z(r) && (r.type === "ObjectPattern" || r.type === "ArrayPattern" || r.type === "Identifier" && r.typeAnnotation && (r.typeAnnotation.type === "TypeAnnotation" || r.typeAnnotation.type === "TSTypeAnnotation") && Si(r.typeAnnotation.typeAnnotation) || r.type === "FunctionTypeParam" && Si(r.typeAnnotation) && r !== t.rest || r.type === "AssignmentPattern" && (r.left.type === "ObjectPattern" || r.left.type === "ArrayPattern") && (r.right.type === "Identifier" || Rr(r.right) && r.right.properties.length === 0 || St(r.right) && r.right.elements.length === 0));
}
function $4(t) {
  let e;
  return t.returnType ? (e = t.returnType, e.typeAnnotation && (e = e.typeAnnotation)) : t.typeAnnotation && (e = t.typeAnnotation), e;
}
function Pa(t, e) {
  var r;
  let s = $4(t);
  if (!s) return !1;
  let i = (r = t.typeParameters) == null ? void 0 : r.params;
  if (i) {
    if (i.length > 1) return !1;
    if (i.length === 1) {
      let n = i[0];
      if (n.constraint || n.default) return !1;
    }
  }
  return Pt(t).length === 1 && (Si(s) || It(e));
}
function Q4(t) {
  return t.match((e) => e.type === "ArrowFunctionExpression" && e.body.type === "BlockStatement", (e, r) => {
    if (e.type === "CallExpression" && r === "arguments" && e.arguments.length === 1 && e.callee.type === "CallExpression") {
      let s = e.callee.callee;
      return s.type === "Identifier" || s.type === "MemberExpression" && !s.computed && s.object.type === "Identifier" && s.property.type === "Identifier";
    }
    return !1;
  }, (e, r) => e.type === "VariableDeclarator" && r === "init" || e.type === "ExportDefaultDeclaration" && r === "declaration" || e.type === "TSExportAssignment" && r === "expression" || e.type === "AssignmentExpression" && r === "right" && e.left.type === "MemberExpression" && e.left.object.type === "Identifier" && e.left.object.name === "module" && e.left.property.type === "Identifier" && e.left.property.name === "exports", (e) => e.type !== "VariableDeclaration" || e.kind === "const" && e.declarations.length === 1);
}
function B4(t) {
  let e = Pt(t);
  return e.length > 1 && e.some((r) => r.type === "TSParameterProperty");
}
var I4 = Pe(["VoidTypeAnnotation", "TSVoidKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword"]), N4 = Pe(["ObjectTypeAnnotation", "TSTypeLiteral", "GenericTypeAnnotation", "TSTypeReference"]);
function M4(t) {
  let { types: e } = t;
  if (e.some((s) => z(s))) return !1;
  let r = e.find((s) => N4(s));
  return r ? e.every((s) => s === r || I4(s)) : !1;
}
function Eb(t) {
  return mm(t) || Si(t) ? !0 : wi(t) ? M4(t) : !1;
}
function L4(t, e, r) {
  let s = e.semi ? ";" : "", { node: i } = t, n = [Ht(t), "opaque type ", r("id"), r("typeParameters")];
  return i.supertype && n.push(": ", r("supertype")), i.impltype && n.push(" = ", r("impltype")), n.push(s), n;
}
function Tb(t, e, r) {
  let s = e.semi ? ";" : "", { node: i } = t, n = [Ht(t)];
  n.push("type ", r("id"), r("typeParameters"));
  let a = i.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
  return [ml(t, e, r, n, " =", a), s];
}
function kb(t, e, r) {
  let s = !1;
  return I(t.map(({ isFirst: i, previous: n, node: a, index: l }) => {
    let c = r();
    if (i) return c;
    let p = Si(a), d = Si(n);
    return d && p ? [" & ", s ? X(c) : c] : !d && !p || ls(e.originalText, a) ? e.experimentalOperatorPosition === "start" ? X([K, "& ", c]) : X([" &", K, c]) : (l > 1 && (s = !0), [" & ", l > 1 ? X(c) : c]);
  }, "types"));
}
function Pb(t, e, r) {
  let { node: s } = t, { parent: i } = t, n = i.type !== "TypeParameterInstantiation" && (!Ai(i) || !e.experimentalTernaries) && i.type !== "TSTypeParameterInstantiation" && i.type !== "GenericTypeAnnotation" && i.type !== "TSTypeReference" && i.type !== "TSTypeAssertion" && i.type !== "TupleTypeAnnotation" && i.type !== "TSTupleType" && !(i.type === "FunctionTypeParam" && !i.name && t.grandparent.this !== i) && !((i.type === "TypeAlias" || i.type === "VariableDeclarator" || i.type === "TSTypeAliasDeclaration") && ls(e.originalText, s)), a = Eb(s), l = t.map((d) => {
    let m = r();
    return a || (m = ps(2, m)), _r(d, m, e);
  }, "types");
  if (a) return be(" | ", l);
  let c = n && !ls(e.originalText, s), p = [de([c ? K : "", "| "]), be([K, "| "], l)];
  return En(t, e) ? I([X(p), R]) : (i.type === "TupleTypeAnnotation" || i.type === "TSTupleType") && i[i.type === "TupleTypeAnnotation" && i.types ? "types" : "elementTypes"].length > 1 ? I([X([de(["(", R]), p]), R, de(")")]) : I(n ? X(p) : p);
}
function _4(t) {
  var e;
  let { node: r, parent: s } = t;
  return r.type === "FunctionTypeAnnotation" && (k2(s) || !((s.type === "ObjectTypeProperty" || s.type === "ObjectTypeInternalSlot") && !s.variance && !s.optional && Jc(s, r) || s.type === "ObjectTypeCallProperty" || ((e = t.getParentNode(2)) == null ? void 0 : e.type) === "DeclareFunction"));
}
function Fb(t, e, r) {
  let { node: s } = t, i = [sh(t)];
  (s.type === "TSConstructorType" || s.type === "TSConstructSignatureDeclaration") && i.push("new ");
  let n = Tn(t, e, r, !1, !0), a = [];
  return s.type === "FunctionTypeAnnotation" ? a.push(_4(t) ? " => " : ": ", r("returnType")) : a.push(bt(t, r, s.returnType ? "returnType" : "typeAnnotation")), Pa(s, a) && (n = I(n)), i.push(n, a), I(i);
}
function $b(t, e, r) {
  return [r("objectType"), Nt(t), "[", r("indexType"), "]"];
}
function Qb(t, e, r) {
  return ["infer ", r("typeParameter")];
}
function LO(t, e, r) {
  let { node: s } = t;
  return [s.postfix ? "" : r, bt(t, e), s.postfix ? r : ""];
}
function Bb(t, e, r) {
  let { node: s } = t;
  return ["...", ...s.type === "TupleTypeSpreadElement" && s.label ? [r("label"), ": "] : [], r("typeAnnotation")];
}
function Ib(t, e, r) {
  let { node: s } = t;
  return [s.variance ? r("variance") : "", r("label"), s.optional ? "?" : "", ": ", r("elementType")];
}
var R4 = /* @__PURE__ */ new WeakSet();
function bt(t, e, r = "typeAnnotation") {
  let { node: { [r]: s } } = t;
  if (!s) return "";
  let i = !1;
  if (s.type === "TSTypeAnnotation" || s.type === "TypeAnnotation") {
    let n = t.call(Nb, r);
    (n === "=>" || n === ":" && z(s, te.Leading)) && (i = !0), R4.add(s);
  }
  return i ? [" ", e(r)] : e(r);
}
var Nb = (t) => t.match((e) => e.type === "TSTypeAnnotation", (e, r) => (r === "returnType" || r === "typeAnnotation") && (e.type === "TSFunctionType" || e.type === "TSConstructorType")) ? "=>" : t.match((e) => e.type === "TSTypeAnnotation", (e, r) => r === "typeAnnotation" && (e.type === "TSJSDocNullableType" || e.type === "TSJSDocNonNullableType" || e.type === "TSTypePredicate")) || t.match((e) => e.type === "TypeAnnotation", (e, r) => r === "typeAnnotation" && e.type === "Identifier", (e, r) => r === "id" && e.type === "DeclareFunction") || t.match((e) => e.type === "TypeAnnotation", (e, r) => r === "typeAnnotation" && e.type === "Identifier", (e, r) => r === "id" && e.type === "DeclareHook") || t.match((e) => e.type === "TypeAnnotation", (e, r) => r === "bound" && e.type === "TypeParameter" && e.usesExtendsBound) ? "" : ":";
function Mb(t, e, r) {
  let s = Nb(t);
  return s ? [s, " ", r("typeAnnotation")] : r("typeAnnotation");
}
function Lb(t) {
  return [t("elementType"), "[]"];
}
function _b({ node: t }, e) {
  let r = t.type === "TSTypeQuery" ? "exprName" : "argument", s = t.type === "TypeofTypeAnnotation" || t.typeArguments ? "typeArguments" : "typeParameters";
  return ["typeof ", e(r), e(s)];
}
function Rb(t, e) {
  let { node: r } = t;
  return [r.type === "TSTypePredicate" && r.asserts ? "asserts " : r.type === "TypePredicate" && r.kind ? `${r.kind} ` : "", e("parameterName"), r.typeAnnotation ? [" is ", bt(t, e)] : ""];
}
function Nt(t) {
  let { node: e } = t;
  return !e.optional || e.type === "Identifier" && e === t.parent.key ? "" : Ae(e) || Ve(e) && e.computed || e.type === "OptionalIndexedAccessType" ? "?." : "?";
}
function qb(t) {
  return t.node.definite || t.match(void 0, (e, r) => r === "id" && e.type === "VariableDeclarator" && e.definite) ? "!" : "";
}
var q4 = /* @__PURE__ */ new Set(["DeclareClass", "DeclareComponent", "DeclareFunction", "DeclareHook", "DeclareVariable", "DeclareExportDeclaration", "DeclareExportAllDeclaration", "DeclareOpaqueType", "DeclareTypeAlias", "DeclareEnum", "DeclareInterface"]);
function Ht(t) {
  let { node: e } = t;
  return e.declare || q4.has(e.type) && t.parent.type !== "DeclareExportDeclaration" ? "declare " : "";
}
var j4 = /* @__PURE__ */ new Set(["TSAbstractMethodDefinition", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]);
function sh({ node: t }) {
  return t.abstract || j4.has(t.type) ? "abstract " : "";
}
function un(t, e, r) {
  let s = t.node;
  return s.typeArguments ? r("typeArguments") : s.typeParameters ? r("typeParameters") : "";
}
function jb(t, e, r) {
  return ["::", r("callee")];
}
function ai(t, e, r) {
  return t.type === "EmptyStatement" ? ";" : t.type === "BlockStatement" || r ? [" ", e] : X([K, e]);
}
function Xb(t, e) {
  return ["...", e("argument"), bt(t, e)];
}
function sc(t) {
  return t.accessibility ? t.accessibility + " " : "";
}
function X4(t, e, r, s) {
  let { node: i } = t, n = i.inexact ? "..." : "";
  return z(i, te.Dangling) ? I([r, n, Le(t, e, { indent: !0 }), R, s]) : [r, n, s];
}
function Tm(t, e, r) {
  let { node: s } = t, i = [], n = "[", a = "]", l = s.type === "TupleTypeAnnotation" && s.types ? "types" : s.type === "TSTupleType" || s.type === "TupleTypeAnnotation" ? "elementTypes" : "elements", c = s[l];
  if (c.length === 0) i.push(X4(t, e, n, a));
  else {
    let p = Fe(!1, c, -1), d = (p == null ? void 0 : p.type) !== "RestElement" && !s.inexact, m = p === null, y = Symbol("array"), g = !e.__inJestEach && c.length > 1 && c.every((w, C, b) => {
      let k = w == null ? void 0 : w.type;
      if (!St(w) && !Rr(w)) return !1;
      let Q = b[C + 1];
      if (Q && k !== Q.type) return !1;
      let F = St(w) ? "elements" : "properties";
      return w[F] && w[F].length > 1;
    }), x = Zb(s, e), v = d ? m ? "," : Ys(e) ? x ? de(",", "", { groupId: y }) : de(",") : "" : "";
    i.push(I([n, X([R, x ? V4(t, e, r, v) : [Z4(t, e, r, l, s.inexact), v], Le(t, e)]), R, a], { shouldBreak: g, id: y }));
  }
  return i.push(Nt(t), bt(t, r)), i;
}
function Zb(t, e) {
  return St(t) && t.elements.length > 1 && t.elements.every((r) => r && (hs(r) || E2(r) && !z(r.argument)) && !z(r, te.Trailing | te.Line, (s) => !cr(e.originalText, ke(s), { backwards: !0 })));
}
function Vb({ node: t }, { originalText: e }) {
  let r = (i) => um(e, cm(e, i)), s = (i) => e[i] === "," ? i : s(r(i + 1));
  return hm(e, s(De(t)));
}
function Z4(t, e, r, s, i) {
  let n = [];
  return t.each(({ node: a, isLast: l }) => {
    n.push(a ? I(r()) : ""), (!l || i) && n.push([",", K, a && Vb(t, e) ? R : ""]);
  }, s), i && n.push("..."), n;
}
function V4(t, e, r, s) {
  let i = [];
  return t.each(({ isLast: n, next: a }) => {
    i.push([r(), n ? s : ","]), n || i.push(Vb(t, e) ? [q, q] : z(a, te.Leading | te.Line) ? q : K);
  }, "elements"), R2(i);
}
var z4 = /^[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC][\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/, U4 = (t) => z4.test(t), Y4 = U4;
function W4(t) {
  return t.length === 1 ? t : t.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/u, "$1$2").replace(/^([+-]?[\d.]+)e[+-]?0+$/u, "$1").replace(/^([+-])?\./u, "$10.").replace(/(\.\d+?)0+(?=e|$)/u, "$1").replace(/\.(?=e|$)/u, "");
}
var ha = W4, $u = /* @__PURE__ */ new WeakMap();
function zb(t) {
  return /^(?:\d+|\d+\.\d+)$/u.test(t);
}
function _O(t, e) {
  return e.parser === "json" || e.parser === "jsonc" || !wt(t.key) || ua(Wt(t.key), e).slice(1, -1) !== t.key.value ? !1 : !!(Y4(t.key.value) && !(e.parser === "babel-ts" && t.type === "ClassProperty" || (e.parser === "typescript" || e.parser === "oxc-ts") && t.type === "PropertyDefinition") || zb(t.key.value) && String(Number(t.key.value)) === t.key.value && t.type !== "ImportAttribute" && (e.parser === "babel" || e.parser === "acorn" || e.parser === "oxc" || e.parser === "espree" || e.parser === "meriyah" || e.parser === "__babel_estree"));
}
function G4(t, e) {
  let { key: r } = t.node;
  return (r.type === "Identifier" || hs(r) && zb(ha(Wt(r))) && String(r.value) === ha(Wt(r)) && !(e.parser === "typescript" || e.parser === "babel-ts" || e.parser === "oxc-ts")) && (e.parser === "json" || e.parser === "jsonc" || e.quoteProps === "consistent" && $u.get(t.parent));
}
function gl(t, e, r) {
  let { node: s } = t;
  if (s.computed) return ["[", r("key"), "]"];
  let { parent: i } = t, { key: n } = s;
  if (e.quoteProps === "consistent" && !$u.has(i)) {
    let a = t.siblings.some((l) => !l.computed && wt(l.key) && !_O(l, e));
    $u.set(i, a);
  }
  if (G4(t, e)) {
    let a = ua(JSON.stringify(n.type === "Identifier" ? n.name : n.value.toString()), e);
    return t.call((l) => _r(l, a, e), "key");
  }
  return _O(s, e) && (e.quoteProps === "as-needed" || e.quoteProps === "consistent" && !$u.get(i)) ? t.call((a) => _r(a, /^\d/u.test(n.value) ? ha(n.value) : n.value, e), "key") : r("key");
}
function lp(t, e, r) {
  let { node: s } = t;
  return s.shorthand ? r("value") : ml(t, e, r, gl(t, e, r), ":", "value");
}
var H4 = ({ node: t, key: e, parent: r }) => e === "value" && t.type === "FunctionExpression" && (r.type === "ObjectMethod" || r.type === "ClassMethod" || r.type === "ClassPrivateMethod" || r.type === "MethodDefinition" || r.type === "TSAbstractMethodDefinition" || r.type === "TSDeclareMethod" || r.type === "Property" && Kc(r));
function Ub(t, e, r, s) {
  if (H4(t)) return km(t, e, r);
  let { node: i } = t, n = !1;
  if ((i.type === "FunctionDeclaration" || i.type === "FunctionExpression") && s != null && s.expandLastArg) {
    let { parent: d } = t;
    Ae(d) && (Tr(d).length > 1 || Pt(i).every((m) => m.type === "Identifier" && !m.typeAnnotation)) && (n = !0);
  }
  let a = [Ht(t), i.async ? "async " : "", `function${i.generator ? "*" : ""} `, i.id ? r("id") : ""], l = Tn(t, e, r, n), c = ih(t, r), p = Pa(i, c);
  return a.push(un(t, e, r), I([p ? I(l) : l, c]), i.body ? " " : "", r("body")), e.semi && (i.declare || !i.body) && a.push(";"), a;
}
function Ad(t, e, r) {
  let { node: s } = t, { kind: i } = s, n = s.value || s, a = [];
  return !i || i === "init" || i === "method" || i === "constructor" ? n.async && a.push("async ") : (pm.ok(i === "get" || i === "set"), a.push(i, " ")), n.generator && a.push("*"), a.push(gl(t, e, r), s.optional ? "?" : "", s === n ? km(t, e, r) : r("value")), a;
}
function km(t, e, r) {
  let { node: s } = t, i = Tn(t, e, r), n = ih(t, r), a = B4(s), l = Pa(s, n), c = [un(t, e, r), I([a ? I(i, { shouldBreak: !0 }) : l ? I(i) : i, n])];
  return s.body ? c.push(" ", r("body")) : c.push(e.semi ? ";" : ""), c;
}
function J4(t) {
  let e = Pt(t);
  return e.length === 1 && !t.typeParameters && !z(t, te.Dangling) && e[0].type === "Identifier" && !e[0].typeAnnotation && !z(e[0]) && !e[0].optional && !t.predicate && !t.returnType;
}
function Yb(t, e) {
  if (e.arrowParens === "always") return !1;
  if (e.arrowParens === "avoid") {
    let { node: r } = t;
    return J4(r);
  }
  return !1;
}
function ih(t, e) {
  let { node: r } = t, s = [bt(t, e, "returnType")];
  return r.predicate && s.push(e("predicate")), s;
}
function Wb(t, e, r) {
  let { node: s } = t, i = e.semi ? ";" : "", n = [];
  if (s.argument) {
    let c = r("argument");
    t9(e, s.argument) ? c = ["(", X([q, c]), q, ")"] : (Bs(s.argument) || e.experimentalTernaries && s.argument.type === "ConditionalExpression" && (s.argument.consequent.type === "ConditionalExpression" || s.argument.alternate.type === "ConditionalExpression")) && (c = I([de("("), X([R, c]), R, de(")")])), n.push(" ", c);
  }
  let a = z(s, te.Dangling), l = i && a && z(s, te.Last | te.Line);
  return l && n.push(i), a && n.push(" ", Le(t, e)), l || n.push(i), n;
}
function K4(t, e, r) {
  return ["return", Wb(t, e, r)];
}
function e9(t, e, r) {
  return ["throw", Wb(t, e, r)];
}
function t9(t, e) {
  if (ls(t.originalText, e) || z(e, te.Leading, (r) => fr(t.originalText, ke(r), De(r))) && !dt(e)) return !0;
  if (dm(e)) {
    let r = e, s;
    for (; s = UQ(r); ) if (r = s, ls(t.originalText, r)) return !0;
  }
  return !1;
}
var up = /* @__PURE__ */ new WeakMap();
function Gb(t) {
  return up.has(t) || up.set(t, t.type === "ConditionalExpression" && !Bt(t, (e) => e.type === "ObjectExpression")), up.get(t);
}
var r9 = (t) => t.type === "SequenceExpression";
function s9(t, e, r, s = {}) {
  let i = [], n, a = [], l = !1, c = !s.expandLastArg && t.node.body.type === "ArrowFunctionExpression", p;
  (function C() {
    let { node: b } = t, k = i9(t, e, r, s);
    if (i.length === 0) i.push(k);
    else {
      let { leading: Q, trailing: F } = db(t, e);
      i.push([Q, k]), a.unshift(F);
    }
    c && (l || (l = b.returnType && Pt(b).length > 0 || b.typeParameters || Pt(b).some((Q) => Q.type !== "Identifier"))), !c || b.body.type !== "ArrowFunctionExpression" ? (n = r("body", s), p = b.body) : t.call(C, "body");
  })();
  let d = !ls(e.originalText, p) && (r9(p) || n9(p, n, e) || !l && Gb(p)), m = t.key === "callee" && ca(t.parent), y = Symbol("arrow-chain"), g = a9(t, s, { signatureDocs: i, shouldBreak: l }), x = !1, v = !1, w = !1;
  return c && (m || s.assignmentLayout) && (v = !0, w = !z(t.node, te.Leading & te.Line), x = s.assignmentLayout === "chain-tail-arrow-chain" || m && !d), n = o9(t, e, s, { bodyDoc: n, bodyComments: a, functionBody: p, shouldPutBodyOnSameLine: d }), I([I(v ? X([w ? R : "", g]) : g, { shouldBreak: x, id: y }), " =>", c ? rh(n, { groupId: y }) : I(n), c && m ? de(R, "", { groupId: y }) : ""]);
}
function i9(t, e, r, s) {
  let { node: i } = t, n = [];
  if (i.async && n.push("async "), Yb(t, e)) n.push(r(["params", 0]));
  else {
    let l = s.expandLastArg || s.expandFirstArg, c = ih(t, r);
    if (l) {
      if (It(c)) throw new tc();
      c = I(md(c));
    }
    n.push(I([Tn(t, e, r, l, !0), c]));
  }
  let a = Le(t, e, { filter(l) {
    let c = Ta(e.originalText, De(l));
    return c !== !1 && e.originalText.slice(c, c + 2) === "=>";
  } });
  return a && n.push(" ", a), n;
}
function n9(t, e, r) {
  var s, i;
  return St(t) || Rr(t) || t.type === "ArrowFunctionExpression" || t.type === "DoExpression" || t.type === "BlockStatement" || dt(t) || ((s = e.label) == null ? void 0 : s.hug) !== !1 && (((i = e.label) == null ? void 0 : i.embed) || $2(t, r.originalText));
}
function a9(t, e, { signatureDocs: r, shouldBreak: s }) {
  if (r.length === 1) return r[0];
  let { parent: i, key: n } = t;
  return n !== "callee" && ca(i) || Bs(i) ? I([r[0], " =>", X([K, be([" =>", K], r.slice(1))])], { shouldBreak: s }) : n === "callee" && ca(i) || e.assignmentLayout ? I(be([" =>", K], r), { shouldBreak: s }) : I(X(be([" =>", K], r)), { shouldBreak: s });
}
function o9(t, e, r, { bodyDoc: s, bodyComments: i, functionBody: n, shouldPutBodyOnSameLine: a }) {
  let { node: l, parent: c } = t, p = r.expandLastArg && Ys(e, "all") ? de(",") : "", d = (r.expandLastArg || c.type === "JSXExpressionContainer") && !z(l) ? R : "";
  return a && Gb(n) ? [" ", I([de("", "("), X([R, s]), de("", ")"), p, d]), i] : a ? [" ", s, i] : [X([K, s, i]), p, d];
}
var l9 = (t, e, r) => {
  if (!(t && e == null)) {
    if (e.findLast) return e.findLast(r);
    for (let s = e.length - 1; s >= 0; s--) {
      let i = e[s];
      if (r(i, s, e)) return i;
    }
  }
}, u9 = l9;
function Cd(t, e, r, s) {
  let { node: i } = t, n = [], a = u9(!1, i[s], (l) => l.type !== "EmptyStatement");
  return t.each(({ node: l }) => {
    l.type !== "EmptyStatement" && (n.push(r()), l !== a && (n.push(q), Ws(l, e) && n.push(q)));
  }, s), n;
}
function Hb(t, e, r) {
  let s = c9(t, e, r), { node: i, parent: n } = t;
  if (i.type === "Program" && (n == null ? void 0 : n.type) !== "ModuleExpression") return s ? [s, q] : "";
  let a = [];
  if (i.type === "StaticBlock" && a.push("static "), a.push("{"), s) a.push(X([q, s]), q);
  else {
    let l = t.grandparent;
    n.type === "ArrowFunctionExpression" || n.type === "FunctionExpression" || n.type === "FunctionDeclaration" || n.type === "ComponentDeclaration" || n.type === "HookDeclaration" || n.type === "ObjectMethod" || n.type === "ClassMethod" || n.type === "ClassPrivateMethod" || n.type === "ForStatement" || n.type === "WhileStatement" || n.type === "DoWhileStatement" || n.type === "DoExpression" || n.type === "ModuleExpression" || n.type === "CatchClause" && !l.finalizer || n.type === "TSModuleDeclaration" || i.type === "StaticBlock" || a.push(q);
  }
  return a.push("}"), a;
}
function c9(t, e, r) {
  let { node: s } = t, i = Ee(s.directives), n = s.body.some((c) => c.type !== "EmptyStatement"), a = z(s, te.Dangling);
  if (!i && !n && !a) return "";
  let l = [];
  return i && (l.push(Cd(t, e, r, "directives")), (n || a) && (l.push(q), Ws(Fe(!1, s.directives, -1), e) && l.push(q))), n && l.push(Cd(t, e, r, "body")), a && l.push(Le(t, e)), l;
}
function h9(t) {
  let e = /* @__PURE__ */ new WeakMap();
  return function(r) {
    return e.has(r) || e.set(r, Symbol(t)), e.get(r);
  };
}
var Jb = h9, Pm = Jb("typeParameters");
function p9(t, e, r) {
  let { node: s } = t;
  return Pt(s).length === 1 && s.type.startsWith("TS") && !s[r][0].constraint && t.parent.type === "ArrowFunctionExpression" && !(e.filepath && /\.ts$/u.test(e.filepath));
}
function So(t, e, r, s) {
  let { node: i } = t;
  if (!i[s]) return "";
  if (!Array.isArray(i[s])) return r(s);
  let n = eh(t.grandparent), a = t.match((c) => !(c[s].length === 1 && Si(c[s][0])), void 0, (c, p) => p === "typeAnnotation", (c) => c.type === "Identifier", wb);
  if (i[s].length === 0 || !a && (n || i[s].length === 1 && (i[s][0].type === "NullableTypeAnnotation" || Eb(i[s][0])))) return ["<", be(", ", t.map(r, s)), d9(t, e), ">"];
  let l = i.type === "TSTypeParameterInstantiation" ? "" : p9(t, e, s) ? "," : Ys(e) ? de(",") : "";
  return I(["<", X([R, be([",", K], t.map(r, s))]), l, R, ">"], { id: Pm(i) });
}
function d9(t, e) {
  let { node: r } = t;
  if (!z(r, te.Dangling)) return "";
  let s = !z(r, te.Line), i = Le(t, e, { indent: !s });
  return s ? i : [i, q];
}
function Kb(t, e, r) {
  let { node: s } = t, i = [s.const ? "const " : ""], n = s.type === "TSTypeParameter" ? r("name") : s.name;
  if (s.variance && i.push(r("variance")), s.in && i.push("in "), s.out && i.push("out "), i.push(n), s.bound && (s.usesExtendsBound && i.push(" extends "), i.push(bt(t, r, "bound"))), s.constraint) {
    let a = Symbol("constraint");
    i.push(" extends", I(X(K), { id: a }), Ns, rh(r("constraint"), { groupId: a }));
  }
  return s.default && i.push(" = ", r("default")), I(i);
}
var ev = Pe(["ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]);
function tv(t, e, r) {
  let { node: s } = t, i = [Ht(t), sh(t), "class"], n = z(s.id, te.Trailing) || z(s.typeParameters, te.Trailing) || z(s.superClass) || Ee(s.extends) || Ee(s.mixins) || Ee(s.implements), a = [], l = [];
  if (s.id && a.push(" ", r("id")), a.push(r("typeParameters")), s.superClass) {
    let d = [g9(t, e, r), r(s.superTypeArguments ? "superTypeArguments" : "superTypeParameters")], m = t.call((y) => ["extends ", _r(y, d, e)], "superClass");
    n ? l.push(K, I(m)) : l.push(" ", m);
  } else l.push(cp(t, e, r, "extends"));
  l.push(cp(t, e, r, "mixins"), cp(t, e, r, "implements"));
  let c;
  if (n) {
    let d;
    sv(s) ? d = [...a, X(l)] : d = X([...a, l]), c = rv(s), i.push(I(d, { id: c }));
  } else i.push(...a, ...l);
  let p = s.body;
  return n && Ee(p.body) ? i.push(de(q, " ", { groupId: c })) : i.push(" "), i.push(r("body")), i;
}
var rv = Jb("heritageGroup");
function f9(t) {
  return de(q, "", { groupId: rv(t) });
}
function m9(t) {
  return ["extends", "mixins", "implements"].reduce((e, r) => e + (Array.isArray(t[r]) ? t[r].length : 0), t.superClass ? 1 : 0) > 1;
}
function sv(t) {
  return t.typeParameters && !z(t.typeParameters, te.Trailing | te.Line) && !m9(t);
}
function cp(t, e, r, s) {
  let { node: i } = t;
  if (!Ee(i[s])) return "";
  let n = Le(t, e, { marker: s });
  return [sv(i) ? de(" ", K, { groupId: Pm(i.typeParameters) }) : K, n, n && q, s, I(X([K, be([",", K], t.map(r, s))]))];
}
function g9(t, e, r) {
  let s = r("superClass"), { parent: i } = t;
  return i.type === "AssignmentExpression" ? I(de(["(", X([R, s]), R, ")"], s)) : s;
}
function iv(t, e, r) {
  let { node: s } = t, i = [];
  return Ee(s.decorators) && i.push(gb(t, e, r)), i.push(sc(s)), s.static && i.push("static "), i.push(sh(t)), s.override && i.push("override "), i.push(Ad(t, e, r)), i;
}
function nv(t, e, r) {
  let { node: s } = t, i = [], n = e.semi ? ";" : "";
  Ee(s.decorators) && i.push(gb(t, e, r)), i.push(Ht(t), sc(s)), s.static && i.push("static "), i.push(sh(t)), s.override && i.push("override "), s.readonly && i.push("readonly "), s.variance && i.push(r("variance")), (s.type === "ClassAccessorProperty" || s.type === "AccessorProperty" || s.type === "TSAbstractAccessorProperty") && i.push("accessor "), i.push(gl(t, e, r), Nt(t), qb(t), bt(t, r));
  let a = s.type === "TSAbstractPropertyDefinition" || s.type === "TSAbstractAccessorProperty";
  return [ml(t, e, r, i, " =", a ? void 0 : "value"), n];
}
function y9(t, e, r) {
  let { node: s } = t, i = [];
  return t.each(({ node: n, next: a, isLast: l }) => {
    i.push(r()), !e.semi && ev(n) && O9(n, a) && i.push(";"), l || (i.push(q), Ws(n, e) && i.push(q));
  }, "body"), z(s, te.Dangling) && i.push(Le(t, e)), ["{", i.length > 0 ? [X([q, i]), q] : "", "}"];
}
function O9(t, e) {
  var r;
  let { type: s, name: i } = t.key;
  if (!t.computed && s === "Identifier" && (i === "static" || i === "get" || i === "set") && !t.value && !t.typeAnnotation) return !0;
  if (!e || e.static || e.accessibility || e.readonly) return !1;
  if (!e.computed) {
    let n = (r = e.key) == null ? void 0 : r.name;
    if (n === "in" || n === "instanceof") return !0;
  }
  if (ev(e) && e.variance && !e.static && !e.declare) return !0;
  switch (e.type) {
    case "ClassProperty":
    case "PropertyDefinition":
    case "TSAbstractPropertyDefinition":
      return e.computed;
    case "MethodDefinition":
    case "TSAbstractMethodDefinition":
    case "ClassMethod":
    case "ClassPrivateMethod": {
      if ((e.value ? e.value.async : e.async) || e.kind === "get" || e.kind === "set") return !1;
      let n = e.value ? e.value.generator : e.generator;
      return !!(e.computed || n);
    }
    case "TSIndexSignature":
      return !0;
  }
  return !1;
}
var x9 = Pe(["TSAsExpression", "TSTypeAssertion", "TSNonNullExpression", "TSInstantiationExpression", "TSSatisfiesExpression"]);
function av(t) {
  return x9(t) ? av(t.expression) : t;
}
var D9 = Pe(["FunctionExpression", "ArrowFunctionExpression"]);
function b9(t) {
  return t.type === "MemberExpression" || t.type === "OptionalMemberExpression" || t.type === "Identifier" && t.name !== "undefined";
}
function v9(t, e) {
  if (e.semi || lv(t, e) || uv(t, e)) return !1;
  let { node: r, key: s, parent: i } = t;
  return !!(r.type === "ExpressionStatement" && (s === "body" && (i.type === "Program" || i.type === "BlockStatement" || i.type === "StaticBlock" || i.type === "TSModuleBlock") || s === "consequent" && i.type === "SwitchCase") && t.call(() => ov(t, e), "expression"));
}
function ov(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case "ParenthesizedExpression":
    case "TypeCastExpression":
    case "ArrayExpression":
    case "ArrayPattern":
    case "TemplateLiteral":
    case "TemplateElement":
    case "RegExpLiteral":
      return !0;
    case "ArrowFunctionExpression":
      if (!Yb(t, e)) return !0;
      break;
    case "UnaryExpression": {
      let { prefix: s, operator: i } = r;
      if (s && (i === "+" || i === "-")) return !0;
      break;
    }
    case "BindExpression":
      if (!r.object) return !0;
      break;
    case "Literal":
      if (r.regex) return !0;
      break;
    default:
      if (dt(r)) return !0;
  }
  return En(t, e) ? !0 : dm(r) ? t.call(() => ov(t, e), ...C2(r)) : !1;
}
function lv({ node: t, parent: e }, r) {
  return (r.parentParser === "markdown" || r.parentParser === "mdx") && t.type === "ExpressionStatement" && dt(t.expression) && e.type === "Program" && e.body.length === 1;
}
function uv({ node: t, parent: e }, r) {
  return (r.parser === "__vue_event_binding" || r.parser === "__vue_ts_event_binding") && t.type === "ExpressionStatement" && e.type === "Program" && e.body.length === 1;
}
function S9(t, e, r) {
  let s = [r("expression")];
  if (uv(t, e)) {
    let i = av(t.node.expression);
    (D9(i) || b9(i)) && s.push(";");
  } else lv(t, e) || e.semi && s.push(";");
  return s;
}
function w9(t, e, r) {
  if (e.__isVueBindings || e.__isVueForBindingLeft) {
    let s = t.map(r, "program", "body", 0, "params");
    if (s.length === 1) return s[0];
    let i = be([",", K], s);
    return e.__isVueForBindingLeft ? ["(", X([R, I(i)]), R, ")"] : i;
  }
  if (e.__isEmbeddedTypescriptGenericParameters) {
    let s = t.map(r, "program", "body", 0, "typeParameters", "params");
    return be([",", K], s);
  }
}
function A9(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case "RegExpLiteral":
      return RO(r);
    case "BigIntLiteral":
      return Ed(r.extra.raw);
    case "NumericLiteral":
      return ha(r.extra.raw);
    case "StringLiteral":
      return ln(ua(r.extra.raw, e));
    case "NullLiteral":
      return "null";
    case "BooleanLiteral":
      return String(r.value);
    case "DirectiveLiteral":
      return qO(r.extra.raw, e);
    case "Literal": {
      if (r.regex) return RO(r.regex);
      if (r.bigint) return Ed(r.raw);
      let { value: s } = r;
      return typeof s == "number" ? ha(r.raw) : typeof s == "string" ? C9(t) ? qO(r.raw, e) : ln(ua(r.raw, e)) : String(s);
    }
  }
}
function C9(t) {
  if (t.key !== "expression") return;
  let { parent: e } = t;
  return e.type === "ExpressionStatement" && typeof e.directive == "string";
}
function Ed(t) {
  return t.toLowerCase();
}
function RO({ pattern: t, flags: e }) {
  return e = [...e].sort().join(""), `/${t}/${e}`;
}
function qO(t, e) {
  let r = t.slice(1, -1);
  if (r.includes('"') || r.includes("'")) return t;
  let s = e.singleQuote ? "'" : '"';
  return s + r + s;
}
function E9(t, e, r) {
  let s = t.originalText.slice(e, r);
  for (let i of t[Symbol.for("comments")]) {
    let n = ke(i);
    if (n > r) break;
    let a = De(i);
    if (a < e) continue;
    let l = a - n;
    s = s.slice(0, n - e) + " ".repeat(l) + s.slice(a - e);
  }
  return s;
}
var Fm = E9;
function T9(t, e, r) {
  let { node: s } = t;
  return ["import", s.phase ? ` ${s.phase}` : "", pv(s), fv(t, e, r), dv(t, e, r), gv(t, e, r), e.semi ? ";" : ""];
}
var cv = (t) => t.type === "ExportDefaultDeclaration" || t.type === "DeclareExportDeclaration" && t.default;
function hv(t, e, r) {
  let { node: s } = t, i = [a4(t, e, r), Ht(t), "export", cv(s) ? " default" : ""], { declaration: n, exported: a } = s;
  return z(s, te.Dangling) && (i.push(" ", Le(t, e)), Q2(s) && i.push(q)), n ? i.push(" ", r("declaration")) : (i.push(F9(s)), s.type === "ExportAllDeclaration" || s.type === "DeclareExportAllDeclaration" ? (i.push(" *"), a && i.push(" as ", r("exported"))) : i.push(fv(t, e, r)), i.push(dv(t, e, r), gv(t, e, r))), i.push(P9(s, e)), i;
}
var k9 = Pe(["ClassDeclaration", "ComponentDeclaration", "FunctionDeclaration", "TSInterfaceDeclaration", "DeclareClass", "DeclareComponent", "DeclareFunction", "DeclareHook", "HookDeclaration", "TSDeclareFunction", "EnumDeclaration"]);
function P9(t, e) {
  return e.semi && (!t.declaration || cv(t) && !k9(t.declaration)) ? ";" : "";
}
function $m(t, e = !0) {
  return t && t !== "value" ? `${e ? " " : ""}${t}${e ? "" : " "}` : "";
}
function pv(t, e) {
  return $m(t.importKind, e);
}
function F9(t) {
  return $m(t.exportKind);
}
function dv(t, e, r) {
  let { node: s } = t;
  if (!s.source) return "";
  let i = [];
  return mv(s, e) && i.push(" from"), i.push(" ", r("source")), i;
}
function fv(t, e, r) {
  let { node: s } = t;
  if (!mv(s, e)) return "";
  let i = [" "];
  if (Ee(s.specifiers)) {
    let n = [], a = [];
    t.each(() => {
      let l = t.node.type;
      if (l === "ExportNamespaceSpecifier" || l === "ExportDefaultSpecifier" || l === "ImportNamespaceSpecifier" || l === "ImportDefaultSpecifier") n.push(r());
      else if (l === "ExportSpecifier" || l === "ImportSpecifier") a.push(r());
      else throw new ka(s, "specifier");
    }, "specifiers"), i.push(be(", ", n)), a.length > 0 && (n.length > 0 && i.push(", "), a.length > 1 || n.length > 0 || s.specifiers.some((l) => z(l)) ? i.push(I(["{", X([e.bracketSpacing ? K : R, be([",", K], a)]), de(Ys(e) ? "," : ""), e.bracketSpacing ? K : R, "}"])) : i.push(["{", e.bracketSpacing ? " " : "", ...a, e.bracketSpacing ? " " : "", "}"]));
  } else i.push("{}");
  return i;
}
function mv(t, e) {
  return t.type !== "ImportDeclaration" || Ee(t.specifiers) || t.importKind === "type" ? !0 : Fm(e, ke(t), ke(t.source)).trimEnd().endsWith("from");
}
function $9(t, e) {
  var r, s;
  if ((r = t.extra) != null && r.deprecatedAssertSyntax) return "assert";
  let i = Fm(e, De(t.source), (s = t.attributes) != null && s[0] ? ke(t.attributes[0]) : De(t)).trimStart();
  return i.startsWith("assert") ? "assert" : i.startsWith("with") || Ee(t.attributes) ? "with" : void 0;
}
function gv(t, e, r) {
  let { node: s } = t;
  if (!s.source) return "";
  let i = $9(s, e);
  if (!i) return "";
  let n = [` ${i} {`];
  return Ee(s.attributes) && (e.bracketSpacing && n.push(" "), n.push(be(", ", t.map(r, "attributes"))), e.bracketSpacing && n.push(" ")), n.push("}"), n;
}
function Q9(t, e, r) {
  let { node: s } = t, { type: i } = s, n = i.startsWith("Import"), a = n ? "imported" : "local", l = n ? "local" : "exported", c = s[a], p = s[l], d = "", m = "";
  return i === "ExportNamespaceSpecifier" || i === "ImportNamespaceSpecifier" ? d = "*" : c && (d = r(a)), p && !B9(s) && (m = r(l)), [$m(i === "ImportSpecifier" ? s.importKind : s.exportKind, !1), d, d && m ? " as " : "", m];
}
function B9(t) {
  if (t.type !== "ImportSpecifier" && t.type !== "ExportSpecifier") return !1;
  let { local: e, [t.type === "ImportSpecifier" ? "imported" : "exported"]: r } = t;
  if (e.type !== r.type || !$Q(e, r)) return !1;
  if (wt(e)) return e.value === r.value && Wt(e) === Wt(r);
  switch (e.type) {
    case "Identifier":
      return e.name === r.name;
    default:
      return !1;
  }
}
function nh(t, e, r) {
  var s;
  let i = e.semi ? ";" : "", { node: n } = t, a = n.type === "ObjectTypeAnnotation", l = n.type === "TSEnumBody" || n.type === "EnumBooleanBody" || n.type === "EnumNumberBody" || n.type === "EnumBigIntBody" || n.type === "EnumStringBody" || n.type === "EnumSymbolBody", c = [n.type === "TSTypeLiteral" || l ? "members" : n.type === "TSInterfaceBody" ? "body" : "properties"];
  a && c.push("indexers", "callProperties", "internalSlots");
  let p = c.flatMap(($) => t.map(({ node: N }) => ({ node: N, printed: r(), loc: ke(N) }), $));
  c.length > 1 && p.sort(($, N) => $.loc - N.loc);
  let { parent: d, key: m } = t, y = a && m === "body" && (d.type === "InterfaceDeclaration" || d.type === "DeclareInterface" || d.type === "DeclareClass"), g = n.type === "TSInterfaceBody" || l || y || n.type === "ObjectPattern" && d.type !== "FunctionDeclaration" && d.type !== "FunctionExpression" && d.type !== "ArrowFunctionExpression" && d.type !== "ObjectMethod" && d.type !== "ClassMethod" && d.type !== "ClassPrivateMethod" && d.type !== "AssignmentPattern" && d.type !== "CatchClause" && n.properties.some(($) => $.value && ($.value.type === "ObjectPattern" || $.value.type === "ArrayPattern")) || n.type !== "ObjectPattern" && e.objectWrap === "preserve" && p.length > 0 && fr(e.originalText, ke(n), p[0].loc), x = y ? ";" : n.type === "TSInterfaceBody" || n.type === "TSTypeLiteral" ? de(i, ";") : ",", v = n.exact ? "{|" : "{", w = n.exact ? "|}" : "}", C = [], b = p.map(($) => {
    let N = [...C, I($.printed)];
    return C = [x, K], ($.node.type === "TSPropertySignature" || $.node.type === "TSMethodSignature" || $.node.type === "TSConstructSignatureDeclaration" || $.node.type === "TSCallSignatureDeclaration") && z($.node, te.PrettierIgnore) && C.shift(), Ws($.node, e) && C.push(q), N;
  });
  if (n.inexact || n.hasUnknownMembers) {
    let $;
    if (z(n, te.Dangling)) {
      let N = z(n, te.Line);
      $ = [Le(t, e), N || cr(e.originalText, De(Fe(!1, nn(n), -1))) ? q : K, "..."];
    } else $ = ["..."];
    b.push([...C, ...$]);
  }
  let k = (s = Fe(!1, p, -1)) == null ? void 0 : s.node, Q = !(n.inexact || n.hasUnknownMembers || k && (k.type === "RestElement" || (k.type === "TSPropertySignature" || k.type === "TSCallSignatureDeclaration" || k.type === "TSMethodSignature" || k.type === "TSConstructSignatureDeclaration" || k.type === "TSIndexSignature") && z(k, te.PrettierIgnore)) || t.match(void 0, ($, N) => $.type === "TSImportType" && N === "options")), F;
  if (b.length === 0) {
    if (!z(n, te.Dangling)) return [v, w, bt(t, r)];
    F = I([v, Le(t, e, { indent: !0 }), R, w, Nt(t), bt(t, r)]);
  } else F = [y && Ee(n.properties) ? f9(d) : "", v, X([e.bracketSpacing ? K : R, ...b]), de(Q && (x !== "," || Ys(e)) ? x : ""), e.bracketSpacing ? K : R, w, Nt(t), bt(t, r)];
  return t.match(($) => $.type === "ObjectPattern" && !Ee($.decorators), hp) || Si(n) && (t.match(void 0, ($, N) => N === "typeAnnotation", ($, N) => N === "typeAnnotation", hp) || t.match(void 0, ($, N) => $.type === "FunctionTypeParam" && N === "typeAnnotation", hp)) || !g && t.match(($) => $.type === "ObjectPattern", ($) => $.type === "AssignmentExpression" || $.type === "VariableDeclarator") ? F : I(F, { shouldBreak: g });
}
function hp(t, e) {
  return (e === "params" || e === "parameters" || e === "this" || e === "rest") && Cb(t);
}
function I9(t) {
  let e = [t];
  for (let r = 0; r < e.length; r++) {
    let s = e[r];
    for (let i of ["test", "consequent", "alternate"]) {
      let n = s[i];
      if (dt(n)) return !0;
      n.type === "ConditionalExpression" && e.push(n);
    }
  }
  return !1;
}
function N9(t, e, r) {
  let { node: s } = t, i = s.type === "ConditionalExpression", n = i ? "alternate" : "falseType", { parent: a } = t, l = i ? r("test") : [r("checkType"), " ", "extends", " ", r("extendsType")];
  return a.type === s.type && a[n] === s ? ps(2, l) : l;
}
var M9 = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"], ["AwaitExpression", "argument"]]);
function L9(t) {
  let { node: e } = t;
  if (e.type !== "ConditionalExpression") return !1;
  let r, s = e;
  for (let i = 0; !r; i++) {
    let n = t.getParentNode(i);
    if (n.type === "ChainExpression" && n.expression === s || Ae(n) && n.callee === s || Ve(n) && n.object === s || n.type === "TSNonNullExpression" && n.expression === s) {
      s = n;
      continue;
    }
    n.type === "NewExpression" && n.callee === s || ss(n) && n.expression === s ? (r = t.getParentNode(i + 1), s = n) : r = n;
  }
  return s === e ? !1 : r[M9.get(r.type)] === s;
}
function _9(t, e, r) {
  let { node: s } = t, i = s.type === "ConditionalExpression", n = i ? "consequent" : "trueType", a = i ? "alternate" : "falseType", l = i ? ["test"] : ["checkType", "extendsType"], c = s[n], p = s[a], d = [], m = !1, { parent: y } = t, g = y.type === s.type && l.some((W) => y[W] === s), x = y.type === s.type && !g, v, w, C = 0;
  do
    w = v || s, v = t.getParentNode(C), C++;
  while (v && v.type === s.type && l.every((W) => v[W] !== w));
  let b = v || y, k = w;
  if (i && (dt(s[l[0]]) || dt(c) || dt(p) || I9(k))) {
    m = !0, x = !0;
    let W = (j) => [de("("), X([R, j]), R, de(")")], V = (j) => j.type === "NullLiteral" || j.type === "Literal" && j.value === null || j.type === "Identifier" && j.name === "undefined";
    d.push(" ? ", V(c) ? r(n) : W(r(n)), " : ", p.type === s.type || V(p) ? r(a) : W(r(a)));
  } else {
    let W = (j) => e.useTabs ? X(r(j)) : ps(2, r(j)), V = [K, "? ", c.type === s.type ? de("", "(") : "", W(n), c.type === s.type ? de("", ")") : "", K, ": ", W(a)];
    d.push(y.type !== s.type || y[a] === s || g ? V : e.useTabs ? _2(X(V)) : ps(Math.max(0, e.tabWidth - 2), V));
  }
  let Q = [n, a, ...l].some((W) => z(s[W], (V) => Er(V) && fr(e.originalText, ke(V), De(V)))), F = (W) => y === b ? I(W, { shouldBreak: Q }) : Q ? [W, ds] : W, $ = !m && (Ve(y) || y.type === "NGPipeExpression" && y.left === s) && !y.computed, N = L9(t), _ = F([N9(t, e, r), x ? d : X(d), i && $ && !N ? R : ""]);
  return g || N ? I([X([R, _]), R]) : _;
}
function R9(t, e) {
  return (Ve(e) || e.type === "NGPipeExpression" && e.left === t) && !e.computed;
}
function q9(t, e, r, s) {
  return [...t.map((i) => nn(i)), nn(e), nn(r)].flat().some((i) => Er(i) && fr(s.originalText, ke(i), De(i)));
}
var j9 = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"], ["AwaitExpression", "argument"]]);
function X9(t) {
  let { node: e } = t;
  if (e.type !== "ConditionalExpression") return !1;
  let r, s = e;
  for (let i = 0; !r; i++) {
    let n = t.getParentNode(i);
    if (n.type === "ChainExpression" && n.expression === s || Ae(n) && n.callee === s || Ve(n) && n.object === s || n.type === "TSNonNullExpression" && n.expression === s) {
      s = n;
      continue;
    }
    n.type === "NewExpression" && n.callee === s || ss(n) && n.expression === s ? (r = t.getParentNode(i + 1), s = n) : r = n;
  }
  return s === e ? !1 : r[j9.get(r.type)] === s;
}
var pp = (t) => [de("("), X([R, t]), R, de(")")];
function Qm(t, e, r, s) {
  if (!e.experimentalTernaries) return _9(t, e, r);
  let { node: i } = t, n = i.type === "ConditionalExpression", a = Ai(i), l = n ? "consequent" : "trueType", c = n ? "alternate" : "falseType", p = n ? ["test"] : ["checkType", "extendsType"], d = i[l], m = i[c], y = p.map((tr) => i[tr]), { parent: g } = t, x = g.type === i.type, v = x && p.some((tr) => g[tr] === i), w = x && g[c] === i, C = d.type === i.type, b = m.type === i.type, k = b || w, Q = e.tabWidth > 2 || e.useTabs, F, $, N = 0;
  do
    $ = F || i, F = t.getParentNode(N), N++;
  while (F && F.type === i.type && p.every((tr) => F[tr] !== $));
  let _ = F || g, W = s && s.assignmentLayout && s.assignmentLayout !== "break-after-operator" && (g.type === "AssignmentExpression" || g.type === "VariableDeclarator" || g.type === "ClassProperty" || g.type === "PropertyDefinition" || g.type === "ClassPrivateProperty" || g.type === "ObjectProperty" || g.type === "Property"), V = (g.type === "ReturnStatement" || g.type === "ThrowStatement") && !(C || b), j = n && _.type === "JSXExpressionContainer" && t.grandparent.type !== "JSXAttribute", B = X9(t), U = R9(i, g), oe = a && En(t, e), he = Q ? e.useTabs ? "	" : " ".repeat(e.tabWidth - 1) : "", Re = q9(y, d, m, e) || C || b, $e = !k && !x && !a && (j ? d.type === "NullLiteral" || d.type === "Literal" && d.value === null : gm(d, e) && DO(i.test, 3)), ft = k || w || a && !x || x && n && DO(i.test, 1) || $e, le = [];
  !C && z(d, te.Dangling) && t.call((tr) => {
    le.push(Le(tr, e), q);
  }, "consequent");
  let ve = [];
  z(i.test, te.Dangling) && t.call((tr) => {
    ve.push(Le(tr, e));
  }, "test"), !b && z(m, te.Dangling) && t.call((tr) => {
    ve.push(Le(tr, e));
  }, "alternate"), z(i, te.Dangling) && ve.push(Le(t, e));
  let ct = Symbol("test"), qe = Symbol("consequent"), it = Symbol("test-and-consequent"), Kt = n ? [pp(r("test")), i.test.type === "ConditionalExpression" ? ds : ""] : [r("checkType"), " ", "extends", " ", Ai(i.extendsType) || i.extendsType.type === "TSMappedType" ? r("extendsType") : I(pp(r("extendsType")))], er = I([Kt, " ?"], { id: ct }), zr = r(l), Pr = X([C || j && (dt(d) || x || k) ? q : K, le, zr]), ne = ft ? I([er, k ? Pr : de(Pr, I(Pr, { id: qe }), { groupId: ct })], { id: it }) : [er, Pr], fe = r(c), Ql = $e ? de(fe, _2(pp(fe)), { groupId: it }) : fe, xe = [ne, ve.length > 0 ? [X([q, ve]), q] : b ? q : $e ? de(K, " ", { groupId: it }) : K, ":", b ? " " : Q ? ft ? de(he, de(k || $e ? " " : he, " "), { groupId: it }) : de(he, " ") : " ", b ? Ql : I([X(Ql), j && !$e ? R : ""]), U && !B ? R : "", Re ? ds : ""];
  return W && !Re ? I(X([R, I(xe)])) : W || V ? I(X(xe)) : B || a && v ? I([X([R, xe]), oe ? R : ""]) : g === _ ? I(xe) : xe;
}
function Z9(t, e, r, s) {
  var l;
  let { node: i } = t;
  if (fm(i)) return A9(t, e);
  let n = e.semi ? ";" : "", a = [];
  switch (i.type) {
    case "JsExpressionRoot":
      return r("node");
    case "JsonRoot":
      return [Le(t, e), r("node"), q];
    case "File":
      return (l = w9(t, e, r)) != null ? l : r("program");
    case "EmptyStatement":
      return "";
    case "ExpressionStatement":
      return S9(t, e, r);
    case "ChainExpression":
      return r("expression");
    case "ParenthesizedExpression":
      return !z(i.expression) && (Rr(i.expression) || St(i.expression)) ? ["(", r("expression"), ")"] : I(["(", X([R, r("expression")]), R, ")"]);
    case "AssignmentExpression":
      return O4(t, e, r);
    case "VariableDeclarator":
      return x4(t, e, r);
    case "BinaryExpression":
    case "LogicalExpression":
      return mb(t, e, r);
    case "AssignmentPattern":
      return [r("left"), " = ", r("right")];
    case "OptionalMemberExpression":
    case "MemberExpression":
      return m4(t, e, r);
    case "MetaProperty":
      return [r("meta"), ".", r("property")];
    case "BindExpression":
      return i.object && a.push(r("object")), a.push(I(X([R, jb(t, e, r)]))), a;
    case "Identifier":
      return [i.name, Nt(t), qb(t), bt(t, r)];
    case "V8IntrinsicIdentifier":
      return ["%", i.name];
    case "SpreadElement":
    case "SpreadElementPattern":
    case "SpreadPropertyPattern":
    case "RestElement":
      return Xb(t, r);
    case "FunctionDeclaration":
    case "FunctionExpression":
      return Ub(t, e, r, s);
    case "ArrowFunctionExpression":
      return s9(t, e, r, s);
    case "YieldExpression":
      return a.push("yield"), i.delegate && a.push("*"), i.argument && a.push(" ", r("argument")), a;
    case "AwaitExpression":
      if (a.push("await"), i.argument) {
        a.push(" ", r("argument"));
        let { parent: c } = t;
        if (Ae(c) && c.callee === i || Ve(c) && c.object === i) {
          a = [X([R, ...a]), R];
          let p = t.findAncestor((d) => d.type === "AwaitExpression" || d.type === "BlockStatement");
          if ((p == null ? void 0 : p.type) !== "AwaitExpression" || !Bt(p.argument, (d) => d === i)) return I(a);
        }
      }
      return a;
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ExportAllDeclaration":
      return hv(t, e, r);
    case "ImportDeclaration":
      return T9(t, e, r);
    case "ImportSpecifier":
    case "ExportSpecifier":
    case "ImportNamespaceSpecifier":
    case "ExportNamespaceSpecifier":
    case "ImportDefaultSpecifier":
    case "ExportDefaultSpecifier":
      return Q9(t, e, r);
    case "ImportAttribute":
      return lp(t, e, r);
    case "Program":
    case "BlockStatement":
    case "StaticBlock":
      return Hb(t, e, r);
    case "ClassBody":
      return y9(t, e, r);
    case "ThrowStatement":
      return e9(t, e, r);
    case "ReturnStatement":
      return K4(t, e, r);
    case "NewExpression":
    case "ImportExpression":
    case "OptionalCallExpression":
    case "CallExpression":
      return vb(t, e, r);
    case "ObjectExpression":
    case "ObjectPattern":
      return nh(t, e, r);
    case "Property":
      return Kc(i) ? Ad(t, e, r) : lp(t, e, r);
    case "ObjectProperty":
      return lp(t, e, r);
    case "ObjectMethod":
      return Ad(t, e, r);
    case "Decorator":
      return ["@", r("expression")];
    case "ArrayExpression":
    case "ArrayPattern":
      return Tm(t, e, r);
    case "SequenceExpression": {
      let { parent: c } = t;
      if (c.type === "ExpressionStatement" || c.type === "ForStatement") {
        let d = [];
        return t.each(({ isFirst: m }) => {
          m ? d.push(r()) : d.push(",", X([K, r()]));
        }, "expressions"), I(d);
      }
      let p = be([",", K], t.map(r, "expressions"));
      return (c.type === "ReturnStatement" || c.type === "ThrowStatement") && t.key === "argument" || c.type === "ArrowFunctionExpression" && t.key === "body" ? I(de([X([R, p]), R], p)) : I(p);
    }
    case "ThisExpression":
      return "this";
    case "Super":
      return "super";
    case "Directive":
      return [r("value"), n];
    case "UnaryExpression":
      return a.push(i.operator), /[a-z]$/u.test(i.operator) && a.push(" "), z(i.argument) ? a.push(I(["(", X([R, r("argument")]), R, ")"])) : a.push(r("argument")), a;
    case "UpdateExpression":
      return [i.prefix ? i.operator : "", r("argument"), i.prefix ? "" : i.operator];
    case "ConditionalExpression":
      return Qm(t, e, r, s);
    case "VariableDeclaration": {
      let c = t.map(r, "declarations"), p = t.parent, d = p.type === "ForStatement" || p.type === "ForInStatement" || p.type === "ForOfStatement", m = i.declarations.some((g) => g.init), y;
      return c.length === 1 && !z(i.declarations[0]) ? y = c[0] : c.length > 0 && (y = X(c[0])), a = [Ht(t), i.kind, y ? [" ", y] : "", X(c.slice(1).map((g) => [",", m && !d ? q : K, g]))], d && p.body !== i || a.push(n), I(a);
    }
    case "WithStatement":
      return I(["with (", r("object"), ")", ai(i.body, r("body"))]);
    case "IfStatement": {
      let c = ai(i.consequent, r("consequent")), p = I(["if (", I([X([R, r("test")]), R]), ")", c]);
      if (a.push(p), i.alternate) {
        let d = z(i.consequent, te.Trailing | te.Line) || Q2(i), m = i.consequent.type === "BlockStatement" && !d;
        a.push(m ? " " : q), z(i, te.Dangling) && a.push(Le(t, e), d ? q : " "), a.push("else", I(ai(i.alternate, r("alternate"), i.alternate.type === "IfStatement")));
      }
      return a;
    }
    case "ForStatement": {
      let c = ai(i.body, r("body")), p = Le(t, e), d = p ? [p, R] : "";
      return !i.init && !i.test && !i.update ? [d, I(["for (;;)", c])] : [d, I(["for (", I([X([R, r("init"), ";", K, r("test"), ";", K, r("update")]), R]), ")", c])];
    }
    case "WhileStatement":
      return I(["while (", I([X([R, r("test")]), R]), ")", ai(i.body, r("body"))]);
    case "ForInStatement":
      return I(["for (", r("left"), " in ", r("right"), ")", ai(i.body, r("body"))]);
    case "ForOfStatement":
      return I(["for", i.await ? " await" : "", " (", r("left"), " of ", r("right"), ")", ai(i.body, r("body"))]);
    case "DoWhileStatement": {
      let c = ai(i.body, r("body"));
      return a = [I(["do", c])], i.body.type === "BlockStatement" ? a.push(" ") : a.push(q), a.push("while (", I([X([R, r("test")]), R]), ")", n), a;
    }
    case "DoExpression":
      return [i.async ? "async " : "", "do ", r("body")];
    case "BreakStatement":
    case "ContinueStatement":
      return a.push(i.type === "BreakStatement" ? "break" : "continue"), i.label && a.push(" ", r("label")), a.push(n), a;
    case "LabeledStatement":
      return i.body.type === "EmptyStatement" ? [r("label"), ":;"] : [r("label"), ": ", r("body")];
    case "TryStatement":
      return ["try ", r("block"), i.handler ? [" ", r("handler")] : "", i.finalizer ? [" finally ", r("finalizer")] : ""];
    case "CatchClause":
      if (i.param) {
        let c = z(i.param, (d) => !Er(d) || d.leading && cr(e.originalText, De(d)) || d.trailing && cr(e.originalText, ke(d), { backwards: !0 })), p = r("param");
        return ["catch ", c ? ["(", X([R, p]), R, ") "] : ["(", p, ") "], r("body")];
      }
      return ["catch ", r("body")];
    case "SwitchStatement":
      return [I(["switch (", X([R, r("discriminant")]), R, ")"]), " {", i.cases.length > 0 ? X([q, be(q, t.map(({ node: c, isLast: p }) => [r(), !p && Ws(c, e) ? q : ""], "cases"))]) : "", q, "}"];
    case "SwitchCase": {
      i.test ? a.push("case ", r("test"), ":") : a.push("default:"), z(i, te.Dangling) && a.push(" ", Le(t, e));
      let c = i.consequent.filter((p) => p.type !== "EmptyStatement");
      if (c.length > 0) {
        let p = Cd(t, e, r, "consequent");
        a.push(c.length === 1 && c[0].type === "BlockStatement" ? [" ", p] : X([q, p]));
      }
      return a;
    }
    case "DebuggerStatement":
      return ["debugger", n];
    case "ClassDeclaration":
    case "ClassExpression":
      return tv(t, e, r);
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "MethodDefinition":
      return iv(t, e, r);
    case "ClassProperty":
    case "PropertyDefinition":
    case "ClassPrivateProperty":
    case "ClassAccessorProperty":
    case "AccessorProperty":
      return nv(t, e, r);
    case "TemplateElement":
      return ln(i.value.raw);
    case "TemplateLiteral":
      return nb(t, e, r);
    case "TaggedTemplateExpression":
      return A5(t, e, r);
    case "PrivateIdentifier":
      return ["#", i.name];
    case "PrivateName":
      return ["#", r("id")];
    case "TopicReference":
      return "%";
    case "ArgumentPlaceholder":
      return "?";
    case "ModuleExpression":
      return ["module ", r("body")];
    case "InterpreterDirective":
    default:
      throw new ka(i, "ESTree");
  }
}
function yv(t, e, r) {
  let { parent: s, node: i, key: n } = t, a = [r("expression")];
  switch (i.type) {
    case "AsConstExpression":
      a.push(" as const");
      break;
    case "AsExpression":
    case "TSAsExpression":
      a.push(" as ", r("typeAnnotation"));
      break;
    case "SatisfiesExpression":
    case "TSSatisfiesExpression":
      a.push(" satisfies ", r("typeAnnotation"));
      break;
  }
  return n === "callee" && Ae(s) || n === "object" && Ve(s) ? I([X([R, ...a]), R]) : a;
}
function V9(t, e, r) {
  let { node: s } = t, i = [Ht(t), "component"];
  s.id && i.push(" ", r("id")), i.push(r("typeParameters"));
  let n = z9(t, e, r);
  return s.rendersType ? i.push(I([n, " ", r("rendersType")])) : i.push(I([n])), s.body && i.push(" ", r("body")), e.semi && s.type === "DeclareComponent" && i.push(";"), i;
}
function z9(t, e, r) {
  let { node: s } = t, i = s.params;
  if (s.rest && (i = [...i, s.rest]), i.length === 0) return ["(", Le(t, e, { filter: (a) => qr(e.originalText, De(a)) === ")" }), ")"];
  let n = [];
  return Y9(t, (a, l) => {
    let c = l === i.length - 1;
    c && s.rest && n.push("..."), n.push(r()), !c && (n.push(","), Ws(i[l], e) ? n.push(q, q) : n.push(K));
  }), ["(", X([R, ...n]), de(Ys(e, "all") && !U9(s, i) ? "," : ""), R, ")"];
}
function U9(t, e) {
  var r;
  return t.rest || ((r = Fe(!1, e, -1)) == null ? void 0 : r.type) === "RestElement";
}
function Y9(t, e) {
  let { node: r } = t, s = 0, i = (n) => e(n, s++);
  t.each(i, "params"), r.rest && t.call(i, "rest");
}
function W9(t, e, r) {
  let { node: s } = t;
  return s.shorthand ? r("local") : [r("name"), " as ", r("local")];
}
function G9(t, e, r) {
  let { node: s } = t, i = [];
  return s.name && i.push(r("name"), s.optional ? "?: " : ": "), i.push(r("typeAnnotation")), i;
}
function Ov(t, e, r) {
  return nh(t, e, r);
}
function xv(t, e) {
  let { node: r } = t, s = e("id");
  r.computed && (s = ["[", s, "]"]);
  let i = "";
  return r.initializer && (i = e("initializer")), r.init && (i = e("init")), i ? [s, " = ", i] : s;
}
function Dv(t, e) {
  let { node: r } = t;
  return [Ht(t), r.const ? "const " : "", "enum ", e("id"), " ", e("body")];
}
function H9(t, e, r) {
  let { node: s } = t, i = ["hook"];
  s.id && i.push(" ", r("id"));
  let n = Tn(t, e, r, !1, !0), a = ih(t, r), l = Pa(s, a);
  return i.push(I([l ? I(n) : n, a]), s.body ? " " : "", r("body")), i;
}
function J9(t, e, r) {
  let { node: s } = t, i = [Ht(t), "hook"];
  return s.id && i.push(" ", r("id")), e.semi && i.push(";"), i;
}
function jO(t) {
  var e;
  let { node: r } = t;
  return r.type === "HookTypeAnnotation" && ((e = t.getParentNode(2)) == null ? void 0 : e.type) === "DeclareHook";
}
function K9(t, e, r) {
  let { node: s } = t, i = [];
  i.push(jO(t) ? "" : "hook ");
  let n = Tn(t, e, r, !1, !0), a = [];
  return a.push(jO(t) ? ": " : " => ", r("returnType")), Pa(s, a) && (n = I(n)), i.push(n, a), I(i);
}
function bv(t, e, r) {
  let { node: s } = t, i = [Ht(t), "interface"], n = [], a = [];
  s.type !== "InterfaceTypeAnnotation" && n.push(" ", r("id"), r("typeParameters"));
  let l = s.typeParameters && !z(s.typeParameters, te.Trailing | te.Line);
  return Ee(s.extends) && a.push(l ? de(" ", K, { groupId: Pm(s.typeParameters) }) : K, "extends ", (s.extends.length === 1 ? oB : X)(be([",", K], t.map(r, "extends")))), z(s.id, te.Trailing) || Ee(s.extends) ? l ? i.push(I([...n, X(a)])) : i.push(I(X([...n, ...a]))) : i.push(...n, ...a), i.push(" ", r("body")), I(i);
}
function e7(t) {
  switch (t) {
    case null:
      return "";
    case "PlusOptional":
      return "+?";
    case "MinusOptional":
      return "-?";
    case "Optional":
      return "?";
  }
}
function t7(t, e, r) {
  let { node: s } = t;
  return I([s.variance ? r("variance") : "", "[", X([r("keyTparam"), " in ", r("sourceType")]), "]", e7(s.optional), ": ", r("propType")]);
}
function XO(t, e) {
  return t === "+" || t === "-" ? t + e : e;
}
function r7(t, e, r) {
  let { node: s } = t, i = !1;
  if (e.objectWrap === "preserve") {
    let n = ke(s), a = Fm(e, n + 1, ke(s.key)), l = n + 1 + a.search(/\S/u);
    fr(e.originalText, n, l) && (i = !0);
  }
  return I(["{", X([e.bracketSpacing ? K : R, z(s, te.Dangling) ? I([Le(t, e), q]) : "", I([s.readonly ? [XO(s.readonly, "readonly"), " "] : "", "[", r("key"), " in ", r("constraint"), s.nameType ? [" as ", r("nameType")] : "", "]", s.optional ? XO(s.optional, "?") : "", s.typeAnnotation ? ": " : "", r("typeAnnotation")]), e.semi ? de(";") : ""]), e.bracketSpacing ? K : R, "}"], { shouldBreak: i });
}
function s7(t, e, r) {
  var n;
  let { node: s } = t;
  if (w2(s)) return s.type.slice(0, -14).toLowerCase();
  let i = e.semi ? ";" : "";
  switch (s.type) {
    case "ComponentDeclaration":
    case "DeclareComponent":
    case "ComponentTypeAnnotation":
      return V9(t, e, r);
    case "ComponentParameter":
      return W9(t, e, r);
    case "ComponentTypeParameter":
      return G9(t, e, r);
    case "HookDeclaration":
      return H9(t, e, r);
    case "DeclareHook":
      return J9(t, e, r);
    case "HookTypeAnnotation":
      return K9(t, e, r);
    case "DeclareClass":
      return tv(t, e, r);
    case "DeclareFunction":
      return [Ht(t), "function ", r("id"), r("predicate"), i];
    case "DeclareModule":
      return ["declare module ", r("id"), " ", r("body")];
    case "DeclareModuleExports":
      return ["declare module.exports", bt(t, r), i];
    case "DeclareNamespace":
      return ["declare namespace ", r("id"), " ", r("body")];
    case "DeclareVariable":
      return [Ht(t), (n = s.kind) != null ? n : "var", " ", r("id"), i];
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
      return hv(t, e, r);
    case "DeclareOpaqueType":
    case "OpaqueType":
      return L4(t, e, r);
    case "DeclareTypeAlias":
    case "TypeAlias":
      return Tb(t, e, r);
    case "IntersectionTypeAnnotation":
      return kb(t, e, r);
    case "UnionTypeAnnotation":
      return Pb(t, e, r);
    case "ConditionalTypeAnnotation":
      return Qm(t, e, r);
    case "InferTypeAnnotation":
      return Qb(t, e, r);
    case "FunctionTypeAnnotation":
      return Fb(t, e, r);
    case "TupleTypeAnnotation":
      return Tm(t, e, r);
    case "TupleTypeLabeledElement":
      return Ib(t, e, r);
    case "TupleTypeSpreadElement":
      return Bb(t, e, r);
    case "GenericTypeAnnotation":
      return [r("id"), So(t, e, r, "typeParameters")];
    case "IndexedAccessType":
    case "OptionalIndexedAccessType":
      return $b(t, e, r);
    case "TypeAnnotation":
      return Mb(t, e, r);
    case "TypeParameter":
      return Kb(t, e, r);
    case "TypeofTypeAnnotation":
      return _b(t, r);
    case "ExistsTypeAnnotation":
      return "*";
    case "ArrayTypeAnnotation":
      return Lb(r);
    case "DeclareEnum":
    case "EnumDeclaration":
      return Dv(t, r);
    case "EnumBooleanBody":
    case "EnumNumberBody":
    case "EnumBigIntBody":
    case "EnumStringBody":
    case "EnumSymbolBody":
      return [s.type === "EnumSymbolBody" || s.explicitType ? `of ${s.type.slice(4, -4).toLowerCase()} ` : "", Ov(t, e, r)];
    case "EnumBooleanMember":
    case "EnumNumberMember":
    case "EnumBigIntMember":
    case "EnumStringMember":
    case "EnumDefaultedMember":
      return xv(t, r);
    case "FunctionTypeParam": {
      let a = s.name ? r("name") : t.parent.this === s ? "this" : "";
      return [a, Nt(t), a ? ": " : "", r("typeAnnotation")];
    }
    case "DeclareInterface":
    case "InterfaceDeclaration":
    case "InterfaceTypeAnnotation":
      return bv(t, e, r);
    case "ClassImplements":
    case "InterfaceExtends":
      return [r("id"), r("typeParameters")];
    case "NullableTypeAnnotation":
      return ["?", r("typeAnnotation")];
    case "Variance": {
      let { kind: a } = s;
      return pm.ok(a === "plus" || a === "minus"), a === "plus" ? "+" : "-";
    }
    case "KeyofTypeAnnotation":
      return ["keyof ", r("argument")];
    case "ObjectTypeCallProperty":
      return [s.static ? "static " : "", r("value")];
    case "ObjectTypeMappedTypeProperty":
      return t7(t, e, r);
    case "ObjectTypeIndexer":
      return [s.static ? "static " : "", s.variance ? r("variance") : "", "[", r("id"), s.id ? ": " : "", r("key"), "]: ", r("value")];
    case "ObjectTypeProperty": {
      let a = "";
      return s.proto ? a = "proto " : s.static && (a = "static "), [a, s.kind !== "init" ? s.kind + " " : "", s.variance ? r("variance") : "", gl(t, e, r), Nt(t), Kc(s) ? "" : ": ", r("value")];
    }
    case "ObjectTypeAnnotation":
      return nh(t, e, r);
    case "ObjectTypeInternalSlot":
      return [s.static ? "static " : "", "[[", r("id"), "]]", Nt(t), s.method ? "" : ": ", r("value")];
    case "ObjectTypeSpreadProperty":
      return Xb(t, r);
    case "QualifiedTypeofIdentifier":
    case "QualifiedTypeIdentifier":
      return [r("qualification"), ".", r("id")];
    case "NullLiteralTypeAnnotation":
      return "null";
    case "BooleanLiteralTypeAnnotation":
      return String(s.value);
    case "StringLiteralTypeAnnotation":
      return ln(ua(Wt(s), e));
    case "NumberLiteralTypeAnnotation":
      return ha(Wt(s));
    case "BigIntLiteralTypeAnnotation":
      return Ed(Wt(s));
    case "TypeCastExpression":
      return ["(", r("expression"), bt(t, r), ")"];
    case "TypePredicate":
      return Rb(t, r);
    case "TypeOperator":
      return [s.operator, " ", r("typeAnnotation")];
    case "TypeParameterDeclaration":
    case "TypeParameterInstantiation":
      return So(t, e, r, "params");
    case "InferredPredicate":
    case "DeclaredPredicate":
      return [t.key === "predicate" && t.parent.type !== "DeclareFunction" && !t.parent.returnType ? ": " : " ", "%checks", ...s.type === "DeclaredPredicate" ? ["(", r("value"), ")"] : []];
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
      return yv(t, e, r);
  }
}
function i7(t, e, r) {
  var s;
  let { node: i } = t;
  if (!i.type.startsWith("TS")) return;
  if (A2(i)) return i.type.slice(2, -7).toLowerCase();
  let n = e.semi ? ";" : "", a = [];
  switch (i.type) {
    case "TSThisType":
      return "this";
    case "TSTypeAssertion": {
      let l = !(St(i.expression) || Rr(i.expression)), c = I(["<", X([R, r("typeAnnotation")]), R, ">"]), p = [de("("), X([R, r("expression")]), R, de(")")];
      return l ? Yi([[c, r("expression")], [c, I(p, { shouldBreak: !0 })], [c, r("expression")]]) : I([c, r("expression")]);
    }
    case "TSDeclareFunction":
      return Ub(t, e, r);
    case "TSExportAssignment":
      return ["export = ", r("expression"), n];
    case "TSModuleBlock":
      return Hb(t, e, r);
    case "TSInterfaceBody":
    case "TSTypeLiteral":
      return nh(t, e, r);
    case "TSTypeAliasDeclaration":
      return Tb(t, e, r);
    case "TSQualifiedName":
      return [r("left"), ".", r("right")];
    case "TSAbstractMethodDefinition":
    case "TSDeclareMethod":
      return iv(t, e, r);
    case "TSAbstractAccessorProperty":
    case "TSAbstractPropertyDefinition":
      return nv(t, e, r);
    case "TSInterfaceHeritage":
    case "TSClassImplements":
    case "TSExpressionWithTypeArguments":
    case "TSInstantiationExpression":
      return [r("expression"), r(i.typeArguments ? "typeArguments" : "typeParameters")];
    case "TSTemplateLiteralType":
      return nb(t, e, r);
    case "TSNamedTupleMember":
      return Ib(t, e, r);
    case "TSRestType":
      return Bb(t, e, r);
    case "TSOptionalType":
      return [r("typeAnnotation"), "?"];
    case "TSInterfaceDeclaration":
      return bv(t, e, r);
    case "TSTypeParameterDeclaration":
    case "TSTypeParameterInstantiation":
      return So(t, e, r, "params");
    case "TSTypeParameter":
      return Kb(t, e, r);
    case "TSAsExpression":
    case "TSSatisfiesExpression":
      return yv(t, e, r);
    case "TSArrayType":
      return Lb(r);
    case "TSPropertySignature":
      return [i.readonly ? "readonly " : "", gl(t, e, r), Nt(t), bt(t, r)];
    case "TSParameterProperty":
      return [sc(i), i.static ? "static " : "", i.override ? "override " : "", i.readonly ? "readonly " : "", r("parameter")];
    case "TSTypeQuery":
      return _b(t, r);
    case "TSIndexSignature": {
      let l = i.parameters.length > 1 ? de(Ys(e) ? "," : "") : "", c = I([X([R, be([", ", R], t.map(r, "parameters"))]), l, R]), p = t.parent.type === "ClassBody" && t.key === "body";
      return [p && i.static ? "static " : "", i.readonly ? "readonly " : "", "[", i.parameters ? c : "", "]", bt(t, r), p ? n : ""];
    }
    case "TSTypePredicate":
      return Rb(t, r);
    case "TSNonNullExpression":
      return [r("expression"), "!"];
    case "TSImportType":
      return ["import", rc(t, e, r), i.qualifier ? [".", r("qualifier")] : "", So(t, e, r, i.typeArguments ? "typeArguments" : "typeParameters")];
    case "TSLiteralType":
      return r("literal");
    case "TSIndexedAccessType":
      return $b(t, e, r);
    case "TSTypeOperator":
      return [i.operator, " ", r("typeAnnotation")];
    case "TSMappedType":
      return r7(t, e, r);
    case "TSMethodSignature": {
      let l = i.kind && i.kind !== "method" ? `${i.kind} ` : "";
      a.push(sc(i), l, i.computed ? "[" : "", r("key"), i.computed ? "]" : "", Nt(t));
      let c = Tn(t, e, r, !1, !0), p = i.returnType ? "returnType" : "typeAnnotation", d = i[p], m = d ? bt(t, r, p) : "", y = Pa(i, m);
      return a.push(y ? I(c) : c), d && a.push(I(m)), I(a);
    }
    case "TSNamespaceExportDeclaration":
      return ["export as namespace ", r("id"), e.semi ? ";" : ""];
    case "TSEnumDeclaration":
      return Dv(t, r);
    case "TSEnumBody":
      return Ov(t, e, r);
    case "TSEnumMember":
      return xv(t, r);
    case "TSImportEqualsDeclaration":
      return [i.isExport ? "export " : "", "import ", pv(i, !1), r("id"), " = ", r("moduleReference"), e.semi ? ";" : ""];
    case "TSExternalModuleReference":
      return ["require(", r("expression"), ")"];
    case "TSModuleDeclaration": {
      let { parent: l } = t, c = l.type === "TSModuleDeclaration", p = ((s = i.body) == null ? void 0 : s.type) === "TSModuleDeclaration";
      return c ? a.push(".") : (a.push(Ht(t)), i.kind !== "global" && a.push(i.kind, " ")), a.push(r("id")), p ? a.push(r("body")) : i.body ? a.push(" ", I(r("body"))) : a.push(n), a;
    }
    case "TSConditionalType":
      return Qm(t, e, r);
    case "TSInferType":
      return Qb(t, e, r);
    case "TSIntersectionType":
      return kb(t, e, r);
    case "TSUnionType":
      return Pb(t, e, r);
    case "TSFunctionType":
    case "TSCallSignatureDeclaration":
    case "TSConstructorType":
    case "TSConstructSignatureDeclaration":
      return Fb(t, e, r);
    case "TSTupleType":
      return Tm(t, e, r);
    case "TSTypeReference":
      return [r("typeName"), So(t, e, r, i.typeArguments ? "typeArguments" : "typeParameters")];
    case "TSTypeAnnotation":
      return Mb(t, e, r);
    case "TSEmptyBodyFunctionExpression":
      return km(t, e, r);
    case "TSJSDocAllType":
      return "*";
    case "TSJSDocUnknownType":
      return "?";
    case "TSJSDocNullableType":
      return LO(t, r, "?");
    case "TSJSDocNonNullableType":
      return LO(t, r, "!");
    case "TSParenthesizedType":
    default:
      throw new ka(i, "TypeScript");
  }
}
function n7(t, e, r, s) {
  if (fb(t)) return O8(t, e);
  for (let i of [r4, W8, s7, i7, Z9]) {
    let n = i(t, e, r, s);
    if (n !== void 0) return n;
  }
}
var a7 = Pe(["ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "ClassPrivateProperty", "MethodDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod"]);
function o7(t, e, r, s) {
  var i;
  t.isRoot && ((i = e.__onHtmlBindingRoot) == null || i.call(e, t.node, e));
  let n = n7(t, e, r, s);
  if (!n) return "";
  let { node: a } = t;
  if (a7(a)) return n;
  let l = Ee(a.decorators), c = o4(t, e, r), p = a.type === "ClassExpression";
  if (l && !p) return gd(n, (y) => I([c, y]));
  let d = En(t, e), m = v9(t, e);
  return !c && !d && !m ? n : gd(n, (y) => [m ? ";" : "", d ? "(" : "", d && p && l ? [X([K, c, y]), K] : [c, y], d ? ")" : ""]);
}
var l7 = o7, u7 = { avoidAstMutation: !0 }, c7 = [{ name: "JSON.stringify", type: "data", extensions: [".importmap"], tmScope: "source.json", aceMode: "json", aliases: ["geojson", "jsonl", "sarif", "topojson"], codemirrorMode: "javascript", codemirrorMimeType: "application/json", filenames: ["package.json", "package-lock.json", "composer.json"], parsers: ["json-stringify"], vscodeLanguageIds: ["json"], linguistLanguageId: 174 }, { name: "JSON", type: "data", extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".json.example", ".mcmeta", ".sarif", ".tact", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], tmScope: "source.json", aceMode: "json", aliases: ["geojson", "jsonl", "sarif", "topojson"], codemirrorMode: "javascript", codemirrorMimeType: "application/json", filenames: [".all-contributorsrc", ".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", ".babelrc", ".jscsrc", ".jshintrc", ".jslintrc", ".swcrc"], parsers: ["json"], vscodeLanguageIds: ["json"], linguistLanguageId: 174 }, { name: "JSON with Comments", type: "data", extensions: [".jsonc", ".code-snippets", ".code-workspace", ".sublime-build", ".sublime-color-scheme", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], tmScope: "source.json.comments", aceMode: "javascript", aliases: ["jsonc"], codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", group: "JSON", filenames: [], parsers: ["jsonc"], vscodeLanguageIds: ["jsonc"], linguistLanguageId: 423 }, { name: "JSON5", type: "data", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", parsers: ["json5"], vscodeLanguageIds: ["json5"], linguistLanguageId: 175 }], vv = {};
Hc(vv, { getVisitorKeys: () => f7, massageAstNode: () => Sv, print: () => m7 });
var h7 = { JsonRoot: ["node"], ArrayExpression: ["elements"], ObjectExpression: ["properties"], ObjectProperty: ["key", "value"], UnaryExpression: ["argument"], NullLiteral: [], BooleanLiteral: [], StringLiteral: [], NumericLiteral: [], Identifier: [], TemplateLiteral: ["quasis"], TemplateElement: [] }, p7 = h7, d7 = v2(p7), f7 = d7;
function m7(t, e, r) {
  let { node: s } = t;
  switch (s.type) {
    case "JsonRoot":
      return [r("node"), q];
    case "ArrayExpression": {
      if (s.elements.length === 0) return "[]";
      let i = t.map(() => t.node === null ? "null" : r(), "elements");
      return ["[", X([q, be([",", q], i)]), q, "]"];
    }
    case "ObjectExpression":
      return s.properties.length === 0 ? "{}" : ["{", X([q, be([",", q], t.map(r, "properties"))]), q, "}"];
    case "ObjectProperty":
      return [r("key"), ": ", r("value")];
    case "UnaryExpression":
      return [s.operator === "+" ? "" : s.operator, r("argument")];
    case "NullLiteral":
      return "null";
    case "BooleanLiteral":
      return s.value ? "true" : "false";
    case "StringLiteral":
      return JSON.stringify(s.value);
    case "NumericLiteral":
      return ZO(t) ? JSON.stringify(String(s.value)) : JSON.stringify(s.value);
    case "Identifier":
      return ZO(t) ? JSON.stringify(s.name) : s.name;
    case "TemplateLiteral":
      return r(["quasis", 0]);
    case "TemplateElement":
      return JSON.stringify(s.value.cooked);
    default:
      throw new ka(s, "JSON");
  }
}
function ZO(t) {
  return t.key === "key" && t.parent.type === "ObjectProperty";
}
var g7 = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
function Sv(t, e) {
  let { type: r } = t;
  if (r === "ObjectProperty") {
    let { key: s } = t;
    s.type === "Identifier" ? e.key = { type: "StringLiteral", value: s.name } : s.type === "NumericLiteral" && (e.key = { type: "StringLiteral", value: String(s.value) });
    return;
  }
  if (r === "UnaryExpression" && t.operator === "+") return e.argument;
  if (r === "ArrayExpression") {
    for (let [s, i] of t.elements.entries()) i === null && e.elements.splice(s, 0, { type: "NullLiteral" });
    return;
  }
  if (r === "TemplateLiteral") return { type: "StringLiteral", value: t.quasis[0].value.cooked };
}
Sv.ignoredProperties = g7;
var Wa = { bracketSpacing: { category: "Common", type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, objectWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap object literals.", choices: [{ value: "preserve", description: "Keep as multi-line, if there is a newline between the opening brace and first property." }, { value: "collapse", description: "Fit to a single line when possible." }] }, singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." }, bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." } }, oi = "JavaScript", y7 = { arrowParens: { category: oi, type: "choice", default: "always", description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: Wa.bracketSameLine, objectWrap: Wa.objectWrap, bracketSpacing: Wa.bracketSpacing, jsxBracketSameLine: { category: oi, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { category: oi, type: "boolean", default: !0, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, experimentalOperatorPosition: { category: oi, type: "choice", default: "end", description: "Where to print operators when binary expressions wrap lines.", choices: [{ value: "start", description: "Print operators at the start of new lines." }, { value: "end", description: "Print operators at the end of previous lines." }] }, experimentalTernaries: { category: oi, type: "boolean", default: !1, description: "Use curious ternaries, with the question mark after the condition.", oppositeDescription: "Default behavior of ternaries; keep question marks on the same line as the consequent." }, singleQuote: Wa.singleQuote, jsxSingleQuote: { category: oi, type: "boolean", default: !1, description: "Use single quotes in JSX." }, quoteProps: { category: oi, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { category: oi, type: "choice", default: "all", description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "all", description: "Trailing commas wherever possible (including function arguments)." }, { value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }] }, singleAttributePerLine: Wa.singleAttributePerLine }, O7 = y7, x7 = { estree: O2, "estree-json": vv }, D7 = [...nQ, ...c7], wv = y2, Av = Object.defineProperty, Cv = (t) => {
  throw TypeError(t);
}, b7 = (t, e, r) => e in t ? Av(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Ev = (t, e) => {
  for (var r in e) Av(t, r, { get: e[r], enumerable: !0 });
}, VO = (t, e, r) => b7(t, typeof e != "symbol" ? e + "" : e, r), Tv = (t, e, r) => e.has(t) || Cv("Cannot " + r), gr = (t, e, r) => (Tv(t, e, "read from private field"), r ? r.call(t) : e.get(t)), kv = (t, e, r) => e.has(t) ? Cv("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r), v7 = (t, e, r, s) => (Tv(t, e, "write to private field"), e.set(t, r), r), Pv = {};
Ev(Pv, { languages: () => mN, options: () => yN, parsers: () => mS, printers: () => CM });
var S7 = (t, e, r, s) => {
  if (!(t && e == null)) return e.replaceAll ? e.replaceAll(r, s) : r.global ? e.replace(r, s) : e.split(r).join(s);
}, hr = S7, Fv = "string", $v = "array", Qv = "cursor", Bm = "indent", Im = "align", Bv = "trim", Nm = "group", Mm = "fill", Lm = "if-break", _m = "indent-if-break", Iv = "line-suffix", Nv = "line-suffix-boundary", Fa = "line", Mv = "label", Rm = "break-parent", Lv = /* @__PURE__ */ new Set([Qv, Bm, Im, Bv, Nm, Mm, Lm, _m, Iv, Nv, Fa, Mv, Rm]), w7 = (t, e, r) => {
  if (!(t && e == null)) return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, yl = w7;
function A7(t) {
  if (typeof t == "string") return Fv;
  if (Array.isArray(t)) return $v;
  if (!t) return;
  let { type: e } = t;
  if (Lv.has(e)) return e;
}
var _v = A7, C7 = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function E7(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object") return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (_v(t)) throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]") return `Unexpected doc '${r}'.`;
  let s = C7([...Lv].map((i) => `'${i}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${s}.`;
}
var T7 = class extends Error {
  constructor(r) {
    super(E7(r));
    vs(this, "name", "InvalidDocError");
    this.doc = r;
  }
}, k7 = T7;
function Rv(t, e) {
  if (typeof t == "string") return e(t);
  let r = /* @__PURE__ */ new Map();
  return s(t);
  function s(n) {
    if (r.has(n)) return r.get(n);
    let a = i(n);
    return r.set(n, a), a;
  }
  function i(n) {
    switch (_v(n)) {
      case $v:
        return e(n.map(s));
      case Mm:
        return e({ ...n, parts: n.parts.map(s) });
      case Lm:
        return e({ ...n, breakContents: s(n.breakContents), flatContents: s(n.flatContents) });
      case Nm: {
        let { expandedStates: a, contents: l } = n;
        return a ? (a = a.map(s), l = a[0]) : l = s(l), e({ ...n, contents: l, expandedStates: a });
      }
      case Im:
      case Bm:
      case _m:
      case Mv:
      case Iv:
        return e({ ...n, contents: s(n.contents) });
      case Fv:
      case Qv:
      case Bv:
      case Nv:
      case Fa:
      case Rm:
        return e(n);
      default:
        throw new k7(n);
    }
  }
}
function Mr(t, e = M7) {
  return Rv(t, (r) => typeof r == "string" ? $a(e, r.split(`
`)) : r);
}
var P7 = () => {
}, F7 = P7;
function ys(t) {
  return { type: Bm, contents: t };
}
function qv(t, e) {
  return { type: Im, contents: e, n: t };
}
function ot(t, e = {}) {
  return F7(e.expandedStates), { type: Nm, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function $7(t) {
  return qv(Number.NEGATIVE_INFINITY, t);
}
function Q7(t) {
  return qv({ type: "root" }, t);
}
function jv(t) {
  return { type: Mm, parts: t };
}
function ic(t, e = "", r = {}) {
  return { type: Lm, breakContents: t, flatContents: e, groupId: r.groupId };
}
function B7(t, e) {
  return { type: _m, contents: t, groupId: e.groupId, negate: e.negate };
}
var Ol = { type: Rm }, I7 = { type: Fa, hard: !0 }, N7 = { type: Fa, hard: !0, literal: !0 }, rt = { type: Fa }, Et = { type: Fa, soft: !0 }, je = [I7, Ol], M7 = [N7, Ol];
function $a(t, e) {
  let r = [];
  for (let s = 0; s < e.length; s++) s !== 0 && r.push(t), r.push(e[s]);
  return r;
}
var Hl = "'", zO = '"';
function L7(t, e) {
  let r = e === !0 || e === Hl ? Hl : zO, s = r === Hl ? zO : Hl, i = 0, n = 0;
  for (let a of t) a === r ? i++ : a === s && n++;
  return i > n ? s : r;
}
var _7 = L7;
function R7(t) {
  if (typeof t != "string") throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var Qr, q7 = class {
  constructor(e) {
    kv(this, Qr), v7(this, Qr, new Set(e));
  }
  getLeadingWhitespaceCount(e) {
    let r = gr(this, Qr), s = 0;
    for (let i = 0; i < e.length && r.has(e.charAt(i)); i++) s++;
    return s;
  }
  getTrailingWhitespaceCount(e) {
    let r = gr(this, Qr), s = 0;
    for (let i = e.length - 1; i >= 0 && r.has(e.charAt(i)); i--) s++;
    return s;
  }
  getLeadingWhitespace(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(0, r);
  }
  getTrailingWhitespace(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(e.length - r);
  }
  hasLeadingWhitespace(e) {
    return gr(this, Qr).has(e.charAt(0));
  }
  hasTrailingWhitespace(e) {
    return gr(this, Qr).has(yl(!1, e, -1));
  }
  trimStart(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(r);
  }
  trimEnd(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(0, e.length - r);
  }
  trim(e) {
    return this.trimEnd(this.trimStart(e));
  }
  split(e, r = !1) {
    let s = `[${R7([...gr(this, Qr)].join(""))}]+`, i = new RegExp(r ? `(${s})` : s, "u");
    return e.split(i);
  }
  hasWhitespaceCharacter(e) {
    let r = gr(this, Qr);
    return Array.prototype.some.call(e, (s) => r.has(s));
  }
  hasNonWhitespaceCharacter(e) {
    let r = gr(this, Qr);
    return Array.prototype.some.call(e, (s) => !r.has(s));
  }
  isWhitespaceOnly(e) {
    let r = gr(this, Qr);
    return Array.prototype.every.call(e, (s) => r.has(s));
  }
};
Qr = /* @__PURE__ */ new WeakMap();
var j7 = q7, X7 = ["	", `
`, "\f", "\r", " "], Z7 = new j7(X7), Ms = Z7, V7 = class extends Error {
  constructor(r, s, i = "type") {
    super(`Unexpected ${s} node ${i}: ${JSON.stringify(r[i])}.`);
    vs(this, "name", "UnexpectedNodeError");
    this.node = r;
  }
}, z7 = V7;
function U7(t) {
  return (t == null ? void 0 : t.type) === "front-matter";
}
var ah = U7, Y7 = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan", "keySpan", "tagDefinition", "tokens", "valueTokens", "switchValueSourceSpan", "expSourceSpan", "valueSourceSpan"]), W7 = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function Xv(t, e) {
  var r;
  if (t.type === "text" || t.type === "comment" || ah(t) || t.type === "yaml" || t.type === "toml") return null;
  if (t.type === "attribute" && delete e.value, t.type === "docType" && delete e.value, t.type === "angularControlFlowBlock" && (r = t.parameters) != null && r.children) for (let s of e.parameters.children) W7.has(t.name) ? delete s.expression : s.expression = s.expression.trim();
  t.type === "angularIcuExpression" && (e.switchValue = t.switchValue.trim()), t.type === "angularLetDeclarationInitializer" && delete e.value;
}
Xv.ignoredProperties = Y7;
var G7 = Xv;
async function H7(t, e) {
  if (t.language === "yaml") {
    let r = t.value.trim(), s = r ? await e(r, { parser: "yaml" }) : "";
    return Q7([t.startDelimiter, t.explicitLanguage, je, s, s ? je : "", t.endDelimiter]);
  }
}
var J7 = H7;
function oh(t, e = !0) {
  return [ys([Et, t]), e ? Et : ""];
}
function Qa(t, e) {
  let r = t.type === "NGRoot" ? t.node.type === "NGMicrosyntax" && t.node.body.length === 1 && t.node.body[0].type === "NGMicrosyntaxExpression" ? t.node.body[0].expression : t.node : t.type === "JsExpressionRoot" ? t.node : t;
  return r && (r.type === "ObjectExpression" || r.type === "ArrayExpression" || (e.parser === "__vue_expression" || e.parser === "__vue_ts_expression") && (r.type === "TemplateLiteral" || r.type === "StringLiteral"));
}
async function jr(t, e, r, s) {
  r = { __isInHtmlAttribute: !0, __embeddedInHtml: !0, ...r };
  let i = !0;
  s && (r.__onHtmlBindingRoot = (a, l) => {
    i = s(a, l);
  });
  let n = await e(t, r, e);
  return i ? ot(n) : oh(n);
}
function K7(t, e, r, s) {
  let { node: i } = r, n = s.originalText.slice(i.sourceSpan.start.offset, i.sourceSpan.end.offset);
  return /^\s*$/u.test(n) ? "" : jr(n, t, { parser: "__ng_directive", __isInHtmlAttribute: !1 }, Qa);
}
var eI = K7, tI = (t, e) => {
  if (!(t && e == null)) return e.toReversed || !Array.isArray(e) ? e.toReversed() : [...e].reverse();
}, rI = tI;
function sI(t) {
  return Array.isArray(t) && t.length > 0;
}
var qm = sI, UO, YO, WO, GO, HO, iI = ((UO = globalThis.Deno) == null ? void 0 : UO.build.os) === "windows" || ((WO = (YO = globalThis.navigator) == null ? void 0 : YO.platform) == null ? void 0 : WO.startsWith("Win")) || ((HO = (GO = globalThis.process) == null ? void 0 : GO.platform) == null ? void 0 : HO.startsWith("win")) || !1;
function Zv(t) {
  if (t = t instanceof URL ? t : new URL(t), t.protocol !== "file:") throw new TypeError(`URL must be a file URL: received "${t.protocol}"`);
  return t;
}
function nI(t) {
  return t = Zv(t), decodeURIComponent(t.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function aI(t) {
  t = Zv(t);
  let e = decodeURIComponent(t.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  return t.hostname !== "" && (e = `\\\\${t.hostname}${e}`), e;
}
function oI(t) {
  return iI ? aI(t) : nI(t);
}
var lI = oI, uI = (t) => String(t).split(/[/\\]/u).pop();
function JO(t, e) {
  var s;
  if (!e) return;
  let r = uI(e).toLowerCase();
  return (s = t.find(({ filenames: i }) => i == null ? void 0 : i.some((n) => n.toLowerCase() === r))) != null ? s : t.find(({ extensions: i }) => i == null ? void 0 : i.some((n) => r.endsWith(n)));
}
function cI(t, e) {
  var r, s;
  if (e) return (s = (r = t.find(({ name: i }) => i.toLowerCase() === e)) != null ? r : t.find(({ aliases: i }) => i == null ? void 0 : i.includes(e))) != null ? s : t.find(({ extensions: i }) => i == null ? void 0 : i.includes(`.${e}`));
}
function KO(t, e) {
  if (e) {
    if (String(e).startsWith("file:")) try {
      e = lI(e);
    } catch {
      return;
    }
    if (typeof e == "string") return t.find(({ isSupported: r }) => r == null ? void 0 : r({ filepath: e }));
  }
}
function hI(t, e) {
  var i, n, a, l, c;
  let r = rI(!1, t.plugins).flatMap((p) => {
    var d;
    return (d = p.languages) != null ? d : [];
  }), s = (c = (l = (a = (n = (i = cI(r, e.language)) != null ? i : JO(r, e.physicalFile)) != null ? n : JO(r, e.file)) != null ? a : KO(r, e.physicalFile)) != null ? l : KO(r, e.file)) != null ? c : (e.physicalFile, void 0);
  return s == null ? void 0 : s.parsers[0];
}
var lh = hI, pI = "inline", e0 = { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", style: "none", template: "inline", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", dialog: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", search: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", menu: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", input: "inline-block", button: "inline-block", fieldset: "block", details: "block", summary: "block", marquee: "inline-block", source: "block", track: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, dI = "normal", t0 = { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" };
function fI(t) {
  return t.type === "element" && !t.hasExplicitNamespace && !["html", "svg"].includes(t.namespace);
}
var Ro = fI, mI = (t) => hr(!1, t, /^[\t\f\r ]*\n/gu, ""), Vv = (t) => mI(Ms.trimEnd(t)), gI = (t) => {
  let e = t, r = Ms.getLeadingWhitespace(e);
  r && (e = e.slice(r.length));
  let s = Ms.getTrailingWhitespace(e);
  return s && (e = e.slice(0, -s.length)), { leadingWhitespace: r, trailingWhitespace: s, text: e };
};
function zv(t, e) {
  return !!(t.type === "ieConditionalComment" && t.lastChild && !t.lastChild.isSelfClosing && !t.lastChild.endSourceSpan || t.type === "ieConditionalComment" && !t.complete || pa(t) && t.children.some((r) => r.type !== "text" && r.type !== "interpolation") || Xm(t, e) && !Ls(t, e) && t.type !== "interpolation");
}
function uh(t) {
  return t.type === "attribute" || !t.parent || !t.prev ? !1 : yI(t.prev);
}
function yI(t) {
  return t.type === "comment" && t.value.trim() === "prettier-ignore";
}
function Or(t) {
  return t.type === "text" || t.type === "comment";
}
function Ls(t, e) {
  return t.type === "element" && (t.fullName === "script" || t.fullName === "style" || t.fullName === "svg:style" || t.fullName === "svg:script" || t.fullName === "mj-style" && e.parser === "mjml" || Ro(t) && (t.name === "script" || t.name === "style"));
}
function OI(t, e) {
  return t.children && !Ls(t, e);
}
function xI(t, e) {
  return Ls(t, e) || t.type === "interpolation" || Uv(t);
}
function Uv(t) {
  return eS(t).startsWith("pre");
}
function DI(t, e) {
  var r, s;
  let i = n();
  if (i && !t.prev && (s = (r = t.parent) == null ? void 0 : r.tagDefinition) != null && s.ignoreFirstLf) return t.type === "interpolation";
  return i;
  function n() {
    return ah(t) || t.type === "angularControlFlowBlock" ? !1 : (t.type === "text" || t.type === "interpolation") && t.prev && (t.prev.type === "text" || t.prev.type === "interpolation") ? !0 : !t.parent || t.parent.cssDisplay === "none" ? !1 : pa(t.parent) ? !0 : !(!t.prev && (t.parent.type === "root" || pa(t) && t.parent || Ls(t.parent, e) || ch(t.parent, e) || !kI(t.parent.cssDisplay)) || t.prev && !$I(t.prev.cssDisplay));
  }
}
function bI(t, e) {
  return ah(t) || t.type === "angularControlFlowBlock" ? !1 : (t.type === "text" || t.type === "interpolation") && t.next && (t.next.type === "text" || t.next.type === "interpolation") ? !0 : !t.parent || t.parent.cssDisplay === "none" ? !1 : pa(t.parent) ? !0 : !(!t.next && (t.parent.type === "root" || pa(t) && t.parent || Ls(t.parent, e) || ch(t.parent, e) || !PI(t.parent.cssDisplay)) || t.next && !FI(t.next.cssDisplay));
}
function vI(t, e) {
  return QI(t.cssDisplay) && !Ls(t, e);
}
function Jl(t) {
  return ah(t) || t.next && t.sourceSpan.end && t.sourceSpan.end.line + 1 < t.next.sourceSpan.start.line;
}
function SI(t) {
  return Yv(t) || t.type === "element" && t.children.length > 0 && (["body", "script", "style"].includes(t.name) || t.children.some((e) => AI(e))) || t.firstChild && t.firstChild === t.lastChild && t.firstChild.type !== "text" && Gv(t.firstChild) && (!t.lastChild.isTrailingSpaceSensitive || Hv(t.lastChild));
}
function Yv(t) {
  return t.type === "element" && t.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(t.name) || t.cssDisplay.startsWith("table") && t.cssDisplay !== "table-cell");
}
function dp(t) {
  return Jv(t) || t.prev && wI(t.prev) || Wv(t);
}
function wI(t) {
  return Jv(t) || t.type === "element" && t.fullName === "br" || Wv(t);
}
function Wv(t) {
  return Gv(t) && Hv(t);
}
function Gv(t) {
  return t.hasLeadingSpaces && (t.prev ? t.prev.sourceSpan.end.line < t.sourceSpan.start.line : t.parent.type === "root" || t.parent.startSourceSpan.end.line < t.sourceSpan.start.line);
}
function Hv(t) {
  return t.hasTrailingSpaces && (t.next ? t.next.sourceSpan.start.line > t.sourceSpan.end.line : t.parent.type === "root" || t.parent.endSourceSpan && t.parent.endSourceSpan.start.line > t.sourceSpan.end.line);
}
function Jv(t) {
  switch (t.type) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return !0;
    case "element":
      return ["script", "select"].includes(t.name);
  }
  return !1;
}
function jm(t) {
  return t.lastChild ? jm(t.lastChild) : t;
}
function AI(t) {
  var e;
  return (e = t.children) == null ? void 0 : e.some((r) => r.type !== "text");
}
function Kv(t) {
  if (t) switch (t) {
    case "module":
    case "text/javascript":
    case "text/babel":
    case "text/jsx":
    case "application/javascript":
      return "babel";
    case "application/x-typescript":
      return "typescript";
    case "text/markdown":
      return "markdown";
    case "text/html":
      return "html";
    case "text/x-handlebars-template":
      return "glimmer";
    default:
      if (t.endsWith("json") || t.endsWith("importmap") || t === "speculationrules") return "json";
  }
}
function CI(t, e) {
  var a;
  let { name: r, attrMap: s } = t;
  if (r !== "script" || Object.prototype.hasOwnProperty.call(s, "src")) return;
  let { type: i, lang: n } = t.attrMap;
  return !n && !i ? "babel" : (a = lh(e, { language: n })) != null ? a : Kv(i);
}
function EI(t, e) {
  var n;
  if (!Xm(t, e)) return;
  let { attrMap: r } = t;
  if (Object.prototype.hasOwnProperty.call(r, "src")) return;
  let { type: s, lang: i } = r;
  return (n = lh(e, { language: i })) != null ? n : Kv(s);
}
function TI(t, e) {
  if (t.name === "style") {
    let { lang: r } = t.attrMap;
    return r ? lh(e, { language: r }) : "css";
  }
  if (t.name === "mj-style" && e.parser === "mjml") return "css";
}
function r0(t, e) {
  var r, s;
  return (s = (r = CI(t, e)) != null ? r : TI(t, e)) != null ? s : EI(t, e);
}
function xl(t) {
  return t === "block" || t === "list-item" || t.startsWith("table");
}
function kI(t) {
  return !xl(t) && t !== "inline-block";
}
function PI(t) {
  return !xl(t) && t !== "inline-block";
}
function FI(t) {
  return !xl(t);
}
function $I(t) {
  return !xl(t);
}
function QI(t) {
  return !xl(t) && t !== "inline-block";
}
function pa(t) {
  return eS(t).startsWith("pre");
}
function BI(t, e) {
  let r = t;
  for (; r; ) {
    if (e(r)) return !0;
    r = r.parent;
  }
  return !1;
}
function II(t, e) {
  var r;
  if (Ba(t, e)) return "block";
  if (((r = t.prev) == null ? void 0 : r.type) === "comment") {
    let i = t.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/u);
    if (i) return i[1];
  }
  let s = !1;
  if (t.type === "element" && t.namespace === "svg") if (BI(t, (i) => i.fullName === "svg:foreignObject")) s = !0;
  else return t.name === "svg" ? "inline-block" : "block";
  switch (e.htmlWhitespaceSensitivity) {
    case "strict":
      return "inline";
    case "ignore":
      return "block";
    default:
      if (t.type === "element" && (!t.namespace || s || Ro(t)) && Object.prototype.hasOwnProperty.call(e0, t.name)) return e0[t.name];
  }
  return pI;
}
function eS(t) {
  return t.type === "element" && (!t.namespace || Ro(t)) && Object.prototype.hasOwnProperty.call(t0, t.name) ? t0[t.name] : dI;
}
function NI(t) {
  let e = Number.POSITIVE_INFINITY;
  for (let r of t.split(`
`)) {
    if (r.length === 0) continue;
    let s = Ms.getLeadingWhitespaceCount(r);
    if (s === 0) return 0;
    r.length !== s && s < e && (e = s);
  }
  return e === Number.POSITIVE_INFINITY ? 0 : e;
}
function tS(t, e = NI(t)) {
  return e === 0 ? t : t.split(`
`).map((r) => r.slice(e)).join(`
`);
}
function rS(t) {
  return hr(!1, hr(!1, t, "&apos;", "'"), "&quot;", '"');
}
function Mi(t) {
  return rS(t.value);
}
var MI = /* @__PURE__ */ new Set(["template", "style", "script"]);
function ch(t, e) {
  return Ba(t, e) && !MI.has(t.fullName);
}
function Ba(t, e) {
  return e.parser === "vue" && t.type === "element" && t.parent.type === "root" && t.fullName.toLowerCase() !== "html";
}
function Xm(t, e) {
  return Ba(t, e) && (ch(t, e) || t.attrMap.lang && t.attrMap.lang !== "html");
}
function LI(t) {
  let e = t.fullName;
  return e.charAt(0) === "#" || e === "slot-scope" || e === "v-slot" || e.startsWith("v-slot:");
}
function _I(t, e) {
  let r = t.parent;
  if (!Ba(r, e)) return !1;
  let s = r.fullName, i = t.fullName;
  return s === "script" && i === "setup" || s === "style" && i === "vars";
}
function sS(t, e = t.value) {
  return t.parent.isWhitespaceSensitive ? t.parent.isIndentationSensitive ? Mr(e) : Mr(tS(Vv(e)), je) : $a(rt, Ms.split(e));
}
function iS(t, e) {
  return Ba(t, e) && t.name === "script";
}
var nS = /\{\{(.+?)\}\}/su;
async function RI(t, e) {
  let r = [];
  for (let [s, i] of t.split(nS).entries()) if (s % 2 === 0) r.push(Mr(i));
  else try {
    r.push(ot(["{{", ys([rt, await jr(i, e, { parser: "__ng_interpolation", __isInHtmlInterpolation: !0 })]), rt, "}}"]));
  } catch {
    r.push("{{", Mr(i), "}}");
  }
  return r;
}
function Zm({ parser: t }) {
  return (e, r, s) => jr(Mi(s.node), e, { parser: t }, Qa);
}
var qI = Zm({ parser: "__ng_action" }), jI = Zm({ parser: "__ng_binding" }), XI = Zm({ parser: "__ng_directive" });
function ZI(t, e) {
  if (e.parser !== "angular") return;
  let { node: r } = t, s = r.fullName;
  if (s.startsWith("(") && s.endsWith(")") || s.startsWith("on-")) return qI;
  if (s.startsWith("[") && s.endsWith("]") || /^bind(?:on)?-/u.test(s) || /^ng-(?:if|show|hide|class|style)$/u.test(s)) return jI;
  if (s.startsWith("*")) return XI;
  let i = Mi(r);
  if (/^i18n(?:-.+)?$/u.test(s)) return () => oh(jv(sS(r, i.trim())), !i.includes("@@"));
  if (nS.test(i)) return (n) => RI(i, n);
}
var VI = ZI;
function zI(t, e) {
  let { node: r } = t, s = Mi(r);
  if (r.fullName === "class" && !e.parentParser && !s.includes("{{")) return () => s.trim().split(/\s+/u).join(" ");
}
var UI = zI;
function s0(t) {
  return t === "	" || t === `
` || t === "\f" || t === "\r" || t === " ";
}
var YI = /^[ \t\n\r\u000c]+/, WI = /^[, \t\n\r\u000c]+/, GI = /^[^ \t\n\r\u000c]+/, HI = /[,]+$/, i0 = /^\d+$/, JI = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
function KI(t) {
  let e = t.length, r, s, i, n, a, l = 0, c;
  function p(g) {
    let x, v = g.exec(t.substring(l));
    if (v) return [x] = v, l += x.length, x;
  }
  let d = [];
  for (; ; ) {
    if (p(WI), l >= e) {
      if (d.length === 0) throw new Error("Must contain one or more image candidate strings.");
      return d;
    }
    c = l, r = p(GI), s = [], r.slice(-1) === "," ? (r = r.replace(HI, ""), y()) : m();
  }
  function m() {
    for (p(YI), i = "", n = "in descriptor"; ; ) {
      if (a = t.charAt(l), n === "in descriptor") if (s0(a)) i && (s.push(i), i = "", n = "after descriptor");
      else if (a === ",") {
        l += 1, i && s.push(i), y();
        return;
      } else if (a === "(") i += a, n = "in parens";
      else if (a === "") {
        i && s.push(i), y();
        return;
      } else i += a;
      else if (n === "in parens") if (a === ")") i += a, n = "in descriptor";
      else if (a === "") {
        s.push(i), y();
        return;
      } else i += a;
      else if (n === "after descriptor" && !s0(a)) if (a === "") {
        y();
        return;
      } else n = "in descriptor", l -= 1;
      l += 1;
    }
  }
  function y() {
    let g = !1, x, v, w, C, b = {}, k, Q, F, $, N;
    for (C = 0; C < s.length; C++) k = s[C], Q = k[k.length - 1], F = k.substring(0, k.length - 1), $ = parseInt(F, 10), N = parseFloat(F), i0.test(F) && Q === "w" ? ((x || v) && (g = !0), $ === 0 ? g = !0 : x = $) : JI.test(F) && Q === "x" ? ((x || v || w) && (g = !0), N < 0 ? g = !0 : v = N) : i0.test(F) && Q === "h" ? ((w || v) && (g = !0), $ === 0 ? g = !0 : w = $) : g = !0;
    if (!g) b.source = { value: r, startOffset: c }, x && (b.width = { value: x }), v && (b.density = { value: v }), w && (b.height = { value: w }), d.push(b);
    else throw new Error(`Invalid srcset descriptor found in "${t}" at "${k}".`);
  }
}
var e6 = KI;
function t6(t) {
  if (t.node.fullName === "srcset" && (t.parent.fullName === "img" || t.parent.fullName === "source")) return () => s6(Mi(t.node));
}
var aS = { width: "w", height: "h", density: "x" }, r6 = Object.keys(aS);
function s6(t) {
  let e = e6(t), r = r6.filter((d) => e.some((m) => Object.prototype.hasOwnProperty.call(m, d)));
  if (r.length > 1) throw new Error("Mixed descriptor in srcset is not supported");
  let [s] = r, i = aS[s], n = e.map((d) => d.source.value), a = Math.max(...n.map((d) => d.length)), l = e.map((d) => d[s] ? String(d[s].value) : ""), c = l.map((d) => {
    let m = d.indexOf(".");
    return m === -1 ? d.length : m;
  }), p = Math.max(...c);
  return oh($a([",", rt], n.map((d, m) => {
    let y = [d], g = l[m];
    if (g) {
      let x = a - d.length + 1, v = p - c[m], w = " ".repeat(x + v);
      y.push(ic(w, " "), g + i);
    }
    return y;
  })));
}
var i6 = t6;
function n6(t, e) {
  let { node: r } = t, s = Mi(t.node).trim();
  if (r.fullName === "style" && !e.parentParser && !s.includes("{{")) return async (i) => oh(await i(s, { parser: "css", __isHTMLStyleAttribute: !0 }));
}
var fp = /* @__PURE__ */ new WeakMap();
function a6(t, e) {
  let { root: r } = t;
  return fp.has(r) || fp.set(r, r.children.some((s) => iS(s, e) && ["ts", "typescript"].includes(s.attrMap.lang))), fp.get(r);
}
var Vm = a6;
function o6(t, e, r) {
  let { node: s } = r, i = Mi(s);
  return jr(`type T<${i}> = any`, t, { parser: "babel-ts", __isEmbeddedTypescriptGenericParameters: !0 }, Qa);
}
function l6(t, e, { parseWithTs: r }) {
  return jr(`function _(${t}) {}`, e, { parser: r ? "babel-ts" : "babel", __isVueBindings: !0 });
}
async function u6(t, e, r, s) {
  let i = Mi(r.node), { left: n, operator: a, right: l } = c6(i), c = Vm(r, s);
  return [ot(await jr(`function _(${n}) {}`, t, { parser: c ? "babel-ts" : "babel", __isVueForBindingLeft: !0 })), " ", a, " ", await jr(l, t, { parser: c ? "__ts_expression" : "__js_expression" })];
}
function c6(t) {
  let e = /(.*?)\s+(in|of)\s+(.*)/su, r = /,([^,\]}]*)(?:,([^,\]}]*))?$/u, s = /^\(|\)$/gu, i = t.match(e);
  if (!i) return;
  let n = {};
  if (n.for = i[3].trim(), !n.for) return;
  let a = hr(!1, i[1].trim(), s, ""), l = a.match(r);
  l ? (n.alias = a.replace(r, ""), n.iterator1 = l[1].trim(), l[2] && (n.iterator2 = l[2].trim())) : n.alias = a;
  let c = [n.alias, n.iterator1, n.iterator2];
  if (!c.some((p, d) => !p && (d === 0 || c.slice(d + 1).some(Boolean)))) return { left: c.filter(Boolean).join(","), operator: i[2], right: n.for };
}
function h6(t, e) {
  if (e.parser !== "vue") return;
  let { node: r } = t, s = r.fullName;
  if (s === "v-for") return u6;
  if (s === "generic" && iS(r.parent, e)) return o6;
  let i = Mi(r), n = Vm(t, e);
  if (LI(r) || _I(r, e)) return (a) => l6(i, a, { parseWithTs: n });
  if (s.startsWith("@") || s.startsWith("v-on:")) return (a) => p6(i, a, { parseWithTs: n });
  if (s.startsWith(":") || s.startsWith(".") || s.startsWith("v-bind:")) return (a) => d6(i, a, { parseWithTs: n });
  if (s.startsWith("v-")) return (a) => oS(i, a, { parseWithTs: n });
}
async function p6(t, e, { parseWithTs: r }) {
  var s;
  try {
    return await oS(t, e, { parseWithTs: r });
  } catch (i) {
    if (((s = i.cause) == null ? void 0 : s.code) !== "BABEL_PARSER_SYNTAX_ERROR") throw i;
  }
  return jr(t, e, { parser: r ? "__vue_ts_event_binding" : "__vue_event_binding" }, Qa);
}
function d6(t, e, { parseWithTs: r }) {
  return jr(t, e, { parser: r ? "__vue_ts_expression" : "__vue_expression" }, Qa);
}
function oS(t, e, { parseWithTs: r }) {
  return jr(t, e, { parser: r ? "__ts_expression" : "__js_expression" }, Qa);
}
var f6 = h6;
function m6(t, e) {
  let { node: r } = t;
  if (r.value) {
    if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(e.originalText.slice(r.valueSpan.start.offset, r.valueSpan.end.offset)) || e.parser === "lwc" && r.value.startsWith("{") && r.value.endsWith("}")) return [r.rawName, "=", r.value];
    for (let s of [i6, n6, UI, f6, VI]) {
      let i = s(t, e);
      if (i) return g6(i);
    }
  }
}
function g6(t) {
  return async (e, r, s, i) => {
    let n = await t(e, r, s, i);
    if (n) return n = Rv(n, (a) => typeof a == "string" ? hr(!1, a, '"', "&quot;") : a), [s.node.rawName, '="', ot(n), '"'];
  };
}
var y6 = m6, O6 = new Proxy(() => {
}, { get: () => O6 });
function Dl(t) {
  return t.sourceSpan.start.offset;
}
function hh(t) {
  return t.sourceSpan.end.offset;
}
function Td(t, e) {
  return [t.isSelfClosing ? "" : x6(t, e), wo(t, e)];
}
function x6(t, e) {
  return t.lastChild && qo(t.lastChild) ? "" : [D6(t, e), zm(t, e)];
}
function wo(t, e) {
  return (t.next ? hn(t.next) : vl(t.parent)) ? "" : [bl(t, e), cn(t, e)];
}
function D6(t, e) {
  return vl(t) ? bl(t.lastChild, e) : "";
}
function cn(t, e) {
  return qo(t) ? zm(t.parent, e) : ph(t) ? Um(t.next, e) : "";
}
function zm(t, e) {
  if (lS(t, e)) return "";
  switch (t.type) {
    case "ieConditionalComment":
      return "<!";
    case "element":
      if (t.hasHtmComponentClosingTag) return "<//";
    default:
      return `</${t.rawName}`;
  }
}
function bl(t, e) {
  if (lS(t, e)) return "";
  switch (t.type) {
    case "ieConditionalComment":
    case "ieConditionalEndComment":
      return "[endif]-->";
    case "ieConditionalStartComment":
      return "]><!-->";
    case "interpolation":
      return "}}";
    case "angularIcuExpression":
      return "}";
    case "element":
      if (t.isSelfClosing) return "/>";
    default:
      return ">";
  }
}
function lS(t, e) {
  return !t.isSelfClosing && !t.endSourceSpan && (uh(t) || zv(t.parent, e));
}
function hn(t) {
  return t.prev && t.prev.type !== "docType" && t.type !== "angularControlFlowBlock" && !Or(t.prev) && t.isLeadingSpaceSensitive && !t.hasLeadingSpaces;
}
function vl(t) {
  var e;
  return ((e = t.lastChild) == null ? void 0 : e.isTrailingSpaceSensitive) && !t.lastChild.hasTrailingSpaces && !Or(jm(t.lastChild)) && !pa(t);
}
function qo(t) {
  return !t.next && !t.hasTrailingSpaces && t.isTrailingSpaceSensitive && Or(jm(t));
}
function ph(t) {
  return t.next && !Or(t.next) && Or(t) && t.isTrailingSpaceSensitive && !t.hasTrailingSpaces;
}
function b6(t) {
  let e = t.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/su);
  return e ? e[1] ? e[1].split(/\s+/u) : !0 : !1;
}
function dh(t) {
  return !t.prev && t.isLeadingSpaceSensitive && !t.hasLeadingSpaces;
}
function v6(t, e, r) {
  var s;
  let { node: i } = t;
  if (!qm(i.attrs)) return i.isSelfClosing ? " " : "";
  let n = ((s = i.prev) == null ? void 0 : s.type) === "comment" && b6(i.prev.value), a = typeof n == "boolean" ? () => n : Array.isArray(n) ? (m) => n.includes(m.rawName) : () => !1, l = t.map(({ node: m }) => a(m) ? Mr(e.originalText.slice(Dl(m), hh(m))) : r(), "attrs"), c = i.type === "element" && i.fullName === "script" && i.attrs.length === 1 && i.attrs[0].fullName === "src" && i.children.length === 0, p = e.singleAttributePerLine && i.attrs.length > 1 && !Ba(i, e) ? je : rt, d = [ys([c ? " " : rt, $a(p, l)])];
  return i.firstChild && dh(i.firstChild) || i.isSelfClosing && vl(i.parent) || c ? d.push(i.isSelfClosing ? " " : "") : d.push(e.bracketSameLine ? i.isSelfClosing ? " " : "" : i.isSelfClosing ? rt : Et), d;
}
function S6(t) {
  return t.firstChild && dh(t.firstChild) ? "" : Ym(t);
}
function kd(t, e, r) {
  let { node: s } = t;
  return [Ao(s, e), v6(t, e, r), s.isSelfClosing ? "" : S6(s)];
}
function Ao(t, e) {
  return t.prev && ph(t.prev) ? "" : [pn(t, e), Um(t, e)];
}
function pn(t, e) {
  return dh(t) ? Ym(t.parent) : hn(t) ? bl(t.prev, e) : "";
}
var n0 = "<!doctype";
function Um(t, e) {
  switch (t.type) {
    case "ieConditionalComment":
    case "ieConditionalStartComment":
      return `<!--[if ${t.condition}`;
    case "ieConditionalEndComment":
      return "<!--<!";
    case "interpolation":
      return "{{";
    case "docType": {
      if (t.value === "html") {
        let { filepath: s } = e;
        if (s && /\.html?$/u.test(s)) return n0;
      }
      let r = Dl(t);
      return e.originalText.slice(r, r + n0.length);
    }
    case "angularIcuExpression":
      return "{";
    case "element":
      if (t.condition) return `<!--[if ${t.condition}]><!--><${t.rawName}`;
    default:
      return `<${t.rawName}`;
  }
}
function Ym(t) {
  switch (t.type) {
    case "ieConditionalComment":
      return "]>";
    case "element":
      if (t.condition) return "><!--<![endif]-->";
    default:
      return ">";
  }
}
function w6(t, e) {
  if (!t.endSourceSpan) return "";
  let r = t.startSourceSpan.end.offset;
  t.firstChild && dh(t.firstChild) && (r -= Ym(t).length);
  let s = t.endSourceSpan.start.offset;
  return t.lastChild && qo(t.lastChild) ? s += zm(t, e).length : vl(t) && (s -= bl(t.lastChild, e).length), e.originalText.slice(r, s);
}
var uS = w6, A6 = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function C6(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case "element":
      if (Ls(r, e) || r.type === "interpolation") return;
      if (!r.isSelfClosing && Xm(r, e)) {
        let s = r0(r, e);
        return s ? async (i, n) => {
          let a = uS(r, e), l = /^\s*$/u.test(a), c = "";
          return l || (c = await i(Vv(a), { parser: s, __embeddedInHtml: !0 }), l = c === ""), [pn(r, e), ot(kd(t, e, n)), l ? "" : je, c, l ? "" : je, Td(r, e), cn(r, e)];
        } : void 0;
      }
      break;
    case "text":
      if (Ls(r.parent, e)) {
        let s = r0(r.parent, e);
        if (s) return async (i) => {
          let n = s === "markdown" ? tS(r.value.replace(/^[^\S\n]*\n/u, "")) : r.value, a = { parser: s, __embeddedInHtml: !0 };
          if (e.parser === "html" && s === "babel") {
            let l = "script", { attrMap: c } = r.parent;
            c && (c.type === "module" || (c.type === "text/babel" || c.type === "text/jsx") && c["data-type"] === "module") && (l = "module"), a.__babelSourceType = l;
          }
          return [Ol, pn(r, e), await i(n, a), cn(r, e)];
        };
      } else if (r.parent.type === "interpolation") return async (s) => {
        let i = { __isInHtmlInterpolation: !0, __embeddedInHtml: !0 };
        return e.parser === "angular" ? i.parser = "__ng_interpolation" : e.parser === "vue" ? i.parser = Vm(t, e) ? "__vue_ts_expression" : "__vue_expression" : i.parser = "__js_expression", [ys([rt, await s(r.value, i)]), r.parent.next && hn(r.parent.next) ? " " : rt];
      };
      break;
    case "attribute":
      return y6(t, e);
    case "front-matter":
      return (s) => J7(r, s);
    case "angularControlFlowBlockParameters":
      return A6.has(t.parent.name) ? eI : void 0;
    case "angularLetDeclarationInitializer":
      return (s) => jr(r.value, s, { parser: "__ng_binding", __isInHtmlAttribute: !1 });
  }
}
var E6 = C6, Ga = null;
function Co(t) {
  if (Ga !== null && typeof Ga.property) {
    let e = Ga;
    return Ga = Co.prototype = null, e;
  }
  return Ga = Co.prototype = t != null ? t : /* @__PURE__ */ Object.create(null), new Co();
}
var T6 = 10;
for (let t = 0; t <= T6; t++) Co();
function k6(t) {
  return Co(t);
}
function P6(t, e = "type") {
  k6(t);
  function r(s) {
    let i = s[e], n = t[i];
    if (!Array.isArray(n)) throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: s });
    return n;
  }
  return r;
}
var F6 = P6, $6 = { "front-matter": [], root: ["children"], element: ["attrs", "children"], ieConditionalComment: ["children"], ieConditionalStartComment: [], ieConditionalEndComment: [], interpolation: ["children"], text: ["children"], docType: [], comment: [], attribute: [], cdata: [], angularControlFlowBlock: ["children", "parameters"], angularControlFlowBlockParameters: ["children"], angularControlFlowBlockParameter: [], angularLetDeclaration: ["init"], angularLetDeclarationInitializer: [], angularIcuExpression: ["cases"], angularIcuCase: ["expression"] }, Q6 = $6, B6 = F6(Q6), I6 = B6, N6 = "format", M6 = /^\s*<!--\s*@(?:noformat|noprettier)\s*-->/u, L6 = /^\s*<!--\s*@(?:format|prettier)\s*-->/u;
function _6(t) {
  return L6.test(t);
}
function R6(t) {
  return M6.test(t);
}
function q6(t) {
  return `<!-- @${N6} -->

${t}`;
}
var j6 = /* @__PURE__ */ new Map([["if", /* @__PURE__ */ new Set(["else if", "else"])], ["else if", /* @__PURE__ */ new Set(["else if", "else"])], ["for", /* @__PURE__ */ new Set(["empty"])], ["defer", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["placeholder", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["error", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["loading", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])]]);
function cS(t) {
  let e = hh(t);
  return t.type === "element" && !t.endSourceSpan && qm(t.children) ? Math.max(e, cS(yl(!1, t.children, -1))) : e;
}
function Ha(t, e, r) {
  let s = t.node;
  if (uh(s)) {
    let i = cS(s);
    return [pn(s, e), Mr(Ms.trimEnd(e.originalText.slice(Dl(s) + (s.prev && ph(s.prev) ? Um(s).length : 0), i - (s.next && hn(s.next) ? bl(s, e).length : 0)))), cn(s, e)];
  }
  return r();
}
function Kl(t, e) {
  return Or(t) && Or(e) ? t.isTrailingSpaceSensitive ? t.hasTrailingSpaces ? dp(e) ? je : rt : "" : dp(e) ? je : Et : ph(t) && (uh(e) || e.firstChild || e.isSelfClosing || e.type === "element" && e.attrs.length > 0) || t.type === "element" && t.isSelfClosing && hn(e) ? "" : !e.isLeadingSpaceSensitive || dp(e) || hn(e) && t.lastChild && qo(t.lastChild) && t.lastChild.lastChild && qo(t.lastChild.lastChild) ? je : e.hasLeadingSpaces ? rt : Et;
}
function Wm(t, e, r) {
  let { node: s } = t;
  if (Yv(s)) return [Ol, ...t.map((n) => {
    let a = n.node, l = a.prev ? Kl(a.prev, a) : "";
    return [l ? [l, Jl(a.prev) ? je : ""] : "", Ha(n, e, r)];
  }, "children")];
  let i = s.children.map(() => Symbol(""));
  return t.map((n, a) => {
    let l = n.node;
    if (Or(l)) {
      if (l.prev && Or(l.prev)) {
        let x = Kl(l.prev, l);
        if (x) return Jl(l.prev) ? [je, je, Ha(n, e, r)] : [x, Ha(n, e, r)];
      }
      return Ha(n, e, r);
    }
    let c = [], p = [], d = [], m = [], y = l.prev ? Kl(l.prev, l) : "", g = l.next ? Kl(l, l.next) : "";
    return y && (Jl(l.prev) ? c.push(je, je) : y === je ? c.push(je) : Or(l.prev) ? p.push(y) : p.push(ic("", Et, { groupId: i[a - 1] }))), g && (Jl(l) ? Or(l.next) && m.push(je, je) : g === je ? Or(l.next) && m.push(je) : d.push(g)), [...c, ot([...p, ot([Ha(n, e, r), ...d], { id: i[a] })]), ...m];
  }, "children");
}
function X6(t, e, r) {
  let { node: s } = t, i = [];
  Z6(t) && i.push("} "), i.push("@", s.name), s.parameters && i.push(" (", ot(r("parameters")), ")"), i.push(" {");
  let n = hS(s);
  return s.children.length > 0 ? (s.firstChild.hasLeadingSpaces = !0, s.lastChild.hasTrailingSpaces = !0, i.push(ys([je, Wm(t, e, r)])), n && i.push(je, "}")) : n && i.push("}"), ot(i, { shouldBreak: !0 });
}
function hS(t) {
  var e, r;
  return !(((e = t.next) == null ? void 0 : e.type) === "angularControlFlowBlock" && (r = j6.get(t.name)) != null && r.has(t.next.name));
}
function Z6(t) {
  let { previous: e } = t;
  return (e == null ? void 0 : e.type) === "angularControlFlowBlock" && !uh(e) && !hS(e);
}
function V6(t, e, r) {
  return [ys([Et, $a([";", rt], t.map(r, "children"))]), Et];
}
function z6(t, e, r) {
  let { node: s } = t;
  return [Ao(s, e), ot([s.switchValue.trim(), ", ", s.clause, s.cases.length > 0 ? [",", ys([rt, $a(rt, t.map(r, "cases"))])] : "", Et]), wo(s, e)];
}
function U6(t, e, r) {
  let { node: s } = t;
  return [s.value, " {", ot([ys([Et, t.map(({ node: i, isLast: n }) => {
    let a = [r()];
    return i.type === "text" && (i.hasLeadingSpaces && a.unshift(rt), i.hasTrailingSpaces && !n && a.push(rt)), a;
  }, "expression")]), Et]), "}"];
}
function Y6(t, e, r) {
  let { node: s } = t;
  if (zv(s, e)) return [pn(s, e), ot(kd(t, e, r)), Mr(uS(s, e)), ...Td(s, e), cn(s, e)];
  let i = s.children.length === 1 && (s.firstChild.type === "interpolation" || s.firstChild.type === "angularIcuExpression") && s.firstChild.isLeadingSpaceSensitive && !s.firstChild.hasLeadingSpaces && s.lastChild.isTrailingSpaceSensitive && !s.lastChild.hasTrailingSpaces, n = Symbol("element-attr-group-id"), a = (d) => ot([ot(kd(t, e, r), { id: n }), d, Td(s, e)]), l = (d) => i ? B7(d, { groupId: n }) : (Ls(s, e) || ch(s, e)) && s.parent.type === "root" && e.parser === "vue" && !e.vueIndentScriptAndStyle ? d : ys(d), c = () => i ? ic(Et, "", { groupId: n }) : s.firstChild.hasLeadingSpaces && s.firstChild.isLeadingSpaceSensitive ? rt : s.firstChild.type === "text" && s.isWhitespaceSensitive && s.isIndentationSensitive ? $7(Et) : Et, p = () => (s.next ? hn(s.next) : vl(s.parent)) ? s.lastChild.hasTrailingSpaces && s.lastChild.isTrailingSpaceSensitive ? " " : "" : i ? ic(Et, "", { groupId: n }) : s.lastChild.hasTrailingSpaces && s.lastChild.isTrailingSpaceSensitive ? rt : (s.lastChild.type === "comment" || s.lastChild.type === "text" && s.isWhitespaceSensitive && s.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${e.tabWidth * (t.ancestors.length - 1)}}$`, "u").test(s.lastChild.value) ? "" : Et;
  return s.children.length === 0 ? a(s.hasDanglingSpaces && s.isDanglingSpaceSensitive ? rt : "") : a([SI(s) ? Ol : "", l([c(), Wm(t, e, r)]), p()]);
}
function nc(t) {
  return t >= 9 && t <= 32 || t == 160;
}
function Gm(t) {
  return 48 <= t && t <= 57;
}
function ac(t) {
  return t >= 97 && t <= 122 || t >= 65 && t <= 90;
}
function W6(t) {
  return t >= 97 && t <= 102 || t >= 65 && t <= 70 || Gm(t);
}
function Hm(t) {
  return t === 10 || t === 13;
}
function a0(t) {
  return 48 <= t && t <= 55;
}
function mp(t) {
  return t === 39 || t === 34 || t === 96;
}
var G6 = /-+([a-z0-9])/g;
function H6(t) {
  return t.replace(G6, (...e) => e[1].toUpperCase());
}
var Pd = class pS {
  constructor(e, r, s, i) {
    this.file = e, this.offset = r, this.line = s, this.col = i;
  }
  toString() {
    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
  }
  moveBy(e) {
    let r = this.file.content, s = r.length, i = this.offset, n = this.line, a = this.col;
    for (; i > 0 && e < 0; ) if (i--, e++, r.charCodeAt(i) == 10) {
      n--;
      let l = r.substring(0, i - 1).lastIndexOf(`
`);
      a = l > 0 ? i - l : i;
    } else a--;
    for (; i < s && e > 0; ) {
      let l = r.charCodeAt(i);
      i++, e--, l == 10 ? (n++, a = 0) : a++;
    }
    return new pS(this.file, i, n, a);
  }
  getContext(e, r) {
    let s = this.file.content, i = this.offset;
    if (i != null) {
      i > s.length - 1 && (i = s.length - 1);
      let n = i, a = 0, l = 0;
      for (; a < e && i > 0 && (i--, a++, !(s[i] == `
` && ++l == r)); ) ;
      for (a = 0, l = 0; a < e && n < s.length - 1 && (n++, a++, !(s[n] == `
` && ++l == r)); ) ;
      return { before: s.substring(i, this.offset), after: s.substring(this.offset, n + 1) };
    }
    return null;
  }
}, dS = class {
  constructor(e, r) {
    this.content = e, this.url = r;
  }
}, Oe = class {
  constructor(t, e, r = t, s = null) {
    this.start = t, this.end = e, this.fullStart = r, this.details = s;
  }
  toString() {
    return this.start.file.content.substring(this.start.offset, this.end.offset);
  }
}, oc;
(function(t) {
  t[t.WARNING = 0] = "WARNING", t[t.ERROR = 1] = "ERROR";
})(oc || (oc = {}));
var fS = class {
  constructor(e, r, s = oc.ERROR, i) {
    this.span = e, this.msg = r, this.level = s, this.relatedError = i;
  }
  contextualMessage() {
    let e = this.span.start.getContext(100, 3);
    return e ? `${this.msg} ("${e.before}[${oc[this.level]} ->]${e.after}")` : this.msg;
  }
  toString() {
    let e = this.span.details ? `, ${this.span.details}` : "";
    return `${this.contextualMessage()}: ${this.span.start}${e}`;
  }
}, J6 = [eN, tN, sN, nN, aN, uN, oN, lN, cN, iN];
function K6(t, e) {
  for (let r of J6) r(t, e);
  return t;
}
function eN(t) {
  t.walk((e) => {
    if (e.type === "element" && e.tagDefinition.ignoreFirstLf && e.children.length > 0 && e.children[0].type === "text" && e.children[0].value[0] === `
`) {
      let r = e.children[0];
      r.value.length === 1 ? e.removeChild(r) : r.value = r.value.slice(1);
    }
  });
}
function tN(t) {
  let e = (r) => {
    var s, i;
    return r.type === "element" && ((s = r.prev) == null ? void 0 : s.type) === "ieConditionalStartComment" && r.prev.sourceSpan.end.offset === r.startSourceSpan.start.offset && ((i = r.firstChild) == null ? void 0 : i.type) === "ieConditionalEndComment" && r.firstChild.sourceSpan.start.offset === r.startSourceSpan.end.offset;
  };
  t.walk((r) => {
    if (r.children) for (let s = 0; s < r.children.length; s++) {
      let i = r.children[s];
      if (!e(i)) continue;
      let n = i.prev, a = i.firstChild;
      r.removeChild(n), s--;
      let l = new Oe(n.sourceSpan.start, a.sourceSpan.end), c = new Oe(l.start, i.sourceSpan.end);
      i.condition = n.condition, i.sourceSpan = c, i.startSourceSpan = l, i.removeChild(a);
    }
  });
}
function rN(t, e, r) {
  t.walk((s) => {
    if (s.children) for (let i = 0; i < s.children.length; i++) {
      let n = s.children[i];
      if (n.type !== "text" && !e(n)) continue;
      n.type !== "text" && (n.type = "text", n.value = r(n));
      let a = n.prev;
      !a || a.type !== "text" || (a.value += n.value, a.sourceSpan = new Oe(a.sourceSpan.start, n.sourceSpan.end), s.removeChild(n), i--);
    }
  });
}
function sN(t) {
  return rN(t, (e) => e.type === "cdata", (e) => `<![CDATA[${e.value}]]>`);
}
function iN(t) {
  let e = (r) => {
    var s, i;
    return r.type === "element" && r.attrs.length === 0 && r.children.length === 1 && r.firstChild.type === "text" && !Ms.hasWhitespaceCharacter(r.children[0].value) && !r.firstChild.hasLeadingSpaces && !r.firstChild.hasTrailingSpaces && r.isLeadingSpaceSensitive && !r.hasLeadingSpaces && r.isTrailingSpaceSensitive && !r.hasTrailingSpaces && ((s = r.prev) == null ? void 0 : s.type) === "text" && ((i = r.next) == null ? void 0 : i.type) === "text";
  };
  t.walk((r) => {
    if (r.children) for (let s = 0; s < r.children.length; s++) {
      let i = r.children[s];
      if (!e(i)) continue;
      let n = i.prev, a = i.next;
      n.value += `<${i.rawName}>` + i.firstChild.value + `</${i.rawName}>` + a.value, n.sourceSpan = new Oe(n.sourceSpan.start, a.sourceSpan.end), n.isTrailingSpaceSensitive = a.isTrailingSpaceSensitive, n.hasTrailingSpaces = a.hasTrailingSpaces, r.removeChild(i), s--, r.removeChild(a);
    }
  });
}
function nN(t, e) {
  if (e.parser === "html") return;
  let r = /\{\{(.+?)\}\}/su;
  t.walk((s) => {
    if (OI(s, e)) for (let i of s.children) {
      if (i.type !== "text") continue;
      let n = i.sourceSpan.start, a = null, l = i.value.split(r);
      for (let c = 0; c < l.length; c++, n = a) {
        let p = l[c];
        if (c % 2 === 0) {
          a = n.moveBy(p.length), p.length > 0 && s.insertChildBefore(i, { type: "text", value: p, sourceSpan: new Oe(n, a) });
          continue;
        }
        a = n.moveBy(p.length + 4), s.insertChildBefore(i, { type: "interpolation", sourceSpan: new Oe(n, a), children: p.length === 0 ? [] : [{ type: "text", value: p, sourceSpan: new Oe(n.moveBy(2), a.moveBy(-2)) }] });
      }
      s.removeChild(i);
    }
  });
}
function aN(t, e) {
  t.walk((r) => {
    let s = r.$children;
    if (!s) return;
    if (s.length === 0 || s.length === 1 && s[0].type === "text" && Ms.trim(s[0].value).length === 0) {
      r.hasDanglingSpaces = s.length > 0, r.$children = [];
      return;
    }
    let i = xI(r, e), n = Uv(r);
    if (!i) for (let a = 0; a < s.length; a++) {
      let l = s[a];
      if (l.type !== "text") continue;
      let { leadingWhitespace: c, text: p, trailingWhitespace: d } = gI(l.value), m = l.prev, y = l.next;
      p ? (l.value = p, l.sourceSpan = new Oe(l.sourceSpan.start.moveBy(c.length), l.sourceSpan.end.moveBy(-d.length)), c && (m && (m.hasTrailingSpaces = !0), l.hasLeadingSpaces = !0), d && (l.hasTrailingSpaces = !0, y && (y.hasLeadingSpaces = !0))) : (r.removeChild(l), a--, (c || d) && (m && (m.hasTrailingSpaces = !0), y && (y.hasLeadingSpaces = !0)));
    }
    r.isWhitespaceSensitive = i, r.isIndentationSensitive = n;
  });
}
function oN(t) {
  t.walk((e) => {
    e.isSelfClosing = !e.children || e.type === "element" && (e.tagDefinition.isVoid || e.endSourceSpan && e.startSourceSpan.start === e.endSourceSpan.start && e.startSourceSpan.end === e.endSourceSpan.end);
  });
}
function lN(t, e) {
  t.walk((r) => {
    r.type === "element" && (r.hasHtmComponentClosingTag = r.endSourceSpan && /^<\s*\/\s*\/\s*>$/u.test(e.originalText.slice(r.endSourceSpan.start.offset, r.endSourceSpan.end.offset)));
  });
}
function uN(t, e) {
  t.walk((r) => {
    r.cssDisplay = II(r, e);
  });
}
function cN(t, e) {
  t.walk((r) => {
    let { children: s } = r;
    if (s) {
      if (s.length === 0) {
        r.isDanglingSpaceSensitive = vI(r, e);
        return;
      }
      for (let i of s) i.isLeadingSpaceSensitive = DI(i, e), i.isTrailingSpaceSensitive = bI(i, e);
      for (let i = 0; i < s.length; i++) {
        let n = s[i];
        n.isLeadingSpaceSensitive = (i === 0 || n.prev.isTrailingSpaceSensitive) && n.isLeadingSpaceSensitive, n.isTrailingSpaceSensitive = (i === s.length - 1 || n.next.isLeadingSpaceSensitive) && n.isTrailingSpaceSensitive;
      }
    }
  });
}
var hN = K6;
function pN(t, e, r) {
  let { node: s } = t;
  switch (s.type) {
    case "front-matter":
      return Mr(s.raw);
    case "root":
      return e.__onHtmlRoot && e.__onHtmlRoot(s), [ot(Wm(t, e, r)), je];
    case "element":
    case "ieConditionalComment":
      return Y6(t, e, r);
    case "angularControlFlowBlock":
      return X6(t, e, r);
    case "angularControlFlowBlockParameters":
      return V6(t, e, r);
    case "angularControlFlowBlockParameter":
      return Ms.trim(s.expression);
    case "angularLetDeclaration":
      return ot(["@let ", ot([s.id, " =", ot(ys([rt, r("init")]))]), ";"]);
    case "angularLetDeclarationInitializer":
      return s.value;
    case "angularIcuExpression":
      return z6(t, e, r);
    case "angularIcuCase":
      return U6(t, e, r);
    case "ieConditionalStartComment":
    case "ieConditionalEndComment":
      return [Ao(s), wo(s)];
    case "interpolation":
      return [Ao(s, e), ...t.map(r, "children"), wo(s, e)];
    case "text": {
      if (s.parent.type === "interpolation") {
        let l = /\n[^\S\n]*$/u, c = l.test(s.value), p = c ? s.value.replace(l, "") : s.value;
        return [Mr(p), c ? je : ""];
      }
      let i = pn(s, e), n = sS(s), a = cn(s, e);
      return n[0] = [i, n[0]], n.push([n.pop(), a]), jv(n);
    }
    case "docType":
      return [ot([Ao(s, e), " ", hr(!1, s.value.replace(/^html\b/iu, "html"), /\s+/gu, " ")]), wo(s, e)];
    case "comment":
      return [pn(s, e), Mr(e.originalText.slice(Dl(s), hh(s))), cn(s, e)];
    case "attribute": {
      if (s.value === null) return s.rawName;
      let i = rS(s.value), n = _7(i, '"');
      return [s.rawName, "=", n, Mr(n === '"' ? hr(!1, i, '"', "&quot;") : hr(!1, i, "'", "&apos;")), n];
    }
    case "cdata":
    default:
      throw new z7(s, "HTML");
  }
}
var dN = { preprocess: hN, print: pN, insertPragma: q6, massageAstNode: G7, embed: E6, getVisitorKeys: I6 }, fN = dN, mN = [{ name: "Angular", type: "markup", extensions: [".component.html"], tmScope: "text.html.basic", aceMode: "html", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["angular"], vscodeLanguageIds: ["html"], filenames: [], linguistLanguageId: 146 }, { name: "HTML", type: "markup", extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], tmScope: "text.html.basic", aceMode: "html", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["html"], vscodeLanguageIds: ["html"], linguistLanguageId: 146 }, { name: "Lightning Web Components", type: "markup", extensions: [], tmScope: "text.html.basic", aceMode: "html", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["lwc"], vscodeLanguageIds: ["html"], filenames: [], linguistLanguageId: 146 }, { name: "MJML", type: "markup", extensions: [".mjml"], tmScope: "text.mjml.basic", aceMode: "html", aliases: ["MJML", "mjml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["mjml"], filenames: [], vscodeLanguageIds: ["mjml"], linguistLanguageId: 146 }, { name: "Vue", type: "markup", extensions: [".vue"], tmScope: "source.vue", aceMode: "html", parsers: ["vue"], vscodeLanguageIds: ["vue"], linguistLanguageId: 391 }], o0 = { bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." } }, l0 = "HTML", gN = { bracketSameLine: o0.bracketSameLine, htmlWhitespaceSensitivity: { category: l0, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: o0.singleAttributePerLine, vueIndentScriptAndStyle: { category: l0, type: "boolean", default: !1, description: "Indent script and style tags in Vue files." } }, yN = gN, mS = {};
Ev(mS, { angular: () => SM, html: () => DM, lwc: () => AM, mjml: () => vM, vue: () => wM });
var u0;
(function(t) {
  t[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom";
})(u0 || (u0 = {}));
var c0;
(function(t) {
  t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default";
})(c0 || (c0 = {}));
var h0;
(function(t) {
  t[t.None = 0] = "None", t[t.SignalBased = 1] = "SignalBased", t[t.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform";
})(h0 || (h0 = {}));
var p0 = { name: "custom-elements" }, d0 = { name: "no-errors-schema" }, Wi;
(function(t) {
  t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL";
})(Wi || (Wi = {}));
var f0;
(function(t) {
  t[t.Error = 0] = "Error", t[t.Warning = 1] = "Warning", t[t.Ignore = 2] = "Ignore";
})(f0 || (f0 = {}));
var Ir;
(function(t) {
  t[t.RAW_TEXT = 0] = "RAW_TEXT", t[t.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", t[t.PARSABLE_DATA = 2] = "PARSABLE_DATA";
})(Ir || (Ir = {}));
function fh(t, e = !0) {
  if (t[0] != ":") return [null, t];
  let r = t.indexOf(":", 1);
  if (r === -1) {
    if (e) throw new Error(`Unsupported format "${t}" expecting ":namespace:name"`);
    return [null, t];
  }
  return [t.slice(1, r), t.slice(r + 1)];
}
function m0(t) {
  return fh(t)[1] === "ng-container";
}
function g0(t) {
  return fh(t)[1] === "ng-content";
}
function Qu(t) {
  return t === null ? null : fh(t)[0];
}
function lc(t, e) {
  return t ? `:${t}:${e}` : e;
}
var Bu;
function y0() {
  return Bu || (Bu = {}, eu(Wi.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), eu(Wi.STYLE, ["*|style"]), eu(Wi.URL, ["*|formAction", "area|href", "area|ping", "audio|src", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "form|action", "img|src", "input|src", "ins|cite", "q|cite", "source|src", "track|src", "video|poster", "video|src"]), eu(Wi.RESOURCE_URL, ["applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])), Bu;
}
function eu(t, e) {
  for (let r of e) Bu[r.toLowerCase()] = t;
}
var ON = class {
}, xN = "boolean", DN = "number", bN = "string", vN = "object", SN = ["[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored", "[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,!inert,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume", ":svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":svg:graphics^:svg:|", ":svg:animation^:svg:|*begin,*end,*repeat", ":svg:geometry^:svg:|", ":svg:componentTransferFunction^:svg:|", ":svg:gradient^:svg:|", ":svg:textContent^:svg:graphics|", ":svg:textPositioning^:svg:textContent|", "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username", "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username", "audio^media|", "br^[HTMLElement]|clear", "base^[HTMLElement]|href,target", "body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink", "button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value", "canvas^[HTMLElement]|#height,#width", "content^[HTMLElement]|select", "dl^[HTMLElement]|!compact", "data^[HTMLElement]|value", "datalist^[HTMLElement]|", "details^[HTMLElement]|!open", "dialog^[HTMLElement]|!open,returnValue", "dir^[HTMLElement]|!compact", "div^[HTMLElement]|align", "embed^[HTMLElement]|align,height,name,src,type,width", "fieldset^[HTMLElement]|!disabled,name", "font^[HTMLElement]|color,face,size", "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target", "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src", "frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows", "hr^[HTMLElement]|align,color,!noShade,size,width", "head^[HTMLElement]|", "h1,h2,h3,h4,h5,h6^[HTMLElement]|align", "html^[HTMLElement]|version", "iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width", "img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width", "input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width", "li^[HTMLElement]|type,#value", "label^[HTMLElement]|htmlFor", "legend^[HTMLElement]|align", "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type", "map^[HTMLElement]|name", "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width", "menu^[HTMLElement]|!compact", "meta^[HTMLElement]|content,httpEquiv,media,name,scheme", "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value", "ins,del^[HTMLElement]|cite,dateTime", "ol^[HTMLElement]|!compact,!reversed,#start,type", "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width", "optgroup^[HTMLElement]|!disabled,label", "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value", "output^[HTMLElement]|defaultValue,%htmlFor,name,value", "p^[HTMLElement]|align", "param^[HTMLElement]|name,type,value,valueType", "picture^[HTMLElement]|", "pre^[HTMLElement]|#width", "progress^[HTMLElement]|#max,#value", "q,blockquote,cite^[HTMLElement]|", "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type", "select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value", "slot^[HTMLElement]|name", "source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width", "span^[HTMLElement]|", "style^[HTMLElement]|!disabled,media,type", "caption^[HTMLElement]|align", "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width", "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width", "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width", "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign", "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign", "template^[HTMLElement]|", "textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap", "time^[HTMLElement]|dateTime", "title^[HTMLElement]|text", "track^[HTMLElement]|!default,kind,label,src,srclang", "ul^[HTMLElement]|!compact,type", "unknown^[HTMLElement]|", "video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width", ":svg:a^:svg:graphics|", ":svg:animate^:svg:animation|", ":svg:animateMotion^:svg:animation|", ":svg:animateTransform^:svg:animation|", ":svg:circle^:svg:geometry|", ":svg:clipPath^:svg:graphics|", ":svg:defs^:svg:graphics|", ":svg:desc^:svg:|", ":svg:discard^:svg:|", ":svg:ellipse^:svg:geometry|", ":svg:feBlend^:svg:|", ":svg:feColorMatrix^:svg:|", ":svg:feComponentTransfer^:svg:|", ":svg:feComposite^:svg:|", ":svg:feConvolveMatrix^:svg:|", ":svg:feDiffuseLighting^:svg:|", ":svg:feDisplacementMap^:svg:|", ":svg:feDistantLight^:svg:|", ":svg:feDropShadow^:svg:|", ":svg:feFlood^:svg:|", ":svg:feFuncA^:svg:componentTransferFunction|", ":svg:feFuncB^:svg:componentTransferFunction|", ":svg:feFuncG^:svg:componentTransferFunction|", ":svg:feFuncR^:svg:componentTransferFunction|", ":svg:feGaussianBlur^:svg:|", ":svg:feImage^:svg:|", ":svg:feMerge^:svg:|", ":svg:feMergeNode^:svg:|", ":svg:feMorphology^:svg:|", ":svg:feOffset^:svg:|", ":svg:fePointLight^:svg:|", ":svg:feSpecularLighting^:svg:|", ":svg:feSpotLight^:svg:|", ":svg:feTile^:svg:|", ":svg:feTurbulence^:svg:|", ":svg:filter^:svg:|", ":svg:foreignObject^:svg:graphics|", ":svg:g^:svg:graphics|", ":svg:image^:svg:graphics|decoding", ":svg:line^:svg:geometry|", ":svg:linearGradient^:svg:gradient|", ":svg:mpath^:svg:|", ":svg:marker^:svg:|", ":svg:mask^:svg:|", ":svg:metadata^:svg:|", ":svg:path^:svg:geometry|", ":svg:pattern^:svg:|", ":svg:polygon^:svg:geometry|", ":svg:polyline^:svg:geometry|", ":svg:radialGradient^:svg:gradient|", ":svg:rect^:svg:geometry|", ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan", ":svg:script^:svg:|type", ":svg:set^:svg:animation|", ":svg:stop^:svg:|", ":svg:style^:svg:|!disabled,media,title,type", ":svg:switch^:svg:graphics|", ":svg:symbol^:svg:|", ":svg:tspan^:svg:textPositioning|", ":svg:text^:svg:textPositioning|", ":svg:textPath^:svg:textContent|", ":svg:title^:svg:|", ":svg:use^:svg:graphics|", ":svg:view^:svg:|#zoomAndPan", "data^[HTMLElement]|value", "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name", "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default", "summary^[HTMLElement]|", "time^[HTMLElement]|dateTime", ":svg:cursor^:svg:|", ":math:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforeinput,*beforematch,*beforetoggle,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contentvisibilityautostatechange,*contextlost,*contextmenu,*contextrestored,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*scrollend,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":math:math^:math:|", ":math:maction^:math:|", ":math:menclose^:math:|", ":math:merror^:math:|", ":math:mfenced^:math:|", ":math:mfrac^:math:|", ":math:mi^:math:|", ":math:mmultiscripts^:math:|", ":math:mn^:math:|", ":math:mo^:math:|", ":math:mover^:math:|", ":math:mpadded^:math:|", ":math:mphantom^:math:|", ":math:mroot^:math:|", ":math:mrow^:math:|", ":math:ms^:math:|", ":math:mspace^:math:|", ":math:msqrt^:math:|", ":math:mstyle^:math:|", ":math:msub^:math:|", ":math:msubsup^:math:|", ":math:msup^:math:|", ":math:mtable^:math:|", ":math:mtd^:math:|", ":math:mtext^:math:|", ":math:mtr^:math:|", ":math:munder^:math:|", ":math:munderover^:math:|", ":math:semantics^:math:|"], gS = new Map(Object.entries({ class: "className", for: "htmlFor", formaction: "formAction", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex" })), wN = Array.from(gS).reduce((t, [e, r]) => (t.set(e, r), t), /* @__PURE__ */ new Map()), AN = class extends ON {
  constructor() {
    super(), this._schema = /* @__PURE__ */ new Map(), this._eventSchema = /* @__PURE__ */ new Map(), SN.forEach((e) => {
      let r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Set(), [i, n] = e.split("|"), a = n.split(","), [l, c] = i.split("^");
      l.split(",").forEach((d) => {
        this._schema.set(d.toLowerCase(), r), this._eventSchema.set(d.toLowerCase(), s);
      });
      let p = c && this._schema.get(c.toLowerCase());
      if (p) {
        for (let [d, m] of p) r.set(d, m);
        for (let d of this._eventSchema.get(c.toLowerCase())) s.add(d);
      }
      a.forEach((d) => {
        if (d.length > 0) switch (d[0]) {
          case "*":
            s.add(d.substring(1));
            break;
          case "!":
            r.set(d.substring(1), xN);
            break;
          case "#":
            r.set(d.substring(1), DN);
            break;
          case "%":
            r.set(d.substring(1), vN);
            break;
          default:
            r.set(d, bN);
        }
      });
    });
  }
  hasProperty(e, r, s) {
    if (s.some((i) => i.name === d0.name)) return !0;
    if (e.indexOf("-") > -1) {
      if (m0(e) || g0(e)) return !1;
      if (s.some((i) => i.name === p0.name)) return !0;
    }
    return (this._schema.get(e.toLowerCase()) || this._schema.get("unknown")).has(r);
  }
  hasElement(e, r) {
    return r.some((s) => s.name === d0.name) || e.indexOf("-") > -1 && (m0(e) || g0(e) || r.some((s) => s.name === p0.name)) ? !0 : this._schema.has(e.toLowerCase());
  }
  securityContext(e, r, s) {
    s && (r = this.getMappedPropName(r)), e = e.toLowerCase(), r = r.toLowerCase();
    let i = y0()[e + "|" + r];
    return i || (i = y0()["*|" + r], i || Wi.NONE);
  }
  getMappedPropName(e) {
    var r;
    return (r = gS.get(e)) != null ? r : e;
  }
  getDefaultComponentElementName() {
    return "ng-component";
  }
  validateProperty(e) {
    return e.toLowerCase().startsWith("on") ? { error: !0, msg: `Binding to event property '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...
If '${e}' is a directive input, make sure the directive is imported by the current module.` } : { error: !1 };
  }
  validateAttribute(e) {
    return e.toLowerCase().startsWith("on") ? { error: !0, msg: `Binding to event attribute '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...` } : { error: !1 };
  }
  allKnownElementNames() {
    return Array.from(this._schema.keys());
  }
  allKnownAttributesOfElement(e) {
    let r = this._schema.get(e.toLowerCase()) || this._schema.get("unknown");
    return Array.from(r.keys()).map((s) => {
      var i;
      return (i = wN.get(s)) != null ? i : s;
    });
  }
  allKnownEventsOfElement(e) {
    var r;
    return Array.from((r = this._eventSchema.get(e.toLowerCase())) != null ? r : []);
  }
  normalizeAnimationStyleProperty(e) {
    return H6(e);
  }
  normalizeAnimationStyleValue(e, r, s) {
    let i = "", n = s.toString().trim(), a = null;
    if (CN(e) && s !== 0 && s !== "0") if (typeof s == "number") i = "px";
    else {
      let l = s.match(/^[+-]?[\d\.]+([a-z]*)$/);
      l && l[1].length == 0 && (a = `Please provide a CSS unit value for ${r}:${s}`);
    }
    return { error: a, value: n + i };
  }
};
function CN(t) {
  switch (t) {
    case "width":
    case "height":
    case "minWidth":
    case "minHeight":
    case "maxWidth":
    case "maxHeight":
    case "left":
    case "top":
    case "bottom":
    case "right":
    case "fontSize":
    case "outlineWidth":
    case "outlineOffset":
    case "paddingTop":
    case "paddingLeft":
    case "paddingBottom":
    case "paddingRight":
    case "marginTop":
    case "marginLeft":
    case "marginBottom":
    case "marginRight":
    case "borderRadius":
    case "borderWidth":
    case "borderTopWidth":
    case "borderLeftWidth":
    case "borderRightWidth":
    case "borderBottomWidth":
    case "textIndent":
      return !0;
    default:
      return !1;
  }
}
var me = class {
  constructor({ closedByChildren: t, implicitNamespacePrefix: e, contentType: r = Ir.PARSABLE_DATA, closedByParent: s = !1, isVoid: i = !1, ignoreFirstLf: n = !1, preventNamespaceInheritance: a = !1, canSelfClose: l = !1 } = {}) {
    this.closedByChildren = {}, this.closedByParent = !1, t && t.length > 0 && t.forEach((c) => this.closedByChildren[c] = !0), this.isVoid = i, this.closedByParent = s || i, this.implicitNamespacePrefix = e || null, this.contentType = r, this.ignoreFirstLf = n, this.preventNamespaceInheritance = a, this.canSelfClose = l != null ? l : i;
  }
  isClosedByChild(t) {
    return this.isVoid || t.toLowerCase() in this.closedByChildren;
  }
  getContentType(t) {
    var e;
    return typeof this.contentType == "object" ? (e = t === void 0 ? void 0 : this.contentType[t]) != null ? e : this.contentType.default : this.contentType;
  }
}, O0, Ja;
function Fd(t) {
  var e;
  return Ja || (O0 = new me({ canSelfClose: !0 }), Ja = Object.assign(/* @__PURE__ */ Object.create(null), { base: new me({ isVoid: !0 }), meta: new me({ isVoid: !0 }), area: new me({ isVoid: !0 }), embed: new me({ isVoid: !0 }), link: new me({ isVoid: !0 }), img: new me({ isVoid: !0 }), input: new me({ isVoid: !0 }), param: new me({ isVoid: !0 }), hr: new me({ isVoid: !0 }), br: new me({ isVoid: !0 }), source: new me({ isVoid: !0 }), track: new me({ isVoid: !0 }), wbr: new me({ isVoid: !0 }), p: new me({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: !0 }), thead: new me({ closedByChildren: ["tbody", "tfoot"] }), tbody: new me({ closedByChildren: ["tbody", "tfoot"], closedByParent: !0 }), tfoot: new me({ closedByChildren: ["tbody"], closedByParent: !0 }), tr: new me({ closedByChildren: ["tr"], closedByParent: !0 }), td: new me({ closedByChildren: ["td", "th"], closedByParent: !0 }), th: new me({ closedByChildren: ["td", "th"], closedByParent: !0 }), col: new me({ isVoid: !0 }), svg: new me({ implicitNamespacePrefix: "svg" }), foreignObject: new me({ implicitNamespacePrefix: "svg", preventNamespaceInheritance: !0 }), math: new me({ implicitNamespacePrefix: "math" }), li: new me({ closedByChildren: ["li"], closedByParent: !0 }), dt: new me({ closedByChildren: ["dt", "dd"] }), dd: new me({ closedByChildren: ["dt", "dd"], closedByParent: !0 }), rb: new me({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), rt: new me({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), rtc: new me({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: !0 }), rp: new me({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), optgroup: new me({ closedByChildren: ["optgroup"], closedByParent: !0 }), option: new me({ closedByChildren: ["option", "optgroup"], closedByParent: !0 }), pre: new me({ ignoreFirstLf: !0 }), listing: new me({ ignoreFirstLf: !0 }), style: new me({ contentType: Ir.RAW_TEXT }), script: new me({ contentType: Ir.RAW_TEXT }), title: new me({ contentType: { default: Ir.ESCAPABLE_RAW_TEXT, svg: Ir.PARSABLE_DATA } }), textarea: new me({ contentType: Ir.ESCAPABLE_RAW_TEXT, ignoreFirstLf: !0 }) }), new AN().allKnownElementNames().forEach((r) => {
    !Ja[r] && Qu(r) === null && (Ja[r] = new me({ canSelfClose: !1 }));
  })), (e = Ja[t]) != null ? e : O0;
}
var Ia = class {
  constructor(e, r) {
    this.sourceSpan = e, this.i18n = r;
  }
}, EN = class extends Ia {
  constructor(e, r, s, i) {
    super(r, i), this.value = e, this.tokens = s, this.type = "text";
  }
  visit(e, r) {
    return e.visitText(this, r);
  }
}, TN = class extends Ia {
  constructor(t, e, r, s) {
    super(e, s), this.value = t, this.tokens = r, this.type = "cdata";
  }
  visit(t, e) {
    return t.visitCdata(this, e);
  }
}, kN = class extends Ia {
  constructor(e, r, s, i, n, a) {
    super(i, a), this.switchValue = e, this.type = r, this.cases = s, this.switchValueSourceSpan = n;
  }
  visit(e, r) {
    return e.visitExpansion(this, r);
  }
}, PN = class {
  constructor(e, r, s, i, n) {
    this.value = e, this.expression = r, this.sourceSpan = s, this.valueSourceSpan = i, this.expSourceSpan = n, this.type = "expansionCase";
  }
  visit(e, r) {
    return e.visitExpansionCase(this, r);
  }
}, FN = class extends Ia {
  constructor(e, r, s, i, n, a, l) {
    super(s, l), this.name = e, this.value = r, this.keySpan = i, this.valueSpan = n, this.valueTokens = a, this.type = "attribute";
  }
  visit(e, r) {
    return e.visitAttribute(this, r);
  }
  get nameSpan() {
    return this.keySpan;
  }
}, li = class extends Ia {
  constructor(e, r, s, i, n, a = null, l = null, c) {
    super(i, c), this.name = e, this.attrs = r, this.children = s, this.startSourceSpan = n, this.endSourceSpan = a, this.nameSpan = l, this.type = "element";
  }
  visit(e, r) {
    return e.visitElement(this, r);
  }
}, $N = class {
  constructor(e, r) {
    this.value = e, this.sourceSpan = r, this.type = "comment";
  }
  visit(e, r) {
    return e.visitComment(this, r);
  }
}, QN = class {
  constructor(e, r) {
    this.value = e, this.sourceSpan = r, this.type = "docType";
  }
  visit(e, r) {
    return e.visitDocType(this, r);
  }
}, Qn = class extends Ia {
  constructor(e, r, s, i, n, a, l = null, c) {
    super(i, c), this.name = e, this.parameters = r, this.children = s, this.nameSpan = n, this.startSourceSpan = a, this.endSourceSpan = l, this.type = "block";
  }
  visit(e, r) {
    return e.visitBlock(this, r);
  }
}, x0 = class {
  constructor(t, e) {
    this.expression = t, this.sourceSpan = e, this.type = "blockParameter", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(t, e) {
    return t.visitBlockParameter(this, e);
  }
}, D0 = class {
  constructor(e, r, s, i, n) {
    this.name = e, this.value = r, this.sourceSpan = s, this.nameSpan = i, this.valueSpan = n, this.type = "letDeclaration", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e, r) {
    return e.visitLetDeclaration(this, r);
  }
};
function yS(t, e, r = null) {
  let s = [], i = t.visit ? (n) => t.visit(n, r) || n.visit(t, r) : (n) => n.visit(t, r);
  return e.forEach((n) => {
    let a = i(n);
    a && s.push(a);
  }), s;
}
var BN = class {
  constructor() {
  }
  visitElement(e, r) {
    this.visitChildren(r, (s) => {
      s(e.attrs), s(e.children);
    });
  }
  visitAttribute(e, r) {
  }
  visitText(e, r) {
  }
  visitCdata(e, r) {
  }
  visitComment(e, r) {
  }
  visitDocType(e, r) {
  }
  visitExpansion(e, r) {
    return this.visitChildren(r, (s) => {
      s(e.cases);
    });
  }
  visitExpansionCase(e, r) {
  }
  visitBlock(e, r) {
    this.visitChildren(r, (s) => {
      s(e.parameters), s(e.children);
    });
  }
  visitBlockParameter(e, r) {
  }
  visitLetDeclaration(e, r) {
  }
  visitChildren(e, r) {
    let s = [], i = this;
    function n(a) {
      a && s.push(yS(i, a, e));
    }
    return r(n), Array.prototype.concat.apply([], s);
  }
}, uc = { AElig: "", AMP: "&", amp: "&", Aacute: "", Abreve: "", Acirc: "", Acy: "", Afr: "", Agrave: "", Alpha: "", Amacr: "", And: "", Aogon: "", Aopf: "", ApplyFunction: "", af: "", Aring: "", angst: "", Ascr: "", Assign: "", colone: "", coloneq: "", Atilde: "", Auml: "", Backslash: "", setminus: "", setmn: "", smallsetminus: "", ssetmn: "", Barv: "", Barwed: "", doublebarwedge: "", Bcy: "", Because: "", becaus: "", because: "", Bernoullis: "", Bscr: "", bernou: "", Beta: "", Bfr: "", Bopf: "", Breve: "", breve: "", Bumpeq: "", HumpDownHump: "", bump: "", CHcy: "", COPY: "", copy: "", Cacute: "", Cap: "", CapitalDifferentialD: "", DD: "", Cayleys: "", Cfr: "", Ccaron: "", Ccedil: "", Ccirc: "", Cconint: "", Cdot: "", Cedilla: "", cedil: "", CenterDot: "", centerdot: "", middot: "", Chi: "", CircleDot: "", odot: "", CircleMinus: "", ominus: "", CirclePlus: "", oplus: "", CircleTimes: "", otimes: "", ClockwiseContourIntegral: "", cwconint: "", CloseCurlyDoubleQuote: "", rdquo: "", rdquor: "", CloseCurlyQuote: "", rsquo: "", rsquor: "", Colon: "", Proportion: "", Colone: "", Congruent: "", equiv: "", Conint: "", DoubleContourIntegral: "", ContourIntegral: "", conint: "", oint: "", Copf: "", complexes: "", Coproduct: "", coprod: "", CounterClockwiseContourIntegral: "", awconint: "", Cross: "", Cscr: "", Cup: "", CupCap: "", asympeq: "", DDotrahd: "", DJcy: "", DScy: "", DZcy: "", Dagger: "", ddagger: "", Darr: "", Dashv: "", DoubleLeftTee: "", Dcaron: "", Dcy: "", Del: "", nabla: "", Delta: "", Dfr: "", DiacriticalAcute: "", acute: "", DiacriticalDot: "", dot: "", DiacriticalDoubleAcute: "", dblac: "", DiacriticalGrave: "`", grave: "`", DiacriticalTilde: "", tilde: "", Diamond: "", diam: "", diamond: "", DifferentialD: "", dd: "", Dopf: "", Dot: "", DoubleDot: "", die: "", uml: "", DotDot: "", DotEqual: "", doteq: "", esdot: "", DoubleDownArrow: "", Downarrow: "", dArr: "", DoubleLeftArrow: "", Leftarrow: "", lArr: "", DoubleLeftRightArrow: "", Leftrightarrow: "", hArr: "", iff: "", DoubleLongLeftArrow: "", Longleftarrow: "", xlArr: "", DoubleLongLeftRightArrow: "", Longleftrightarrow: "", xhArr: "", DoubleLongRightArrow: "", Longrightarrow: "", xrArr: "", DoubleRightArrow: "", Implies: "", Rightarrow: "", rArr: "", DoubleRightTee: "", vDash: "", DoubleUpArrow: "", Uparrow: "", uArr: "", DoubleUpDownArrow: "", Updownarrow: "", vArr: "", DoubleVerticalBar: "", par: "", parallel: "", shortparallel: "", spar: "", DownArrow: "", ShortDownArrow: "", darr: "", downarrow: "", DownArrowBar: "", DownArrowUpArrow: "", duarr: "", DownBreve: "", DownLeftRightVector: "", DownLeftTeeVector: "", DownLeftVector: "", leftharpoondown: "", lhard: "", DownLeftVectorBar: "", DownRightTeeVector: "", DownRightVector: "", rhard: "", rightharpoondown: "", DownRightVectorBar: "", DownTee: "", top: "", DownTeeArrow: "", mapstodown: "", Dscr: "", Dstrok: "", ENG: "", ETH: "", Eacute: "", Ecaron: "", Ecirc: "", Ecy: "", Edot: "", Efr: "", Egrave: "", Element: "", in: "", isin: "", isinv: "", Emacr: "", EmptySmallSquare: "", EmptyVerySmallSquare: "", Eogon: "", Eopf: "", Epsilon: "", Equal: "", EqualTilde: "", eqsim: "", esim: "", Equilibrium: "", rightleftharpoons: "", rlhar: "", Escr: "", expectation: "", Esim: "", Eta: "", Euml: "", Exists: "", exist: "", ExponentialE: "", ee: "", exponentiale: "", Fcy: "", Ffr: "", FilledSmallSquare: "", FilledVerySmallSquare: "", blacksquare: "", squarf: "", squf: "", Fopf: "", ForAll: "", forall: "", Fouriertrf: "", Fscr: "", GJcy: "", GT: ">", gt: ">", Gamma: "", Gammad: "", Gbreve: "", Gcedil: "", Gcirc: "", Gcy: "", Gdot: "", Gfr: "", Gg: "", ggg: "", Gopf: "", GreaterEqual: "", ge: "", geq: "", GreaterEqualLess: "", gel: "", gtreqless: "", GreaterFullEqual: "", gE: "", geqq: "", GreaterGreater: "", GreaterLess: "", gl: "", gtrless: "", GreaterSlantEqual: "", geqslant: "", ges: "", GreaterTilde: "", gsim: "", gtrsim: "", Gscr: "", Gt: "", NestedGreaterGreater: "", gg: "", HARDcy: "", Hacek: "", caron: "", Hat: "^", Hcirc: "", Hfr: "", Poincareplane: "", HilbertSpace: "", Hscr: "", hamilt: "", Hopf: "", quaternions: "", HorizontalLine: "", boxh: "", Hstrok: "", HumpEqual: "", bumpe: "", bumpeq: "", IEcy: "", IJlig: "", IOcy: "", Iacute: "", Icirc: "", Icy: "", Idot: "", Ifr: "", Im: "", image: "", imagpart: "", Igrave: "", Imacr: "", ImaginaryI: "", ii: "", Int: "", Integral: "", int: "", Intersection: "", bigcap: "", xcap: "", InvisibleComma: "", ic: "", InvisibleTimes: "", it: "", Iogon: "", Iopf: "", Iota: "", Iscr: "", imagline: "", Itilde: "", Iukcy: "", Iuml: "", Jcirc: "", Jcy: "", Jfr: "", Jopf: "", Jscr: "", Jsercy: "", Jukcy: "", KHcy: "", KJcy: "", Kappa: "", Kcedil: "", Kcy: "", Kfr: "", Kopf: "", Kscr: "", LJcy: "", LT: "<", lt: "<", Lacute: "", Lambda: "", Lang: "", Laplacetrf: "", Lscr: "", lagran: "", Larr: "", twoheadleftarrow: "", Lcaron: "", Lcedil: "", Lcy: "", LeftAngleBracket: "", lang: "", langle: "", LeftArrow: "", ShortLeftArrow: "", larr: "", leftarrow: "", slarr: "", LeftArrowBar: "", larrb: "", LeftArrowRightArrow: "", leftrightarrows: "", lrarr: "", LeftCeiling: "", lceil: "", LeftDoubleBracket: "", lobrk: "", LeftDownTeeVector: "", LeftDownVector: "", dharl: "", downharpoonleft: "", LeftDownVectorBar: "", LeftFloor: "", lfloor: "", LeftRightArrow: "", harr: "", leftrightarrow: "", LeftRightVector: "", LeftTee: "", dashv: "", LeftTeeArrow: "", mapstoleft: "", LeftTeeVector: "", LeftTriangle: "", vartriangleleft: "", vltri: "", LeftTriangleBar: "", LeftTriangleEqual: "", ltrie: "", trianglelefteq: "", LeftUpDownVector: "", LeftUpTeeVector: "", LeftUpVector: "", uharl: "", upharpoonleft: "", LeftUpVectorBar: "", LeftVector: "", leftharpoonup: "", lharu: "", LeftVectorBar: "", LessEqualGreater: "", leg: "", lesseqgtr: "", LessFullEqual: "", lE: "", leqq: "", LessGreater: "", lessgtr: "", lg: "", LessLess: "", LessSlantEqual: "", leqslant: "", les: "", LessTilde: "", lesssim: "", lsim: "", Lfr: "", Ll: "", Lleftarrow: "", lAarr: "", Lmidot: "", LongLeftArrow: "", longleftarrow: "", xlarr: "", LongLeftRightArrow: "", longleftrightarrow: "", xharr: "", LongRightArrow: "", longrightarrow: "", xrarr: "", Lopf: "", LowerLeftArrow: "", swarr: "", swarrow: "", LowerRightArrow: "", searr: "", searrow: "", Lsh: "", lsh: "", Lstrok: "", Lt: "", NestedLessLess: "", ll: "", Map: "", Mcy: "", MediumSpace: "", Mellintrf: "", Mscr: "", phmmat: "", Mfr: "", MinusPlus: "", mnplus: "", mp: "", Mopf: "", Mu: "", NJcy: "", Nacute: "", Ncaron: "", Ncedil: "", Ncy: "", NegativeMediumSpace: "", NegativeThickSpace: "", NegativeThinSpace: "", NegativeVeryThinSpace: "", ZeroWidthSpace: "", NewLine: `
`, Nfr: "", NoBreak: "", NonBreakingSpace: "", nbsp: "", Nopf: "", naturals: "", Not: "", NotCongruent: "", nequiv: "", NotCupCap: "", NotDoubleVerticalBar: "", npar: "", nparallel: "", nshortparallel: "", nspar: "", NotElement: "", notin: "", notinva: "", NotEqual: "", ne: "", NotEqualTilde: "", nesim: "", NotExists: "", nexist: "", nexists: "", NotGreater: "", ngt: "", ngtr: "", NotGreaterEqual: "", nge: "", ngeq: "", NotGreaterFullEqual: "", ngE: "", ngeqq: "", NotGreaterGreater: "", nGtv: "", NotGreaterLess: "", ntgl: "", NotGreaterSlantEqual: "", ngeqslant: "", nges: "", NotGreaterTilde: "", ngsim: "", NotHumpDownHump: "", nbump: "", NotHumpEqual: "", nbumpe: "", NotLeftTriangle: "", nltri: "", ntriangleleft: "", NotLeftTriangleBar: "", NotLeftTriangleEqual: "", nltrie: "", ntrianglelefteq: "", NotLess: "", nless: "", nlt: "", NotLessEqual: "", nle: "", nleq: "", NotLessGreater: "", ntlg: "", NotLessLess: "", nLtv: "", NotLessSlantEqual: "", nleqslant: "", nles: "", NotLessTilde: "", nlsim: "", NotNestedGreaterGreater: "", NotNestedLessLess: "", NotPrecedes: "", npr: "", nprec: "", NotPrecedesEqual: "", npre: "", npreceq: "", NotPrecedesSlantEqual: "", nprcue: "", NotReverseElement: "", notni: "", notniva: "", NotRightTriangle: "", nrtri: "", ntriangleright: "", NotRightTriangleBar: "", NotRightTriangleEqual: "", nrtrie: "", ntrianglerighteq: "", NotSquareSubset: "", NotSquareSubsetEqual: "", nsqsube: "", NotSquareSuperset: "", NotSquareSupersetEqual: "", nsqsupe: "", NotSubset: "", nsubset: "", vnsub: "", NotSubsetEqual: "", nsube: "", nsubseteq: "", NotSucceeds: "", nsc: "", nsucc: "", NotSucceedsEqual: "", nsce: "", nsucceq: "", NotSucceedsSlantEqual: "", nsccue: "", NotSucceedsTilde: "", NotSuperset: "", nsupset: "", vnsup: "", NotSupersetEqual: "", nsupe: "", nsupseteq: "", NotTilde: "", nsim: "", NotTildeEqual: "", nsime: "", nsimeq: "", NotTildeFullEqual: "", ncong: "", NotTildeTilde: "", nap: "", napprox: "", NotVerticalBar: "", nmid: "", nshortmid: "", nsmid: "", Nscr: "", Ntilde: "", Nu: "", OElig: "", Oacute: "", Ocirc: "", Ocy: "", Odblac: "", Ofr: "", Ograve: "", Omacr: "", Omega: "", ohm: "", Omicron: "", Oopf: "", OpenCurlyDoubleQuote: "", ldquo: "", OpenCurlyQuote: "", lsquo: "", Or: "", Oscr: "", Oslash: "", Otilde: "", Otimes: "", Ouml: "", OverBar: "", oline: "", OverBrace: "", OverBracket: "", tbrk: "", OverParenthesis: "", PartialD: "", part: "", Pcy: "", Pfr: "", Phi: "", Pi: "", PlusMinus: "", plusmn: "", pm: "", Popf: "", primes: "", Pr: "", Precedes: "", pr: "", prec: "", PrecedesEqual: "", pre: "", preceq: "", PrecedesSlantEqual: "", prcue: "", preccurlyeq: "", PrecedesTilde: "", precsim: "", prsim: "", Prime: "", Product: "", prod: "", Proportional: "", prop: "", propto: "", varpropto: "", vprop: "", Pscr: "", Psi: "", QUOT: '"', quot: '"', Qfr: "", Qopf: "", rationals: "", Qscr: "", RBarr: "", drbkarow: "", REG: "", circledR: "", reg: "", Racute: "", Rang: "", Rarr: "", twoheadrightarrow: "", Rarrtl: "", Rcaron: "", Rcedil: "", Rcy: "", Re: "", Rfr: "", real: "", realpart: "", ReverseElement: "", SuchThat: "", ni: "", niv: "", ReverseEquilibrium: "", leftrightharpoons: "", lrhar: "", ReverseUpEquilibrium: "", duhar: "", Rho: "", RightAngleBracket: "", rang: "", rangle: "", RightArrow: "", ShortRightArrow: "", rarr: "", rightarrow: "", srarr: "", RightArrowBar: "", rarrb: "", RightArrowLeftArrow: "", rightleftarrows: "", rlarr: "", RightCeiling: "", rceil: "", RightDoubleBracket: "", robrk: "", RightDownTeeVector: "", RightDownVector: "", dharr: "", downharpoonright: "", RightDownVectorBar: "", RightFloor: "", rfloor: "", RightTee: "", vdash: "", RightTeeArrow: "", map: "", mapsto: "", RightTeeVector: "", RightTriangle: "", vartriangleright: "", vrtri: "", RightTriangleBar: "", RightTriangleEqual: "", rtrie: "", trianglerighteq: "", RightUpDownVector: "", RightUpTeeVector: "", RightUpVector: "", uharr: "", upharpoonright: "", RightUpVectorBar: "", RightVector: "", rharu: "", rightharpoonup: "", RightVectorBar: "", Ropf: "", reals: "", RoundImplies: "", Rrightarrow: "", rAarr: "", Rscr: "", realine: "", Rsh: "", rsh: "", RuleDelayed: "", SHCHcy: "", SHcy: "", SOFTcy: "", Sacute: "", Sc: "", Scaron: "", Scedil: "", Scirc: "", Scy: "", Sfr: "", ShortUpArrow: "", UpArrow: "", uarr: "", uparrow: "", Sigma: "", SmallCircle: "", compfn: "", Sopf: "", Sqrt: "", radic: "", Square: "", squ: "", square: "", SquareIntersection: "", sqcap: "", SquareSubset: "", sqsub: "", sqsubset: "", SquareSubsetEqual: "", sqsube: "", sqsubseteq: "", SquareSuperset: "", sqsup: "", sqsupset: "", SquareSupersetEqual: "", sqsupe: "", sqsupseteq: "", SquareUnion: "", sqcup: "", Sscr: "", Star: "", sstarf: "", Sub: "", Subset: "", SubsetEqual: "", sube: "", subseteq: "", Succeeds: "", sc: "", succ: "", SucceedsEqual: "", sce: "", succeq: "", SucceedsSlantEqual: "", sccue: "", succcurlyeq: "", SucceedsTilde: "", scsim: "", succsim: "", Sum: "", sum: "", Sup: "", Supset: "", Superset: "", sup: "", supset: "", SupersetEqual: "", supe: "", supseteq: "", THORN: "", TRADE: "", trade: "", TSHcy: "", TScy: "", Tab: "	", Tau: "", Tcaron: "", Tcedil: "", Tcy: "", Tfr: "", Therefore: "", there4: "", therefore: "", Theta: "", ThickSpace: "", ThinSpace: "", thinsp: "", Tilde: "", sim: "", thicksim: "", thksim: "", TildeEqual: "", sime: "", simeq: "", TildeFullEqual: "", cong: "", TildeTilde: "", ap: "", approx: "", asymp: "", thickapprox: "", thkap: "", Topf: "", TripleDot: "", tdot: "", Tscr: "", Tstrok: "", Uacute: "", Uarr: "", Uarrocir: "", Ubrcy: "", Ubreve: "", Ucirc: "", Ucy: "", Udblac: "", Ufr: "", Ugrave: "", Umacr: "", UnderBar: "_", lowbar: "_", UnderBrace: "", UnderBracket: "", bbrk: "", UnderParenthesis: "", Union: "", bigcup: "", xcup: "", UnionPlus: "", uplus: "", Uogon: "", Uopf: "", UpArrowBar: "", UpArrowDownArrow: "", udarr: "", UpDownArrow: "", updownarrow: "", varr: "", UpEquilibrium: "", udhar: "", UpTee: "", bot: "", bottom: "", perp: "", UpTeeArrow: "", mapstoup: "", UpperLeftArrow: "", nwarr: "", nwarrow: "", UpperRightArrow: "", nearr: "", nearrow: "", Upsi: "", upsih: "", Upsilon: "", Uring: "", Uscr: "", Utilde: "", Uuml: "", VDash: "", Vbar: "", Vcy: "", Vdash: "", Vdashl: "", Vee: "", bigvee: "", xvee: "", Verbar: "", Vert: "", VerticalBar: "", mid: "", shortmid: "", smid: "", VerticalLine: "|", verbar: "|", vert: "|", VerticalSeparator: "", VerticalTilde: "", wr: "", wreath: "", VeryThinSpace: "", hairsp: "", Vfr: "", Vopf: "", Vscr: "", Vvdash: "", Wcirc: "", Wedge: "", bigwedge: "", xwedge: "", Wfr: "", Wopf: "", Wscr: "", Xfr: "", Xi: "", Xopf: "", Xscr: "", YAcy: "", YIcy: "", YUcy: "", Yacute: "", Ycirc: "", Ycy: "", Yfr: "", Yopf: "", Yscr: "", Yuml: "", ZHcy: "", Zacute: "", Zcaron: "", Zcy: "", Zdot: "", Zeta: "", Zfr: "", zeetrf: "", Zopf: "", integers: "", Zscr: "", aacute: "", abreve: "", ac: "", mstpos: "", acE: "", acd: "", acirc: "", acy: "", aelig: "", afr: "", agrave: "", alefsym: "", aleph: "", alpha: "", amacr: "", amalg: "", and: "", wedge: "", andand: "", andd: "", andslope: "", andv: "", ang: "", angle: "", ange: "", angmsd: "", measuredangle: "", angmsdaa: "", angmsdab: "", angmsdac: "", angmsdad: "", angmsdae: "", angmsdaf: "", angmsdag: "", angmsdah: "", angrt: "", angrtvb: "", angrtvbd: "", angsph: "", angzarr: "", aogon: "", aopf: "", apE: "", apacir: "", ape: "", approxeq: "", apid: "", apos: "'", aring: "", ascr: "", ast: "*", midast: "*", atilde: "", auml: "", awint: "", bNot: "", backcong: "", bcong: "", backepsilon: "", bepsi: "", backprime: "", bprime: "", backsim: "", bsim: "", backsimeq: "", bsime: "", barvee: "", barwed: "", barwedge: "", bbrktbrk: "", bcy: "", bdquo: "", ldquor: "", bemptyv: "", beta: "", beth: "", between: "", twixt: "", bfr: "", bigcirc: "", xcirc: "", bigodot: "", xodot: "", bigoplus: "", xoplus: "", bigotimes: "", xotime: "", bigsqcup: "", xsqcup: "", bigstar: "", starf: "", bigtriangledown: "", xdtri: "", bigtriangleup: "", xutri: "", biguplus: "", xuplus: "", bkarow: "", rbarr: "", blacklozenge: "", lozf: "", blacktriangle: "", utrif: "", blacktriangledown: "", dtrif: "", blacktriangleleft: "", ltrif: "", blacktriangleright: "", rtrif: "", blank: "", blk12: "", blk14: "", blk34: "", block: "", bne: "=", bnequiv: "", bnot: "", bopf: "", bowtie: "", boxDL: "", boxDR: "", boxDl: "", boxDr: "", boxH: "", boxHD: "", boxHU: "", boxHd: "", boxHu: "", boxUL: "", boxUR: "", boxUl: "", boxUr: "", boxV: "", boxVH: "", boxVL: "", boxVR: "", boxVh: "", boxVl: "", boxVr: "", boxbox: "", boxdL: "", boxdR: "", boxdl: "", boxdr: "", boxhD: "", boxhU: "", boxhd: "", boxhu: "", boxminus: "", minusb: "", boxplus: "", plusb: "", boxtimes: "", timesb: "", boxuL: "", boxuR: "", boxul: "", boxur: "", boxv: "", boxvH: "", boxvL: "", boxvR: "", boxvh: "", boxvl: "", boxvr: "", brvbar: "", bscr: "", bsemi: "", bsol: "\\", bsolb: "", bsolhsub: "", bull: "", bullet: "", bumpE: "", cacute: "", cap: "", capand: "", capbrcup: "", capcap: "", capcup: "", capdot: "", caps: "", caret: "", ccaps: "", ccaron: "", ccedil: "", ccirc: "", ccups: "", ccupssm: "", cdot: "", cemptyv: "", cent: "", cfr: "", chcy: "", check: "", checkmark: "", chi: "", cir: "", cirE: "", circ: "", circeq: "", cire: "", circlearrowleft: "", olarr: "", circlearrowright: "", orarr: "", circledS: "", oS: "", circledast: "", oast: "", circledcirc: "", ocir: "", circleddash: "", odash: "", cirfnint: "", cirmid: "", cirscir: "", clubs: "", clubsuit: "", colon: ":", comma: ",", commat: "@", comp: "", complement: "", congdot: "", copf: "", copysr: "", crarr: "", cross: "", cscr: "", csub: "", csube: "", csup: "", csupe: "", ctdot: "", cudarrl: "", cudarrr: "", cuepr: "", curlyeqprec: "", cuesc: "", curlyeqsucc: "", cularr: "", curvearrowleft: "", cularrp: "", cup: "", cupbrcap: "", cupcap: "", cupcup: "", cupdot: "", cupor: "", cups: "", curarr: "", curvearrowright: "", curarrm: "", curlyvee: "", cuvee: "", curlywedge: "", cuwed: "", curren: "", cwint: "", cylcty: "", dHar: "", dagger: "", daleth: "", dash: "", hyphen: "", dbkarow: "", rBarr: "", dcaron: "", dcy: "", ddarr: "", downdownarrows: "", ddotseq: "", eDDot: "", deg: "", delta: "", demptyv: "", dfisht: "", dfr: "", diamondsuit: "", diams: "", digamma: "", gammad: "", disin: "", div: "", divide: "", divideontimes: "", divonx: "", djcy: "", dlcorn: "", llcorner: "", dlcrop: "", dollar: "$", dopf: "", doteqdot: "", eDot: "", dotminus: "", minusd: "", dotplus: "", plusdo: "", dotsquare: "", sdotb: "", drcorn: "", lrcorner: "", drcrop: "", dscr: "", dscy: "", dsol: "", dstrok: "", dtdot: "", dtri: "", triangledown: "", dwangle: "", dzcy: "", dzigrarr: "", eacute: "", easter: "", ecaron: "", ecir: "", eqcirc: "", ecirc: "", ecolon: "", eqcolon: "", ecy: "", edot: "", efDot: "", fallingdotseq: "", efr: "", eg: "", egrave: "", egs: "", eqslantgtr: "", egsdot: "", el: "", elinters: "", ell: "", els: "", eqslantless: "", elsdot: "", emacr: "", empty: "", emptyset: "", emptyv: "", varnothing: "", emsp13: "", emsp14: "", emsp: "", eng: "", ensp: "", eogon: "", eopf: "", epar: "", eparsl: "", eplus: "", epsi: "", epsilon: "", epsiv: "", straightepsilon: "", varepsilon: "", equals: "=", equest: "", questeq: "", equivDD: "", eqvparsl: "", erDot: "", risingdotseq: "", erarr: "", escr: "", eta: "", eth: "", euml: "", euro: "", excl: "!", fcy: "", female: "", ffilig: "", fflig: "", ffllig: "", ffr: "", filig: "", fjlig: "fj", flat: "", fllig: "", fltns: "", fnof: "", fopf: "", fork: "", pitchfork: "", forkv: "", fpartint: "", frac12: "", half: "", frac13: "", frac14: "", frac15: "", frac16: "", frac18: "", frac23: "", frac25: "", frac34: "", frac35: "", frac38: "", frac45: "", frac56: "", frac58: "", frac78: "", frasl: "", frown: "", sfrown: "", fscr: "", gEl: "", gtreqqless: "", gacute: "", gamma: "", gap: "", gtrapprox: "", gbreve: "", gcirc: "", gcy: "", gdot: "", gescc: "", gesdot: "", gesdoto: "", gesdotol: "", gesl: "", gesles: "", gfr: "", gimel: "", gjcy: "", glE: "", gla: "", glj: "", gnE: "", gneqq: "", gnap: "", gnapprox: "", gne: "", gneq: "", gnsim: "", gopf: "", gscr: "", gsime: "", gsiml: "", gtcc: "", gtcir: "", gtdot: "", gtrdot: "", gtlPar: "", gtquest: "", gtrarr: "", gvertneqq: "", gvnE: "", hardcy: "", harrcir: "", harrw: "", leftrightsquigarrow: "", hbar: "", hslash: "", planck: "", plankv: "", hcirc: "", hearts: "", heartsuit: "", hellip: "", mldr: "", hercon: "", hfr: "", hksearow: "", searhk: "", hkswarow: "", swarhk: "", hoarr: "", homtht: "", hookleftarrow: "", larrhk: "", hookrightarrow: "", rarrhk: "", hopf: "", horbar: "", hscr: "", hstrok: "", hybull: "", iacute: "", icirc: "", icy: "", iecy: "", iexcl: "", ifr: "", igrave: "", iiiint: "", qint: "", iiint: "", tint: "", iinfin: "", iiota: "", ijlig: "", imacr: "", imath: "", inodot: "", imof: "", imped: "", incare: "", infin: "", infintie: "", intcal: "", intercal: "", intlarhk: "", intprod: "", iprod: "", iocy: "", iogon: "", iopf: "", iota: "", iquest: "", iscr: "", isinE: "", isindot: "", isins: "", isinsv: "", itilde: "", iukcy: "", iuml: "", jcirc: "", jcy: "", jfr: "", jmath: "", jopf: "", jscr: "", jsercy: "", jukcy: "", kappa: "", kappav: "", varkappa: "", kcedil: "", kcy: "", kfr: "", kgreen: "", khcy: "", kjcy: "", kopf: "", kscr: "", lAtail: "", lBarr: "", lEg: "", lesseqqgtr: "", lHar: "", lacute: "", laemptyv: "", lambda: "", langd: "", lap: "", lessapprox: "", laquo: "", larrbfs: "", larrfs: "", larrlp: "", looparrowleft: "", larrpl: "", larrsim: "", larrtl: "", leftarrowtail: "", lat: "", latail: "", late: "", lates: "", lbarr: "", lbbrk: "", lbrace: "{", lcub: "{", lbrack: "[", lsqb: "[", lbrke: "", lbrksld: "", lbrkslu: "", lcaron: "", lcedil: "", lcy: "", ldca: "", ldrdhar: "", ldrushar: "", ldsh: "", le: "", leq: "", leftleftarrows: "", llarr: "", leftthreetimes: "", lthree: "", lescc: "", lesdot: "", lesdoto: "", lesdotor: "", lesg: "", lesges: "", lessdot: "", ltdot: "", lfisht: "", lfr: "", lgE: "", lharul: "", lhblk: "", ljcy: "", llhard: "", lltri: "", lmidot: "", lmoust: "", lmoustache: "", lnE: "", lneqq: "", lnap: "", lnapprox: "", lne: "", lneq: "", lnsim: "", loang: "", loarr: "", longmapsto: "", xmap: "", looparrowright: "", rarrlp: "", lopar: "", lopf: "", loplus: "", lotimes: "", lowast: "", loz: "", lozenge: "", lpar: "(", lparlt: "", lrhard: "", lrm: "", lrtri: "", lsaquo: "", lscr: "", lsime: "", lsimg: "", lsquor: "", sbquo: "", lstrok: "", ltcc: "", ltcir: "", ltimes: "", ltlarr: "", ltquest: "", ltrPar: "", ltri: "", triangleleft: "", lurdshar: "", luruhar: "", lvertneqq: "", lvnE: "", mDDot: "", macr: "", strns: "", male: "", malt: "", maltese: "", marker: "", mcomma: "", mcy: "", mdash: "", mfr: "", mho: "", micro: "", midcir: "", minus: "", minusdu: "", mlcp: "", models: "", mopf: "", mscr: "", mu: "", multimap: "", mumap: "", nGg: "", nGt: "", nLeftarrow: "", nlArr: "", nLeftrightarrow: "", nhArr: "", nLl: "", nLt: "", nRightarrow: "", nrArr: "", nVDash: "", nVdash: "", nacute: "", nang: "", napE: "", napid: "", napos: "", natur: "", natural: "", ncap: "", ncaron: "", ncedil: "", ncongdot: "", ncup: "", ncy: "", ndash: "", neArr: "", nearhk: "", nedot: "", nesear: "", toea: "", nfr: "", nharr: "", nleftrightarrow: "", nhpar: "", nis: "", nisd: "", njcy: "", nlE: "", nleqq: "", nlarr: "", nleftarrow: "", nldr: "", nopf: "", not: "", notinE: "", notindot: "", notinvb: "", notinvc: "", notnivb: "", notnivc: "", nparsl: "", npart: "", npolint: "", nrarr: "", nrightarrow: "", nrarrc: "", nrarrw: "", nscr: "", nsub: "", nsubE: "", nsubseteqq: "", nsup: "", nsupE: "", nsupseteqq: "", ntilde: "", nu: "", num: "#", numero: "", numsp: "", nvDash: "", nvHarr: "", nvap: "", nvdash: "", nvge: "", nvgt: ">", nvinfin: "", nvlArr: "", nvle: "", nvlt: "<", nvltrie: "", nvrArr: "", nvrtrie: "", nvsim: "", nwArr: "", nwarhk: "", nwnear: "", oacute: "", ocirc: "", ocy: "", odblac: "", odiv: "", odsold: "", oelig: "", ofcir: "", ofr: "", ogon: "", ograve: "", ogt: "", ohbar: "", olcir: "", olcross: "", olt: "", omacr: "", omega: "", omicron: "", omid: "", oopf: "", opar: "", operp: "", or: "", vee: "", ord: "", order: "", orderof: "", oscr: "", ordf: "", ordm: "", origof: "", oror: "", orslope: "", orv: "", oslash: "", osol: "", otilde: "", otimesas: "", ouml: "", ovbar: "", para: "", parsim: "", parsl: "", pcy: "", percnt: "%", period: ".", permil: "", pertenk: "", pfr: "", phi: "", phiv: "", straightphi: "", varphi: "", phone: "", pi: "", piv: "", varpi: "", planckh: "", plus: "+", plusacir: "", pluscir: "", plusdu: "", pluse: "", plussim: "", plustwo: "", pointint: "", popf: "", pound: "", prE: "", prap: "", precapprox: "", precnapprox: "", prnap: "", precneqq: "", prnE: "", precnsim: "", prnsim: "", prime: "", profalar: "", profline: "", profsurf: "", prurel: "", pscr: "", psi: "", puncsp: "", qfr: "", qopf: "", qprime: "", qscr: "", quatint: "", quest: "?", rAtail: "", rHar: "", race: "", racute: "", raemptyv: "", rangd: "", range: "", raquo: "", rarrap: "", rarrbfs: "", rarrc: "", rarrfs: "", rarrpl: "", rarrsim: "", rarrtl: "", rightarrowtail: "", rarrw: "", rightsquigarrow: "", ratail: "", ratio: "", rbbrk: "", rbrace: "}", rcub: "}", rbrack: "]", rsqb: "]", rbrke: "", rbrksld: "", rbrkslu: "", rcaron: "", rcedil: "", rcy: "", rdca: "", rdldhar: "", rdsh: "", rect: "", rfisht: "", rfr: "", rharul: "", rho: "", rhov: "", varrho: "", rightrightarrows: "", rrarr: "", rightthreetimes: "", rthree: "", ring: "", rlm: "", rmoust: "", rmoustache: "", rnmid: "", roang: "", roarr: "", ropar: "", ropf: "", roplus: "", rotimes: "", rpar: ")", rpargt: "", rppolint: "", rsaquo: "", rscr: "", rtimes: "", rtri: "", triangleright: "", rtriltri: "", ruluhar: "", rx: "", sacute: "", scE: "", scap: "", succapprox: "", scaron: "", scedil: "", scirc: "", scnE: "", succneqq: "", scnap: "", succnapprox: "", scnsim: "", succnsim: "", scpolint: "", scy: "", sdot: "", sdote: "", seArr: "", sect: "", semi: ";", seswar: "", tosa: "", sext: "", sfr: "", sharp: "", shchcy: "", shcy: "", shy: "", sigma: "", sigmaf: "", sigmav: "", varsigma: "", simdot: "", simg: "", simgE: "", siml: "", simlE: "", simne: "", simplus: "", simrarr: "", smashp: "", smeparsl: "", smile: "", ssmile: "", smt: "", smte: "", smtes: "", softcy: "", sol: "/", solb: "", solbar: "", sopf: "", spades: "", spadesuit: "", sqcaps: "", sqcups: "", sscr: "", star: "", sub: "", subset: "", subE: "", subseteqq: "", subdot: "", subedot: "", submult: "", subnE: "", subsetneqq: "", subne: "", subsetneq: "", subplus: "", subrarr: "", subsim: "", subsub: "", subsup: "", sung: "", sup1: "", sup2: "", sup3: "", supE: "", supseteqq: "", supdot: "", supdsub: "", supedot: "", suphsol: "", suphsub: "", suplarr: "", supmult: "", supnE: "", supsetneqq: "", supne: "", supsetneq: "", supplus: "", supsim: "", supsub: "", supsup: "", swArr: "", swnwar: "", szlig: "", target: "", tau: "", tcaron: "", tcedil: "", tcy: "", telrec: "", tfr: "", theta: "", thetasym: "", thetav: "", vartheta: "", thorn: "", times: "", timesbar: "", timesd: "", topbot: "", topcir: "", topf: "", topfork: "", tprime: "", triangle: "", utri: "", triangleq: "", trie: "", tridot: "", triminus: "", triplus: "", trisb: "", tritime: "", trpezium: "", tscr: "", tscy: "", tshcy: "", tstrok: "", uHar: "", uacute: "", ubrcy: "", ubreve: "", ucirc: "", ucy: "", udblac: "", ufisht: "", ufr: "", ugrave: "", uhblk: "", ulcorn: "", ulcorner: "", ulcrop: "", ultri: "", umacr: "", uogon: "", uopf: "", upsi: "", upsilon: "", upuparrows: "", uuarr: "", urcorn: "", urcorner: "", urcrop: "", uring: "", urtri: "", uscr: "", utdot: "", utilde: "", uuml: "", uwangle: "", vBar: "", vBarv: "", vangrt: "", varsubsetneq: "", vsubne: "", varsubsetneqq: "", vsubnE: "", varsupsetneq: "", vsupne: "", varsupsetneqq: "", vsupnE: "", vcy: "", veebar: "", veeeq: "", vellip: "", vfr: "", vopf: "", vscr: "", vzigzag: "", wcirc: "", wedbar: "", wedgeq: "", weierp: "", wp: "", wfr: "", wopf: "", wscr: "", xfr: "", xi: "", xnis: "", xopf: "", xscr: "", yacute: "", yacy: "", ycirc: "", ycy: "", yen: "", yfr: "", yicy: "", yopf: "", yscr: "", yucy: "", yuml: "", zacute: "", zcaron: "", zcy: "", zdot: "", zeta: "", zfr: "", zhcy: "", zigrarr: "", zopf: "", zscr: "", zwj: "", zwnj: "" }, IN = "";
uc.ngsp = IN;
var NN = [/@/, /^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
function MN(t, e) {
  if (e != null && !(Array.isArray(e) && e.length == 2)) throw new Error(`Expected '${t}' to be an array, [start, end].`);
  if (e != null) {
    let r = e[0], s = e[1];
    NN.forEach((i) => {
      if (i.test(r) || i.test(s)) throw new Error(`['${r}', '${s}'] contains unusable interpolation symbol.`);
    });
  }
}
var LN = class OS {
  static fromArray(e) {
    return e ? (MN("interpolation", e), new OS(e[0], e[1])) : xS;
  }
  constructor(e, r) {
    this.start = e, this.end = r;
  }
}, xS = new LN("{{", "}}"), gp = class extends fS {
  constructor(e, r, s) {
    super(s, e), this.tokenType = r;
  }
}, _N = class {
  constructor(e, r, s) {
    this.tokens = e, this.errors = r, this.nonNormalizedIcuExpressions = s;
  }
};
function RN(t, e, r, s = {}) {
  let i = new XN(new dS(t, e), r, s);
  return i.tokenize(), new _N(WN(i.tokens), i.errors, i.nonNormalizedIcuExpressions);
}
var qN = /\r\n?/g;
function Bn(t) {
  return `Unexpected character "${t === 0 ? "EOF" : String.fromCharCode(t)}"`;
}
function b0(t) {
  return `Unknown entity "${t}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
}
function jN(t, e) {
  return `Unable to parse entity "${e}" - ${t} character reference entities must end with ";"`;
}
var cc;
(function(t) {
  t.HEX = "hexadecimal", t.DEC = "decimal";
})(cc || (cc = {}));
var yp = class {
  constructor(e) {
    this.error = e;
  }
}, XN = class {
  constructor(e, r, s) {
    var n, a;
    this._getTagContentType = r, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = !1, this._fullNameStack = [], this.tokens = [], this.errors = [], this.nonNormalizedIcuExpressions = [], this._tokenizeIcu = s.tokenizeExpansionForms || !1, this._interpolationConfig = s.interpolationConfig || xS, this._leadingTriviaCodePoints = s.leadingTriviaChars && s.leadingTriviaChars.map((l) => l.codePointAt(0) || 0), this._canSelfClose = s.canSelfClose || !1, this._allowHtmComponentClosingTags = s.allowHtmComponentClosingTags || !1;
    let i = s.range || { endPos: e.content.length, startPos: 0, startLine: 0, startCol: 0 };
    this._cursor = s.escapedString ? new GN(e, i) : new DS(e, i), this._preserveLineEndings = s.preserveLineEndings || !1, this._i18nNormalizeLineEndingsInICUs = s.i18nNormalizeLineEndingsInICUs || !1, this._tokenizeBlocks = (n = s.tokenizeBlocks) != null ? n : !0, this._tokenizeLet = (a = s.tokenizeLet) != null ? a : !0;
    try {
      this._cursor.init();
    } catch (l) {
      this.handleError(l);
    }
  }
  _processCarriageReturns(e) {
    return this._preserveLineEndings ? e : e.replace(qN, `
`);
  }
  tokenize() {
    for (; this._cursor.peek() !== 0; ) {
      let e = this._cursor.clone();
      try {
        if (this._attemptCharCode(60)) if (this._attemptCharCode(33)) this._attemptStr("[CDATA[") ? this._consumeCdata(e) : this._attemptStr("--") ? this._consumeComment(e) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e) : this._consumeBogusComment(e);
        else if (this._attemptCharCode(47)) this._consumeTagClose(e);
        else {
          let r = this._cursor.clone();
          this._attemptCharCode(63) ? (this._cursor = r, this._consumeBogusComment(e)) : this._consumeTagOpen(e);
        }
        else this._tokenizeLet && this._cursor.peek() === 64 && !this._inInterpolation && this._attemptStr("@let") ? this._consumeLetDeclaration(e) : this._tokenizeBlocks && this._attemptCharCode(64) ? this._consumeBlockStart(e) : this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode(125) ? this._consumeBlockEnd(e) : this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());
      } catch (r) {
        this.handleError(r);
      }
    }
    this._beginToken(34), this._endToken([]);
  }
  _getBlockName() {
    let e = !1, r = this._cursor.clone();
    return this._attemptCharCodeUntilFn((s) => nc(s) ? !e : w0(s) ? (e = !0, !1) : !0), this._cursor.getChars(r).trim();
  }
  _consumeBlockStart(e) {
    this._beginToken(25, e);
    let r = this._endToken([this._getBlockName()]);
    if (this._cursor.peek() === 40) if (this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(Ke), this._attemptCharCode(41)) this._attemptCharCodeUntilFn(Ke);
    else {
      r.type = 29;
      return;
    }
    this._attemptCharCode(123) ? (this._beginToken(26), this._endToken([])) : r.type = 29;
  }
  _consumeBlockEnd(e) {
    this._beginToken(27, e), this._endToken([]);
  }
  _consumeBlockParameters() {
    for (this._attemptCharCodeUntilFn(A0); this._cursor.peek() !== 41 && this._cursor.peek() !== 0; ) {
      this._beginToken(28);
      let e = this._cursor.clone(), r = null, s = 0;
      for (; this._cursor.peek() !== 59 && this._cursor.peek() !== 0 || r !== null; ) {
        let i = this._cursor.peek();
        if (i === 92) this._cursor.advance();
        else if (i === r) r = null;
        else if (r === null && mp(i)) r = i;
        else if (i === 40 && r === null) s++;
        else if (i === 41 && r === null) {
          if (s === 0) break;
          s > 0 && s--;
        }
        this._cursor.advance();
      }
      this._endToken([this._cursor.getChars(e)]), this._attemptCharCodeUntilFn(A0);
    }
  }
  _consumeLetDeclaration(e) {
    if (this._beginToken(30, e), nc(this._cursor.peek())) this._attemptCharCodeUntilFn(Ke);
    else {
      let s = this._endToken([this._cursor.getChars(e)]);
      s.type = 33;
      return;
    }
    let r = this._endToken([this._getLetDeclarationName()]);
    if (this._attemptCharCodeUntilFn(Ke), !this._attemptCharCode(61)) {
      r.type = 33;
      return;
    }
    this._attemptCharCodeUntilFn((s) => Ke(s) && !Hm(s)), this._consumeLetDeclarationValue(), this._cursor.peek() === 59 ? (this._beginToken(32), this._endToken([]), this._cursor.advance()) : (r.type = 33, r.sourceSpan = this._cursor.getSpan(e));
  }
  _getLetDeclarationName() {
    let e = this._cursor.clone(), r = !1;
    return this._attemptCharCodeUntilFn((s) => ac(s) || s === 36 || s === 95 || r && Gm(s) ? (r = !0, !1) : !0), this._cursor.getChars(e).trim();
  }
  _consumeLetDeclarationValue() {
    let e = this._cursor.clone();
    for (this._beginToken(31, e); this._cursor.peek() !== 0; ) {
      let r = this._cursor.peek();
      if (r === 59) break;
      mp(r) && (this._cursor.advance(), this._attemptCharCodeUntilFn((s) => s === 92 ? (this._cursor.advance(), !1) : s === r)), this._cursor.advance();
    }
    this._endToken([this._cursor.getChars(e)]);
  }
  _tokenizeExpansionForm() {
    if (this.isExpansionFormStart()) return this._consumeExpansionFormStart(), !0;
    if (UN(this._cursor.peek()) && this._isInExpansionForm()) return this._consumeExpansionCaseStart(), !0;
    if (this._cursor.peek() === 125) {
      if (this._isInExpansionCase()) return this._consumeExpansionCaseEnd(), !0;
      if (this._isInExpansionForm()) return this._consumeExpansionFormEnd(), !0;
    }
    return !1;
  }
  _beginToken(e, r = this._cursor.clone()) {
    this._currentTokenStart = r, this._currentTokenType = e;
  }
  _endToken(e, r) {
    if (this._currentTokenStart === null) throw new gp("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(r));
    if (this._currentTokenType === null) throw new gp("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
    let s = { type: this._currentTokenType, parts: e, sourceSpan: (r != null ? r : this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints) };
    return this.tokens.push(s), this._currentTokenStart = null, this._currentTokenType = null, s;
  }
  _createError(e, r) {
    this._isInExpansionForm() && (e += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
    let s = new gp(e, this._currentTokenType, r);
    return this._currentTokenStart = null, this._currentTokenType = null, new yp(s);
  }
  handleError(e) {
    if (e instanceof Jm && (e = this._createError(e.msg, this._cursor.getSpan(e.cursor))), e instanceof yp) this.errors.push(e.error);
    else throw e;
  }
  _attemptCharCode(e) {
    return this._cursor.peek() === e ? (this._cursor.advance(), !0) : !1;
  }
  _attemptCharCodeCaseInsensitive(e) {
    return YN(this._cursor.peek(), e) ? (this._cursor.advance(), !0) : !1;
  }
  _requireCharCode(e) {
    let r = this._cursor.clone();
    if (!this._attemptCharCode(e)) throw this._createError(Bn(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _attemptStr(e) {
    let r = e.length;
    if (this._cursor.charsLeft() < r) return !1;
    let s = this._cursor.clone();
    for (let i = 0; i < r; i++) if (!this._attemptCharCode(e.charCodeAt(i))) return this._cursor = s, !1;
    return !0;
  }
  _attemptStrCaseInsensitive(e) {
    for (let r = 0; r < e.length; r++) if (!this._attemptCharCodeCaseInsensitive(e.charCodeAt(r))) return !1;
    return !0;
  }
  _requireStr(e) {
    let r = this._cursor.clone();
    if (!this._attemptStr(e)) throw this._createError(Bn(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _requireStrCaseInsensitive(e) {
    let r = this._cursor.clone();
    if (!this._attemptStrCaseInsensitive(e)) throw this._createError(Bn(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _attemptCharCodeUntilFn(e) {
    for (; !e(this._cursor.peek()); ) this._cursor.advance();
  }
  _requireCharCodeUntilFn(e, r) {
    let s = this._cursor.clone();
    if (this._attemptCharCodeUntilFn(e), this._cursor.diff(s) < r) throw this._createError(Bn(this._cursor.peek()), this._cursor.getSpan(s));
  }
  _attemptUntilChar(e) {
    for (; this._cursor.peek() !== e; ) this._cursor.advance();
  }
  _readChar() {
    let e = String.fromCodePoint(this._cursor.peek());
    return this._cursor.advance(), e;
  }
  _consumeEntity(e) {
    this._beginToken(9);
    let r = this._cursor.clone();
    if (this._cursor.advance(), this._attemptCharCode(35)) {
      let s = this._attemptCharCode(120) || this._attemptCharCode(88), i = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(VN), this._cursor.peek() != 59) {
        this._cursor.advance();
        let a = s ? cc.HEX : cc.DEC;
        throw this._createError(jN(a, this._cursor.getChars(r)), this._cursor.getSpan());
      }
      let n = this._cursor.getChars(i);
      this._cursor.advance();
      try {
        let a = parseInt(n, s ? 16 : 10);
        this._endToken([String.fromCharCode(a), this._cursor.getChars(r)]);
      } catch {
        throw this._createError(b0(this._cursor.getChars(r)), this._cursor.getSpan());
      }
    } else {
      let s = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(zN), this._cursor.peek() != 59) this._beginToken(e, r), this._cursor = s, this._endToken(["&"]);
      else {
        let i = this._cursor.getChars(s);
        this._cursor.advance();
        let n = uc[i];
        if (!n) throw this._createError(b0(i), this._cursor.getSpan(r));
        this._endToken([n, `&${i};`]);
      }
    }
  }
  _consumeRawText(e, r) {
    this._beginToken(e ? 6 : 7);
    let s = [];
    for (; ; ) {
      let i = this._cursor.clone(), n = r();
      if (this._cursor = i, n) break;
      e && this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(s.join(""))]), s.length = 0, this._consumeEntity(6), this._beginToken(6)) : s.push(this._readChar());
    }
    this._endToken([this._processCarriageReturns(s.join(""))]);
  }
  _consumeComment(e) {
    this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("-->")), this._beginToken(11), this._requireStr("-->"), this._endToken([]);
  }
  _consumeBogusComment(e) {
    this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => this._cursor.peek() === 62), this._beginToken(11), this._cursor.advance(), this._endToken([]);
  }
  _consumeCdata(e) {
    this._beginToken(12, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("]]>")), this._beginToken(13), this._requireStr("]]>"), this._endToken([]);
  }
  _consumeDocType(e) {
    this._beginToken(18, e), this._endToken([]), this._consumeRawText(!1, () => this._cursor.peek() === 62), this._beginToken(19), this._cursor.advance(), this._endToken([]);
  }
  _consumePrefixAndName() {
    let e = this._cursor.clone(), r = "";
    for (; this._cursor.peek() !== 58 && !ZN(this._cursor.peek()); ) this._cursor.advance();
    let s;
    this._cursor.peek() === 58 ? (r = this._cursor.getChars(e), this._cursor.advance(), s = this._cursor.clone()) : s = e, this._requireCharCodeUntilFn(v0, r === "" ? 0 : 1);
    let i = this._cursor.getChars(s);
    return [r, i];
  }
  _consumeTagOpen(e) {
    let r, s, i, n = [];
    try {
      if (!ac(this._cursor.peek())) throw this._createError(Bn(this._cursor.peek()), this._cursor.getSpan(e));
      for (i = this._consumeTagOpenStart(e), s = i.parts[0], r = i.parts[1], this._attemptCharCodeUntilFn(Ke); this._cursor.peek() !== 47 && this._cursor.peek() !== 62 && this._cursor.peek() !== 60 && this._cursor.peek() !== 0; ) {
        let [l, c] = this._consumeAttributeName();
        if (this._attemptCharCodeUntilFn(Ke), this._attemptCharCode(61)) {
          this._attemptCharCodeUntilFn(Ke);
          let p = this._consumeAttributeValue();
          n.push({ prefix: l, name: c, value: p });
        } else n.push({ prefix: l, name: c });
        this._attemptCharCodeUntilFn(Ke);
      }
      this._consumeTagOpenEnd();
    } catch (l) {
      if (l instanceof yp) {
        i ? i.type = 4 : (this._beginToken(5, e), this._endToken(["<"]));
        return;
      }
      throw l;
    }
    if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === 2) return;
    let a = this._getTagContentType(r, s, this._fullNameStack.length > 0, n);
    this._handleFullNameStackForTagOpen(s, r), a === Ir.RAW_TEXT ? this._consumeRawTextWithTagClose(s, r, !1) : a === Ir.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(s, r, !0);
  }
  _consumeRawTextWithTagClose(e, r, s) {
    this._consumeRawText(s, () => !this._attemptCharCode(60) || !this._attemptCharCode(47) || (this._attemptCharCodeUntilFn(Ke), !this._attemptStrCaseInsensitive(e ? `${e}:${r}` : r)) ? !1 : (this._attemptCharCodeUntilFn(Ke), this._attemptCharCode(62))), this._beginToken(3), this._requireCharCodeUntilFn((i) => i === 62, 3), this._cursor.advance(), this._endToken([e, r]), this._handleFullNameStackForTagClose(e, r);
  }
  _consumeTagOpenStart(e) {
    this._beginToken(0, e);
    let r = this._consumePrefixAndName();
    return this._endToken(r);
  }
  _consumeAttributeName() {
    let e = this._cursor.peek();
    if (e === 39 || e === 34) throw this._createError(Bn(e), this._cursor.getSpan());
    this._beginToken(14);
    let r = this._consumePrefixAndName();
    return this._endToken(r), r;
  }
  _consumeAttributeValue() {
    let e;
    if (this._cursor.peek() === 39 || this._cursor.peek() === 34) {
      let r = this._cursor.peek();
      this._consumeQuote(r);
      let s = () => this._cursor.peek() === r;
      e = this._consumeWithInterpolation(16, 17, s, s), this._consumeQuote(r);
    } else {
      let r = () => v0(this._cursor.peek());
      e = this._consumeWithInterpolation(16, 17, r, r);
    }
    return e;
  }
  _consumeQuote(e) {
    this._beginToken(15), this._requireCharCode(e), this._endToken([String.fromCodePoint(e)]);
  }
  _consumeTagOpenEnd() {
    let e = this._attemptCharCode(47) ? 2 : 1;
    this._beginToken(e), this._requireCharCode(62), this._endToken([]);
  }
  _consumeTagClose(e) {
    if (this._beginToken(3, e), this._attemptCharCodeUntilFn(Ke), this._allowHtmComponentClosingTags && this._attemptCharCode(47)) this._attemptCharCodeUntilFn(Ke), this._requireCharCode(62), this._endToken([]);
    else {
      let [r, s] = this._consumePrefixAndName();
      this._attemptCharCodeUntilFn(Ke), this._requireCharCode(62), this._endToken([r, s]), this._handleFullNameStackForTagClose(r, s);
    }
  }
  _consumeExpansionFormStart() {
    this._beginToken(20), this._requireCharCode(123), this._endToken([]), this._expansionCaseStack.push(20), this._beginToken(7);
    let e = this._readUntil(44), r = this._processCarriageReturns(e);
    if (this._i18nNormalizeLineEndingsInICUs) this._endToken([r]);
    else {
      let i = this._endToken([e]);
      r !== e && this.nonNormalizedIcuExpressions.push(i);
    }
    this._requireCharCode(44), this._attemptCharCodeUntilFn(Ke), this._beginToken(7);
    let s = this._readUntil(44);
    this._endToken([s]), this._requireCharCode(44), this._attemptCharCodeUntilFn(Ke);
  }
  _consumeExpansionCaseStart() {
    this._beginToken(21);
    let e = this._readUntil(123).trim();
    this._endToken([e]), this._attemptCharCodeUntilFn(Ke), this._beginToken(22), this._requireCharCode(123), this._endToken([]), this._attemptCharCodeUntilFn(Ke), this._expansionCaseStack.push(22);
  }
  _consumeExpansionCaseEnd() {
    this._beginToken(23), this._requireCharCode(125), this._endToken([]), this._attemptCharCodeUntilFn(Ke), this._expansionCaseStack.pop();
  }
  _consumeExpansionFormEnd() {
    this._beginToken(24), this._requireCharCode(125), this._endToken([]), this._expansionCaseStack.pop();
  }
  _consumeWithInterpolation(e, r, s, i) {
    this._beginToken(e);
    let n = [];
    for (; !s(); ) {
      let l = this._cursor.clone();
      this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (this._endToken([this._processCarriageReturns(n.join(""))], l), n.length = 0, this._consumeInterpolation(r, l, i), this._beginToken(e)) : this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(n.join(""))]), n.length = 0, this._consumeEntity(e), this._beginToken(e)) : n.push(this._readChar());
    }
    this._inInterpolation = !1;
    let a = this._processCarriageReturns(n.join(""));
    return this._endToken([a]), a;
  }
  _consumeInterpolation(e, r, s) {
    let i = [];
    this._beginToken(e, r), i.push(this._interpolationConfig.start);
    let n = this._cursor.clone(), a = null, l = !1;
    for (; this._cursor.peek() !== 0 && (s === null || !s()); ) {
      let c = this._cursor.clone();
      if (this._isTagStart()) {
        this._cursor = c, i.push(this._getProcessedChars(n, c)), this._endToken(i);
        return;
      }
      if (a === null) if (this._attemptStr(this._interpolationConfig.end)) {
        i.push(this._getProcessedChars(n, c)), i.push(this._interpolationConfig.end), this._endToken(i);
        return;
      } else this._attemptStr("//") && (l = !0);
      let p = this._cursor.peek();
      this._cursor.advance(), p === 92 ? this._cursor.advance() : p === a ? a = null : !l && a === null && mp(p) && (a = p);
    }
    i.push(this._getProcessedChars(n, this._cursor)), this._endToken(i);
  }
  _getProcessedChars(e, r) {
    return this._processCarriageReturns(r.getChars(e));
  }
  _isTextEnd() {
    return !!(this._isTagStart() || this._cursor.peek() === 0 || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === 125 && this._isInExpansionCase()) || this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || this._cursor.peek() === 64 || this._cursor.peek() === 125));
  }
  _isTagStart() {
    if (this._cursor.peek() === 60) {
      let e = this._cursor.clone();
      e.advance();
      let r = e.peek();
      if (97 <= r && r <= 122 || 65 <= r && r <= 90 || r === 47 || r === 33) return !0;
    }
    return !1;
  }
  _isBlockStart() {
    if (this._tokenizeBlocks && this._cursor.peek() === 64) {
      let e = this._cursor.clone();
      if (e.advance(), w0(e.peek())) return !0;
    }
    return !1;
  }
  _readUntil(e) {
    let r = this._cursor.clone();
    return this._attemptUntilChar(e), this._cursor.getChars(r);
  }
  _isInExpansion() {
    return this._isInExpansionCase() || this._isInExpansionForm();
  }
  _isInExpansionCase() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 22;
  }
  _isInExpansionForm() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 20;
  }
  isExpansionFormStart() {
    if (this._cursor.peek() !== 123) return !1;
    if (this._interpolationConfig) {
      let e = this._cursor.clone(), r = this._attemptStr(this._interpolationConfig.start);
      return this._cursor = e, !r;
    }
    return !0;
  }
  _handleFullNameStackForTagOpen(e, r) {
    let s = lc(e, r);
    (this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === s) && this._fullNameStack.push(s);
  }
  _handleFullNameStackForTagClose(e, r) {
    let s = lc(e, r);
    this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === s && this._fullNameStack.pop();
  }
};
function Ke(t) {
  return !nc(t) || t === 0;
}
function v0(t) {
  return nc(t) || t === 62 || t === 60 || t === 47 || t === 39 || t === 34 || t === 61 || t === 0;
}
function ZN(t) {
  return (t < 97 || 122 < t) && (t < 65 || 90 < t) && (t < 48 || t > 57);
}
function VN(t) {
  return t === 59 || t === 0 || !W6(t);
}
function zN(t) {
  return t === 59 || t === 0 || !ac(t);
}
function UN(t) {
  return t !== 125;
}
function YN(t, e) {
  return S0(t) === S0(e);
}
function S0(t) {
  return t >= 97 && t <= 122 ? t - 97 + 65 : t;
}
function w0(t) {
  return ac(t) || Gm(t) || t === 95;
}
function A0(t) {
  return t !== 59 && Ke(t);
}
function WN(t) {
  let e = [], r;
  for (let s = 0; s < t.length; s++) {
    let i = t[s];
    r && r.type === 5 && i.type === 5 || r && r.type === 16 && i.type === 16 ? (r.parts[0] += i.parts[0], r.sourceSpan.end = i.sourceSpan.end) : (r = i, e.push(r));
  }
  return e;
}
var DS = class $d {
  constructor(e, r) {
    if (e instanceof $d) {
      this.file = e.file, this.input = e.input, this.end = e.end;
      let s = e.state;
      this.state = { peek: s.peek, offset: s.offset, line: s.line, column: s.column };
    } else {
      if (!r) throw new Error("Programming error: the range argument must be provided with a file argument.");
      this.file = e, this.input = e.content, this.end = r.endPos, this.state = { peek: -1, offset: r.startPos, line: r.startLine, column: r.startCol };
    }
  }
  clone() {
    return new $d(this);
  }
  peek() {
    return this.state.peek;
  }
  charsLeft() {
    return this.end - this.state.offset;
  }
  diff(e) {
    return this.state.offset - e.state.offset;
  }
  advance() {
    this.advanceState(this.state);
  }
  init() {
    this.updatePeek(this.state);
  }
  getSpan(e, r) {
    e = e || this;
    let s = e;
    if (r) for (; this.diff(e) > 0 && r.indexOf(e.peek()) !== -1; ) s === e && (e = e.clone()), e.advance();
    let i = this.locationFromCursor(e), n = this.locationFromCursor(this), a = s !== e ? this.locationFromCursor(s) : i;
    return new Oe(i, n, a);
  }
  getChars(e) {
    return this.input.substring(e.state.offset, this.state.offset);
  }
  charAt(e) {
    return this.input.charCodeAt(e);
  }
  advanceState(e) {
    if (e.offset >= this.end) throw this.state = e, new Jm('Unexpected character "EOF"', this);
    let r = this.charAt(e.offset);
    r === 10 ? (e.line++, e.column = 0) : Hm(r) || e.column++, e.offset++, this.updatePeek(e);
  }
  updatePeek(e) {
    e.peek = e.offset >= this.end ? 0 : this.charAt(e.offset);
  }
  locationFromCursor(e) {
    return new Pd(e.file, e.state.offset, e.state.line, e.state.column);
  }
}, GN = class Qd extends DS {
  constructor(e, r) {
    e instanceof Qd ? (super(e), this.internalState = { ...e.internalState }) : (super(e, r), this.internalState = this.state);
  }
  advance() {
    this.state = this.internalState, super.advance(), this.processEscapeSequence();
  }
  init() {
    super.init(), this.processEscapeSequence();
  }
  clone() {
    return new Qd(this);
  }
  getChars(e) {
    let r = e.clone(), s = "";
    for (; r.internalState.offset < this.internalState.offset; ) s += String.fromCodePoint(r.peek()), r.advance();
    return s;
  }
  processEscapeSequence() {
    let e = () => this.internalState.peek;
    if (e() === 92) if (this.internalState = { ...this.state }, this.advanceState(this.internalState), e() === 110) this.state.peek = 10;
    else if (e() === 114) this.state.peek = 13;
    else if (e() === 118) this.state.peek = 11;
    else if (e() === 116) this.state.peek = 9;
    else if (e() === 98) this.state.peek = 8;
    else if (e() === 102) this.state.peek = 12;
    else if (e() === 117) if (this.advanceState(this.internalState), e() === 123) {
      this.advanceState(this.internalState);
      let r = this.clone(), s = 0;
      for (; e() !== 125; ) this.advanceState(this.internalState), s++;
      this.state.peek = this.decodeHexDigits(r, s);
    } else {
      let r = this.clone();
      this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 4);
    }
    else if (e() === 120) {
      this.advanceState(this.internalState);
      let r = this.clone();
      this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 2);
    } else if (a0(e())) {
      let r = "", s = 0, i = this.clone();
      for (; a0(e()) && s < 3; ) i = this.clone(), r += String.fromCodePoint(e()), this.advanceState(this.internalState), s++;
      this.state.peek = parseInt(r, 8), this.internalState = i.internalState;
    } else Hm(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
  }
  decodeHexDigits(e, r) {
    let s = this.input.slice(e.internalState.offset, e.internalState.offset + r), i = parseInt(s, 16);
    if (isNaN(i)) throw e.state = e.internalState, new Jm("Invalid hexadecimal escape sequence", e);
    return i;
  }
}, Jm = class {
  constructor(e, r) {
    this.msg = e, this.cursor = r;
  }
}, Qt = class bS extends fS {
  static create(e, r, s) {
    return new bS(e, r, s);
  }
  constructor(e, r, s) {
    super(r, s), this.elementName = e;
  }
}, HN = class {
  constructor(e, r) {
    this.rootNodes = e, this.errors = r;
  }
}, JN = class {
  constructor(e) {
    this.getTagDefinition = e;
  }
  parse(e, r, s, i = !1, n) {
    let a = (x) => (v, ...w) => x(v.toLowerCase(), ...w), l = i ? this.getTagDefinition : a(this.getTagDefinition), c = (x) => l(x).getContentType(), p = i ? n : a(n), d = RN(e, r, n ? (x, v, w, C) => {
      let b = p(x, v, w, C);
      return b !== void 0 ? b : c(x);
    } : c, s), m = s && s.canSelfClose || !1, y = s && s.allowHtmComponentClosingTags || !1, g = new KN(d.tokens, l, m, y, i);
    return g.build(), new HN(g.rootNodes, d.errors.concat(g.errors));
  }
}, KN = class vS {
  constructor(e, r, s, i, n) {
    this.tokens = e, this.getTagDefinition = r, this.canSelfClose = s, this.allowHtmComponentClosingTags = i, this.isTagNameCaseSensitive = n, this._index = -1, this._containerStack = [], this.rootNodes = [], this.errors = [], this._advance();
  }
  build() {
    for (; this._peek.type !== 34; ) this._peek.type === 0 || this._peek.type === 4 ? this._consumeStartTag(this._advance()) : this._peek.type === 3 ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === 12 ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === 10 ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6 ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === 20 ? this._consumeExpansion(this._advance()) : this._peek.type === 25 ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : this._peek.type === 27 ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : this._peek.type === 29 ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : this._peek.type === 30 ? (this._closeVoidElement(), this._consumeLet(this._advance())) : this._peek.type === 18 ? this._consumeDocType(this._advance()) : this._peek.type === 33 ? (this._closeVoidElement(), this._consumeIncompleteLet(this._advance())) : this._advance();
    for (let e of this._containerStack) e instanceof Qn && this.errors.push(Qt.create(e.name, e.sourceSpan, `Unclosed block "${e.name}"`));
  }
  _advance() {
    let e = this._peek;
    return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e;
  }
  _advanceIf(e) {
    return this._peek.type === e ? this._advance() : null;
  }
  _consumeCdata(e) {
    let r = this._advance(), s = this._getText(r), i = this._advanceIf(13);
    this._addToParent(new TN(s, new Oe(e.sourceSpan.start, (i || r).sourceSpan.end), [r]));
  }
  _consumeComment(e) {
    let r = this._advanceIf(7), s = this._advanceIf(11), i = r != null ? r.parts[0].trim() : null, n = s == null ? e.sourceSpan : new Oe(e.sourceSpan.start, s.sourceSpan.end, e.sourceSpan.fullStart);
    this._addToParent(new $N(i, n));
  }
  _consumeDocType(e) {
    let r = this._advanceIf(7), s = this._advanceIf(19), i = r != null ? r.parts[0].trim() : null, n = new Oe(e.sourceSpan.start, (s || r || e).sourceSpan.end);
    this._addToParent(new QN(i, n));
  }
  _consumeExpansion(e) {
    let r = this._advance(), s = this._advance(), i = [];
    for (; this._peek.type === 21; ) {
      let a = this._parseExpansionCase();
      if (!a) return;
      i.push(a);
    }
    if (this._peek.type !== 24) {
      this.errors.push(Qt.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
      return;
    }
    let n = new Oe(e.sourceSpan.start, this._peek.sourceSpan.end, e.sourceSpan.fullStart);
    this._addToParent(new kN(r.parts[0], s.parts[0], i, n, r.sourceSpan)), this._advance();
  }
  _parseExpansionCase() {
    let e = this._advance();
    if (this._peek.type !== 22) return this.errors.push(Qt.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
    let r = this._advance(), s = this._collectExpansionExpTokens(r);
    if (!s) return null;
    let i = this._advance();
    s.push({ type: 34, parts: [], sourceSpan: i.sourceSpan });
    let n = new vS(s, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive);
    if (n.build(), n.errors.length > 0) return this.errors = this.errors.concat(n.errors), null;
    let a = new Oe(e.sourceSpan.start, i.sourceSpan.end, e.sourceSpan.fullStart), l = new Oe(r.sourceSpan.start, i.sourceSpan.end, r.sourceSpan.fullStart);
    return new PN(e.parts[0], n.rootNodes, a, e.sourceSpan, l);
  }
  _collectExpansionExpTokens(e) {
    let r = [], s = [22];
    for (; ; ) {
      if ((this._peek.type === 20 || this._peek.type === 22) && s.push(this._peek.type), this._peek.type === 23) if (C0(s, 22)) {
        if (s.pop(), s.length === 0) return r;
      } else return this.errors.push(Qt.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 24) if (C0(s, 20)) s.pop();
      else return this.errors.push(Qt.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 34) return this.errors.push(Qt.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      r.push(this._advance());
    }
  }
  _getText(e) {
    let r = e.parts[0];
    if (r.length > 0 && r[0] == `
`) {
      let s = this._getClosestParentElement();
      s != null && s.children.length == 0 && this.getTagDefinition(s.name).ignoreFirstLf && (r = r.substring(1));
    }
    return r;
  }
  _consumeText(e) {
    let r = [e], s = e.sourceSpan, i = e.parts[0];
    if (i.length > 0 && i[0] === `
`) {
      let n = this._getContainer();
      n != null && n.children.length === 0 && this.getTagDefinition(n.name).ignoreFirstLf && (i = i.substring(1), r[0] = { type: e.type, sourceSpan: e.sourceSpan, parts: [i] });
    }
    for (; this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9; ) e = this._advance(), r.push(e), e.type === 8 ? i += e.parts.join("").replace(/&([^;]+);/g, E0) : e.type === 9 ? i += e.parts[0] : i += e.parts.join("");
    if (i.length > 0) {
      let n = e.sourceSpan;
      this._addToParent(new EN(i, new Oe(s.start, n.end, s.fullStart, s.details), r));
    }
  }
  _closeVoidElement() {
    let e = this._getContainer();
    e instanceof li && this.getTagDefinition(e.name).isVoid && this._containerStack.pop();
  }
  _consumeStartTag(e) {
    let [r, s] = e.parts, i = [];
    for (; this._peek.type === 14; ) i.push(this._consumeAttr(this._advance()));
    let n = this._getElementFullName(r, s, this._getClosestParentElement()), a = !1;
    if (this._peek.type === 2) {
      this._advance(), a = !0;
      let g = this.getTagDefinition(n);
      this.canSelfClose || g.canSelfClose || Qu(n) !== null || g.isVoid || this.errors.push(Qt.create(n, e.sourceSpan, `Only void, custom and foreign elements can be self closed "${e.parts[1]}"`));
    } else this._peek.type === 1 && (this._advance(), a = !1);
    let l = this._peek.sourceSpan.fullStart, c = new Oe(e.sourceSpan.start, l, e.sourceSpan.fullStart), p = new Oe(e.sourceSpan.start, l, e.sourceSpan.fullStart), d = new Oe(e.sourceSpan.start.moveBy(1), e.sourceSpan.end), m = new li(n, i, [], c, p, void 0, d), y = this._getContainer();
    this._pushContainer(m, y instanceof li && this.getTagDefinition(y.name).isClosedByChild(m.name)), a ? this._popContainer(n, li, c) : e.type === 4 && (this._popContainer(n, li, null), this.errors.push(Qt.create(n, c, `Opening tag "${n}" not terminated.`)));
  }
  _pushContainer(e, r) {
    r && this._containerStack.pop(), this._addToParent(e), this._containerStack.push(e);
  }
  _consumeEndTag(e) {
    let r = this.allowHtmComponentClosingTags && e.parts.length === 0 ? null : this._getElementFullName(e.parts[0], e.parts[1], this._getClosestParentElement());
    if (r && this.getTagDefinition(r).isVoid) this.errors.push(Qt.create(r, e.sourceSpan, `Void elements do not have end tags "${e.parts[1]}"`));
    else if (!this._popContainer(r, li, e.sourceSpan)) {
      let s = `Unexpected closing tag "${r}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
      this.errors.push(Qt.create(r, e.sourceSpan, s));
    }
  }
  _popContainer(e, r, s) {
    let i = !1;
    for (let n = this._containerStack.length - 1; n >= 0; n--) {
      let a = this._containerStack[n];
      if (Qu(a.name) ? a.name === e : (e == null || a.name.toLowerCase() === e.toLowerCase()) && a instanceof r) return a.endSourceSpan = s, a.sourceSpan.end = s !== null ? s.end : a.sourceSpan.end, this._containerStack.splice(n, this._containerStack.length - n), !i;
      (a instanceof Qn || a instanceof li && !this.getTagDefinition(a.name).closedByParent) && (i = !0);
    }
    return !1;
  }
  _consumeAttr(e) {
    var d, m;
    let r = lc(e.parts[0], e.parts[1]), s = e.sourceSpan.end, i;
    this._peek.type === 15 && (i = this._advance());
    let n = "", a = [], l, c;
    if (this._peek.type === 16) for (l = this._peek.sourceSpan, c = this._peek.sourceSpan.end; this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9; ) {
      let y = this._advance();
      a.push(y), y.type === 17 ? n += y.parts.join("").replace(/&([^;]+);/g, E0) : y.type === 9 ? n += y.parts[0] : n += y.parts.join(""), c = s = y.sourceSpan.end;
    }
    this._peek.type === 15 && (c = s = this._advance().sourceSpan.end);
    let p = l && c && new Oe((d = i == null ? void 0 : i.sourceSpan.start) != null ? d : l.start, c, (m = i == null ? void 0 : i.sourceSpan.fullStart) != null ? m : l.fullStart);
    return new FN(r, n, new Oe(e.sourceSpan.start, s, e.sourceSpan.fullStart), e.sourceSpan, p, a.length > 0 ? a : void 0, void 0);
  }
  _consumeBlockOpen(e) {
    let r = [];
    for (; this._peek.type === 28; ) {
      let l = this._advance();
      r.push(new x0(l.parts[0], l.sourceSpan));
    }
    this._peek.type === 26 && this._advance();
    let s = this._peek.sourceSpan.fullStart, i = new Oe(e.sourceSpan.start, s, e.sourceSpan.fullStart), n = new Oe(e.sourceSpan.start, s, e.sourceSpan.fullStart), a = new Qn(e.parts[0], r, [], i, e.sourceSpan, n);
    this._pushContainer(a, !1);
  }
  _consumeBlockClose(e) {
    this._popContainer(null, Qn, e.sourceSpan) || this.errors.push(Qt.create(null, e.sourceSpan, 'Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the "&#125;" HTML entity instead.'));
  }
  _consumeIncompleteBlock(e) {
    let r = [];
    for (; this._peek.type === 28; ) {
      let l = this._advance();
      r.push(new x0(l.parts[0], l.sourceSpan));
    }
    let s = this._peek.sourceSpan.fullStart, i = new Oe(e.sourceSpan.start, s, e.sourceSpan.fullStart), n = new Oe(e.sourceSpan.start, s, e.sourceSpan.fullStart), a = new Qn(e.parts[0], r, [], i, e.sourceSpan, n);
    this._pushContainer(a, !1), this._popContainer(null, Qn, null), this.errors.push(Qt.create(e.parts[0], i, `Incomplete block "${e.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`));
  }
  _consumeLet(e) {
    let r = e.parts[0], s, i;
    if (this._peek.type !== 31) {
      this.errors.push(Qt.create(e.parts[0], e.sourceSpan, `Invalid @let declaration "${r}". Declaration must have a value.`));
      return;
    } else s = this._advance();
    if (this._peek.type !== 32) {
      this.errors.push(Qt.create(e.parts[0], e.sourceSpan, `Unterminated @let declaration "${r}". Declaration must be terminated with a semicolon.`));
      return;
    } else i = this._advance();
    let n = i.sourceSpan.fullStart, a = new Oe(e.sourceSpan.start, n, e.sourceSpan.fullStart), l = e.sourceSpan.toString().lastIndexOf(r), c = e.sourceSpan.start.moveBy(l), p = new Oe(c, e.sourceSpan.end), d = new D0(r, s.parts[0], a, p, s.sourceSpan);
    this._addToParent(d);
  }
  _consumeIncompleteLet(e) {
    var i;
    let r = (i = e.parts[0]) != null ? i : "", s = r ? ` "${r}"` : "";
    if (r.length > 0) {
      let n = e.sourceSpan.toString().lastIndexOf(r), a = e.sourceSpan.start.moveBy(n), l = new Oe(a, e.sourceSpan.end), c = new Oe(e.sourceSpan.start, e.sourceSpan.start.moveBy(0)), p = new D0(r, "", e.sourceSpan, l, c);
      this._addToParent(p);
    }
    this.errors.push(Qt.create(e.parts[0], e.sourceSpan, `Incomplete @let declaration${s}. @let declarations must be written as \`@let <name> = <value>;\``));
  }
  _getContainer() {
    return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;
  }
  _getClosestParentElement() {
    for (let e = this._containerStack.length - 1; e > -1; e--) if (this._containerStack[e] instanceof li) return this._containerStack[e];
    return null;
  }
  _addToParent(e) {
    let r = this._getContainer();
    r === null ? this.rootNodes.push(e) : r.children.push(e);
  }
  _getElementFullName(e, r, s) {
    if (e === "" && (e = this.getTagDefinition(r).implicitNamespacePrefix || "", e === "" && s != null)) {
      let i = fh(s.name)[1];
      this.getTagDefinition(i).preventNamespaceInheritance || (e = Qu(s.name));
    }
    return lc(e, r);
  }
};
function C0(t, e) {
  return t.length > 0 && t[t.length - 1] === e;
}
function E0(t, e) {
  return uc[e] !== void 0 ? uc[e] || t : /^#x[a-f0-9]+$/i.test(e) ? String.fromCodePoint(parseInt(e.slice(2), 16)) : /^#\d+$/.test(e) ? String.fromCodePoint(parseInt(e.slice(1), 10)) : t;
}
var eM = class extends JN {
  constructor() {
    super(Fd);
  }
  parse(e, r, s, i = !1, n) {
    return super.parse(e, r, s, i, n);
  }
}, Op = null, tM = () => (Op || (Op = new eM()), Op);
function T0(t, e = {}) {
  let { canSelfClose: r = !1, allowHtmComponentClosingTags: s = !1, isTagNameCaseSensitive: i = !1, getTagContentType: n, tokenizeAngularBlocks: a = !1, tokenizeAngularLetDeclaration: l = !1 } = e;
  return tM().parse(t, "angular-html-parser", { tokenizeExpansionForms: a, interpolationConfig: void 0, canSelfClose: r, allowHtmComponentClosingTags: s, tokenizeBlocks: a, tokenizeLet: l }, i, n);
}
function rM(t, e) {
  let r = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
var sM = rM, Ka = 3;
function iM(t) {
  let e = t.slice(0, Ka);
  if (e !== "---" && e !== "+++") return;
  let r = t.indexOf(`
`, Ka);
  if (r === -1) return;
  let s = t.slice(Ka, r).trim(), i = t.indexOf(`
${e}`, r), n = s;
  if (n || (n = e === "+++" ? "toml" : "yaml"), i === -1 && e === "---" && n === "yaml" && (i = t.indexOf(`
...`, r)), i === -1) return;
  let a = i + 1 + Ka, l = t.charAt(a + 1);
  if (!/\s?/u.test(l)) return;
  let c = t.slice(0, a);
  return { type: "front-matter", language: n, explicitLanguage: s, value: t.slice(r + 1, i), startDelimiter: e, endDelimiter: c.slice(-Ka), raw: c };
}
function nM(t) {
  let e = iM(t);
  if (!e) return { content: t };
  let { raw: r } = e;
  return { frontMatter: e, content: hr(!1, r, /[^\n]/gu, " ") + t.slice(r.length) };
}
var aM = nM, tu = { attrs: !0, children: !0, cases: !0, expression: !0 }, k0 = /* @__PURE__ */ new Set(["parent"]), Rn, Bd, Id, oM = class uo {
  constructor(e = {}) {
    kv(this, Rn), VO(this, "type"), VO(this, "parent");
    for (let r of /* @__PURE__ */ new Set([...k0, ...Object.keys(e)])) this.setProperty(r, e[r]);
  }
  setProperty(e, r) {
    if (this[e] !== r) {
      if (e in tu && (r = r.map((s) => this.createChild(s))), !k0.has(e)) {
        this[e] = r;
        return;
      }
      Object.defineProperty(this, e, { value: r, enumerable: !1, configurable: !0 });
    }
  }
  map(e) {
    let r;
    for (let s in tu) {
      let i = this[s];
      if (i) {
        let n = uM(i, (a) => a.map(e));
        r !== i && (r || (r = new uo({ parent: this.parent })), r.setProperty(s, n));
      }
    }
    if (r) for (let s in this) s in tu || (r[s] = this[s]);
    return e(r || this);
  }
  walk(e) {
    for (let r in tu) {
      let s = this[r];
      if (s) for (let i = 0; i < s.length; i++) s[i].walk(e);
    }
    e(this);
  }
  createChild(e) {
    let r = e instanceof uo ? e.clone() : new uo(e);
    return r.setProperty("parent", this), r;
  }
  insertChildBefore(e, r) {
    let s = this.$children;
    s.splice(s.indexOf(e), 0, this.createChild(r));
  }
  removeChild(e) {
    let r = this.$children;
    r.splice(r.indexOf(e), 1);
  }
  replaceChild(e, r) {
    let s = this.$children;
    s[s.indexOf(e)] = this.createChild(r);
  }
  clone() {
    return new uo(this);
  }
  get $children() {
    return this[gr(this, Rn, Bd)];
  }
  set $children(e) {
    this[gr(this, Rn, Bd)] = e;
  }
  get firstChild() {
    var e;
    return (e = this.$children) == null ? void 0 : e[0];
  }
  get lastChild() {
    return yl(!0, this.$children, -1);
  }
  get prev() {
    let e = gr(this, Rn, Id);
    return e[e.indexOf(this) - 1];
  }
  get next() {
    let e = gr(this, Rn, Id);
    return e[e.indexOf(this) + 1];
  }
  get rawName() {
    return this.hasExplicitNamespace ? this.fullName : this.name;
  }
  get fullName() {
    return this.namespace ? this.namespace + ":" + this.name : this.name;
  }
  get attrMap() {
    return Object.fromEntries(this.attrs.map((e) => [e.fullName, e.value]));
  }
};
Rn = /* @__PURE__ */ new WeakSet(), Bd = function() {
  return this.type === "angularIcuCase" ? "expression" : this.type === "angularIcuExpression" ? "cases" : "children";
}, Id = function() {
  var e;
  var t;
  return (e = (t = this.parent) == null ? void 0 : t.$children) != null ? e : [];
};
var lM = oM;
function uM(t, e) {
  let r = t.map(e);
  return r.some((s, i) => s !== t[i]) ? r : t;
}
var cM = [{ regex: /^(\[if([^\]]*)\]>)(.*?)<!\s*\[endif\]$/su, parse: pM }, { regex: /^\[if([^\]]*)\]><!$/u, parse: dM }, { regex: /^<!\s*\[endif\]$/u, parse: fM }];
function hM(t, e) {
  if (t.value) for (let { regex: r, parse: s } of cM) {
    let i = t.value.match(r);
    if (i) return s(t, e, i);
  }
  return null;
}
function pM(t, e, r) {
  let [, s, i, n] = r, a = 4 + s.length, l = t.sourceSpan.start.moveBy(a), c = l.moveBy(n.length), [p, d] = (() => {
    try {
      return [!0, e(n, l).children];
    } catch {
      return [!1, [{ type: "text", value: n, sourceSpan: new Oe(l, c) }]];
    }
  })();
  return { type: "ieConditionalComment", complete: p, children: d, condition: hr(!1, i.trim(), /\s+/gu, " "), sourceSpan: t.sourceSpan, startSourceSpan: new Oe(t.sourceSpan.start, l), endSourceSpan: new Oe(c, t.sourceSpan.end) };
}
function dM(t, e, r) {
  let [, s] = r;
  return { type: "ieConditionalStartComment", condition: hr(!1, s.trim(), /\s+/gu, " "), sourceSpan: t.sourceSpan };
}
function fM(t) {
  return { type: "ieConditionalEndComment", sourceSpan: t.sourceSpan };
}
var xp = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set(["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inert", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "popover", "slot", "spellcheck", "style", "tabindex", "title", "translate", "writingsuggestions"])], ["a", /* @__PURE__ */ new Set(["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"])], ["applet", /* @__PURE__ */ new Set(["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"])], ["area", /* @__PURE__ */ new Set(["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"])], ["audio", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"])], ["base", /* @__PURE__ */ new Set(["href", "target"])], ["basefont", /* @__PURE__ */ new Set(["color", "face", "size"])], ["blockquote", /* @__PURE__ */ new Set(["cite"])], ["body", /* @__PURE__ */ new Set(["alink", "background", "bgcolor", "link", "text", "vlink"])], ["br", /* @__PURE__ */ new Set(["clear"])], ["button", /* @__PURE__ */ new Set(["disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "popovertarget", "popovertargetaction", "type", "value"])], ["canvas", /* @__PURE__ */ new Set(["height", "width"])], ["caption", /* @__PURE__ */ new Set(["align"])], ["col", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["colgroup", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["data", /* @__PURE__ */ new Set(["value"])], ["del", /* @__PURE__ */ new Set(["cite", "datetime"])], ["details", /* @__PURE__ */ new Set(["name", "open"])], ["dialog", /* @__PURE__ */ new Set(["open"])], ["dir", /* @__PURE__ */ new Set(["compact"])], ["div", /* @__PURE__ */ new Set(["align"])], ["dl", /* @__PURE__ */ new Set(["compact"])], ["embed", /* @__PURE__ */ new Set(["height", "src", "type", "width"])], ["fieldset", /* @__PURE__ */ new Set(["disabled", "form", "name"])], ["font", /* @__PURE__ */ new Set(["color", "face", "size"])], ["form", /* @__PURE__ */ new Set(["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"])], ["frame", /* @__PURE__ */ new Set(["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"])], ["frameset", /* @__PURE__ */ new Set(["cols", "rows"])], ["h1", /* @__PURE__ */ new Set(["align"])], ["h2", /* @__PURE__ */ new Set(["align"])], ["h3", /* @__PURE__ */ new Set(["align"])], ["h4", /* @__PURE__ */ new Set(["align"])], ["h5", /* @__PURE__ */ new Set(["align"])], ["h6", /* @__PURE__ */ new Set(["align"])], ["head", /* @__PURE__ */ new Set(["profile"])], ["hr", /* @__PURE__ */ new Set(["align", "noshade", "size", "width"])], ["html", /* @__PURE__ */ new Set(["manifest", "version"])], ["iframe", /* @__PURE__ */ new Set(["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"])], ["img", /* @__PURE__ */ new Set(["align", "alt", "border", "crossorigin", "decoding", "fetchpriority", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"])], ["input", /* @__PURE__ */ new Set(["accept", "align", "alt", "autocomplete", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "popovertarget", "popovertargetaction", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"])], ["ins", /* @__PURE__ */ new Set(["cite", "datetime"])], ["isindex", /* @__PURE__ */ new Set(["prompt"])], ["label", /* @__PURE__ */ new Set(["for", "form"])], ["legend", /* @__PURE__ */ new Set(["align"])], ["li", /* @__PURE__ */ new Set(["type", "value"])], ["link", /* @__PURE__ */ new Set(["as", "blocking", "charset", "color", "crossorigin", "disabled", "fetchpriority", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"])], ["map", /* @__PURE__ */ new Set(["name"])], ["menu", /* @__PURE__ */ new Set(["compact"])], ["meta", /* @__PURE__ */ new Set(["charset", "content", "http-equiv", "media", "name", "scheme"])], ["meter", /* @__PURE__ */ new Set(["high", "low", "max", "min", "optimum", "value"])], ["object", /* @__PURE__ */ new Set(["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"])], ["ol", /* @__PURE__ */ new Set(["compact", "reversed", "start", "type"])], ["optgroup", /* @__PURE__ */ new Set(["disabled", "label"])], ["option", /* @__PURE__ */ new Set(["disabled", "label", "selected", "value"])], ["output", /* @__PURE__ */ new Set(["for", "form", "name"])], ["p", /* @__PURE__ */ new Set(["align"])], ["param", /* @__PURE__ */ new Set(["name", "type", "value", "valuetype"])], ["pre", /* @__PURE__ */ new Set(["width"])], ["progress", /* @__PURE__ */ new Set(["max", "value"])], ["q", /* @__PURE__ */ new Set(["cite"])], ["script", /* @__PURE__ */ new Set(["async", "blocking", "charset", "crossorigin", "defer", "fetchpriority", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"])], ["select", /* @__PURE__ */ new Set(["autocomplete", "disabled", "form", "multiple", "name", "required", "size"])], ["slot", /* @__PURE__ */ new Set(["name"])], ["source", /* @__PURE__ */ new Set(["height", "media", "sizes", "src", "srcset", "type", "width"])], ["style", /* @__PURE__ */ new Set(["blocking", "media", "type"])], ["table", /* @__PURE__ */ new Set(["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"])], ["tbody", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["td", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["template", /* @__PURE__ */ new Set(["shadowrootclonable", "shadowrootdelegatesfocus", "shadowrootmode"])], ["textarea", /* @__PURE__ */ new Set(["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"])], ["tfoot", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["th", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["thead", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["time", /* @__PURE__ */ new Set(["datetime"])], ["tr", /* @__PURE__ */ new Set(["align", "bgcolor", "char", "charoff", "valign"])], ["track", /* @__PURE__ */ new Set(["default", "kind", "label", "src", "srclang"])], ["ul", /* @__PURE__ */ new Set(["compact", "type"])], ["video", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"])]]), mM = /* @__PURE__ */ new Set(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]);
function gM(t) {
  if (t.type === "block") {
    if (t.name = hr(!1, t.name.toLowerCase(), /\s+/gu, " ").trim(), t.type = "angularControlFlowBlock", !qm(t.parameters)) {
      delete t.parameters;
      return;
    }
    for (let e of t.parameters) e.type = "angularControlFlowBlockParameter";
    t.parameters = { type: "angularControlFlowBlockParameters", children: t.parameters, sourceSpan: new Oe(t.parameters[0].sourceSpan.start, yl(!1, t.parameters, -1).sourceSpan.end) };
  }
}
function yM(t) {
  t.type === "letDeclaration" && (t.type = "angularLetDeclaration", t.id = t.name, t.init = { type: "angularLetDeclarationInitializer", sourceSpan: new Oe(t.valueSpan.start, t.valueSpan.end), value: t.value }, delete t.name, delete t.value);
}
function OM(t) {
  (t.type === "plural" || t.type === "select") && (t.clause = t.type, t.type = "angularIcuExpression"), t.type === "expansionCase" && (t.type = "angularIcuCase");
}
function SS(t, e, r) {
  let { name: s, canSelfClose: i = !0, normalizeTagName: n = !1, normalizeAttributeName: a = !1, allowHtmComponentClosingTags: l = !1, isTagNameCaseSensitive: c = !1, shouldParseAsRawText: p } = e, { rootNodes: d, errors: m } = T0(t, { canSelfClose: i, allowHtmComponentClosingTags: l, isTagNameCaseSensitive: c, getTagContentType: p ? (...b) => p(...b) ? Ir.RAW_TEXT : void 0 : void 0, tokenizeAngularBlocks: s === "angular" ? !0 : void 0, tokenizeAngularLetDeclaration: s === "angular" ? !0 : void 0 });
  if (s === "vue") {
    if (d.some((F) => F.type === "docType" && F.value === "html" || F.type === "element" && F.name.toLowerCase() === "html")) return SS(t, Km, r);
    let b, k = () => b != null ? b : b = T0(t, { canSelfClose: i, allowHtmComponentClosingTags: l, isTagNameCaseSensitive: c }), Q = (F) => {
      var $;
      return ($ = k().rootNodes.find(({ startSourceSpan: N }) => N && N.start.offset === F.startSourceSpan.start.offset)) != null ? $ : F;
    };
    for (let [F, $] of d.entries()) {
      let { endSourceSpan: N, startSourceSpan: _ } = $;
      if (N === null) m = k().errors, d[F] = Q($);
      else if (xM($, r)) {
        let W = k().errors.find((V) => V.span.start.offset > _.start.offset && V.span.start.offset < N.end.offset);
        W && P0(W), d[F] = Q($);
      }
    }
  }
  m.length > 0 && P0(m[0]);
  let y = (b) => {
    let k = b.name.startsWith(":") ? b.name.slice(1).split(":")[0] : null, Q = b.nameSpan.toString(), F = k !== null && Q.startsWith(`${k}:`), $ = F ? Q.slice(k.length + 1) : Q;
    b.name = $, b.namespace = k, b.hasExplicitNamespace = F;
  }, g = (b) => {
    switch (b.type) {
      case "element":
        y(b);
        for (let k of b.attrs) y(k), k.valueSpan ? (k.value = k.valueSpan.toString(), /["']/u.test(k.value[0]) && (k.value = k.value.slice(1, -1))) : k.value = null;
        break;
      case "comment":
        b.value = b.sourceSpan.toString().slice(4, -3);
        break;
      case "text":
        b.value = b.sourceSpan.toString();
        break;
    }
  }, x = (b, k) => {
    let Q = b.toLowerCase();
    return k(Q) ? Q : b;
  }, v = (b) => {
    if (b.type === "element" && (n && (!b.namespace || b.namespace === b.tagDefinition.implicitNamespacePrefix || Ro(b)) && (b.name = x(b.name, (k) => mM.has(k))), a)) for (let k of b.attrs) k.namespace || (k.name = x(k.name, (Q) => xp.has(b.name) && (xp.get("*").has(Q) || xp.get(b.name).has(Q))));
  }, w = (b) => {
    b.sourceSpan && b.endSourceSpan && (b.sourceSpan = new Oe(b.sourceSpan.start, b.endSourceSpan.end));
  }, C = (b) => {
    if (b.type === "element") {
      let k = Fd(c ? b.name : b.name.toLowerCase());
      !b.namespace || b.namespace === k.implicitNamespacePrefix || Ro(b) ? b.tagDefinition = k : b.tagDefinition = Fd("");
    }
  };
  return yS(new class extends BN {
    visitExpansionCase(b, k) {
      s === "angular" && this.visitChildren(k, (Q) => {
        Q(b.expression);
      });
    }
    visit(b) {
      g(b), C(b), v(b), w(b);
    }
  }(), d), d;
}
function xM(t, e) {
  var r;
  if (t.type !== "element" || t.name !== "template") return !1;
  let s = (r = t.attrs.find((i) => i.name === "lang")) == null ? void 0 : r.value;
  return !s || lh(e, { language: s }) === "html";
}
function P0(t) {
  let { msg: e, span: { start: r, end: s } } = t;
  throw sM(e, { loc: { start: { line: r.line + 1, column: r.col + 1 }, end: { line: s.line + 1, column: s.col + 1 } }, cause: t });
}
function wS(t, e, r = {}, s = !0) {
  let { frontMatter: i, content: n } = s ? aM(t) : { frontMatter: null, content: t }, a = new dS(t, r.filepath), l = new Pd(a, 0, 0, 0), c = l.moveBy(t.length), p = { type: "root", sourceSpan: new Oe(l, c), children: SS(n, e, r) };
  if (i) {
    let y = new Pd(a, 0, 0, 0), g = y.moveBy(i.raw.length);
    i.sourceSpan = new Oe(y, g), p.children.unshift(i);
  }
  let d = new lM(p), m = (y, g) => {
    let { offset: x } = g, v = hr(!1, t.slice(0, x), /[^\n\r]/gu, " "), w = wS(v + y, e, r, !1);
    w.sourceSpan = new Oe(g, yl(!1, w.children, -1).sourceSpan.end);
    let C = w.children[0];
    return C.length === x ? w.children.shift() : (C.sourceSpan = new Oe(C.sourceSpan.start.moveBy(x), C.sourceSpan.end), C.value = C.value.slice(x)), w;
  };
  return d.walk((y) => {
    if (y.type === "comment") {
      let g = hM(y, m);
      g && y.parent.replaceChild(y, g);
    }
    gM(y), yM(y), OM(y);
  }), d;
}
function Sl(t) {
  return { parse: (e, r) => wS(e, t, r), hasPragma: _6, hasIgnorePragma: R6, astFormat: "html", locStart: Dl, locEnd: hh };
}
var Km = { name: "html", normalizeTagName: !0, normalizeAttributeName: !0, allowHtmComponentClosingTags: !0 }, DM = Sl(Km), bM = /* @__PURE__ */ new Set(["mj-style", "mj-raw"]), vM = Sl({ ...Km, name: "mjml", shouldParseAsRawText: (t) => bM.has(t) }), SM = Sl({ name: "angular" }), wM = Sl({ name: "vue", isTagNameCaseSensitive: !0, shouldParseAsRawText(t, e, r, s) {
  return t.toLowerCase() !== "html" && !r && (t !== "template" || s.some(({ name: i, value: n }) => i === "lang" && n !== "html" && n !== "" && n !== void 0));
} }), AM = Sl({ name: "lwc", canSelfClose: !1 }), CM = { html: fN }, EM = Pv;
const In = (t) => [...t.attributes].map((e) => `${e.name}="${e.value}"`).join(" "), AS = (t) => {
  const e = document.createElement("textarea");
  return e.innerHTML = t, e.value;
}, F0 = (t) => hl(
  t,
  {
    parser: "json5",
    plugins: [f2, wv]
  }
).catch((e) => t), TM = (t) => hl(
  AS(t),
  {
    parser: "babel",
    plugins: [f2, wv]
  }
).catch((e) => t), kM = async (t) => {
  const e = AS(await hl(
    t,
    {
      parser: "html",
      plugins: [EM],
      htmlWhitespaceSensitivity: "ignore"
    }
  ).catch((r) => t));
  return e.endsWith(`
`) ? e.slice(0, -1) : e;
}, PM = async (t, e = {}) => {
  const r = e.gScript || e["g-script"] ? "g-script" : "script";
  let s = `<grapper-view ${In(t)}>
`;
  const i = t.querySelector("template");
  if (i) {
    s += `<template ${In(i)}>
`;
    const p = i.content.querySelector("svg");
    p && (s += p.outerHTML), s += `</template>
`;
  } else {
    const p = t.querySelector("svg");
    p && (s += `<template>
${p.outerHTML}</template>
`);
  }
  const n = t.querySelector("script[type=data],g-script[type=data]");
  n && (s += `<${r} ${In(n)}>
${await F0(n.innerHTML)}
</${r}>`);
  const a = t.querySelector("script[type=methods],g-script[type=methods]");
  a && (s += `<${r} ${In(a)}>
${await TM(a.innerHTML)}
</${r}>
`);
  const l = t.querySelector("script[type=config],g-script[type=config]");
  return l && (s += `<${r} ${In(l)}>
${await F0(l.innerHTML)}
</${r}>
`), t.querySelectorAll("script[type=plugin],g-script[type=plugin]").forEach((p) => {
    s += `<${r} ${In(p)}></${r}>
`;
  }), s += "</grapper-view>", s;
}, FM = async (t, e) => {
  const r = document.createElement("div");
  r.innerHTML = t;
  for (let s of [...r.children])
    s.tagName.toLowerCase() === "grapper-view" && (s.outerHTML = await PM(s, e));
  return kM(r.innerHTML);
}, $M = (t, e, r) => {
  const s = t.createElement("div");
  s.innerHTML = e;
  const i = s.querySelector(r);
  return i ? {
    el: i,
    code: e,
    outer: i.outerHTML,
    inner: i.innerHTML
  } : {
    code: e
  };
};
var ol, Ji, Ki, ra, qc, CS;
class QM {
  constructor(e = globalThis.document) {
    At(this, qc);
    At(this, ol);
    At(this, Ji, "");
    At(this, Ki, {});
    At(this, ra, 0);
    mt(this, ol, e);
  }
  async load(e, r, s = !1) {
    this.code = s ? e : await FM(e, r);
  }
  set code(e) {
    Y(this, Ji) !== e && (mt(this, Ji, e), Dy(this, qc, CS).call(this));
  }
  get code() {
    return Y(this, Ji);
  }
  subscribe(e) {
    return by(this, ra)._++, Y(this, Ki)[Y(this, ra)] = e, Y(this, ra);
  }
  unsubscribe(e) {
    delete Y(this, Ki)[e];
  }
}
ol = new WeakMap(), Ji = new WeakMap(), Ki = new WeakMap(), ra = new WeakMap(), qc = new WeakSet(), CS = function() {
  for (let e in Y(this, Ki)) {
    const r = $M(Y(this, ol), Y(this, Ji), "grapper-view");
    setTimeout(() => Y(this, Ki)[e](r), 1);
  }
};
let Nd = [], ES = [];
(() => {
  let t = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
  for (let e = 0, r = 0; e < t.length; e++)
    (e % 2 ? ES : Nd).push(r = r + t[e]);
})();
function BM(t) {
  if (t < 768) return !1;
  for (let e = 0, r = Nd.length; ; ) {
    let s = e + r >> 1;
    if (t < Nd[s]) r = s;
    else if (t >= ES[s]) e = s + 1;
    else return !0;
    if (e == r) return !1;
  }
}
function $0(t) {
  return t >= 127462 && t <= 127487;
}
const Q0 = 8205;
function IM(t, e, r = !0, s = !0) {
  return (r ? TS : NM)(t, e, s);
}
function TS(t, e, r) {
  if (e == t.length) return e;
  e && kS(t.charCodeAt(e)) && PS(t.charCodeAt(e - 1)) && e--;
  let s = Dp(t, e);
  for (e += B0(s); e < t.length; ) {
    let i = Dp(t, e);
    if (s == Q0 || i == Q0 || r && BM(i))
      e += B0(i), s = i;
    else if ($0(i)) {
      let n = 0, a = e - 2;
      for (; a >= 0 && $0(Dp(t, a)); )
        n++, a -= 2;
      if (n % 2 == 0) break;
      e += 2;
    } else
      break;
  }
  return e;
}
function NM(t, e, r) {
  for (; e > 0; ) {
    let s = TS(t, e - 2, r);
    if (s < e) return s;
    e--;
  }
  return 0;
}
function Dp(t, e) {
  let r = t.charCodeAt(e);
  if (!PS(r) || e + 1 == t.length) return r;
  let s = t.charCodeAt(e + 1);
  return kS(s) ? (r - 55296 << 10) + (s - 56320) + 65536 : r;
}
function kS(t) {
  return t >= 56320 && t < 57344;
}
function PS(t) {
  return t >= 55296 && t < 56320;
}
function B0(t) {
  return t < 65536 ? 1 : 2;
}
class Se {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, r, s) {
    [e, r] = da(this, e, r);
    let i = [];
    return this.decompose(
      0,
      e,
      i,
      2
      /* Open.To */
    ), s.length && s.decompose(
      0,
      s.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      r,
      this.length,
      i,
      1
      /* Open.From */
    ), Kr.from(i, this.length - (r - e) + s.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, r = this.length) {
    [e, r] = da(this, e, r);
    let s = [];
    return this.decompose(e, r, s, 0), Kr.from(s, r - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let r = this.scanIdentical(e, 1), s = this.length - this.scanIdentical(e, -1), i = new Eo(this), n = new Eo(e);
    for (let a = r, l = r; ; ) {
      if (i.next(a), n.next(a), a = 0, i.lineBreak != n.lineBreak || i.done != n.done || i.value != n.value)
        return !1;
      if (l += i.value.length, i.done || l >= s)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Eo(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, r = this.length) {
    return new FS(this, e, r);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, r) {
    let s;
    if (e == null)
      s = this.iter();
    else {
      r == null && (r = this.lines + 1);
      let i = this.line(e).from;
      s = this.iterRange(i, Math.max(i, r == this.lines + 1 ? this.length : r <= 1 ? 0 : this.line(r - 1).to));
    }
    return new $S(s);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? Se.empty : e.length <= 32 ? new Je(e) : Kr.from(Je.split(e, []));
  }
}
class Je extends Se {
  constructor(e, r = MM(e)) {
    super(), this.text = e, this.length = r;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, r, s, i) {
    for (let n = 0; ; n++) {
      let a = this.text[n], l = i + a.length;
      if ((r ? s : l) >= e)
        return new LM(i, l, s, a);
      i = l + 1, s++;
    }
  }
  decompose(e, r, s, i) {
    let n = e <= 0 && r >= this.length ? this : new Je(I0(this.text, e, r), Math.min(r, this.length) - Math.max(0, e));
    if (i & 1) {
      let a = s.pop(), l = Iu(n.text, a.text.slice(), 0, n.length);
      if (l.length <= 32)
        s.push(new Je(l, a.length + n.length));
      else {
        let c = l.length >> 1;
        s.push(new Je(l.slice(0, c)), new Je(l.slice(c)));
      }
    } else
      s.push(n);
  }
  replace(e, r, s) {
    if (!(s instanceof Je))
      return super.replace(e, r, s);
    [e, r] = da(this, e, r);
    let i = Iu(this.text, Iu(s.text, I0(this.text, 0, e)), r), n = this.length + s.length - (r - e);
    return i.length <= 32 ? new Je(i, n) : Kr.from(Je.split(i, []), n);
  }
  sliceString(e, r = this.length, s = `
`) {
    [e, r] = da(this, e, r);
    let i = "";
    for (let n = 0, a = 0; n <= r && a < this.text.length; a++) {
      let l = this.text[a], c = n + l.length;
      n > e && a && (i += s), e < c && r > n && (i += l.slice(Math.max(0, e - n), r - n)), n = c + 1;
    }
    return i;
  }
  flatten(e) {
    for (let r of this.text)
      e.push(r);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, r) {
    let s = [], i = -1;
    for (let n of e)
      s.push(n), i += n.length + 1, s.length == 32 && (r.push(new Je(s, i)), s = [], i = -1);
    return i > -1 && r.push(new Je(s, i)), r;
  }
}
class Kr extends Se {
  constructor(e, r) {
    super(), this.children = e, this.length = r, this.lines = 0;
    for (let s of e)
      this.lines += s.lines;
  }
  lineInner(e, r, s, i) {
    for (let n = 0; ; n++) {
      let a = this.children[n], l = i + a.length, c = s + a.lines - 1;
      if ((r ? c : l) >= e)
        return a.lineInner(e, r, s, i);
      i = l + 1, s = c + 1;
    }
  }
  decompose(e, r, s, i) {
    for (let n = 0, a = 0; a <= r && n < this.children.length; n++) {
      let l = this.children[n], c = a + l.length;
      if (e <= c && r >= a) {
        let p = i & ((a <= e ? 1 : 0) | (c >= r ? 2 : 0));
        a >= e && c <= r && !p ? s.push(l) : l.decompose(e - a, r - a, s, p);
      }
      a = c + 1;
    }
  }
  replace(e, r, s) {
    if ([e, r] = da(this, e, r), s.lines < this.lines)
      for (let i = 0, n = 0; i < this.children.length; i++) {
        let a = this.children[i], l = n + a.length;
        if (e >= n && r <= l) {
          let c = a.replace(e - n, r - n, s), p = this.lines - a.lines + c.lines;
          if (c.lines < p >> 4 && c.lines > p >> 6) {
            let d = this.children.slice();
            return d[i] = c, new Kr(d, this.length - (r - e) + s.length);
          }
          return super.replace(n, l, c);
        }
        n = l + 1;
      }
    return super.replace(e, r, s);
  }
  sliceString(e, r = this.length, s = `
`) {
    [e, r] = da(this, e, r);
    let i = "";
    for (let n = 0, a = 0; n < this.children.length && a <= r; n++) {
      let l = this.children[n], c = a + l.length;
      a > e && n && (i += s), e < c && r > a && (i += l.sliceString(e - a, r - a, s)), a = c + 1;
    }
    return i;
  }
  flatten(e) {
    for (let r of this.children)
      r.flatten(e);
  }
  scanIdentical(e, r) {
    if (!(e instanceof Kr))
      return 0;
    let s = 0, [i, n, a, l] = r > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += r, n += r) {
      if (i == a || n == l)
        return s;
      let c = this.children[i], p = e.children[n];
      if (c != p)
        return s + c.scanIdentical(p, r);
      s += c.length + 1;
    }
  }
  static from(e, r = e.reduce((s, i) => s + i.length + 1, -1)) {
    let s = 0;
    for (let g of e)
      s += g.lines;
    if (s < 32) {
      let g = [];
      for (let x of e)
        x.flatten(g);
      return new Je(g, r);
    }
    let i = Math.max(
      32,
      s >> 5
      /* Tree.BranchShift */
    ), n = i << 1, a = i >> 1, l = [], c = 0, p = -1, d = [];
    function m(g) {
      let x;
      if (g.lines > n && g instanceof Kr)
        for (let v of g.children)
          m(v);
      else g.lines > a && (c > a || !c) ? (y(), l.push(g)) : g instanceof Je && c && (x = d[d.length - 1]) instanceof Je && g.lines + x.lines <= 32 ? (c += g.lines, p += g.length + 1, d[d.length - 1] = new Je(x.text.concat(g.text), x.length + 1 + g.length)) : (c + g.lines > i && y(), c += g.lines, p += g.length + 1, d.push(g));
    }
    function y() {
      c != 0 && (l.push(d.length == 1 ? d[0] : Kr.from(d, p)), p = -1, c = d.length = 0);
    }
    for (let g of e)
      m(g);
    return y(), l.length == 1 ? l[0] : new Kr(l, r);
  }
}
Se.empty = /* @__PURE__ */ new Je([""], 0);
function MM(t) {
  let e = -1;
  for (let r of t)
    e += r.length + 1;
  return e;
}
function Iu(t, e, r = 0, s = 1e9) {
  for (let i = 0, n = 0, a = !0; n < t.length && i <= s; n++) {
    let l = t[n], c = i + l.length;
    c >= r && (c > s && (l = l.slice(0, s - i)), i < r && (l = l.slice(r - i)), a ? (e[e.length - 1] += l, a = !1) : e.push(l)), i = c + 1;
  }
  return e;
}
function I0(t, e, r) {
  return Iu(t, [""], e, r);
}
class Eo {
  constructor(e, r = 1) {
    this.dir = r, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [r > 0 ? 1 : (e instanceof Je ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, r) {
    for (this.done = this.lineBreak = !1; ; ) {
      let s = this.nodes.length - 1, i = this.nodes[s], n = this.offsets[s], a = n >> 1, l = i instanceof Je ? i.text.length : i.children.length;
      if (a == (r > 0 ? l : 0)) {
        if (s == 0)
          return this.done = !0, this.value = "", this;
        r > 0 && this.offsets[s - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((n & 1) == (r > 0 ? 0 : 1)) {
        if (this.offsets[s] += r, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (i instanceof Je) {
        let c = i.text[a + (r < 0 ? -1 : 0)];
        if (this.offsets[s] += r, c.length > Math.max(0, e))
          return this.value = e == 0 ? c : r > 0 ? c.slice(e) : c.slice(0, c.length - e), this;
        e -= c.length;
      } else {
        let c = i.children[a + (r < 0 ? -1 : 0)];
        e > c.length ? (e -= c.length, this.offsets[s] += r) : (r < 0 && this.offsets[s]--, this.nodes.push(c), this.offsets.push(r > 0 ? 1 : (c instanceof Je ? c.text.length : c.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class FS {
  constructor(e, r, s) {
    this.value = "", this.done = !1, this.cursor = new Eo(e, r > s ? -1 : 1), this.pos = r > s ? e.length : 0, this.from = Math.min(r, s), this.to = Math.max(r, s);
  }
  nextInner(e, r) {
    if (r < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, r < 0 ? this.pos - this.to : this.from - this.pos);
    let s = r < 0 ? this.pos - this.from : this.to - this.pos;
    e > s && (e = s), s -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * r, this.value = i.length <= s ? i : r < 0 ? i.slice(i.length - s) : i.slice(0, s), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class $S {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: r, lineBreak: s, value: i } = this.inner.next(e);
    return r && this.afterBreak ? (this.value = "", this.afterBreak = !1) : r ? (this.done = !0, this.value = "") : s ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol != "undefined" && (Se.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Eo.prototype[Symbol.iterator] = FS.prototype[Symbol.iterator] = $S.prototype[Symbol.iterator] = function() {
  return this;
});
class LM {
  /**
  @internal
  */
  constructor(e, r, s, i) {
    this.from = e, this.to = r, this.number = s, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function da(t, e, r) {
  return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, r))];
}
function Dt(t, e, r = !0, s = !0) {
  return IM(t, e, r, s);
}
function _M(t) {
  return t >= 56320 && t < 57344;
}
function RM(t) {
  return t >= 55296 && t < 56320;
}
function Zt(t, e) {
  let r = t.charCodeAt(e);
  if (!RM(r) || e + 1 == t.length)
    return r;
  let s = t.charCodeAt(e + 1);
  return _M(s) ? (r - 55296 << 10) + (s - 56320) + 65536 : r;
}
function eg(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function es(t) {
  return t < 65536 ? 1 : 2;
}
const Md = /\r\n?|\n/;
var Ot = /* @__PURE__ */ function(t) {
  return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
}(Ot || (Ot = {}));
class cs {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2)
      e += this.sections[r];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2) {
      let s = this.sections[r + 1];
      e += s < 0 ? this.sections[r] : s;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let r = 0, s = 0, i = 0; r < this.sections.length; ) {
      let n = this.sections[r++], a = this.sections[r++];
      a < 0 ? (e(s, i, n), i += n) : i += a, s += n;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, r = !1) {
    Ld(this, e, r);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let r = 0; r < this.sections.length; ) {
      let s = this.sections[r++], i = this.sections[r++];
      i < 0 ? e.push(s, i) : e.push(i, s);
    }
    return new cs(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : QS(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(e, r = !1) {
    return e.empty ? this : _d(this, e, r);
  }
  mapPos(e, r = -1, s = Ot.Simple) {
    let i = 0, n = 0;
    for (let a = 0; a < this.sections.length; ) {
      let l = this.sections[a++], c = this.sections[a++], p = i + l;
      if (c < 0) {
        if (p > e)
          return n + (e - i);
        n += l;
      } else {
        if (s != Ot.Simple && p >= e && (s == Ot.TrackDel && i < e && p > e || s == Ot.TrackBefore && i < e || s == Ot.TrackAfter && p > e))
          return null;
        if (p > e || p == e && r < 0 && !l)
          return e == i || r < 0 ? n : n + c;
        n += c;
      }
      i = p;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return n;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, r = e) {
    for (let s = 0, i = 0; s < this.sections.length && i <= r; ) {
      let n = this.sections[s++], a = this.sections[s++], l = i + n;
      if (a >= 0 && i <= r && l >= e)
        return i < e && l > r ? "cover" : !0;
      i = l;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let r = 0; r < this.sections.length; ) {
      let s = this.sections[r++], i = this.sections[r++];
      e += (e ? " " : "") + s + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((r) => typeof r != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new cs(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new cs(e);
  }
}
class at extends cs {
  constructor(e, r) {
    super(e), this.inserted = r;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return Ld(this, (r, s, i, n, a) => e = e.replace(i, i + (s - r), a), !1), e;
  }
  mapDesc(e, r = !1) {
    return _d(this, e, r, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let r = this.sections.slice(), s = [];
    for (let i = 0, n = 0; i < r.length; i += 2) {
      let a = r[i], l = r[i + 1];
      if (l >= 0) {
        r[i] = l, r[i + 1] = a;
        let c = i >> 1;
        for (; s.length < c; )
          s.push(Se.empty);
        s.push(a ? e.slice(n, n + a) : Se.empty);
      }
      n += a;
    }
    return new at(r, s);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA`  `docB` and `other` represents `docB`  `docC`, the
  returned value will represent the change `docA`  `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : QS(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, r = !1) {
    return e.empty ? this : _d(this, e, r, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, r = !1) {
    Ld(this, e, r);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return cs.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let r = [], s = [], i = [], n = new jo(this);
    e: for (let a = 0, l = 0; ; ) {
      let c = a == e.length ? 1e9 : e[a++];
      for (; l < c || l == c && n.len == 0; ) {
        if (n.done)
          break e;
        let d = Math.min(n.len, c - l);
        Ct(i, d, -1);
        let m = n.ins == -1 ? -1 : n.off == 0 ? n.ins : 0;
        Ct(r, d, m), m > 0 && yi(s, r, n.text), n.forward(d), l += d;
      }
      let p = e[a++];
      for (; l < p; ) {
        if (n.done)
          break e;
        let d = Math.min(n.len, p - l);
        Ct(r, d, -1), Ct(i, d, n.ins == -1 ? -1 : n.off == 0 ? n.ins : 0), n.forward(d), l += d;
      }
    }
    return {
      changes: new at(r, s),
      filtered: cs.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let r = 0; r < this.sections.length; r += 2) {
      let s = this.sections[r], i = this.sections[r + 1];
      i < 0 ? e.push(s) : i == 0 ? e.push([s]) : e.push([s].concat(this.inserted[r >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, r, s) {
    let i = [], n = [], a = 0, l = null;
    function c(d = !1) {
      if (!d && !i.length)
        return;
      a < r && Ct(i, r - a, -1);
      let m = new at(i, n);
      l = l ? l.compose(m.map(l)) : m, i = [], n = [], a = 0;
    }
    function p(d) {
      if (Array.isArray(d))
        for (let m of d)
          p(m);
      else if (d instanceof at) {
        if (d.length != r)
          throw new RangeError(`Mismatched change set length (got ${d.length}, expected ${r})`);
        c(), l = l ? l.compose(d.map(l)) : d;
      } else {
        let { from: m, to: y = m, insert: g } = d;
        if (m > y || m < 0 || y > r)
          throw new RangeError(`Invalid change range ${m} to ${y} (in doc of length ${r})`);
        let x = g ? typeof g == "string" ? Se.of(g.split(s || Md)) : g : Se.empty, v = x.length;
        if (m == y && v == 0)
          return;
        m < a && c(), m > a && Ct(i, m - a, -1), Ct(i, y - m, v), yi(n, i, x), a = y;
      }
    }
    return p(e), c(!l), l;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new at(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let r = [], s = [];
    for (let i = 0; i < e.length; i++) {
      let n = e[i];
      if (typeof n == "number")
        r.push(n, -1);
      else {
        if (!Array.isArray(n) || typeof n[0] != "number" || n.some((a, l) => l && typeof a != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (n.length == 1)
          r.push(n[0], 0);
        else {
          for (; s.length < i; )
            s.push(Se.empty);
          s[i] = Se.of(n.slice(1)), r.push(n[0], s[i].length);
        }
      }
    }
    return new at(r, s);
  }
  /**
  @internal
  */
  static createSet(e, r) {
    return new at(e, r);
  }
}
function Ct(t, e, r, s = !1) {
  if (e == 0 && r <= 0)
    return;
  let i = t.length - 2;
  i >= 0 && r <= 0 && r == t[i + 1] ? t[i] += e : i >= 0 && e == 0 && t[i] == 0 ? t[i + 1] += r : s ? (t[i] += e, t[i + 1] += r) : t.push(e, r);
}
function yi(t, e, r) {
  if (r.length == 0)
    return;
  let s = e.length - 2 >> 1;
  if (s < t.length)
    t[t.length - 1] = t[t.length - 1].append(r);
  else {
    for (; t.length < s; )
      t.push(Se.empty);
    t.push(r);
  }
}
function Ld(t, e, r) {
  let s = t.inserted;
  for (let i = 0, n = 0, a = 0; a < t.sections.length; ) {
    let l = t.sections[a++], c = t.sections[a++];
    if (c < 0)
      i += l, n += l;
    else {
      let p = i, d = n, m = Se.empty;
      for (; p += l, d += c, c && s && (m = m.append(s[a - 2 >> 1])), !(r || a == t.sections.length || t.sections[a + 1] < 0); )
        l = t.sections[a++], c = t.sections[a++];
      e(i, p, n, d, m), i = p, n = d;
    }
  }
}
function _d(t, e, r, s = !1) {
  let i = [], n = s ? [] : null, a = new jo(t), l = new jo(e);
  for (let c = -1; ; ) {
    if (a.done && l.len || l.done && a.len)
      throw new Error("Mismatched change set lengths");
    if (a.ins == -1 && l.ins == -1) {
      let p = Math.min(a.len, l.len);
      Ct(i, p, -1), a.forward(p), l.forward(p);
    } else if (l.ins >= 0 && (a.ins < 0 || c == a.i || a.off == 0 && (l.len < a.len || l.len == a.len && !r))) {
      let p = l.len;
      for (Ct(i, l.ins, -1); p; ) {
        let d = Math.min(a.len, p);
        a.ins >= 0 && c < a.i && a.len <= d && (Ct(i, 0, a.ins), n && yi(n, i, a.text), c = a.i), a.forward(d), p -= d;
      }
      l.next();
    } else if (a.ins >= 0) {
      let p = 0, d = a.len;
      for (; d; )
        if (l.ins == -1) {
          let m = Math.min(d, l.len);
          p += m, d -= m, l.forward(m);
        } else if (l.ins == 0 && l.len < d)
          d -= l.len, l.next();
        else
          break;
      Ct(i, p, c < a.i ? a.ins : 0), n && c < a.i && yi(n, i, a.text), c = a.i, a.forward(a.len - d);
    } else {
      if (a.done && l.done)
        return n ? at.createSet(i, n) : cs.create(i);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function QS(t, e, r = !1) {
  let s = [], i = r ? [] : null, n = new jo(t), a = new jo(e);
  for (let l = !1; ; ) {
    if (n.done && a.done)
      return i ? at.createSet(s, i) : cs.create(s);
    if (n.ins == 0)
      Ct(s, n.len, 0, l), n.next();
    else if (a.len == 0 && !a.done)
      Ct(s, 0, a.ins, l), i && yi(i, s, a.text), a.next();
    else {
      if (n.done || a.done)
        throw new Error("Mismatched change set lengths");
      {
        let c = Math.min(n.len2, a.len), p = s.length;
        if (n.ins == -1) {
          let d = a.ins == -1 ? -1 : a.off ? 0 : a.ins;
          Ct(s, c, d, l), i && d && yi(i, s, a.text);
        } else a.ins == -1 ? (Ct(s, n.off ? 0 : n.len, c, l), i && yi(i, s, n.textBit(c))) : (Ct(s, n.off ? 0 : n.len, a.off ? 0 : a.ins, l), i && !a.off && yi(i, s, a.text));
        l = (n.ins > c || a.ins >= 0 && a.len > c) && (l || s.length > p), n.forward2(c), a.forward(c);
      }
    }
  }
}
class jo {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, r = this.i - 2 >> 1;
    return r >= e.length ? Se.empty : e[r];
  }
  textBit(e) {
    let { inserted: r } = this.set, s = this.i - 2 >> 1;
    return s >= r.length && !e ? Se.empty : r[s].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class Gi {
  constructor(e, r, s) {
    this.from = e, this.to = r, this.flags = s;
  }
  /**
  The anchor of the rangethe side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, r = -1) {
    let s, i;
    return this.empty ? s = i = e.mapPos(this.from, r) : (s = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), s == this.from && i == this.to ? this : new Gi(s, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, r = e) {
    if (e <= this.anchor && r >= this.anchor)
      return L.range(e, r);
    let s = Math.abs(e - this.anchor) > Math.abs(r - this.anchor) ? e : r;
    return L.range(this.anchor, s);
  }
  /**
  Compare this range to another range.
  */
  eq(e, r = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!r || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return L.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, r, s) {
    return new Gi(e, r, s);
  }
}
class L {
  constructor(e, r) {
    this.ranges = e, this.mainIndex = r;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, r = -1) {
    return e.empty ? this : L.create(this.ranges.map((s) => s.map(e, r)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, r = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let s = 0; s < this.ranges.length; s++)
      if (!this.ranges[s].eq(e.ranges[s], r))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new L([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, r = !0) {
    return L.create([e].concat(this.ranges), r ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, r = this.mainIndex) {
    let s = this.ranges.slice();
    return s[r] = e, L.create(s, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new L(e.ranges.map((r) => Gi.fromJSON(r)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, r = e) {
    return new L([L.range(e, r)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, r = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let s = 0, i = 0; i < e.length; i++) {
      let n = e[i];
      if (n.empty ? n.from <= s : n.from < s)
        return L.normalized(e.slice(), r);
      s = n.to;
    }
    return new L(e, r);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, r = 0, s, i) {
    return Gi.create(e, e, (r == 0 ? 0 : r < 0 ? 8 : 16) | (s == null ? 7 : Math.min(6, s)) | (i != null ? i : 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, r, s, i) {
    let n = (s != null ? s : 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return r < e ? Gi.create(r, e, 48 | n) : Gi.create(e, r, (r > e ? 8 : 0) | n);
  }
  /**
  @internal
  */
  static normalized(e, r = 0) {
    let s = e[r];
    e.sort((i, n) => i.from - n.from), r = e.indexOf(s);
    for (let i = 1; i < e.length; i++) {
      let n = e[i], a = e[i - 1];
      if (n.empty ? n.from <= a.to : n.from < a.to) {
        let l = a.from, c = Math.max(n.to, a.to);
        i <= r && r--, e.splice(--i, 2, n.anchor > n.head ? L.range(c, l) : L.range(l, c));
      }
    }
    return new L(e, r);
  }
}
function BS(t, e) {
  for (let r of t.ranges)
    if (r.to > e)
      throw new RangeError("Selection points outside of document");
}
let tg = 0;
class re {
  constructor(e, r, s, i, n) {
    this.combine = e, this.compareInput = r, this.compare = s, this.isStatic = i, this.id = tg++, this.default = e([]), this.extensions = typeof n == "function" ? n(this) : n;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new re(e.combine || ((r) => r), e.compareInput || ((r, s) => r === s), e.compare || (e.combine ? (r, s) => r === s : rg), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new Nu([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Nu(e, this, 1, r);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Nu(e, this, 2, r);
  }
  from(e, r) {
    return r || (r = (s) => s), this.compute([e], (s) => r(s.field(e)));
  }
}
function rg(t, e) {
  return t == e || t.length == e.length && t.every((r, s) => r === e[s]);
}
class Nu {
  constructor(e, r, s, i) {
    this.dependencies = e, this.facet = r, this.type = s, this.value = i, this.id = tg++;
  }
  dynamicSlot(e) {
    var r;
    let s = this.value, i = this.facet.compareInput, n = this.id, a = e[n] >> 1, l = this.type == 2, c = !1, p = !1, d = [];
    for (let m of this.dependencies)
      m == "doc" ? c = !0 : m == "selection" ? p = !0 : (((r = e[m.id]) !== null && r !== void 0 ? r : 1) & 1) == 0 && d.push(e[m.id]);
    return {
      create(m) {
        return m.values[a] = s(m), 1;
      },
      update(m, y) {
        if (c && y.docChanged || p && (y.docChanged || y.selection) || Rd(m, d)) {
          let g = s(m);
          if (l ? !N0(g, m.values[a], i) : !i(g, m.values[a]))
            return m.values[a] = g, 1;
        }
        return 0;
      },
      reconfigure: (m, y) => {
        let g, x = y.config.address[n];
        if (x != null) {
          let v = pc(y, x);
          if (this.dependencies.every((w) => w instanceof re ? y.facet(w) === m.facet(w) : w instanceof ut ? y.field(w, !1) == m.field(w, !1) : !0) || (l ? N0(g = s(m), v, i) : i(g = s(m), v)))
            return m.values[a] = v, 0;
        } else
          g = s(m);
        return m.values[a] = g, 1;
      }
    };
  }
}
function N0(t, e, r) {
  if (t.length != e.length)
    return !1;
  for (let s = 0; s < t.length; s++)
    if (!r(t[s], e[s]))
      return !1;
  return !0;
}
function Rd(t, e) {
  let r = !1;
  for (let s of e)
    To(t, s) & 1 && (r = !0);
  return r;
}
function qM(t, e, r) {
  let s = r.map((c) => t[c.id]), i = r.map((c) => c.type), n = s.filter((c) => !(c & 1)), a = t[e.id] >> 1;
  function l(c) {
    let p = [];
    for (let d = 0; d < s.length; d++) {
      let m = pc(c, s[d]);
      if (i[d] == 2)
        for (let y of m)
          p.push(y);
      else
        p.push(m);
    }
    return e.combine(p);
  }
  return {
    create(c) {
      for (let p of s)
        To(c, p);
      return c.values[a] = l(c), 1;
    },
    update(c, p) {
      if (!Rd(c, n))
        return 0;
      let d = l(c);
      return e.compare(d, c.values[a]) ? 0 : (c.values[a] = d, 1);
    },
    reconfigure(c, p) {
      let d = Rd(c, s), m = p.config.facets[e.id], y = p.facet(e);
      if (m && !d && rg(r, m))
        return c.values[a] = y, 0;
      let g = l(c);
      return e.compare(g, y) ? (c.values[a] = y, 0) : (c.values[a] = g, 1);
    }
  };
}
const ru = /* @__PURE__ */ re.define({ static: !0 });
class ut {
  constructor(e, r, s, i, n) {
    this.id = e, this.createF = r, this.updateF = s, this.compareF = i, this.spec = n, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let r = new ut(tg++, e.create, e.update, e.compare || ((s, i) => s === i), e);
    return e.provide && (r.provides = e.provide(r)), r;
  }
  create(e) {
    let r = e.facet(ru).find((s) => s.field == this);
    return ((r == null ? void 0 : r.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let r = e[this.id] >> 1;
    return {
      create: (s) => (s.values[r] = this.create(s), 1),
      update: (s, i) => {
        let n = s.values[r], a = this.updateF(n, i);
        return this.compareF(n, a) ? 0 : (s.values[r] = a, 1);
      },
      reconfigure: (s, i) => {
        let n = s.facet(ru), a = i.facet(ru), l;
        return (l = n.find((c) => c.field == this)) && l != a.find((c) => c.field == this) ? (s.values[r] = l.create(s), 1) : i.config.address[this.id] != null ? (s.values[r] = i.field(this), 0) : (s.values[r] = this.create(s), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, ru.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Vi = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function eo(t) {
  return (e) => new IS(e, t);
}
const Li = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ eo(Vi.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ eo(Vi.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ eo(Vi.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ eo(Vi.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ eo(Vi.lowest)
};
class IS {
  constructor(e, r) {
    this.inner = e, this.prec = r;
  }
}
class Na {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new qd(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Na.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class qd {
  constructor(e, r) {
    this.compartment = e, this.inner = r;
  }
}
class hc {
  constructor(e, r, s, i, n, a) {
    for (this.base = e, this.compartments = r, this.dynamicSlots = s, this.address = i, this.staticValues = n, this.facets = a, this.statusTemplate = []; this.statusTemplate.length < s.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let r = this.address[e.id];
    return r == null ? e.default : this.staticValues[r >> 1];
  }
  static resolve(e, r, s) {
    let i = [], n = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ new Map();
    for (let y of jM(e, r, a))
      y instanceof ut ? i.push(y) : (n[y.facet.id] || (n[y.facet.id] = [])).push(y);
    let l = /* @__PURE__ */ Object.create(null), c = [], p = [];
    for (let y of i)
      l[y.id] = p.length << 1, p.push((g) => y.slot(g));
    let d = s == null ? void 0 : s.config.facets;
    for (let y in n) {
      let g = n[y], x = g[0].facet, v = d && d[y] || [];
      if (g.every(
        (w) => w.type == 0
        /* Provider.Static */
      ))
        if (l[x.id] = c.length << 1 | 1, rg(v, g))
          c.push(s.facet(x));
        else {
          let w = x.combine(g.map((C) => C.value));
          c.push(s && x.compare(w, s.facet(x)) ? s.facet(x) : w);
        }
      else {
        for (let w of g)
          w.type == 0 ? (l[w.id] = c.length << 1 | 1, c.push(w.value)) : (l[w.id] = p.length << 1, p.push((C) => w.dynamicSlot(C)));
        l[x.id] = p.length << 1, p.push((w) => qM(w, x, g));
      }
    }
    let m = p.map((y) => y(l));
    return new hc(e, a, m, l, c, n);
  }
}
function jM(t, e, r) {
  let s = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function n(a, l) {
    let c = i.get(a);
    if (c != null) {
      if (c <= l)
        return;
      let p = s[c].indexOf(a);
      p > -1 && s[c].splice(p, 1), a instanceof qd && r.delete(a.compartment);
    }
    if (i.set(a, l), Array.isArray(a))
      for (let p of a)
        n(p, l);
    else if (a instanceof qd) {
      if (r.has(a.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let p = e.get(a.compartment) || a.inner;
      r.set(a.compartment, p), n(p, l);
    } else if (a instanceof IS)
      n(a.inner, a.prec);
    else if (a instanceof ut)
      s[l].push(a), a.provides && n(a.provides, l);
    else if (a instanceof Nu)
      s[l].push(a), a.facet.extensions && n(a.facet.extensions, Vi.default);
    else {
      let p = a.extension;
      if (!p)
        throw new Error(`Unrecognized extension value in extension set (${a}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      n(p, l);
    }
  }
  return n(t, Vi.default), s.reduce((a, l) => a.concat(l));
}
function To(t, e) {
  if (e & 1)
    return 2;
  let r = e >> 1, s = t.status[r];
  if (s == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (s & 2)
    return s;
  t.status[r] = 4;
  let i = t.computeSlot(t, t.config.dynamicSlots[r]);
  return t.status[r] = 2 | i;
}
function pc(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const NS = /* @__PURE__ */ re.define(), jd = /* @__PURE__ */ re.define({
  combine: (t) => t.some((e) => e),
  static: !0
}), MS = /* @__PURE__ */ re.define({
  combine: (t) => t.length ? t[0] : void 0,
  static: !0
}), LS = /* @__PURE__ */ re.define(), _S = /* @__PURE__ */ re.define(), RS = /* @__PURE__ */ re.define(), qS = /* @__PURE__ */ re.define({
  combine: (t) => t.length ? t[0] : !1
});
class Ks {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new XM();
  }
}
class XM {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new Ks(this, e);
  }
}
class ZM {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new pe(this, e);
  }
}
class pe {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let r = this.type.map(this.value, e);
    return r === void 0 ? void 0 : r == this.value ? this : new pe(this.type, r);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new ZM(e.map || ((r) => r));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, r) {
    if (!e.length)
      return e;
    let s = [];
    for (let i of e) {
      let n = i.map(r);
      n && s.push(n);
    }
    return s;
  }
}
pe.reconfigure = /* @__PURE__ */ pe.define();
pe.appendConfig = /* @__PURE__ */ pe.define();
class tt {
  constructor(e, r, s, i, n, a) {
    this.startState = e, this.changes = r, this.selection = s, this.effects = i, this.annotations = n, this.scrollIntoView = a, this._doc = null, this._state = null, s && BS(s, r.newLength), n.some((l) => l.type == tt.time) || (this.annotations = n.concat(tt.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, r, s, i, n, a) {
    return new tt(e, r, s, i, n, a);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let r of this.annotations)
      if (r.type == e)
        return r.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let r = this.annotation(tt.userEvent);
    return !!(r && (r == e || r.length > e.length && r.slice(0, e.length) == e && r[e.length] == "."));
  }
}
tt.time = /* @__PURE__ */ Ks.define();
tt.userEvent = /* @__PURE__ */ Ks.define();
tt.addToHistory = /* @__PURE__ */ Ks.define();
tt.remote = /* @__PURE__ */ Ks.define();
function VM(t, e) {
  let r = [];
  for (let s = 0, i = 0; ; ) {
    let n, a;
    if (s < t.length && (i == e.length || e[i] >= t[s]))
      n = t[s++], a = t[s++];
    else if (i < e.length)
      n = e[i++], a = e[i++];
    else
      return r;
    !r.length || r[r.length - 1] < n ? r.push(n, a) : r[r.length - 1] < a && (r[r.length - 1] = a);
  }
}
function jS(t, e, r) {
  var s;
  let i, n, a;
  return r ? (i = e.changes, n = at.empty(e.changes.length), a = t.changes.compose(e.changes)) : (i = e.changes.map(t.changes), n = t.changes.mapDesc(e.changes, !0), a = t.changes.compose(i)), {
    changes: a,
    selection: e.selection ? e.selection.map(n) : (s = t.selection) === null || s === void 0 ? void 0 : s.map(i),
    effects: pe.mapEffects(t.effects, i).concat(pe.mapEffects(e.effects, n)),
    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t.scrollIntoView || e.scrollIntoView
  };
}
function Xd(t, e, r) {
  let s = e.selection, i = Gn(e.annotations);
  return e.userEvent && (i = i.concat(tt.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof at ? e.changes : at.of(e.changes || [], r, t.facet(MS)),
    selection: s && (s instanceof L ? s : L.single(s.anchor, s.head)),
    effects: Gn(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function XS(t, e, r) {
  let s = Xd(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (r = !1);
  for (let n = 1; n < e.length; n++) {
    e[n].filter === !1 && (r = !1);
    let a = !!e[n].sequential;
    s = jS(s, Xd(t, e[n], a ? s.changes.newLength : t.doc.length), a);
  }
  let i = tt.create(t, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
  return UM(r ? zM(i) : i);
}
function zM(t) {
  let e = t.startState, r = !0;
  for (let i of e.facet(LS)) {
    let n = i(t);
    if (n === !1) {
      r = !1;
      break;
    }
    Array.isArray(n) && (r = r === !0 ? n : VM(r, n));
  }
  if (r !== !0) {
    let i, n;
    if (r === !1)
      n = t.changes.invertedDesc, i = at.empty(e.doc.length);
    else {
      let a = t.changes.filter(r);
      i = a.changes, n = a.filtered.mapDesc(a.changes).invertedDesc;
    }
    t = tt.create(e, i, t.selection && t.selection.map(n), pe.mapEffects(t.effects, n), t.annotations, t.scrollIntoView);
  }
  let s = e.facet(_S);
  for (let i = s.length - 1; i >= 0; i--) {
    let n = s[i](t);
    n instanceof tt ? t = n : Array.isArray(n) && n.length == 1 && n[0] instanceof tt ? t = n[0] : t = XS(e, Gn(n), !1);
  }
  return t;
}
function UM(t) {
  let e = t.startState, r = e.facet(RS), s = t;
  for (let i = r.length - 1; i >= 0; i--) {
    let n = r[i](t);
    n && Object.keys(n).length && (s = jS(s, Xd(e, n, t.changes.newLength), !0));
  }
  return s == t ? t : tt.create(e, t.changes, t.selection, s.effects, s.annotations, s.scrollIntoView);
}
const YM = [];
function Gn(t) {
  return t == null ? YM : Array.isArray(t) ? t : [t];
}
var Xe = /* @__PURE__ */ function(t) {
  return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
}(Xe || (Xe = {}));
const WM = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Zd;
try {
  Zd = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function GM(t) {
  if (Zd)
    return Zd.test(t);
  for (let e = 0; e < t.length; e++) {
    let r = t[e];
    if (/\w/.test(r) || r > "" && (r.toUpperCase() != r.toLowerCase() || WM.test(r)))
      return !0;
  }
  return !1;
}
function HM(t) {
  return (e) => {
    if (!/\S/.test(e))
      return Xe.Space;
    if (GM(e))
      return Xe.Word;
    for (let r = 0; r < t.length; r++)
      if (e.indexOf(t[r]) > -1)
        return Xe.Word;
    return Xe.Other;
  };
}
class we {
  constructor(e, r, s, i, n, a) {
    this.config = e, this.doc = r, this.selection = s, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = n, a && (a._state = this);
    for (let l = 0; l < this.config.dynamicSlots.length; l++)
      To(this, l << 1);
    this.computeSlot = null;
  }
  field(e, r = !0) {
    let s = this.config.address[e.id];
    if (s == null) {
      if (r)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return To(this, s), pc(this, s);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return XS(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let r = this.config, { base: s, compartments: i } = r;
    for (let l of e.effects)
      l.is(Na.reconfigure) ? (r && (i = /* @__PURE__ */ new Map(), r.compartments.forEach((c, p) => i.set(p, c)), r = null), i.set(l.value.compartment, l.value.extension)) : l.is(pe.reconfigure) ? (r = null, s = l.value) : l.is(pe.appendConfig) && (r = null, s = Gn(s).concat(l.value));
    let n;
    r ? n = e.startState.values.slice() : (r = hc.resolve(s, i, this), n = new we(r, this.doc, this.selection, r.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values);
    let a = e.startState.facet(jd) ? e.newSelection : e.newSelection.asSingle();
    new we(r, e.newDoc, a, n, (l, c) => c.update(l, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((r) => ({
      changes: { from: r.from, to: r.to, insert: e },
      range: L.cursor(r.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let r = this.selection, s = e(r.ranges[0]), i = this.changes(s.changes), n = [s.range], a = Gn(s.effects);
    for (let l = 1; l < r.ranges.length; l++) {
      let c = e(r.ranges[l]), p = this.changes(c.changes), d = p.map(i);
      for (let y = 0; y < l; y++)
        n[y] = n[y].map(d);
      let m = i.mapDesc(p, !0);
      n.push(c.range.map(m)), i = i.compose(d), a = pe.mapEffects(a, d).concat(pe.mapEffects(Gn(c.effects), m));
    }
    return {
      changes: i,
      selection: L.create(n, r.mainIndex),
      effects: a
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof at ? e : at.of(e, this.doc.length, this.facet(we.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return Se.of(e.split(this.facet(we.lineSeparator) || Md));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, r = this.doc.length) {
    return this.doc.sliceString(e, r, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let r = this.config.address[e.id];
    return r == null ? e.default : (To(this, r), pc(this, r));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let r = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let s in e) {
        let i = e[s];
        i instanceof ut && this.config.address[i.id] != null && (r[s] = i.spec.toJSON(this.field(e[s]), this));
      }
    return r;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, r = {}, s) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (s) {
      for (let n in s)
        if (Object.prototype.hasOwnProperty.call(e, n)) {
          let a = s[n], l = e[n];
          i.push(a.init((c) => a.spec.fromJSON(l, c)));
        }
    }
    return we.create({
      doc: e.doc,
      selection: L.fromJSON(e.selection),
      extensions: r.extensions ? i.concat([r.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorupdated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let r = hc.resolve(e.extensions || [], /* @__PURE__ */ new Map()), s = e.doc instanceof Se ? e.doc : Se.of((e.doc || "").split(r.staticFacet(we.lineSeparator) || Md)), i = e.selection ? e.selection instanceof L ? e.selection : L.single(e.selection.anchor, e.selection.head) : L.single(0);
    return BS(i, s.length), r.staticFacet(jd) || (i = i.asSingle()), new we(r, s, i, r.dynamicSlots.map(() => null), (n, a) => a.create(n), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(we.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(we.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(qS);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...r) {
    for (let s of this.facet(we.phrases))
      if (Object.prototype.hasOwnProperty.call(s, e)) {
        e = s[e];
        break;
      }
    return r.length && (e = e.replace(/\$(\$|\d*)/g, (s, i) => {
      if (i == "$")
        return "$";
      let n = +(i || 1);
      return !n || n > r.length ? s : r[n - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, r, s = -1) {
    let i = [];
    for (let n of this.facet(NS))
      for (let a of n(this, r, s))
        Object.prototype.hasOwnProperty.call(a, e) && i.push(a[e]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return HM(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: r, from: s, length: i } = this.doc.lineAt(e), n = this.charCategorizer(e), a = e - s, l = e - s;
    for (; a > 0; ) {
      let c = Dt(r, a, !1);
      if (n(r.slice(c, a)) != Xe.Word)
        break;
      a = c;
    }
    for (; l < i; ) {
      let c = Dt(r, l);
      if (n(r.slice(l, c)) != Xe.Word)
        break;
      l = c;
    }
    return a == l ? null : L.range(a + s, l + s);
  }
}
we.allowMultipleSelections = jd;
we.tabSize = /* @__PURE__ */ re.define({
  combine: (t) => t.length ? t[0] : 4
});
we.lineSeparator = MS;
we.readOnly = qS;
we.phrases = /* @__PURE__ */ re.define({
  compare(t, e) {
    let r = Object.keys(t), s = Object.keys(e);
    return r.length == s.length && r.every((i) => t[i] == e[i]);
  }
});
we.languageData = NS;
we.changeFilter = LS;
we.transactionFilter = _S;
we.transactionExtender = RS;
Na.reconfigure = /* @__PURE__ */ pe.define();
function Os(t, e, r = {}) {
  let s = {};
  for (let i of t)
    for (let n of Object.keys(i)) {
      let a = i[n], l = s[n];
      if (l === void 0)
        s[n] = a;
      else if (!(l === a || a === void 0)) if (Object.hasOwnProperty.call(r, n))
        s[n] = r[n](l, a);
      else
        throw new Error("Config merge conflict for field " + n);
    }
  for (let i in e)
    s[i] === void 0 && (s[i] = e[i]);
  return s;
}
class dn {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, r = e) {
    return Vd.create(e, r, this);
  }
}
dn.prototype.startSide = dn.prototype.endSide = 0;
dn.prototype.point = !1;
dn.prototype.mapMode = Ot.TrackDel;
let Vd = class ZS {
  constructor(e, r, s) {
    this.from = e, this.to = r, this.value = s;
  }
  /**
  @internal
  */
  static create(e, r, s) {
    return new ZS(e, r, s);
  }
};
function zd(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
class sg {
  constructor(e, r, s, i) {
    this.from = e, this.to = r, this.value = s, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, r, s, i = 0) {
    let n = s ? this.to : this.from;
    for (let a = i, l = n.length; ; ) {
      if (a == l)
        return a;
      let c = a + l >> 1, p = n[c] - e || (s ? this.value[c].endSide : this.value[c].startSide) - r;
      if (c == a)
        return p >= 0 ? a : l;
      p >= 0 ? l = c : a = c + 1;
    }
  }
  between(e, r, s, i) {
    for (let n = this.findIndex(r, -1e9, !0), a = this.findIndex(s, 1e9, !1, n); n < a; n++)
      if (i(this.from[n] + e, this.to[n] + e, this.value[n]) === !1)
        return !1;
  }
  map(e, r) {
    let s = [], i = [], n = [], a = -1, l = -1;
    for (let c = 0; c < this.value.length; c++) {
      let p = this.value[c], d = this.from[c] + e, m = this.to[c] + e, y, g;
      if (d == m) {
        let x = r.mapPos(d, p.startSide, p.mapMode);
        if (x == null || (y = g = x, p.startSide != p.endSide && (g = r.mapPos(d, p.endSide), g < y)))
          continue;
      } else if (y = r.mapPos(d, p.startSide), g = r.mapPos(m, p.endSide), y > g || y == g && p.startSide > 0 && p.endSide <= 0)
        continue;
      (g - y || p.endSide - p.startSide) < 0 || (a < 0 && (a = y), p.point && (l = Math.max(l, g - y)), s.push(p), i.push(y - a), n.push(g - a));
    }
    return { mapped: s.length ? new sg(i, n, s, l) : null, pos: a };
  }
}
class Ce {
  constructor(e, r, s, i) {
    this.chunkPos = e, this.chunk = r, this.nextLayer = s, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(e, r, s, i) {
    return new Ce(e, r, s, i);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let r of this.chunk)
      e += r.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: r = [], sort: s = !1, filterFrom: i = 0, filterTo: n = this.length } = e, a = e.filter;
    if (r.length == 0 && !a)
      return this;
    if (s && (r = r.slice().sort(zd)), this.isEmpty)
      return r.length ? Ce.of(r) : this;
    let l = new VS(this, null, -1).goto(0), c = 0, p = [], d = new _s();
    for (; l.value || c < r.length; )
      if (c < r.length && (l.from - r[c].from || l.startSide - r[c].value.startSide) >= 0) {
        let m = r[c++];
        d.addInner(m.from, m.to, m.value) || p.push(m);
      } else l.rangeIndex == 1 && l.chunkIndex < this.chunk.length && (c == r.length || this.chunkEnd(l.chunkIndex) < r[c].from) && (!a || i > this.chunkEnd(l.chunkIndex) || n < this.chunkPos[l.chunkIndex]) && d.addChunk(this.chunkPos[l.chunkIndex], this.chunk[l.chunkIndex]) ? l.nextChunk() : ((!a || i > l.to || n < l.from || a(l.from, l.to, l.value)) && (d.addInner(l.from, l.to, l.value) || p.push(Vd.create(l.from, l.to, l.value))), l.next());
    return d.finishInner(this.nextLayer.isEmpty && !p.length ? Ce.empty : this.nextLayer.update({ add: p, filter: a, filterFrom: i, filterTo: n }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let r = [], s = [], i = -1;
    for (let a = 0; a < this.chunk.length; a++) {
      let l = this.chunkPos[a], c = this.chunk[a], p = e.touchesRange(l, l + c.length);
      if (p === !1)
        i = Math.max(i, c.maxPoint), r.push(c), s.push(e.mapPos(l));
      else if (p === !0) {
        let { mapped: d, pos: m } = c.map(l, e);
        d && (i = Math.max(i, d.maxPoint), r.push(d), s.push(m));
      }
    }
    let n = this.nextLayer.map(e);
    return r.length == 0 ? n : new Ce(s, r, n || Ce.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, r, s) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let n = this.chunkPos[i], a = this.chunk[i];
        if (r >= n && e <= n + a.length && a.between(n, e - n, r - n, s) === !1)
          return;
      }
      this.nextLayer.between(e, r, s);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return Xo.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, r = 0) {
    return Xo.from(e).goto(r);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, r, s, i, n = -1) {
    let a = e.filter((m) => m.maxPoint > 0 || !m.isEmpty && m.maxPoint >= n), l = r.filter((m) => m.maxPoint > 0 || !m.isEmpty && m.maxPoint >= n), c = M0(a, l, s), p = new to(a, c, n), d = new to(l, c, n);
    s.iterGaps((m, y, g) => L0(p, m, d, y, g, i)), s.empty && s.length == 0 && L0(p, 0, d, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, r, s = 0, i) {
    i == null && (i = 999999999);
    let n = e.filter((d) => !d.isEmpty && r.indexOf(d) < 0), a = r.filter((d) => !d.isEmpty && e.indexOf(d) < 0);
    if (n.length != a.length)
      return !1;
    if (!n.length)
      return !0;
    let l = M0(n, a), c = new to(n, l, 0).goto(s), p = new to(a, l, 0).goto(s);
    for (; ; ) {
      if (c.to != p.to || !Ud(c.active, p.active) || c.point && (!p.point || !c.point.eq(p.point)))
        return !1;
      if (c.to > i)
        return !0;
      c.next(), p.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, r, s, i, n = -1) {
    let a = new to(e, null, n).goto(r), l = r, c = a.openStart;
    for (; ; ) {
      let p = Math.min(a.to, s);
      if (a.point) {
        let d = a.activeForPoint(a.to), m = a.pointFrom < r ? d.length + 1 : a.point.startSide < 0 ? d.length : Math.min(d.length, c);
        i.point(l, p, a.point, d, m, a.pointRank), c = Math.min(a.openEnd(p), d.length);
      } else p > l && (i.span(l, p, a.active, c), c = a.openEnd(p));
      if (a.to > s)
        return c + (a.point && a.to > s ? 1 : 0);
      l = a.to, a.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, r = !1) {
    let s = new _s();
    for (let i of e instanceof Vd ? [e] : r ? JM(e) : e)
      s.add(i.from, i.to, i.value);
    return s.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return Ce.empty;
    let r = e[e.length - 1];
    for (let s = e.length - 2; s >= 0; s--)
      for (let i = e[s]; i != Ce.empty; i = i.nextLayer)
        r = new Ce(i.chunkPos, i.chunk, r, Math.max(i.maxPoint, r.maxPoint));
    return r;
  }
}
Ce.empty = /* @__PURE__ */ new Ce([], [], null, -1);
function JM(t) {
  if (t.length > 1)
    for (let e = t[0], r = 1; r < t.length; r++) {
      let s = t[r];
      if (zd(e, s) > 0)
        return t.slice().sort(zd);
      e = s;
    }
  return t;
}
Ce.empty.nextLayer = Ce.empty;
class _s {
  finishChunk(e) {
    this.chunks.push(new sg(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, r, s) {
    this.addInner(e, r, s) || (this.nextLayer || (this.nextLayer = new _s())).add(e, r, s);
  }
  /**
  @internal
  */
  addInner(e, r, s) {
    let i = e - this.lastTo || s.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || s.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(r - this.chunkStart), this.last = s, this.lastFrom = e, this.lastTo = r, this.value.push(s), s.point && (this.maxPoint = Math.max(this.maxPoint, r - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, r) {
    if ((e - this.lastTo || r.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, r.maxPoint), this.chunks.push(r), this.chunkPos.push(e);
    let s = r.value.length - 1;
    return this.last = r.value[s], this.lastFrom = r.from[s] + e, this.lastTo = r.to[s] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(Ce.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let r = Ce.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, r;
  }
}
function M0(t, e, r) {
  let s = /* @__PURE__ */ new Map();
  for (let n of t)
    for (let a = 0; a < n.chunk.length; a++)
      n.chunk[a].maxPoint <= 0 && s.set(n.chunk[a], n.chunkPos[a]);
  let i = /* @__PURE__ */ new Set();
  for (let n of e)
    for (let a = 0; a < n.chunk.length; a++) {
      let l = s.get(n.chunk[a]);
      l != null && (r ? r.mapPos(l) : l) == n.chunkPos[a] && !(r != null && r.touchesRange(l, l + n.chunk[a].length)) && i.add(n.chunk[a]);
    }
  return i;
}
class VS {
  constructor(e, r, s, i = 0) {
    this.layer = e, this.skip = r, this.minPoint = s, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, r = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, r, !1), this;
  }
  gotoInner(e, r, s) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, s = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], r, !0);
      (!s || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, r) {
    (this.to - e || this.endSide - r) < 0 && this.gotoInner(e, r, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], r = this.layer.chunk[this.chunkIndex], s = e + r.from[this.rangeIndex];
        if (this.from = s, this.to = e + r.to[this.rangeIndex], this.value = r.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Xo {
  constructor(e) {
    this.heap = e;
  }
  static from(e, r = null, s = -1) {
    let i = [];
    for (let n = 0; n < e.length; n++)
      for (let a = e[n]; !a.isEmpty; a = a.nextLayer)
        a.maxPoint >= s && i.push(new VS(a, r, s, n));
    return i.length == 1 ? i[0] : new Xo(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, r = -1e9) {
    for (let s of this.heap)
      s.goto(e, r);
    for (let s = this.heap.length >> 1; s >= 0; s--)
      bp(this.heap, s);
    return this.next(), this;
  }
  forward(e, r) {
    for (let s of this.heap)
      s.forward(e, r);
    for (let s = this.heap.length >> 1; s >= 0; s--)
      bp(this.heap, s);
    (this.to - e || this.value.endSide - r) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), bp(this.heap, 0);
    }
  }
}
function bp(t, e) {
  for (let r = t[e]; ; ) {
    let s = (e << 1) + 1;
    if (s >= t.length)
      break;
    let i = t[s];
    if (s + 1 < t.length && i.compare(t[s + 1]) >= 0 && (i = t[s + 1], s++), r.compare(i) < 0)
      break;
    t[s] = r, t[e] = i, e = s;
  }
}
class to {
  constructor(e, r, s) {
    this.minPoint = s, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Xo.from(e, r, s);
  }
  goto(e, r = -1e9) {
    return this.cursor.goto(e, r), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = r, this.openStart = -1, this.next(), this;
  }
  forward(e, r) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - r) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, r);
  }
  removeActive(e) {
    su(this.active, e), su(this.activeTo, e), su(this.activeRank, e), this.minActive = _0(this.active, this.activeTo);
  }
  addActive(e) {
    let r = 0, { value: s, to: i, rank: n } = this.cursor;
    for (; r < this.activeRank.length && (n - this.activeRank[r] || i - this.activeTo[r]) > 0; )
      r++;
    iu(this.active, r, s), iu(this.activeTo, r, i), iu(this.activeRank, r, n), e && iu(e, r, this.cursor.from), this.minActive = _0(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, r = this.point;
    this.point = null;
    let s = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), s && su(s, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let n = this.cursor.value;
          if (!n.point)
            this.addActive(s), this.cursor.next();
          else if (r && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = n, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = n.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (s) {
      this.openStart = 0;
      for (let i = s.length - 1; i >= 0 && s[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let r = [];
    for (let s = this.active.length - 1; s >= 0 && !(this.activeRank[s] < this.pointRank); s--)
      (this.activeTo[s] > e || this.activeTo[s] == e && this.active[s].endSide >= this.point.endSide) && r.push(this.active[s]);
    return r.reverse();
  }
  openEnd(e) {
    let r = 0;
    for (let s = this.activeTo.length - 1; s >= 0 && this.activeTo[s] > e; s--)
      r++;
    return r;
  }
}
function L0(t, e, r, s, i, n) {
  t.goto(e), r.goto(s);
  let a = s + i, l = s, c = s - e;
  for (; ; ) {
    let p = t.to + c - r.to, d = p || t.endSide - r.endSide, m = d < 0 ? t.to + c : r.to, y = Math.min(m, a);
    if (t.point || r.point ? t.point && r.point && (t.point == r.point || t.point.eq(r.point)) && Ud(t.activeForPoint(t.to), r.activeForPoint(r.to)) || n.comparePoint(l, y, t.point, r.point) : y > l && !Ud(t.active, r.active) && n.compareRange(l, y, t.active, r.active), m > a)
      break;
    (p || t.openEnd != r.openEnd) && n.boundChange && n.boundChange(m), l = m, d <= 0 && t.next(), d >= 0 && r.next();
  }
}
function Ud(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (t[r] != e[r] && !t[r].eq(e[r]))
      return !1;
  return !0;
}
function su(t, e) {
  for (let r = e, s = t.length - 1; r < s; r++)
    t[r] = t[r + 1];
  t.pop();
}
function iu(t, e, r) {
  for (let s = t.length - 1; s >= e; s--)
    t[s + 1] = t[s];
  t[e] = r;
}
function _0(t, e) {
  let r = -1, s = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - s || t[i].endSide - t[r].endSide) < 0 && (r = i, s = e[i]);
  return r;
}
function Ma(t, e, r = t.length) {
  let s = 0;
  for (let i = 0; i < r && i < t.length; )
    t.charCodeAt(i) == 9 ? (s += e - s % e, i++) : (s++, i = Dt(t, i));
  return s;
}
function Yd(t, e, r, s) {
  for (let i = 0, n = 0; ; ) {
    if (n >= e)
      return i;
    if (i == t.length)
      break;
    n += t.charCodeAt(i) == 9 ? r - n % r : 1, i = Dt(t, i);
  }
  return s === !0 ? -1 : t.length;
}
const Wd = "", R0 = typeof Symbol == "undefined" ? "__" + Wd : Symbol.for(Wd), Gd = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), q0 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
class Ci {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, r) {
    this.rules = [];
    let { finish: s } = r || {};
    function i(a) {
      return /^@/.test(a) ? [a] : a.split(/,\s*/);
    }
    function n(a, l, c, p) {
      let d = [], m = /^@(\w+)\b/.exec(a[0]), y = m && m[1] == "keyframes";
      if (m && l == null) return c.push(a[0] + ";");
      for (let g in l) {
        let x = l[g];
        if (/&/.test(g))
          n(
            g.split(/,\s*/).map((v) => a.map((w) => v.replace(/&/, w))).reduce((v, w) => v.concat(w)),
            x,
            c
          );
        else if (x && typeof x == "object") {
          if (!m) throw new RangeError("The value of a property (" + g + ") should be a primitive value.");
          n(i(g), x, d, y);
        } else x != null && d.push(g.replace(/_.*/, "").replace(/[A-Z]/g, (v) => "-" + v.toLowerCase()) + ": " + x + ";");
      }
      (d.length || y) && c.push((s && !m && !p ? a.map(s) : a).join(", ") + " {" + d.join(" ") + "}");
    }
    for (let a in e) n(i(a), e[a], this.rules);
  }
  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let e = q0[R0] || 1;
    return q0[R0] = e + 1, Wd + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, r, s) {
    let i = e[Gd], n = s && s.nonce;
    i ? n && i.setNonce(n) : i = new KM(e, n), i.mount(Array.isArray(r) ? r : [r], e);
  }
}
let j0 = /* @__PURE__ */ new Map();
class KM {
  constructor(e, r) {
    let s = e.ownerDocument || e, i = s.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let n = j0.get(s);
      if (n) return e[Gd] = n;
      this.sheet = new i.CSSStyleSheet(), j0.set(s, this);
    } else
      this.styleTag = s.createElement("style"), r && this.styleTag.setAttribute("nonce", r);
    this.modules = [], e[Gd] = this;
  }
  mount(e, r) {
    let s = this.sheet, i = 0, n = 0;
    for (let a = 0; a < e.length; a++) {
      let l = e[a], c = this.modules.indexOf(l);
      if (c < n && c > -1 && (this.modules.splice(c, 1), n--, c = -1), c == -1) {
        if (this.modules.splice(n++, 0, l), s) for (let p = 0; p < l.rules.length; p++)
          s.insertRule(l.rules[p], i++);
      } else {
        for (; n < c; ) i += this.modules[n++].rules.length;
        i += l.rules.length, n++;
      }
    }
    if (s)
      r.adoptedStyleSheets.indexOf(this.sheet) < 0 && (r.adoptedStyleSheets = [this.sheet, ...r.adoptedStyleSheets]);
    else {
      let a = "";
      for (let c = 0; c < this.modules.length; c++)
        a += this.modules[c].getRules() + `
`;
      this.styleTag.textContent = a;
      let l = r.head || r;
      this.styleTag.parentNode != l && l.insertBefore(this.styleTag, l.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var Ei = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Zo = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, eL = typeof navigator != "undefined" && /Mac/.test(navigator.platform), tL = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var yt = 0; yt < 10; yt++) Ei[48 + yt] = Ei[96 + yt] = String(yt);
for (var yt = 1; yt <= 24; yt++) Ei[yt + 111] = "F" + yt;
for (var yt = 65; yt <= 90; yt++)
  Ei[yt] = String.fromCharCode(yt + 32), Zo[yt] = String.fromCharCode(yt);
for (var vp in Ei) Zo.hasOwnProperty(vp) || (Zo[vp] = Ei[vp]);
function rL(t) {
  var e = eL && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || tL && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", r = !e && t.key || (t.shiftKey ? Zo : Ei)[t.keyCode] || t.key || "Unidentified";
  return r == "Esc" && (r = "Escape"), r == "Del" && (r = "Delete"), r == "Left" && (r = "ArrowLeft"), r == "Up" && (r = "ArrowUp"), r == "Right" && (r = "ArrowRight"), r == "Down" && (r = "ArrowDown"), r;
}
function Qe() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1, r = arguments[1];
  if (r && typeof r == "object" && r.nodeType == null && !Array.isArray(r)) {
    for (var s in r) if (Object.prototype.hasOwnProperty.call(r, s)) {
      var i = r[s];
      typeof i == "string" ? t.setAttribute(s, i) : i != null && (t[s] = i);
    }
    e++;
  }
  for (; e < arguments.length; e++) zS(t, arguments[e]);
  return t;
}
function zS(t, e) {
  if (typeof e == "string")
    t.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    t.appendChild(e);
  else if (Array.isArray(e))
    for (var r = 0; r < e.length; r++) zS(t, e[r]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
function Vo(t) {
  let e;
  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
}
function Hd(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function Mu(t, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return Hd(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function zo(t) {
  return t.nodeType == 3 ? mn(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function ko(t, e, r, s) {
  return r ? X0(t, e, r, s, -1) || X0(t, e, r, s, 1) : !1;
}
function fn(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}
function dc(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
function X0(t, e, r, s, i) {
  for (; ; ) {
    if (t == r && e == s)
      return !0;
    if (e == (i < 0 ? 0 : fs(t))) {
      if (t.nodeName == "DIV")
        return !1;
      let n = t.parentNode;
      if (!n || n.nodeType != 1)
        return !1;
      e = fn(t) + (i < 0 ? 0 : 1), t = n;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
        return !1;
      e = i < 0 ? fs(t) : 0;
    } else
      return !1;
  }
}
function fs(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function mh(t, e) {
  let r = e ? t.left : t.right;
  return { left: r, right: r, top: t.top, bottom: t.bottom };
}
function sL(t) {
  let e = t.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.innerWidth,
    top: 0,
    bottom: t.innerHeight
  };
}
function US(t, e) {
  let r = e.width / t.offsetWidth, s = e.height / t.offsetHeight;
  return (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.width - t.offsetWidth) < 1) && (r = 1), (s > 0.995 && s < 1.005 || !isFinite(s) || Math.abs(e.height - t.offsetHeight) < 1) && (s = 1), { scaleX: r, scaleY: s };
}
function iL(t, e, r, s, i, n, a, l) {
  let c = t.ownerDocument, p = c.defaultView || window;
  for (let d = t, m = !1; d && !m; )
    if (d.nodeType == 1) {
      let y, g = d == c.body, x = 1, v = 1;
      if (g)
        y = sL(p);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(d).position) && (m = !0), d.scrollHeight <= d.clientHeight && d.scrollWidth <= d.clientWidth) {
          d = d.assignedSlot || d.parentNode;
          continue;
        }
        let b = d.getBoundingClientRect();
        ({ scaleX: x, scaleY: v } = US(d, b)), y = {
          left: b.left,
          right: b.left + d.clientWidth * x,
          top: b.top,
          bottom: b.top + d.clientHeight * v
        };
      }
      let w = 0, C = 0;
      if (i == "nearest")
        e.top < y.top ? (C = e.top - (y.top + a), r > 0 && e.bottom > y.bottom + C && (C = e.bottom - y.bottom + a)) : e.bottom > y.bottom && (C = e.bottom - y.bottom + a, r < 0 && e.top - C < y.top && (C = e.top - (y.top + a)));
      else {
        let b = e.bottom - e.top, k = y.bottom - y.top;
        C = (i == "center" && b <= k ? e.top + b / 2 - k / 2 : i == "start" || i == "center" && r < 0 ? e.top - a : e.bottom - k + a) - y.top;
      }
      if (s == "nearest" ? e.left < y.left ? (w = e.left - (y.left + n), r > 0 && e.right > y.right + w && (w = e.right - y.right + n)) : e.right > y.right && (w = e.right - y.right + n, r < 0 && e.left < y.left + w && (w = e.left - (y.left + n))) : w = (s == "center" ? e.left + (e.right - e.left) / 2 - (y.right - y.left) / 2 : s == "start" == l ? e.left - n : e.right - (y.right - y.left) + n) - y.left, w || C)
        if (g)
          p.scrollBy(w, C);
        else {
          let b = 0, k = 0;
          if (C) {
            let Q = d.scrollTop;
            d.scrollTop += C / v, k = (d.scrollTop - Q) * v;
          }
          if (w) {
            let Q = d.scrollLeft;
            d.scrollLeft += w / x, b = (d.scrollLeft - Q) * x;
          }
          e = {
            left: e.left - b,
            top: e.top - k,
            right: e.right - b,
            bottom: e.bottom - k
          }, b && Math.abs(b - w) < 1 && (s = "nearest"), k && Math.abs(k - C) < 1 && (i = "nearest");
        }
      if (g)
        break;
      (e.top < y.top || e.bottom > y.bottom || e.left < y.left || e.right > y.right) && (e = {
        left: Math.max(e.left, y.left),
        right: Math.min(e.right, y.right),
        top: Math.max(e.top, y.top),
        bottom: Math.min(e.bottom, y.bottom)
      }), d = d.assignedSlot || d.parentNode;
    } else if (d.nodeType == 11)
      d = d.host;
    else
      break;
}
function nL(t) {
  let e = t.ownerDocument, r, s;
  for (let i = t.parentNode; i && !(i == e.body || r && s); )
    if (i.nodeType == 1)
      !s && i.scrollHeight > i.clientHeight && (s = i), !r && i.scrollWidth > i.clientWidth && (r = i), i = i.assignedSlot || i.parentNode;
    else if (i.nodeType == 11)
      i = i.host;
    else
      break;
  return { x: r, y: s };
}
class aL {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: r, focusNode: s } = e;
    this.set(r, Math.min(e.anchorOffset, r ? fs(r) : 0), s, Math.min(e.focusOffset, s ? fs(s) : 0));
  }
  set(e, r, s, i) {
    this.anchorNode = e, this.anchorOffset = r, this.focusNode = s, this.focusOffset = i;
  }
}
let Nn = null;
function YS(t) {
  if (t.setActive)
    return t.setActive();
  if (Nn)
    return t.focus(Nn);
  let e = [];
  for (let r = t; r && (e.push(r, r.scrollTop, r.scrollLeft), r != r.ownerDocument); r = r.parentNode)
    ;
  if (t.focus(Nn == null ? {
    get preventScroll() {
      return Nn = { preventScroll: !0 }, !0;
    }
  } : void 0), !Nn) {
    Nn = !1;
    for (let r = 0; r < e.length; ) {
      let s = e[r++], i = e[r++], n = e[r++];
      s.scrollTop != i && (s.scrollTop = i), s.scrollLeft != n && (s.scrollLeft = n);
    }
  }
}
let Z0;
function mn(t, e, r = e) {
  let s = Z0 || (Z0 = document.createRange());
  return s.setEnd(t, r), s.setStart(t, e), s;
}
function Hn(t, e, r, s) {
  let i = { key: e, code: e, keyCode: r, which: r, cancelable: !0 };
  s && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = s);
  let n = new KeyboardEvent("keydown", i);
  n.synthetic = !0, t.dispatchEvent(n);
  let a = new KeyboardEvent("keyup", i);
  return a.synthetic = !0, t.dispatchEvent(a), n.defaultPrevented || a.defaultPrevented;
}
function oL(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
      return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function WS(t) {
  for (; t.attributes.length; )
    t.removeAttributeNode(t.attributes[0]);
}
function lL(t, e) {
  let r = e.focusNode, s = e.focusOffset;
  if (!r || e.anchorNode != r || e.anchorOffset != s)
    return !1;
  for (s = Math.min(s, fs(r)); ; )
    if (s) {
      if (r.nodeType != 1)
        return !1;
      let i = r.childNodes[s - 1];
      i.contentEditable == "false" ? s-- : (r = i, s = fs(r));
    } else {
      if (r == t)
        return !0;
      s = fn(r), r = r.parentNode;
    }
}
function GS(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
function HS(t, e) {
  for (let r = t, s = e; ; ) {
    if (r.nodeType == 3 && s > 0)
      return { node: r, offset: s };
    if (r.nodeType == 1 && s > 0) {
      if (r.contentEditable == "false")
        return null;
      r = r.childNodes[s - 1], s = fs(r);
    } else if (r.parentNode && !dc(r))
      s = fn(r), r = r.parentNode;
    else
      return null;
  }
}
function JS(t, e) {
  for (let r = t, s = e; ; ) {
    if (r.nodeType == 3 && s < r.nodeValue.length)
      return { node: r, offset: s };
    if (r.nodeType == 1 && s < r.childNodes.length) {
      if (r.contentEditable == "false")
        return null;
      r = r.childNodes[s], s = 0;
    } else if (r.parentNode && !dc(r))
      s = fn(r) + 1, r = r.parentNode;
    else
      return null;
  }
}
class Tt {
  constructor(e, r, s = !0) {
    this.node = e, this.offset = r, this.precise = s;
  }
  static before(e, r) {
    return new Tt(e.parentNode, fn(e), r);
  }
  static after(e, r) {
    return new Tt(e.parentNode, fn(e) + 1, r);
  }
}
const ig = [];
class Ie {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let r = this.posAtStart;
    for (let s of this.children) {
      if (s == e)
        return r;
      r += s.length + s.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, r) {
    if (this.flags & 2) {
      let s = this.dom, i = null, n;
      for (let a of this.children) {
        if (a.flags & 7) {
          if (!a.dom && (n = i ? i.nextSibling : s.firstChild)) {
            let l = Ie.get(n);
            (!l || !l.parent && l.canReuseDOM(a)) && a.reuseDOM(n);
          }
          a.sync(e, r), a.flags &= -8;
        }
        if (n = i ? i.nextSibling : s.firstChild, r && !r.written && r.node == s && n != a.dom && (r.written = !0), a.dom.parentNode == s)
          for (; n && n != a.dom; )
            n = V0(n);
        else
          s.insertBefore(a.dom, n);
        i = a.dom;
      }
      for (n = i ? i.nextSibling : s.firstChild, n && r && r.node == s && (r.written = !0); n; )
        n = V0(n);
    } else if (this.flags & 1)
      for (let s of this.children)
        s.flags & 7 && (s.sync(e, r), s.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, r) {
    let s;
    if (e == this.dom)
      s = this.dom.childNodes[r];
    else {
      let i = fs(e) == 0 ? 0 : r == 0 ? -1 : 1;
      for (; ; ) {
        let n = e.parentNode;
        if (n == this.dom)
          break;
        i == 0 && n.firstChild != n.lastChild && (e == n.firstChild ? i = -1 : i = 1), e = n;
      }
      i < 0 ? s = e : s = e.nextSibling;
    }
    if (s == this.dom.firstChild)
      return 0;
    for (; s && !Ie.get(s); )
      s = s.nextSibling;
    if (!s)
      return this.length;
    for (let i = 0, n = 0; ; i++) {
      let a = this.children[i];
      if (a.dom == s)
        return n;
      n += a.length + a.breakAfter;
    }
  }
  domBoundsAround(e, r, s = 0) {
    let i = -1, n = -1, a = -1, l = -1;
    for (let c = 0, p = s, d = s; c < this.children.length; c++) {
      let m = this.children[c], y = p + m.length;
      if (p < e && y > r)
        return m.domBoundsAround(e, r, p);
      if (y >= e && i == -1 && (i = c, n = p), p > r && m.dom.parentNode == this.dom) {
        a = c, l = d;
        break;
      }
      d = y, p = y + m.breakAfter;
    }
    return {
      from: n,
      to: l < 0 ? s + this.length : l,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: a < this.children.length && a >= 0 ? this.children[a].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let r = this.parent; r; r = r.parent) {
      if (e && (r.flags |= 2), r.flags & 1)
        return;
      r.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let r = e.parent;
      if (!r)
        return e;
      e = r;
    }
  }
  replaceChildren(e, r, s = ig) {
    this.markDirty();
    for (let i = e; i < r; i++) {
      let n = this.children[i];
      n.parent == this && s.indexOf(n) < 0 && n.destroy();
    }
    s.length < 250 ? this.children.splice(e, r - e, ...s) : this.children = [].concat(this.children.slice(0, e), s, this.children.slice(r));
    for (let i = 0; i < s.length; i++)
      s[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new KS(this.children, e, this.children.length);
  }
  childPos(e, r = 1) {
    return this.childCursor().findPos(e, r);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, r, s, i, n, a) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
Ie.prototype.breakAfter = 0;
function V0(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class KS {
  constructor(e, r, s) {
    this.children = e, this.pos = r, this.i = s, this.off = 0;
  }
  findPos(e, r = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (r > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let s = this.children[--this.i];
      this.pos -= s.length + s.breakAfter;
    }
  }
}
function ew(t, e, r, s, i, n, a, l, c) {
  let { children: p } = t, d = p.length ? p[e] : null, m = n.length ? n[n.length - 1] : null, y = m ? m.breakAfter : a;
  if (!(e == s && d && !a && !y && n.length < 2 && d.merge(r, i, n.length ? m : null, r == 0, l, c))) {
    if (s < p.length) {
      let g = p[s];
      g && (i < g.length || g.breakAfter && m != null && m.breakAfter) ? (e == s && (g = g.split(i), i = 0), !y && m && g.merge(0, i, m, !0, 0, c) ? n[n.length - 1] = g : ((i || g.children.length && !g.children[0].length) && g.merge(0, i, null, !1, 0, c), n.push(g))) : g != null && g.breakAfter && (m ? m.breakAfter = 1 : a = 1), s++;
    }
    for (d && (d.breakAfter = a, r > 0 && (!a && n.length && d.merge(r, d.length, n[0], !1, l, 0) ? d.breakAfter = n.shift().breakAfter : (r < d.length || d.children.length && d.children[d.children.length - 1].length == 0) && d.merge(r, d.length, null, !1, l, 0), e++)); e < s && n.length; )
      if (p[s - 1].become(n[n.length - 1]))
        s--, n.pop(), c = n.length ? 0 : l;
      else if (p[e].become(n[0]))
        e++, n.shift(), l = n.length ? 0 : c;
      else
        break;
    !n.length && e && s < p.length && !p[e - 1].breakAfter && p[s].merge(0, 0, p[e - 1], !1, l, c) && e--, (e < s || n.length) && t.replaceChildren(e, s, n);
  }
}
function tw(t, e, r, s, i, n) {
  let a = t.childCursor(), { i: l, off: c } = a.findPos(r, 1), { i: p, off: d } = a.findPos(e, -1), m = e - r;
  for (let y of s)
    m += y.length;
  t.length += m, ew(t, p, d, l, c, s, 0, i, n);
}
let Vt = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" }, Jd = typeof document != "undefined" ? document : { documentElement: { style: {} } };
const Kd = /* @__PURE__ */ /Edge\/(\d+)/.exec(Vt.userAgent), rw = /* @__PURE__ */ /MSIE \d/.test(Vt.userAgent), ef = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Vt.userAgent), gh = !!(rw || ef || Kd), z0 = !gh && /* @__PURE__ */ /gecko\/(\d+)/i.test(Vt.userAgent), Sp = !gh && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Vt.userAgent), uL = "webkitFontSmoothing" in Jd.documentElement.style, sw = !gh && /* @__PURE__ */ /Apple Computer/.test(Vt.vendor), U0 = sw && (/* @__PURE__ */ /Mobile\/\w+/.test(Vt.userAgent) || Vt.maxTouchPoints > 2);
var ee = {
  mac: U0 || /* @__PURE__ */ /Mac/.test(Vt.platform),
  windows: /* @__PURE__ */ /Win/.test(Vt.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Vt.platform),
  ie: gh,
  ie_version: rw ? Jd.documentMode || 6 : ef ? +ef[1] : Kd ? +Kd[1] : 0,
  gecko: z0,
  gecko_version: z0 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Vt.userAgent) || [0, 0])[1] : 0,
  chrome: !!Sp,
  chrome_version: Sp ? +Sp[1] : 0,
  ios: U0,
  android: /* @__PURE__ */ /Android\b/.test(Vt.userAgent),
  safari: sw,
  webkit_version: uL ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(Vt.userAgent) || [0, 0])[1] : 0,
  tabSize: Jd.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const cL = 256;
class Xr extends Ie {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, r) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (r && r.node == this.dom && (r.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, r, s) {
    return this.flags & 8 || s && (!(s instanceof Xr) || this.length - (r - e) + s.length > cL || s.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (s ? s.text : "") + this.text.slice(r), this.markDirty(), !0);
  }
  split(e) {
    let r = new Xr(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), r.flags |= this.flags & 8, r;
  }
  localPosFromDOM(e, r) {
    return e == this.dom ? r : r ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Tt(this.dom, e);
  }
  domBoundsAround(e, r, s) {
    return { from: s, to: s + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, r) {
    return hL(this.dom, e, r);
  }
}
class Rs extends Ie {
  constructor(e, r = [], s = 0) {
    super(), this.mark = e, this.children = r, this.length = s;
    for (let i of r)
      i.setParent(this);
  }
  setAttrs(e) {
    if (WS(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let r in this.mark.attrs)
        e.setAttribute(r, this.mark.attrs[r]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, r);
  }
  merge(e, r, s, i, n, a) {
    return s && (!(s instanceof Rs && s.mark.eq(this.mark)) || e && n <= 0 || r < this.length && a <= 0) ? !1 : (tw(this, e, r, s ? s.children.slice() : [], n - 1, a - 1), this.markDirty(), !0);
  }
  split(e) {
    let r = [], s = 0, i = -1, n = 0;
    for (let l of this.children) {
      let c = s + l.length;
      c > e && r.push(s < e ? l.split(e - s) : l), i < 0 && s >= e && (i = n), s = c, n++;
    }
    let a = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new Rs(this.mark, r, a);
  }
  domAtPos(e) {
    return iw(this, e);
  }
  coordsAt(e, r) {
    return aw(this, e, r);
  }
}
function hL(t, e, r) {
  let s = t.nodeValue.length;
  e > s && (e = s);
  let i = e, n = e, a = 0;
  e == 0 && r < 0 || e == s && r >= 0 ? ee.chrome || ee.gecko || (e ? (i--, a = 1) : n < s && (n++, a = -1)) : r < 0 ? i-- : n < s && n++;
  let l = mn(t, i, n).getClientRects();
  if (!l.length)
    return null;
  let c = l[(a ? a < 0 : r >= 0) ? 0 : l.length - 1];
  return ee.safari && !a && c.width == 0 && (c = Array.prototype.find.call(l, (p) => p.width) || c), a ? mh(c, a < 0) : c || null;
}
class Oi extends Ie {
  static create(e, r, s) {
    return new Oi(e, r, s);
  }
  constructor(e, r, s) {
    super(), this.widget = e, this.length = r, this.side = s, this.prevWidget = null;
  }
  split(e) {
    let r = Oi.create(this.widget, this.length - e, this.side);
    return this.length -= e, r;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, r, s, i, n, a) {
    return s && (!(s instanceof Oi) || !this.widget.compare(s.widget) || e > 0 && n <= 0 || r < this.length && a <= 0) ? !1 : (this.length = e + (s ? s.length : 0) + (this.length - r), !0);
  }
  become(e) {
    return e instanceof Oi && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Se.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: r } = e, s = r && r.state.doc, i = this.posAtStart;
    return s ? s.slice(i, i + this.length) : Se.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Tt.before(this.dom) : Tt.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, r) {
    let s = this.widget.coordsAt(this.dom, e, r);
    if (s)
      return s;
    let i = this.dom.getClientRects(), n = null;
    if (!i.length)
      return null;
    let a = this.side ? this.side < 0 : e > 0;
    for (let l = a ? i.length - 1 : 0; n = i[l], !(e > 0 ? l == 0 : l == i.length - 1 || n.top < n.bottom); l += a ? -1 : 1)
      ;
    return mh(n, !a);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class fa extends Ie {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof fa && e.side == this.side;
  }
  split() {
    return new fa(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Tt.before(this.dom) : Tt.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Se.empty;
  }
  get isHidden() {
    return !0;
  }
}
Xr.prototype.children = Oi.prototype.children = fa.prototype.children = ig;
function iw(t, e) {
  let r = t.dom, { children: s } = t, i = 0;
  for (let n = 0; i < s.length; i++) {
    let a = s[i], l = n + a.length;
    if (!(l == n && a.getSide() <= 0)) {
      if (e > n && e < l && a.dom.parentNode == r)
        return a.domAtPos(e - n);
      if (e <= n)
        break;
      n = l;
    }
  }
  for (let n = i; n > 0; n--) {
    let a = s[n - 1];
    if (a.dom.parentNode == r)
      return a.domAtPos(a.length);
  }
  for (let n = i; n < s.length; n++) {
    let a = s[n];
    if (a.dom.parentNode == r)
      return a.domAtPos(0);
  }
  return new Tt(r, 0);
}
function nw(t, e, r) {
  let s, { children: i } = t;
  r > 0 && e instanceof Rs && i.length && (s = i[i.length - 1]) instanceof Rs && s.mark.eq(e.mark) ? nw(s, e.children[0], r - 1) : (i.push(e), e.setParent(t)), t.length += e.length;
}
function aw(t, e, r) {
  let s = null, i = -1, n = null, a = -1;
  function l(p, d) {
    for (let m = 0, y = 0; m < p.children.length && y <= d; m++) {
      let g = p.children[m], x = y + g.length;
      x >= d && (g.children.length ? l(g, d - y) : (!n || n.isHidden && (r > 0 || dL(n, g))) && (x > d || y == x && g.getSide() > 0) ? (n = g, a = d - y) : (y < d || y == x && g.getSide() < 0 && !g.isHidden) && (s = g, i = d - y)), y = x;
    }
  }
  l(t, e);
  let c = (r < 0 ? s : n) || s || n;
  return c ? c.coordsAt(Math.max(0, c == s ? i : a), r) : pL(t);
}
function pL(t) {
  let e = t.dom.lastChild;
  if (!e)
    return t.dom.getBoundingClientRect();
  let r = zo(e);
  return r[r.length - 1] || null;
}
function dL(t, e) {
  let r = t.coordsAt(0, 1), s = e.coordsAt(0, 1);
  return r && s && s.top < r.bottom;
}
function tf(t, e) {
  for (let r in t)
    r == "class" && e.class ? e.class += " " + t.class : r == "style" && e.style ? e.style += ";" + t.style : e[r] = t[r];
  return e;
}
const Y0 = /* @__PURE__ */ Object.create(null);
function fc(t, e, r) {
  if (t == e)
    return !0;
  t || (t = Y0), e || (e = Y0);
  let s = Object.keys(t), i = Object.keys(e);
  if (s.length - (r && s.indexOf(r) > -1 ? 1 : 0) != i.length - (r && i.indexOf(r) > -1 ? 1 : 0))
    return !1;
  for (let n of s)
    if (n != r && (i.indexOf(n) == -1 || t[n] !== e[n]))
      return !1;
  return !0;
}
function rf(t, e, r) {
  let s = !1;
  if (e)
    for (let i in e)
      r && i in r || (s = !0, i == "style" ? t.style.cssText = "" : t.removeAttribute(i));
  if (r)
    for (let i in r)
      e && e[i] == r[i] || (s = !0, i == "style" ? t.style.cssText = r[i] : t.setAttribute(i, r[i]));
  return s;
}
function fL(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r = 0; r < t.attributes.length; r++) {
    let s = t.attributes[r];
    e[s.name] = s.value;
  }
  return e;
}
class ei {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, r) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedless than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, r, s) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Mt = /* @__PURE__ */ function(t) {
  return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
}(Mt || (Mt = {}));
class ce extends dn {
  constructor(e, r, s, i) {
    super(), this.startSide = e, this.endSide = r, this.widget = s, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new wl(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let r = Math.max(-1e4, Math.min(1e4, e.side || 0)), s = !!e.block;
    return r += s && !e.inlineOrder ? r > 0 ? 3e8 : -4e8 : r > 0 ? 1e8 : -1e8, new Ti(e, r, r, s, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let r = !!e.block, s, i;
    if (e.isBlockGap)
      s = -5e8, i = 4e8;
    else {
      let { start: n, end: a } = ow(e, r);
      s = (n ? r ? -3e8 : -1 : 5e8) - 1, i = (a ? r ? 2e8 : 1 : -6e8) + 1;
    }
    return new Ti(e, s, i, r, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Al(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, r = !1) {
    return Ce.of(e, r);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
ce.none = Ce.empty;
class wl extends ce {
  constructor(e) {
    let { start: r, end: s } = ow(e);
    super(r ? -1 : 5e8, s ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var r, s;
    return this == e || e instanceof wl && this.tagName == e.tagName && (this.class || ((r = this.attrs) === null || r === void 0 ? void 0 : r.class)) == (e.class || ((s = e.attrs) === null || s === void 0 ? void 0 : s.class)) && fc(this.attrs, e.attrs, "class");
  }
  range(e, r = e) {
    if (e >= r)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, r);
  }
}
wl.prototype.point = !1;
class Al extends ce {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Al && this.spec.class == e.spec.class && fc(this.spec.attributes, e.spec.attributes);
  }
  range(e, r = e) {
    if (r != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, r);
  }
}
Al.prototype.mapMode = Ot.TrackBefore;
Al.prototype.point = !0;
class Ti extends ce {
  constructor(e, r, s, i, n, a) {
    super(r, s, n, e), this.block = i, this.isReplace = a, this.mapMode = i ? r <= 0 ? Ot.TrackBefore : Ot.TrackAfter : Ot.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Mt.WidgetRange : this.startSide <= 0 ? Mt.WidgetBefore : Mt.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof Ti && mL(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, r = e) {
    if (this.isReplace && (e > r || e == r && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && r != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, r);
  }
}
Ti.prototype.point = !0;
function ow(t, e = !1) {
  let { inclusiveStart: r, inclusiveEnd: s } = t;
  return r == null && (r = t.inclusive), s == null && (s = t.inclusive), { start: r != null ? r : e, end: s != null ? s : e };
}
function mL(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function Lu(t, e, r, s = 0) {
  let i = r.length - 1;
  i >= 0 && r[i] + s >= t ? r[i] = Math.max(r[i], e) : r.push(t, e);
}
class et extends Ie {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, r, s, i, n, a) {
    if (s) {
      if (!(s instanceof et))
        return !1;
      this.dom || s.transferDOM(this);
    }
    return i && this.setDeco(s ? s.attrs : null), tw(this, e, r, s ? s.children.slice() : [], n, a), !0;
  }
  split(e) {
    let r = new et();
    if (r.breakAfter = this.breakAfter, this.length == 0)
      return r;
    let { i: s, off: i } = this.childPos(e);
    i && (r.append(this.children[s].split(i), 0), this.children[s].merge(i, this.children[s].length, null, !1, 0, 0), s++);
    for (let n = s; n < this.children.length; n++)
      r.append(this.children[n], 0);
    for (; s > 0 && this.children[s - 1].length == 0; )
      this.children[--s].destroy();
    return this.children.length = s, this.markDirty(), this.length = e, r;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    fc(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, r) {
    nw(this, e, r);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let r = e.spec.attributes, s = e.spec.class;
    r && (this.attrs = tf(r, this.attrs || {})), s && (this.attrs = tf({ class: s }, this.attrs || {}));
  }
  domAtPos(e) {
    return iw(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    var s;
    this.dom ? this.flags & 4 && (WS(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (rf(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, r);
    let i = this.dom.lastChild;
    for (; i && Ie.get(i) instanceof Rs; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((s = Ie.get(i)) === null || s === void 0 ? void 0 : s.isEditable) == !1 && (!ee.ios || !this.children.some((n) => n instanceof Xr))) {
      let n = document.createElement("BR");
      n.cmIgnore = !0, this.dom.appendChild(n);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, r;
    for (let s of this.children) {
      if (!(s instanceof Xr) || /[^ -~]/.test(s.text))
        return null;
      let i = zo(s.dom);
      if (i.length != 1)
        return null;
      e += i[0].width, r = i[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: r
    } : null;
  }
  coordsAt(e, r) {
    let s = aw(this, e, r);
    if (!this.children.length && s && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, n = s.bottom - s.top;
      if (Math.abs(n - i.lineHeight) < 2 && i.textHeight < n) {
        let a = (n - i.textHeight) / 2;
        return { top: s.top + a, bottom: s.bottom - a, left: s.left, right: s.left };
      }
    }
    return s;
  }
  become(e) {
    return e instanceof et && this.children.length == 0 && e.children.length == 0 && fc(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, r) {
    for (let s = 0, i = 0; s < e.children.length; s++) {
      let n = e.children[s], a = i + n.length;
      if (a >= r) {
        if (n instanceof et)
          return n;
        if (a > r)
          break;
      }
      i = a + n.breakAfter;
    }
    return null;
  }
}
class Ps extends Ie {
  constructor(e, r, s) {
    super(), this.widget = e, this.length = r, this.deco = s, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, r, s, i, n, a) {
    return s && (!(s instanceof Ps) || !this.widget.compare(s.widget) || e > 0 && n <= 0 || r < this.length && a <= 0) ? !1 : (this.length = e + (s ? s.length : 0) + (this.length - r), !0);
  }
  domAtPos(e) {
    return e == 0 ? Tt.before(this.dom) : Tt.after(this.dom, e == this.length);
  }
  split(e) {
    let r = this.length - e;
    this.length = e;
    let s = new Ps(this.widget, r, this.deco);
    return s.breakAfter = this.breakAfter, s;
  }
  get children() {
    return ig;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Se.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Ps && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, r) {
    return this.widget.coordsAt(this.dom, e, r) || (this.widget instanceof sf ? null : mh(this.dom.getBoundingClientRect(), this.length ? e == 0 : r <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: r, endSide: s } = this.deco;
    return r == s ? !1 : e < 0 ? r < 0 : s > 0;
  }
}
class sf extends ei {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class Po {
  constructor(e, r, s, i) {
    this.doc = e, this.pos = r, this.end = s, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = r;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof Ps && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new et()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(nu(new fa(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof Ps) && this.getLine();
  }
  buildText(e, r, s) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: n, lineBreak: a, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (a) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = n, this.textOff = 0;
      }
      let i = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(r.slice(r.length - s)), this.getLine().append(nu(new Xr(this.text.slice(this.textOff, this.textOff + i)), r), s), this.atCursorPos = !0, this.textOff += i, e -= i, s = 0;
    }
  }
  span(e, r, s, i) {
    this.buildText(r - e, s, i), this.pos = r, this.openStart < 0 && (this.openStart = i);
  }
  point(e, r, s, i, n, a) {
    if (this.disallowBlockEffectsFor[a] && s instanceof Ti) {
      if (s.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (r > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let l = r - e;
    if (s instanceof Ti)
      if (s.block)
        s.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Ps(s.widget || ma.block, l, s));
      else {
        let c = Oi.create(s.widget || ma.inline, l, l ? 0 : s.startSide), p = this.atCursorPos && !c.isEditable && n <= i.length && (e < r || s.startSide > 0), d = !c.isEditable && (e < r || n > i.length || s.startSide <= 0), m = this.getLine();
        this.pendingBuffer == 2 && !p && !c.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), p && (m.append(nu(new fa(1), i), n), n = i.length + Math.max(0, n - i.length)), m.append(nu(c, i), n), this.atCursorPos = d, this.pendingBuffer = d ? e < r || n > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(s);
    l && (this.textOff + l <= this.text.length ? this.textOff += l : (this.skip += l - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = r), this.openStart < 0 && (this.openStart = n);
  }
  static build(e, r, s, i, n) {
    let a = new Po(e, r, s, n);
    return a.openEnd = Ce.spans(i, r, s, a), a.openStart < 0 && (a.openStart = a.openEnd), a.finish(a.openEnd), a;
  }
}
function nu(t, e) {
  for (let r of e)
    t = new Rs(r, [t], t.length);
  return t;
}
class ma extends ei {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
ma.inline = /* @__PURE__ */ new ma("span");
ma.block = /* @__PURE__ */ new ma("div");
var _e = /* @__PURE__ */ function(t) {
  return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
}(_e || (_e = {}));
const gn = _e.LTR, ng = _e.RTL;
function lw(t) {
  let e = [];
  for (let r = 0; r < t.length; r++)
    e.push(1 << +t[r]);
  return e;
}
const gL = /* @__PURE__ */ lw("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), yL = /* @__PURE__ */ lw("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), nf = /* @__PURE__ */ Object.create(null), Ur = [];
for (let t of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ t.charCodeAt(0), r = /* @__PURE__ */ t.charCodeAt(1);
  nf[e] = r, nf[r] = -e;
}
function uw(t) {
  return t <= 247 ? gL[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? yL[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
}
const OL = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class xi {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? ng : gn;
  }
  /**
  @internal
  */
  constructor(e, r, s) {
    this.from = e, this.to = r, this.level = s;
  }
  /**
  @internal
  */
  side(e, r) {
    return this.dir == r == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, r) {
    return e == (this.dir == r);
  }
  /**
  @internal
  */
  static find(e, r, s, i) {
    let n = -1;
    for (let a = 0; a < e.length; a++) {
      let l = e[a];
      if (l.from <= r && l.to >= r) {
        if (l.level == s)
          return a;
        (n < 0 || (i != 0 ? i < 0 ? l.from < r : l.to > r : e[n].level > l.level)) && (n = a);
      }
    }
    if (n < 0)
      throw new RangeError("Index out of range");
    return n;
  }
}
function cw(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++) {
    let s = t[r], i = e[r];
    if (s.from != i.from || s.to != i.to || s.direction != i.direction || !cw(s.inner, i.inner))
      return !1;
  }
  return !0;
}
const Be = [];
function xL(t, e, r, s, i) {
  for (let n = 0; n <= s.length; n++) {
    let a = n ? s[n - 1].to : e, l = n < s.length ? s[n].from : r, c = n ? 256 : i;
    for (let p = a, d = c, m = c; p < l; p++) {
      let y = uw(t.charCodeAt(p));
      y == 512 ? y = d : y == 8 && m == 4 && (y = 16), Be[p] = y == 4 ? 2 : y, y & 7 && (m = y), d = y;
    }
    for (let p = a, d = c, m = c; p < l; p++) {
      let y = Be[p];
      if (y == 128)
        p < l - 1 && d == Be[p + 1] && d & 24 ? y = Be[p] = d : Be[p] = 256;
      else if (y == 64) {
        let g = p + 1;
        for (; g < l && Be[g] == 64; )
          g++;
        let x = p && d == 8 || g < r && Be[g] == 8 ? m == 1 ? 1 : 8 : 256;
        for (let v = p; v < g; v++)
          Be[v] = x;
        p = g - 1;
      } else y == 8 && m == 1 && (Be[p] = 1);
      d = y, y & 7 && (m = y);
    }
  }
}
function DL(t, e, r, s, i) {
  let n = i == 1 ? 2 : 1;
  for (let a = 0, l = 0, c = 0; a <= s.length; a++) {
    let p = a ? s[a - 1].to : e, d = a < s.length ? s[a].from : r;
    for (let m = p, y, g, x; m < d; m++)
      if (g = nf[y = t.charCodeAt(m)])
        if (g < 0) {
          for (let v = l - 3; v >= 0; v -= 3)
            if (Ur[v + 1] == -g) {
              let w = Ur[v + 2], C = w & 2 ? i : w & 4 ? w & 1 ? n : i : 0;
              C && (Be[m] = Be[Ur[v]] = C), l = v;
              break;
            }
        } else {
          if (Ur.length == 189)
            break;
          Ur[l++] = m, Ur[l++] = y, Ur[l++] = c;
        }
      else if ((x = Be[m]) == 2 || x == 1) {
        let v = x == i;
        c = v ? 0 : 1;
        for (let w = l - 3; w >= 0; w -= 3) {
          let C = Ur[w + 2];
          if (C & 2)
            break;
          if (v)
            Ur[w + 2] |= 2;
          else {
            if (C & 4)
              break;
            Ur[w + 2] |= 4;
          }
        }
      }
  }
}
function bL(t, e, r, s) {
  for (let i = 0, n = s; i <= r.length; i++) {
    let a = i ? r[i - 1].to : t, l = i < r.length ? r[i].from : e;
    for (let c = a; c < l; ) {
      let p = Be[c];
      if (p == 256) {
        let d = c + 1;
        for (; ; )
          if (d == l) {
            if (i == r.length)
              break;
            d = r[i++].to, l = i < r.length ? r[i].from : e;
          } else if (Be[d] == 256)
            d++;
          else
            break;
        let m = n == 1, y = (d < e ? Be[d] : s) == 1, g = m == y ? m ? 1 : 2 : s;
        for (let x = d, v = i, w = v ? r[v - 1].to : t; x > c; )
          x == w && (x = r[--v].from, w = v ? r[v - 1].to : t), Be[--x] = g;
        c = d;
      } else
        n = p, c++;
    }
  }
}
function af(t, e, r, s, i, n, a) {
  let l = s % 2 ? 2 : 1;
  if (s % 2 == i % 2)
    for (let c = e, p = 0; c < r; ) {
      let d = !0, m = !1;
      if (p == n.length || c < n[p].from) {
        let v = Be[c];
        v != l && (d = !1, m = v == 16);
      }
      let y = !d && l == 1 ? [] : null, g = d ? s : s + 1, x = c;
      e: for (; ; )
        if (p < n.length && x == n[p].from) {
          if (m)
            break e;
          let v = n[p];
          if (!d)
            for (let w = v.to, C = p + 1; ; ) {
              if (w == r)
                break e;
              if (C < n.length && n[C].from == w)
                w = n[C++].to;
              else {
                if (Be[w] == l)
                  break e;
                break;
              }
            }
          if (p++, y)
            y.push(v);
          else {
            v.from > c && a.push(new xi(c, v.from, g));
            let w = v.direction == gn != !(g % 2);
            of(t, w ? s + 1 : s, i, v.inner, v.from, v.to, a), c = v.to;
          }
          x = v.to;
        } else {
          if (x == r || (d ? Be[x] != l : Be[x] == l))
            break;
          x++;
        }
      y ? af(t, c, x, s + 1, i, y, a) : c < x && a.push(new xi(c, x, g)), c = x;
    }
  else
    for (let c = r, p = n.length; c > e; ) {
      let d = !0, m = !1;
      if (!p || c > n[p - 1].to) {
        let v = Be[c - 1];
        v != l && (d = !1, m = v == 16);
      }
      let y = !d && l == 1 ? [] : null, g = d ? s : s + 1, x = c;
      e: for (; ; )
        if (p && x == n[p - 1].to) {
          if (m)
            break e;
          let v = n[--p];
          if (!d)
            for (let w = v.from, C = p; ; ) {
              if (w == e)
                break e;
              if (C && n[C - 1].to == w)
                w = n[--C].from;
              else {
                if (Be[w - 1] == l)
                  break e;
                break;
              }
            }
          if (y)
            y.push(v);
          else {
            v.to < c && a.push(new xi(v.to, c, g));
            let w = v.direction == gn != !(g % 2);
            of(t, w ? s + 1 : s, i, v.inner, v.from, v.to, a), c = v.from;
          }
          x = v.from;
        } else {
          if (x == e || (d ? Be[x - 1] != l : Be[x - 1] == l))
            break;
          x--;
        }
      y ? af(t, x, c, s + 1, i, y, a) : x < c && a.push(new xi(x, c, g)), c = x;
    }
}
function of(t, e, r, s, i, n, a) {
  let l = e % 2 ? 2 : 1;
  xL(t, i, n, s, l), DL(t, i, n, s, l), bL(i, n, s, l), af(t, i, n, e, r, s, a);
}
function vL(t, e, r) {
  if (!t)
    return [new xi(0, 0, e == ng ? 1 : 0)];
  if (e == gn && !r.length && !OL.test(t))
    return hw(t.length);
  if (r.length)
    for (; t.length > Be.length; )
      Be[Be.length] = 256;
  let s = [], i = e == gn ? 0 : 1;
  return of(t, i, i, r, 0, t.length, s), s;
}
function hw(t) {
  return [new xi(0, t, 0)];
}
let pw = "";
function SL(t, e, r, s, i) {
  var n;
  let a = s.head - t.from, l = xi.find(e, a, (n = s.bidiLevel) !== null && n !== void 0 ? n : -1, s.assoc), c = e[l], p = c.side(i, r);
  if (a == p) {
    let y = l += i ? 1 : -1;
    if (y < 0 || y >= e.length)
      return null;
    c = e[l = y], a = c.side(!i, r), p = c.side(i, r);
  }
  let d = Dt(t.text, a, c.forward(i, r));
  (d < c.from || d > c.to) && (d = p), pw = t.text.slice(Math.min(a, d), Math.max(a, d));
  let m = l == (i ? e.length - 1 : 0) ? null : e[l + (i ? 1 : -1)];
  return m && d == p && m.level + (i ? 0 : 1) < c.level ? L.cursor(m.side(!i, r) + t.from, m.forward(i, r) ? 1 : -1, m.level) : L.cursor(d + t.from, c.forward(i, r) ? -1 : 1, c.level);
}
function wL(t, e, r) {
  for (let s = e; s < r; s++) {
    let i = uw(t.charCodeAt(s));
    if (i == 1)
      return gn;
    if (i == 2 || i == 4)
      return ng;
  }
  return gn;
}
const dw = /* @__PURE__ */ re.define(), fw = /* @__PURE__ */ re.define(), mw = /* @__PURE__ */ re.define(), gw = /* @__PURE__ */ re.define(), lf = /* @__PURE__ */ re.define(), yw = /* @__PURE__ */ re.define(), Ow = /* @__PURE__ */ re.define(), ag = /* @__PURE__ */ re.define(), og = /* @__PURE__ */ re.define(), xw = /* @__PURE__ */ re.define({
  combine: (t) => t.some((e) => e)
}), Dw = /* @__PURE__ */ re.define({
  combine: (t) => t.some((e) => e)
}), bw = /* @__PURE__ */ re.define();
class Jn {
  constructor(e, r = "nearest", s = "nearest", i = 5, n = 5, a = !1) {
    this.range = e, this.y = r, this.x = s, this.yMargin = i, this.xMargin = n, this.isSnapshot = a;
  }
  map(e) {
    return e.empty ? this : new Jn(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new Jn(L.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const au = /* @__PURE__ */ pe.define({ map: (t, e) => t.map(e) }), vw = /* @__PURE__ */ pe.define();
function Ut(t, e, r) {
  let s = t.facet(gw);
  s.length ? s[0](e) : window.onerror && window.onerror(String(e), r, void 0, void 0, e) || (r ? console.error(r + ":", e) : console.error(e));
}
const Ts = /* @__PURE__ */ re.define({ combine: (t) => t.length ? t[0] : !0 });
let AL = 0;
const zn = /* @__PURE__ */ re.define({
  combine(t) {
    return t.filter((e, r) => {
      for (let s = 0; s < r; s++)
        if (t[s].plugin == e.plugin)
          return !1;
      return !0;
    });
  }
});
class st {
  constructor(e, r, s, i, n) {
    this.id = e, this.create = r, this.domEventHandlers = s, this.domEventObservers = i, this.baseExtensions = n(this), this.extension = this.baseExtensions.concat(zn.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(e) {
    return this.baseExtensions.concat(zn.of({ plugin: this, arg: e }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, r) {
    const { eventHandlers: s, eventObservers: i, provide: n, decorations: a } = r || {};
    return new st(AL++, e, s, i, (l) => {
      let c = [];
      return a && c.push(Uo.of((p) => {
        let d = p.plugin(l);
        return d ? a(d) : ce.none;
      })), n && c.push(n(l)), c;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, r) {
    return st.define((s, i) => new e(s, i), r);
  }
}
class wp {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let r = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(r);
          } catch (s) {
            if (Ut(r.state, s, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(e, this.spec.arg);
      } catch (r) {
        Ut(e.state, r, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var r;
    if (!((r = this.value) === null || r === void 0) && r.destroy)
      try {
        this.value.destroy();
      } catch (s) {
        Ut(e.state, s, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const Sw = /* @__PURE__ */ re.define(), lg = /* @__PURE__ */ re.define(), Uo = /* @__PURE__ */ re.define(), ww = /* @__PURE__ */ re.define(), ug = /* @__PURE__ */ re.define(), Aw = /* @__PURE__ */ re.define();
function W0(t, e) {
  let r = t.state.facet(Aw);
  if (!r.length)
    return r;
  let s = r.map((n) => n instanceof Function ? n(t) : n), i = [];
  return Ce.spans(s, e.from, e.to, {
    point() {
    },
    span(n, a, l, c) {
      let p = n - e.from, d = a - e.from, m = i;
      for (let y = l.length - 1; y >= 0; y--, c--) {
        let g = l[y].spec.bidiIsolate, x;
        if (g == null && (g = wL(e.text, p, d)), c > 0 && m.length && (x = m[m.length - 1]).to == p && x.direction == g)
          x.to = d, m = x.inner;
        else {
          let v = { from: p, to: d, direction: g, inner: [] };
          m.push(v), m = v.inner;
        }
      }
    }
  }), i;
}
const Cw = /* @__PURE__ */ re.define();
function cg(t) {
  let e = 0, r = 0, s = 0, i = 0;
  for (let n of t.state.facet(Cw)) {
    let a = n(t);
    a && (a.left != null && (e = Math.max(e, a.left)), a.right != null && (r = Math.max(r, a.right)), a.top != null && (s = Math.max(s, a.top)), a.bottom != null && (i = Math.max(i, a.bottom)));
  }
  return { left: e, right: r, top: s, bottom: i };
}
const co = /* @__PURE__ */ re.define();
class Sr {
  constructor(e, r, s, i) {
    this.fromA = e, this.toA = r, this.fromB = s, this.toB = i;
  }
  join(e) {
    return new Sr(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let r = e.length, s = this;
    for (; r > 0; r--) {
      let i = e[r - 1];
      if (!(i.fromA > s.toA)) {
        if (i.toA < s.fromA)
          break;
        s = s.join(i), e.splice(r - 1, 1);
      }
    }
    return e.splice(r, 0, s), e;
  }
  static extendWithRanges(e, r) {
    if (r.length == 0)
      return e;
    let s = [];
    for (let i = 0, n = 0, a = 0, l = 0; ; i++) {
      let c = i == e.length ? null : e[i], p = a - l, d = c ? c.fromB : 1e9;
      for (; n < r.length && r[n] < d; ) {
        let m = r[n], y = r[n + 1], g = Math.max(l, m), x = Math.min(d, y);
        if (g <= x && new Sr(g + p, x + p, g, x).addToSet(s), y > d)
          break;
        n += 2;
      }
      if (!c)
        return s;
      new Sr(c.fromA, c.toA, c.fromB, c.toB).addToSet(s), a = c.toA, l = c.toB;
    }
  }
}
class mc {
  constructor(e, r, s) {
    this.view = e, this.state = r, this.transactions = s, this.flags = 0, this.startState = e.state, this.changes = at.empty(this.startState.doc.length);
    for (let n of s)
      this.changes = this.changes.compose(n.changes);
    let i = [];
    this.changes.iterChangedRanges((n, a, l, c) => i.push(new Sr(n, a, l, c))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(e, r, s) {
    return new mc(e, r, s);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class G0 extends Ie {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = ce.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new et()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Sr(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var r;
    let s = e.changedRanges;
    this.minWidth > 0 && s.length && (s.every(({ fromA: p, toA: d }) => d < this.minWidthFrom || p > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let i = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((r = this.domChanged) === null || r === void 0) && r.newSel ? i = this.domChanged.newSel.head : !$L(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let n = i > -1 ? EL(this.view, e.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: p, to: d } = this.hasComposition;
      s = new Sr(p, d, e.changes.mapPos(p, -1), e.changes.mapPos(d, 1)).addToSet(s.slice());
    }
    this.hasComposition = n ? { from: n.range.fromB, to: n.range.toB } : null, (ee.ie || ee.chrome) && !n && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let a = this.decorations, l = this.updateDeco(), c = PL(a, l, e.changes);
    return s = Sr.extendWithRanges(s, c), !(this.flags & 7) && s.length == 0 ? !1 : (this.updateInner(s, e.startState.doc.length, n), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, r, s) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, r, s);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let a = ee.chrome || ee.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, a), this.flags &= -8, a && (a.written || i.selectionRange.focusNode != a.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (a) => a.flags &= -9
      /* ViewFlag.Composition */
    );
    let n = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let a of this.children)
        a instanceof Ps && a.widget instanceof sf && n.push(a.dom);
    i.updateGaps(n);
  }
  updateChildren(e, r, s) {
    let i = s ? s.range.addToSet(e.slice()) : e, n = this.childCursor(r);
    for (let a = i.length - 1; ; a--) {
      let l = a >= 0 ? i[a] : null;
      if (!l)
        break;
      let { fromA: c, toA: p, fromB: d, toB: m } = l, y, g, x, v;
      if (s && s.range.fromB < m && s.range.toB > d) {
        let Q = Po.build(this.view.state.doc, d, s.range.fromB, this.decorations, this.dynamicDecorationMap), F = Po.build(this.view.state.doc, s.range.toB, m, this.decorations, this.dynamicDecorationMap);
        g = Q.breakAtStart, x = Q.openStart, v = F.openEnd;
        let $ = this.compositionView(s);
        F.breakAtStart ? $.breakAfter = 1 : F.content.length && $.merge($.length, $.length, F.content[0], !1, F.openStart, 0) && ($.breakAfter = F.content[0].breakAfter, F.content.shift()), Q.content.length && $.merge(0, 0, Q.content[Q.content.length - 1], !0, 0, Q.openEnd) && Q.content.pop(), y = Q.content.concat($).concat(F.content);
      } else
        ({ content: y, breakAtStart: g, openStart: x, openEnd: v } = Po.build(this.view.state.doc, d, m, this.decorations, this.dynamicDecorationMap));
      let { i: w, off: C } = n.findPos(p, 1), { i: b, off: k } = n.findPos(c, -1);
      ew(this, b, k, w, C, y, g, x, v);
    }
    s && this.fixCompositionDOM(s);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let r of e.transactions)
      for (let s of r.effects)
        s.is(vw) && (this.editContextFormatting = s.value);
  }
  compositionView(e) {
    let r = new Xr(e.text.nodeValue);
    r.flags |= 8;
    for (let { deco: i } of e.marks)
      r = new Rs(i, [r], r.length);
    let s = new et();
    return s.append(r, 0), s;
  }
  fixCompositionDOM(e) {
    let r = (n, a) => {
      a.flags |= 8 | (a.children.some(
        (c) => c.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(a);
      let l = Ie.get(n);
      l && l != a && (l.dom = null), a.setDOM(n);
    }, s = this.childPos(e.range.fromB, 1), i = this.children[s.i];
    r(e.line, i);
    for (let n = e.marks.length - 1; n >= -1; n--)
      s = i.childPos(s.off, 1), i = i.children[s.i], r(n >= 0 ? e.marks[n].node : e.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, r = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let s = this.view.root.activeElement, i = s == this.dom, n = !i && !(this.view.state.facet(Ts) || this.dom.tabIndex > -1) && Mu(this.dom, this.view.observer.selectionRange) && !(s && this.dom.contains(s));
    if (!(i || r || n))
      return;
    let a = this.forceSelection;
    this.forceSelection = !1;
    let l = this.view.state.selection.main, c = this.moveToLine(this.domAtPos(l.anchor)), p = l.empty ? c : this.moveToLine(this.domAtPos(l.head));
    if (ee.gecko && l.empty && !this.hasComposition && CL(c)) {
      let m = document.createTextNode("");
      this.view.observer.ignore(() => c.node.insertBefore(m, c.node.childNodes[c.offset] || null)), c = p = new Tt(m, 0), a = !0;
    }
    let d = this.view.observer.selectionRange;
    (a || !d.focusNode || (!ko(c.node, c.offset, d.anchorNode, d.anchorOffset) || !ko(p.node, p.offset, d.focusNode, d.focusOffset)) && !this.suppressWidgetCursorChange(d, l)) && (this.view.observer.ignore(() => {
      ee.android && ee.chrome && this.dom.contains(d.focusNode) && FL(d.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let m = Vo(this.view.root);
      if (m) if (l.empty) {
        if (ee.gecko) {
          let y = TL(c.node, c.offset);
          if (y && y != 3) {
            let g = (y == 1 ? HS : JS)(c.node, c.offset);
            g && (c = new Tt(g.node, g.offset));
          }
        }
        m.collapse(c.node, c.offset), l.bidiLevel != null && m.caretBidiLevel !== void 0 && (m.caretBidiLevel = l.bidiLevel);
      } else if (m.extend) {
        m.collapse(c.node, c.offset);
        try {
          m.extend(p.node, p.offset);
        } catch {
        }
      } else {
        let y = document.createRange();
        l.anchor > l.head && ([c, p] = [p, c]), y.setEnd(p.node, p.offset), y.setStart(c.node, c.offset), m.removeAllRanges(), m.addRange(y);
      }
      n && this.view.root.activeElement == this.dom && (this.dom.blur(), s && s.focus());
    }), this.view.observer.setSelectionRange(c, p)), this.impreciseAnchor = c.precise ? null : new Tt(d.anchorNode, d.anchorOffset), this.impreciseHead = p.precise ? null : new Tt(d.focusNode, d.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, r) {
    return this.hasComposition && r.empty && ko(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == r.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, r = e.state.selection.main, s = Vo(e.root), { anchorNode: i, anchorOffset: n } = e.observer.selectionRange;
    if (!s || !r.empty || !r.assoc || !s.modify)
      return;
    let a = et.find(this, r.head);
    if (!a)
      return;
    let l = a.posAtStart;
    if (r.head == l || r.head == l + a.length)
      return;
    let c = this.coordsAt(r.head, -1), p = this.coordsAt(r.head, 1);
    if (!c || !p || c.bottom > p.top)
      return;
    let d = this.domAtPos(r.head + r.assoc);
    s.collapse(d.node, d.offset), s.modify("move", r.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let m = e.observer.selectionRange;
    e.docView.posFromDOM(m.anchorNode, m.anchorOffset) != r.from && s.collapse(i, n);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let r = this.dom, s;
    if (e.node != r)
      return e;
    for (let i = e.offset; !s && i < r.childNodes.length; i++) {
      let n = Ie.get(r.childNodes[i]);
      n instanceof et && (s = n.domAtPos(0));
    }
    for (let i = e.offset - 1; !s && i >= 0; i--) {
      let n = Ie.get(r.childNodes[i]);
      n instanceof et && (s = n.domAtPos(n.length));
    }
    return s ? new Tt(s.node, s.offset, !0) : e;
  }
  nearest(e) {
    for (let r = e; r; ) {
      let s = Ie.get(r);
      if (s && s.rootView == this)
        return s;
      r = r.parentNode;
    }
    return null;
  }
  posFromDOM(e, r) {
    let s = this.nearest(e);
    if (!s)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return s.localPosFromDOM(e, r) + s.posAtStart;
  }
  domAtPos(e) {
    let { i: r, off: s } = this.childCursor().findPos(e, -1);
    for (; r < this.children.length - 1; ) {
      let i = this.children[r];
      if (s < i.length || i instanceof et)
        break;
      r++, s = 0;
    }
    return this.children[r].domAtPos(s);
  }
  coordsAt(e, r) {
    let s = null, i = 0;
    for (let n = this.length, a = this.children.length - 1; a >= 0; a--) {
      let l = this.children[a], c = n - l.breakAfter, p = c - l.length;
      if (c < e)
        break;
      if (p <= e && (p < e || l.covers(-1)) && (c > e || l.covers(1)) && (!s || l instanceof et && !(s instanceof et && r >= 0)))
        s = l, i = p;
      else if (s && p == e && c == e && l instanceof Ps && Math.abs(r) < 2) {
        if (l.deco.startSide < 0)
          break;
        a && (s = null);
      }
      n = p;
    }
    return s ? s.coordsAt(e - i, r) : null;
  }
  coordsForChar(e) {
    let { i: r, off: s } = this.childPos(e, 1), i = this.children[r];
    if (!(i instanceof et))
      return null;
    for (; i.children.length; ) {
      let { i: l, off: c } = i.childPos(s, 1);
      for (; ; l++) {
        if (l == i.children.length)
          return null;
        if ((i = i.children[l]).length)
          break;
      }
      s = c;
    }
    if (!(i instanceof Xr))
      return null;
    let n = Dt(i.text, s);
    if (n == s)
      return null;
    let a = mn(i.dom, s, n).getClientRects();
    for (let l = 0; l < a.length; l++) {
      let c = a[l];
      if (l == a.length - 1 || c.top < c.bottom && c.left < c.right)
        return c;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let r = [], { from: s, to: i } = e, n = this.view.contentDOM.clientWidth, a = n > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, l = -1, c = this.view.textDirection == _e.LTR;
    for (let p = 0, d = 0; d < this.children.length; d++) {
      let m = this.children[d], y = p + m.length;
      if (y > i)
        break;
      if (p >= s) {
        let g = m.dom.getBoundingClientRect();
        if (r.push(g.height), a) {
          let x = m.dom.lastChild, v = x ? zo(x) : [];
          if (v.length) {
            let w = v[v.length - 1], C = c ? w.right - g.left : g.right - w.left;
            C > l && (l = C, this.minWidth = n, this.minWidthFrom = p, this.minWidthTo = y);
          }
        }
      }
      p = y + m.breakAfter;
    }
    return r;
  }
  textDirectionAt(e) {
    let { i: r } = this.childPos(e, 1);
    return getComputedStyle(this.children[r].dom).direction == "rtl" ? _e.RTL : _e.LTR;
  }
  measureTextSize() {
    for (let n of this.children)
      if (n instanceof et) {
        let a = n.measureTextSize();
        if (a)
          return a;
      }
    let e = document.createElement("div"), r, s, i;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let n = zo(e.firstChild)[0];
      r = e.getBoundingClientRect().height, s = n ? n.width / 27 : 7, i = n ? n.height : r, e.remove();
    }), { lineHeight: r, charWidth: s, textHeight: i };
  }
  childCursor(e = this.length) {
    let r = this.children.length;
    return r && (e -= this.children[--r].length), new KS(this.children, e, r);
  }
  computeBlockGapDeco() {
    let e = [], r = this.view.viewState;
    for (let s = 0, i = 0; ; i++) {
      let n = i == r.viewports.length ? null : r.viewports[i], a = n ? n.from - 1 : this.length;
      if (a > s) {
        let l = (r.lineBlockAt(a).bottom - r.lineBlockAt(s).top) / this.view.scaleY;
        e.push(ce.replace({
          widget: new sf(l),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(s, a));
      }
      if (!n)
        break;
      s = n.to + 1;
    }
    return ce.set(e);
  }
  updateDeco() {
    let e = 1, r = this.view.state.facet(Uo).map((n) => (this.dynamicDecorationMap[e++] = typeof n == "function") ? n(this.view) : n), s = !1, i = this.view.state.facet(ww).map((n, a) => {
      let l = typeof n == "function";
      return l && (s = !0), l ? n(this.view) : n;
    });
    for (i.length && (this.dynamicDecorationMap[e++] = s, r.push(Ce.join(i))), this.decorations = [
      this.editContextFormatting,
      ...r,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let p = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = p.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let p of this.view.state.facet(bw))
      try {
        if (p(this.view, e.range, e))
          return !0;
      } catch (d) {
        Ut(this.view.state, d, "scroll handler");
      }
    let { range: r } = e, s = this.coordsAt(r.head, r.empty ? r.assoc : r.head > r.anchor ? -1 : 1), i;
    if (!s)
      return;
    !r.empty && (i = this.coordsAt(r.anchor, r.anchor > r.head ? -1 : 1)) && (s = {
      left: Math.min(s.left, i.left),
      top: Math.min(s.top, i.top),
      right: Math.max(s.right, i.right),
      bottom: Math.max(s.bottom, i.bottom)
    });
    let n = cg(this.view), a = {
      left: s.left - n.left,
      top: s.top - n.top,
      right: s.right + n.right,
      bottom: s.bottom + n.bottom
    }, { offsetWidth: l, offsetHeight: c } = this.view.scrollDOM;
    iL(this.view.scrollDOM, a, r.head < r.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, l), -l), Math.max(Math.min(e.yMargin, c), -c), this.view.textDirection == _e.LTR);
  }
}
function CL(t) {
  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
}
function Ew(t, e) {
  let r = t.observer.selectionRange;
  if (!r.focusNode)
    return null;
  let s = HS(r.focusNode, r.focusOffset), i = JS(r.focusNode, r.focusOffset), n = s || i;
  if (i && s && i.node != s.node) {
    let l = Ie.get(i.node);
    if (!l || l instanceof Xr && l.text != i.node.nodeValue)
      n = i;
    else if (t.docView.lastCompositionAfterCursor) {
      let c = Ie.get(s.node);
      !c || c instanceof Xr && c.text != s.node.nodeValue || (n = i);
    }
  }
  if (t.docView.lastCompositionAfterCursor = n != s, !n)
    return null;
  let a = e - n.offset;
  return { from: a, to: a + n.node.nodeValue.length, node: n.node };
}
function EL(t, e, r) {
  let s = Ew(t, r);
  if (!s)
    return null;
  let { node: i, from: n, to: a } = s, l = i.nodeValue;
  if (/[\n\r]/.test(l) || t.state.doc.sliceString(s.from, s.to) != l)
    return null;
  let c = e.invertedDesc, p = new Sr(c.mapPos(n), c.mapPos(a), n, a), d = [];
  for (let m = i.parentNode; ; m = m.parentNode) {
    let y = Ie.get(m);
    if (y instanceof Rs)
      d.push({ node: m, deco: y.mark });
    else {
      if (y instanceof et || m.nodeName == "DIV" && m.parentNode == t.contentDOM)
        return { range: p, text: i, marks: d, line: m };
      if (m != t.contentDOM)
        d.push({ node: m, deco: new wl({
          inclusive: !0,
          attributes: fL(m),
          tagName: m.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function TL(t, e) {
  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let kL = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t, e) {
    Lu(t, e, this.changes);
  }
  comparePoint(t, e) {
    Lu(t, e, this.changes);
  }
  boundChange(t) {
    Lu(t, t, this.changes);
  }
};
function PL(t, e, r) {
  let s = new kL();
  return Ce.compare(t, e, r, s), s.changes;
}
function FL(t, e) {
  for (let r = t; r && r != e; r = r.assignedSlot || r.parentNode)
    if (r.nodeType == 1 && r.contentEditable == "false")
      return !0;
  return !1;
}
function $L(t, e) {
  let r = !1;
  return e && t.iterChangedRanges((s, i) => {
    s < e.to && i > e.from && (r = !0);
  }), r;
}
function QL(t, e, r = 1) {
  let s = t.charCategorizer(e), i = t.doc.lineAt(e), n = e - i.from;
  if (i.length == 0)
    return L.cursor(e);
  n == 0 ? r = 1 : n == i.length && (r = -1);
  let a = n, l = n;
  r < 0 ? a = Dt(i.text, n, !1) : l = Dt(i.text, n);
  let c = s(i.text.slice(a, l));
  for (; a > 0; ) {
    let p = Dt(i.text, a, !1);
    if (s(i.text.slice(p, a)) != c)
      break;
    a = p;
  }
  for (; l < i.length; ) {
    let p = Dt(i.text, l);
    if (s(i.text.slice(l, p)) != c)
      break;
    l = p;
  }
  return L.range(a + i.from, l + i.from);
}
function BL(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function IL(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function Ap(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function H0(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function J0(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function uf(t, e, r) {
  let s, i, n, a, l = !1, c, p, d, m;
  for (let x = t.firstChild; x; x = x.nextSibling) {
    let v = zo(x);
    for (let w = 0; w < v.length; w++) {
      let C = v[w];
      i && Ap(i, C) && (C = H0(J0(C, i.bottom), i.top));
      let b = BL(e, C), k = IL(r, C);
      if (b == 0 && k == 0)
        return x.nodeType == 3 ? K0(x, e, r) : uf(x, e, r);
      (!s || a > k || a == k && n > b) && (s = x, i = C, n = b, a = k, l = b ? e < C.left ? w > 0 : w < v.length - 1 : !0), b == 0 ? r > C.bottom && (!d || d.bottom < C.bottom) ? (c = x, d = C) : r < C.top && (!m || m.top > C.top) && (p = x, m = C) : d && Ap(d, C) ? d = J0(d, C.bottom) : m && Ap(m, C) && (m = H0(m, C.top));
    }
  }
  if (d && d.bottom >= r ? (s = c, i = d) : m && m.top <= r && (s = p, i = m), !s)
    return { node: t, offset: 0 };
  let y = Math.max(i.left, Math.min(i.right, e));
  if (s.nodeType == 3)
    return K0(s, y, r);
  if (l && s.contentEditable != "false")
    return uf(s, y, r);
  let g = Array.prototype.indexOf.call(t.childNodes, s) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: t, offset: g };
}
function K0(t, e, r) {
  let s = t.nodeValue.length, i = -1, n = 1e9, a = 0;
  for (let l = 0; l < s; l++) {
    let c = mn(t, l, l + 1).getClientRects();
    for (let p = 0; p < c.length; p++) {
      let d = c[p];
      if (d.top == d.bottom)
        continue;
      a || (a = e - d.left);
      let m = (d.top > r ? d.top - r : r - d.bottom) - 1;
      if (d.left - 1 <= e && d.right + 1 >= e && m < n) {
        let y = e >= (d.left + d.right) / 2, g = y;
        if ((ee.chrome || ee.gecko) && mn(t, l).getBoundingClientRect().left == d.right && (g = !y), m <= 0)
          return { node: t, offset: l + (g ? 1 : 0) };
        i = l + (g ? 1 : 0), n = m;
      }
    }
  }
  return { node: t, offset: i > -1 ? i : a > 0 ? t.nodeValue.length : 0 };
}
function Tw(t, e, r, s = -1) {
  var i, n;
  let a = t.contentDOM.getBoundingClientRect(), l = a.top + t.viewState.paddingTop, c, { docHeight: p } = t.viewState, { x: d, y: m } = e, y = m - l;
  if (y < 0)
    return 0;
  if (y > p)
    return t.state.doc.length;
  for (let Q = t.viewState.heightOracle.textHeight / 2, F = !1; c = t.elementAtHeight(y), c.type != Mt.Text; )
    for (; y = s > 0 ? c.bottom + Q : c.top - Q, !(y >= 0 && y <= p); ) {
      if (F)
        return r ? null : 0;
      F = !0, s = -s;
    }
  m = l + y;
  let g = c.from;
  if (g < t.viewport.from)
    return t.viewport.from == 0 ? 0 : r ? null : e1(t, a, c, d, m);
  if (g > t.viewport.to)
    return t.viewport.to == t.state.doc.length ? t.state.doc.length : r ? null : e1(t, a, c, d, m);
  let x = t.dom.ownerDocument, v = t.root.elementFromPoint ? t.root : x, w = v.elementFromPoint(d, m);
  w && !t.contentDOM.contains(w) && (w = null), w || (d = Math.max(a.left + 1, Math.min(a.right - 1, d)), w = v.elementFromPoint(d, m), w && !t.contentDOM.contains(w) && (w = null));
  let C, b = -1;
  if (w && ((i = t.docView.nearest(w)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (x.caretPositionFromPoint) {
      let Q = x.caretPositionFromPoint(d, m);
      Q && ({ offsetNode: C, offset: b } = Q);
    } else if (x.caretRangeFromPoint) {
      let Q = x.caretRangeFromPoint(d, m);
      Q && ({ startContainer: C, startOffset: b } = Q, (!t.contentDOM.contains(C) || ee.safari && NL(C, b, d) || ee.chrome && ML(C, b, d)) && (C = void 0));
    }
    C && (b = Math.min(fs(C), b));
  }
  if (!C || !t.docView.dom.contains(C)) {
    let Q = et.find(t.docView, g);
    if (!Q)
      return y > c.top + c.height / 2 ? c.to : c.from;
    ({ node: C, offset: b } = uf(Q.dom, d, m));
  }
  let k = t.docView.nearest(C);
  if (!k)
    return null;
  if (k.isWidget && ((n = k.dom) === null || n === void 0 ? void 0 : n.nodeType) == 1) {
    let Q = k.dom.getBoundingClientRect();
    return e.y < Q.top || e.y <= Q.bottom && e.x <= (Q.left + Q.right) / 2 ? k.posAtStart : k.posAtEnd;
  } else
    return k.localPosFromDOM(C, b) + k.posAtStart;
}
function e1(t, e, r, s, i) {
  let n = Math.round((s - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && r.height > t.defaultLineHeight * 1.5) {
    let l = t.viewState.heightOracle.textHeight, c = Math.floor((i - r.top - (t.defaultLineHeight - l) * 0.5) / l);
    n += c * t.viewState.heightOracle.lineLength;
  }
  let a = t.state.sliceDoc(r.from, r.to);
  return r.from + Yd(a, n, t.state.tabSize);
}
function NL(t, e, r) {
  let s, i = t;
  if (t.nodeType != 3 || e != (s = t.nodeValue.length))
    return !1;
  for (; ; ) {
    let n = i.nextSibling;
    if (n) {
      if (n.nodeName == "BR")
        break;
      return !1;
    } else {
      let a = i.parentNode;
      if (!a || a.nodeName == "DIV")
        break;
      i = a;
    }
  }
  return mn(t, s - 1, s).getBoundingClientRect().right > r;
}
function ML(t, e, r) {
  if (e != 0)
    return !1;
  for (let i = t; ; ) {
    let n = i.parentNode;
    if (!n || n.nodeType != 1 || n.firstChild != i)
      return !1;
    if (n.classList.contains("cm-line"))
      break;
    i = n;
  }
  let s = t.nodeType == 1 ? t.getBoundingClientRect() : mn(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return r - s.left > 5;
}
function cf(t, e, r) {
  let s = t.lineBlockAt(e);
  if (Array.isArray(s.type)) {
    let i;
    for (let n of s.type) {
      if (n.from > e)
        break;
      if (!(n.to < e)) {
        if (n.from < e && n.to > e)
          return n;
        (!i || n.type == Mt.Text && (i.type != n.type || (r < 0 ? n.from < e : n.to > e))) && (i = n);
      }
    }
    return i || s;
  }
  return s;
}
function LL(t, e, r, s) {
  let i = cf(t, e.head, e.assoc || -1), n = !s || i.type != Mt.Text || !(t.lineWrapping || i.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (n) {
    let a = t.dom.getBoundingClientRect(), l = t.textDirectionAt(i.from), c = t.posAtCoords({
      x: r == (l == _e.LTR) ? a.right - 1 : a.left + 1,
      y: (n.top + n.bottom) / 2
    });
    if (c != null)
      return L.cursor(c, r ? -1 : 1);
  }
  return L.cursor(r ? i.to : i.from, r ? -1 : 1);
}
function t1(t, e, r, s) {
  let i = t.state.doc.lineAt(e.head), n = t.bidiSpans(i), a = t.textDirectionAt(i.from);
  for (let l = e, c = null; ; ) {
    let p = SL(i, n, a, l, r), d = pw;
    if (!p) {
      if (i.number == (r ? t.state.doc.lines : 1))
        return l;
      d = `
`, i = t.state.doc.line(i.number + (r ? 1 : -1)), n = t.bidiSpans(i), p = t.visualLineSide(i, !r);
    }
    if (c) {
      if (!c(d))
        return l;
    } else {
      if (!s)
        return p;
      c = s(d);
    }
    l = p;
  }
}
function _L(t, e, r) {
  let s = t.state.charCategorizer(e), i = s(r);
  return (n) => {
    let a = s(n);
    return i == Xe.Space && (i = a), i == a;
  };
}
function RL(t, e, r, s) {
  let i = e.head, n = r ? 1 : -1;
  if (i == (r ? t.state.doc.length : 0))
    return L.cursor(i, e.assoc);
  let a = e.goalColumn, l, c = t.contentDOM.getBoundingClientRect(), p = t.coordsAtPos(i, e.assoc || -1), d = t.documentTop;
  if (p)
    a == null && (a = p.left - c.left), l = n < 0 ? p.top : p.bottom;
  else {
    let g = t.viewState.lineBlockAt(i);
    a == null && (a = Math.min(c.right - c.left, t.defaultCharacterWidth * (i - g.from))), l = (n < 0 ? g.top : g.bottom) + d;
  }
  let m = c.left + a, y = s != null ? s : t.viewState.heightOracle.textHeight >> 1;
  for (let g = 0; ; g += 10) {
    let x = l + (y + g) * n, v = Tw(t, { x: m, y: x }, !1, n);
    if (x < c.top || x > c.bottom || (n < 0 ? v < i : v > i)) {
      let w = t.docView.coordsForChar(v), C = !w || x < w.top ? -1 : 1;
      return L.cursor(v, C, void 0, a);
    }
  }
}
function _u(t, e, r) {
  for (; ; ) {
    let s = 0;
    for (let i of t)
      i.between(e - 1, e + 1, (n, a, l) => {
        if (e > n && e < a) {
          let c = s || r || (e - n < a - e ? -1 : 1);
          e = c < 0 ? n : a, s = c;
        }
      });
    if (!s)
      return e;
  }
}
function Cp(t, e, r) {
  let s = _u(t.state.facet(ug).map((i) => i(t)), r.from, e.head > r.from ? -1 : 1);
  return s == r.from ? r : L.cursor(s, s < r.from ? 1 : -1);
}
const ho = "";
class qL {
  constructor(e, r) {
    this.points = e, this.text = "", this.lineSeparator = r.facet(we.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += ho;
  }
  readRange(e, r) {
    if (!e)
      return this;
    let s = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(s, i);
      let n = this.text.length;
      this.readNode(i);
      let a = i.nextSibling;
      if (a == r)
        break;
      let l = Ie.get(i), c = Ie.get(a);
      (l && c ? l.breakAfter : (l ? l.breakAfter : dc(i)) || dc(a) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > n) && this.lineBreak(), i = a;
    }
    return this.findPointBefore(s, r), this;
  }
  readTextNode(e) {
    let r = e.nodeValue;
    for (let s of this.points)
      s.node == e && (s.pos = this.text.length + Math.min(s.offset, r.length));
    for (let s = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let n = -1, a = 1, l;
      if (this.lineSeparator ? (n = r.indexOf(this.lineSeparator, s), a = this.lineSeparator.length) : (l = i.exec(r)) && (n = l.index, a = l[0].length), this.append(r.slice(s, n < 0 ? r.length : n)), n < 0)
        break;
      if (this.lineBreak(), a > 1)
        for (let c of this.points)
          c.node == e && c.pos > this.text.length && (c.pos -= a - 1);
      s = n + a;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let r = Ie.get(e), s = r && r.overrideDOMText;
    if (s != null) {
      this.findPointInside(e, s.length);
      for (let i = s.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, r) {
    for (let s of this.points)
      s.node == e && e.childNodes[s.offset] == r && (s.pos = this.text.length);
  }
  findPointInside(e, r) {
    for (let s of this.points)
      (e.nodeType == 3 ? s.node == e : e.contains(s.node)) && (s.pos = this.text.length + (jL(e, s.node, s.offset) ? r : 0));
  }
}
function jL(t, e, r) {
  for (; ; ) {
    if (!e || r < fs(e))
      return !1;
    if (e == t)
      return !0;
    r = fn(e) + 1, e = e.parentNode;
  }
}
class r1 {
  constructor(e, r) {
    this.node = e, this.offset = r, this.pos = -1;
  }
}
class XL {
  constructor(e, r, s, i) {
    this.typeOver = i, this.bounds = null, this.text = "", this.domChanged = r > -1;
    let { impreciseHead: n, impreciseAnchor: a } = e.docView;
    if (e.state.readOnly && r > -1)
      this.newSel = null;
    else if (r > -1 && (this.bounds = e.docView.domBoundsAround(r, s, 0))) {
      let l = n || a ? [] : zL(e), c = new qL(l, e.state);
      c.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = c.text, this.newSel = UL(l, this.bounds.from);
    } else {
      let l = e.observer.selectionRange, c = n && n.node == l.focusNode && n.offset == l.focusOffset || !Hd(e.contentDOM, l.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(l.focusNode, l.focusOffset), p = a && a.node == l.anchorNode && a.offset == l.anchorOffset || !Hd(e.contentDOM, l.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(l.anchorNode, l.anchorOffset), d = e.viewport;
      if ((ee.ios || ee.chrome) && e.state.selection.main.empty && c != p && (d.from > 0 || d.to < e.state.doc.length)) {
        let m = Math.min(c, p), y = Math.max(c, p), g = d.from - m, x = d.to - y;
        (g == 0 || g == 1 || m == 0) && (x == 0 || x == -1 || y == e.state.doc.length) && (c = 0, p = e.state.doc.length);
      }
      this.newSel = L.single(p, c);
    }
  }
}
function kw(t, e) {
  let r, { newSel: s } = e, i = t.state.selection.main, n = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: a, to: l } = e.bounds, c = i.from, p = null;
    (n === 8 || ee.android && e.text.length < l - a) && (c = i.to, p = "end");
    let d = VL(t.state.doc.sliceString(a, l, ho), e.text, c - a, p);
    d && (ee.chrome && n == 13 && d.toB == d.from + 2 && e.text.slice(d.from, d.toB) == ho + ho && d.toB--, r = {
      from: a + d.from,
      to: a + d.toA,
      insert: Se.of(e.text.slice(d.from, d.toB).split(ho))
    });
  } else s && (!t.hasFocus && t.state.facet(Ts) || s.main.eq(i)) && (s = null);
  if (!r && !s)
    return !1;
  if (!r && e.typeOver && !i.empty && s && s.main.empty ? r = { from: i.from, to: i.to, insert: t.state.doc.slice(i.from, i.to) } : (ee.mac || ee.android) && r && r.from == r.to && r.from == i.head - 1 && /^\. ?$/.test(r.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (s && r.insert.length == 2 && (s = L.single(s.main.anchor - 1, s.main.head - 1)), r = { from: r.from, to: r.to, insert: Se.of([r.insert.toString().replace(".", " ")]) }) : r && r.from >= i.from && r.to <= i.to && (r.from != i.from || r.to != i.to) && i.to - i.from - (r.to - r.from) <= 4 ? r = {
    from: i.from,
    to: i.to,
    insert: t.state.doc.slice(i.from, r.from).append(r.insert).append(t.state.doc.slice(r.to, i.to))
  } : ee.chrome && r && r.from == r.to && r.from == i.head && r.insert.toString() == `
 ` && t.lineWrapping && (s && (s = L.single(s.main.anchor - 1, s.main.head - 1)), r = { from: i.from, to: i.to, insert: Se.of([" "]) }), r)
    return hg(t, r, s, n);
  if (s && !s.main.eq(i)) {
    let a = !1, l = "select";
    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (a = !0), l = t.inputState.lastSelectionOrigin), t.dispatch({ selection: s, scrollIntoView: a, userEvent: l }), !0;
  } else
    return !1;
}
function hg(t, e, r, s = -1) {
  if (ee.ios && t.inputState.flushIOSKey(e))
    return !0;
  let i = t.state.selection.main;
  if (ee.android && (e.to == i.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == i.from || e.from == i.from - 1 && t.state.sliceDoc(e.from, i.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && Hn(t.contentDOM, "Enter", 13) || (e.from == i.from - 1 && e.to == i.to && e.insert.length == 0 || s == 8 && e.insert.length < e.to - e.from && e.to > i.head) && Hn(t.contentDOM, "Backspace", 8) || e.from == i.from && e.to == i.to + 1 && e.insert.length == 0 && Hn(t.contentDOM, "Delete", 46)))
    return !0;
  let n = e.insert.toString();
  t.inputState.composing >= 0 && t.inputState.composing++;
  let a, l = () => a || (a = ZL(t, e, r));
  return t.state.facet(yw).some((c) => c(t, e.from, e.to, n, l)) || t.dispatch(l()), !0;
}
function ZL(t, e, r) {
  let s, i = t.state, n = i.selection.main;
  if (e.from >= n.from && e.to <= n.to && e.to - e.from >= (n.to - n.from) / 3 && (!r || r.main.empty && r.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
    let l = n.from < e.from ? i.sliceDoc(n.from, e.from) : "", c = n.to > e.to ? i.sliceDoc(e.to, n.to) : "";
    s = i.replaceSelection(t.state.toText(l + e.insert.sliceString(0, void 0, t.state.lineBreak) + c));
  } else {
    let l = i.changes(e), c = r && r.main.to <= l.newLength ? r.main : void 0;
    if (i.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= n.to && e.to >= n.to - 10) {
      let p = t.state.sliceDoc(e.from, e.to), d, m = r && Ew(t, r.main.head);
      if (m) {
        let x = e.insert.length - (e.to - e.from);
        d = { from: m.from, to: m.to - x };
      } else
        d = t.state.doc.lineAt(n.head);
      let y = n.to - e.to, g = n.to - n.from;
      s = i.changeByRange((x) => {
        if (x.from == n.from && x.to == n.to)
          return { changes: l, range: c || x.map(l) };
        let v = x.to - y, w = v - p.length;
        if (x.to - x.from != g || t.state.sliceDoc(w, v) != p || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        x.to >= d.from && x.from <= d.to)
          return { range: x };
        let C = i.changes({ from: w, to: v, insert: e.insert }), b = x.to - n.to;
        return {
          changes: C,
          range: c ? L.range(Math.max(0, c.anchor + b), Math.max(0, c.head + b)) : x.map(C)
        };
      });
    } else
      s = {
        changes: l,
        selection: c && i.selection.replaceRange(c)
      };
  }
  let a = "input.type";
  return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, a += ".compose", t.inputState.compositionFirstChange && (a += ".start", t.inputState.compositionFirstChange = !1)), i.update(s, { userEvent: a, scrollIntoView: !0 });
}
function VL(t, e, r, s) {
  let i = Math.min(t.length, e.length), n = 0;
  for (; n < i && t.charCodeAt(n) == e.charCodeAt(n); )
    n++;
  if (n == i && t.length == e.length)
    return null;
  let a = t.length, l = e.length;
  for (; a > 0 && l > 0 && t.charCodeAt(a - 1) == e.charCodeAt(l - 1); )
    a--, l--;
  if (s == "end") {
    let c = Math.max(0, n - Math.min(a, l));
    r -= a + c - n;
  }
  if (a < n && t.length < e.length) {
    let c = r <= n && r >= a ? n - r : 0;
    n -= c, l = n + (l - a), a = n;
  } else if (l < n) {
    let c = r <= n && r >= l ? n - r : 0;
    n -= c, a = n + (a - l), l = n;
  }
  return { from: n, toA: a, toB: l };
}
function zL(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM)
    return e;
  let { anchorNode: r, anchorOffset: s, focusNode: i, focusOffset: n } = t.observer.selectionRange;
  return r && (e.push(new r1(r, s)), (i != r || n != s) && e.push(new r1(i, n))), e;
}
function UL(t, e) {
  if (t.length == 0)
    return null;
  let r = t[0].pos, s = t.length == 2 ? t[1].pos : r;
  return r > -1 && s > -1 ? L.single(r + e, s + e) : null;
}
class YL {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, ee.safari && e.contentDOM.addEventListener("input", () => null), ee.gecko && c_(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !r_(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
  }
  runHandlers(e, r) {
    let s = this.handlers[e];
    if (s) {
      for (let i of s.observers)
        i(this.view, r);
      for (let i of s.handlers) {
        if (r.defaultPrevented)
          break;
        if (i(this.view, r)) {
          r.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let r = WL(e), s = this.handlers, i = this.view.contentDOM;
    for (let n in r)
      if (n != "scroll") {
        let a = !r[n].handlers.length, l = s[n];
        l && a != !l.handlers.length && (i.removeEventListener(n, this.handleEvent), l = null), l || i.addEventListener(n, this.handleEvent, { passive: a });
      }
    for (let n in s)
      n != "scroll" && !r[n] && i.removeEventListener(n, this.handleEvent);
    this.handlers = r;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && Fw.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), ee.android && ee.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let r;
    return ee.ios && !e.synthetic && !e.altKey && !e.metaKey && ((r = Pw.find((s) => s.keyCode == e.keyCode)) && !e.ctrlKey || GL.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = r || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let r = this.pendingIOSKey;
    return !r || r.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, Hn(this.view.contentDOM, r.key, r.keyCode, r instanceof KeyboardEvent ? r : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : ee.safari && !ee.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function s1(t, e) {
  return (r, s) => {
    try {
      return e.call(t, s, r);
    } catch (i) {
      Ut(r.state, i);
    }
  };
}
function WL(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function r(s) {
    return e[s] || (e[s] = { observers: [], handlers: [] });
  }
  for (let s of t) {
    let i = s.spec, n = i && i.plugin.domEventHandlers, a = i && i.plugin.domEventObservers;
    if (n)
      for (let l in n) {
        let c = n[l];
        c && r(l).handlers.push(s1(s.value, c));
      }
    if (a)
      for (let l in a) {
        let c = a[l];
        c && r(l).observers.push(s1(s.value, c));
      }
  }
  for (let s in Zr)
    r(s).handlers.push(Zr[s]);
  for (let s in Cr)
    r(s).observers.push(Cr[s]);
  return e;
}
const Pw = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], GL = "dthko", Fw = [16, 17, 18, 20, 91, 92, 224, 225], ou = 6;
function lu(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function HL(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class JL {
  constructor(e, r, s, i) {
    this.view = e, this.startEvent = r, this.style = s, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = r, this.scrollParents = nL(e.contentDOM), this.atoms = e.state.facet(ug).map((a) => a(e));
    let n = e.contentDOM.ownerDocument;
    n.addEventListener("mousemove", this.move = this.move.bind(this)), n.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = r.shiftKey, this.multiple = e.state.facet(we.allowMultipleSelections) && KL(e, r), this.dragging = t_(e, r) && Bw(r) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && HL(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let r = 0, s = 0, i = 0, n = 0, a = this.view.win.innerWidth, l = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: i, right: a } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: n, bottom: l } = this.scrollParents.y.getBoundingClientRect());
    let c = cg(this.view);
    e.clientX - c.left <= i + ou ? r = -lu(i - e.clientX) : e.clientX + c.right >= a - ou && (r = lu(e.clientX - a)), e.clientY - c.top <= n + ou ? s = -lu(n - e.clientY) : e.clientY + c.bottom >= l - ou && (s = lu(e.clientY - l)), this.setScrollSpeed(r, s);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, r) {
    this.scrollSpeed = { x: e, y: r }, e || r ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: r } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), r && this.scrollParents.y && (this.scrollParents.y.scrollTop += r, r = 0), (e || r) && this.view.win.scrollBy(e, r), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let r = null;
    for (let s = 0; s < e.ranges.length; s++) {
      let i = e.ranges[s], n = null;
      if (i.empty) {
        let a = _u(this.atoms, i.from, 0);
        a != i.from && (n = L.cursor(a, -1));
      } else {
        let a = _u(this.atoms, i.from, -1), l = _u(this.atoms, i.to, 1);
        (a != i.from || l != i.to) && (n = L.range(i.from == i.anchor ? a : l, i.from == i.head ? a : l));
      }
      n && (r || (r = e.ranges.slice()), r[s] = n);
    }
    return r ? L.create(r, e.mainIndex) : e;
  }
  select(e) {
    let { view: r } = this, s = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !s.eq(r.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: s,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((r) => r.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function KL(t, e) {
  let r = t.state.facet(dw);
  return r.length ? r[0](e) : ee.mac ? e.metaKey : e.ctrlKey;
}
function e_(t, e) {
  let r = t.state.facet(fw);
  return r.length ? r[0](e) : ee.mac ? !e.altKey : !e.ctrlKey;
}
function t_(t, e) {
  let { main: r } = t.state.selection;
  if (r.empty)
    return !1;
  let s = Vo(t.root);
  if (!s || s.rangeCount == 0)
    return !0;
  let i = s.getRangeAt(0).getClientRects();
  for (let n = 0; n < i.length; n++) {
    let a = i[n];
    if (a.left <= e.clientX && a.right >= e.clientX && a.top <= e.clientY && a.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function r_(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let r = e.target, s; r != t.contentDOM; r = r.parentNode)
    if (!r || r.nodeType == 11 || (s = Ie.get(r)) && s.ignoreEvent(e))
      return !1;
  return !0;
}
const Zr = /* @__PURE__ */ Object.create(null), Cr = /* @__PURE__ */ Object.create(null), $w = ee.ie && ee.ie_version < 15 || ee.ios && ee.webkit_version < 604;
function s_(t) {
  let e = t.dom.parentNode;
  if (!e)
    return;
  let r = e.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(), setTimeout(() => {
    t.focus(), r.remove(), Qw(t, r.value);
  }, 50);
}
function yh(t, e, r) {
  for (let s of t.facet(e))
    r = s(r, t);
  return r;
}
function Qw(t, e) {
  e = yh(t.state, ag, e);
  let { state: r } = t, s, i = 1, n = r.toText(e), a = n.lines == r.selection.ranges.length;
  if (hf != null && r.selection.ranges.every((l) => l.empty) && hf == n.toString()) {
    let l = -1;
    s = r.changeByRange((c) => {
      let p = r.doc.lineAt(c.from);
      if (p.from == l)
        return { range: c };
      l = p.from;
      let d = r.toText((a ? n.line(i++).text : e) + r.lineBreak);
      return {
        changes: { from: p.from, insert: d },
        range: L.cursor(c.from + d.length)
      };
    });
  } else a ? s = r.changeByRange((l) => {
    let c = n.line(i++);
    return {
      changes: { from: l.from, to: l.to, insert: c.text },
      range: L.cursor(l.from + c.length)
    };
  }) : s = r.replaceSelection(n);
  t.dispatch(s, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
Cr.scroll = (t) => {
  t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
};
Zr.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && t.inputState.tabFocusMode != 0 && (t.inputState.tabFocusMode = Date.now() + 2e3), !1);
Cr.touchstart = (t, e) => {
  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
};
Cr.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
Zr.mousedown = (t, e) => {
  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let r = null;
  for (let s of t.state.facet(mw))
    if (r = s(t, e), r)
      break;
  if (!r && e.button == 0 && (r = a_(t, e)), r) {
    let s = !t.hasFocus;
    t.inputState.startMouseSelection(new JL(t, e, r, s)), s && t.observer.ignore(() => {
      YS(t.contentDOM);
      let n = t.root.activeElement;
      n && !n.contains(t.contentDOM) && n.blur();
    });
    let i = t.inputState.mouseSelection;
    if (i)
      return i.start(e), i.dragging === !1;
  }
  return !1;
};
function i1(t, e, r, s) {
  if (s == 1)
    return L.cursor(e, r);
  if (s == 2)
    return QL(t.state, e, r);
  {
    let i = et.find(t.docView, e), n = t.state.doc.lineAt(i ? i.posAtEnd : e), a = i ? i.posAtStart : n.from, l = i ? i.posAtEnd : n.to;
    return l < t.state.doc.length && l == n.to && l++, L.range(a, l);
  }
}
let n1 = (t, e, r) => e >= r.top && e <= r.bottom && t >= r.left && t <= r.right;
function i_(t, e, r, s) {
  let i = et.find(t.docView, e);
  if (!i)
    return 1;
  let n = e - i.posAtStart;
  if (n == 0)
    return 1;
  if (n == i.length)
    return -1;
  let a = i.coordsAt(n, -1);
  if (a && n1(r, s, a))
    return -1;
  let l = i.coordsAt(n, 1);
  return l && n1(r, s, l) ? 1 : a && a.bottom >= s ? -1 : 1;
}
function a1(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: r, bias: i_(t, r, e.clientX, e.clientY) };
}
const n_ = ee.ie && ee.ie_version <= 11;
let o1 = null, l1 = 0, u1 = 0;
function Bw(t) {
  if (!n_)
    return t.detail;
  let e = o1, r = u1;
  return o1 = t, u1 = Date.now(), l1 = !e || r > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (l1 + 1) % 3 : 1;
}
function a_(t, e) {
  let r = a1(t, e), s = Bw(e), i = t.state.selection;
  return {
    update(n) {
      n.docChanged && (r.pos = n.changes.mapPos(r.pos), i = i.map(n.changes));
    },
    get(n, a, l) {
      let c = a1(t, n), p, d = i1(t, c.pos, c.bias, s);
      if (r.pos != c.pos && !a) {
        let m = i1(t, r.pos, r.bias, s), y = Math.min(m.from, d.from), g = Math.max(m.to, d.to);
        d = y < d.from ? L.range(y, g) : L.range(g, y);
      }
      return a ? i.replaceRange(i.main.extend(d.from, d.to)) : l && s == 1 && i.ranges.length > 1 && (p = o_(i, c.pos)) ? p : l ? i.addRange(d) : L.create([d]);
    }
  };
}
function o_(t, e) {
  for (let r = 0; r < t.ranges.length; r++) {
    let { from: s, to: i } = t.ranges[r];
    if (s <= e && i >= e)
      return L.create(t.ranges.slice(0, r).concat(t.ranges.slice(r + 1)), t.mainIndex == r ? 0 : t.mainIndex - (t.mainIndex > r ? 1 : 0));
  }
  return null;
}
Zr.dragstart = (t, e) => {
  let { selection: { main: r } } = t.state;
  if (e.target.draggable) {
    let i = t.docView.nearest(e.target);
    if (i && i.isWidget) {
      let n = i.posAtStart, a = n + i.length;
      (n >= r.to || a <= r.from) && (r = L.range(n, a));
    }
  }
  let { inputState: s } = t;
  return s.mouseSelection && (s.mouseSelection.dragging = !0), s.draggedContent = r, e.dataTransfer && (e.dataTransfer.setData("Text", yh(t.state, og, t.state.sliceDoc(r.from, r.to))), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
Zr.dragend = (t) => (t.inputState.draggedContent = null, !1);
function c1(t, e, r, s) {
  if (r = yh(t.state, ag, r), !r)
    return;
  let i = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: n } = t.inputState, a = s && n && e_(t, e) ? { from: n.from, to: n.to } : null, l = { from: i, insert: r }, c = t.state.changes(a ? [a, l] : l);
  t.focus(), t.dispatch({
    changes: c,
    selection: { anchor: c.mapPos(i, -1), head: c.mapPos(i, 1) },
    userEvent: a ? "move.drop" : "input.drop"
  }), t.inputState.draggedContent = null;
}
Zr.drop = (t, e) => {
  if (!e.dataTransfer)
    return !1;
  if (t.state.readOnly)
    return !0;
  let r = e.dataTransfer.files;
  if (r && r.length) {
    let s = Array(r.length), i = 0, n = () => {
      ++i == r.length && c1(t, e, s.filter((a) => a != null).join(t.state.lineBreak), !1);
    };
    for (let a = 0; a < r.length; a++) {
      let l = new FileReader();
      l.onerror = n, l.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (s[a] = l.result), n();
      }, l.readAsText(r[a]);
    }
    return !0;
  } else {
    let s = e.dataTransfer.getData("Text");
    if (s)
      return c1(t, e, s, !0), !0;
  }
  return !1;
};
Zr.paste = (t, e) => {
  if (t.state.readOnly)
    return !0;
  t.observer.flush();
  let r = $w ? null : e.clipboardData;
  return r ? (Qw(t, r.getData("text/plain") || r.getData("text/uri-list")), !0) : (s_(t), !1);
};
function l_(t, e) {
  let r = t.dom.parentNode;
  if (!r)
    return;
  let s = r.appendChild(document.createElement("textarea"));
  s.style.cssText = "position: fixed; left: -10000px; top: 10px", s.value = e, s.focus(), s.selectionEnd = e.length, s.selectionStart = 0, setTimeout(() => {
    s.remove(), t.focus();
  }, 50);
}
function u_(t) {
  let e = [], r = [], s = !1;
  for (let i of t.selection.ranges)
    i.empty || (e.push(t.sliceDoc(i.from, i.to)), r.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: n } of t.selection.ranges) {
      let a = t.doc.lineAt(n);
      a.number > i && (e.push(a.text), r.push({ from: a.from, to: Math.min(t.doc.length, a.to + 1) })), i = a.number;
    }
    s = !0;
  }
  return { text: yh(t, og, e.join(t.lineBreak)), ranges: r, linewise: s };
}
let hf = null;
Zr.copy = Zr.cut = (t, e) => {
  let { text: r, ranges: s, linewise: i } = u_(t.state);
  if (!r && !i)
    return !1;
  hf = i ? r : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
    changes: s,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let n = $w ? null : e.clipboardData;
  return n ? (n.clearData(), n.setData("text/plain", r), !0) : (l_(t, r), !1);
};
const Iw = /* @__PURE__ */ Ks.define();
function Nw(t, e) {
  let r = [];
  for (let s of t.facet(Ow)) {
    let i = s(t, e);
    i && r.push(i);
  }
  return r.length ? t.update({ effects: r, annotations: Iw.of(!0) }) : null;
}
function Mw(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let r = Nw(t.state, e);
      r ? t.dispatch(r) : t.update([]);
    }
  }, 10);
}
Cr.focus = (t) => {
  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), Mw(t);
};
Cr.blur = (t) => {
  t.observer.clearSelectionRange(), Mw(t);
};
Cr.compositionstart = Cr.compositionupdate = (t) => {
  t.observer.editContext || (t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0));
};
Cr.compositionend = (t) => {
  t.observer.editContext || (t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, ee.chrome && ee.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
    t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
  }, 50));
};
Cr.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
Zr.beforeinput = (t, e) => {
  var r, s;
  if (e.inputType == "insertReplacementText" && t.observer.editContext) {
    let n = (r = e.dataTransfer) === null || r === void 0 ? void 0 : r.getData("text/plain"), a = e.getTargetRanges();
    if (n && a.length) {
      let l = a[0], c = t.posAtDOM(l.startContainer, l.startOffset), p = t.posAtDOM(l.endContainer, l.endOffset);
      return hg(t, { from: c, to: p, insert: t.state.toText(n) }, null), !0;
    }
  }
  let i;
  if (ee.chrome && ee.android && (i = Pw.find((n) => n.inputType == e.inputType)) && (t.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let n = ((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0;
    setTimeout(() => {
      var a;
      (((a = window.visualViewport) === null || a === void 0 ? void 0 : a.height) || 0) > n + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return ee.ios && e.inputType == "deleteContentForward" && t.observer.flushSoon(), ee.safari && e.inputType == "insertText" && t.inputState.composing >= 0 && setTimeout(() => Cr.compositionend(t, e), 20), !1;
};
const h1 = /* @__PURE__ */ new Set();
function c_(t) {
  h1.has(t) || (h1.add(t), t.addEventListener("copy", () => {
  }), t.addEventListener("cut", () => {
  }));
}
const p1 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let ga = !1;
function d1() {
  ga = !1;
}
class h_ {
  constructor(e) {
    this.lineWrapping = e, this.doc = Se.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, r) {
    let s = this.doc.lineAt(r).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (s += Math.max(0, Math.ceil((r - e - s * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * s;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / Math.max(1, this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return p1.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let r = !1;
    for (let s = 0; s < e.length; s++) {
      let i = e[s];
      i < 0 ? s++ : this.heightSamples[Math.floor(i * 10)] || (r = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return r;
  }
  refresh(e, r, s, i, n, a) {
    let l = p1.indexOf(e) > -1, c = Math.round(r) != Math.round(this.lineHeight) || this.lineWrapping != l;
    if (this.lineWrapping = l, this.lineHeight = r, this.charWidth = s, this.textHeight = i, this.lineLength = n, c) {
      this.heightSamples = {};
      for (let p = 0; p < a.length; p++) {
        let d = a[p];
        d < 0 ? p++ : this.heightSamples[Math.floor(d * 10)] = !0;
      }
    }
    return c;
  }
}
class p_ {
  constructor(e, r) {
    this.from = e, this.heights = r, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class ts {
  /**
  @internal
  */
  constructor(e, r, s, i, n) {
    this.from = e, this.length = r, this.top = s, this.height = i, this._content = n;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Mt.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Ti ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let r = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new ts(this.from, this.length + e.length, this.top, this.height + e.height, r);
  }
}
var Me = /* @__PURE__ */ function(t) {
  return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
}(Me || (Me = {}));
const Ru = 1e-3;
class Lt {
  constructor(e, r, s = 2) {
    this.length = e, this.height = r, this.flags = s;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > Ru && (ga = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, r, s) {
    return Lt.of(s);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, r) {
    r.push(this);
  }
  decomposeRight(e, r) {
    r.push(this);
  }
  applyChanges(e, r, s, i) {
    let n = this, a = s.doc;
    for (let l = i.length - 1; l >= 0; l--) {
      let { fromA: c, toA: p, fromB: d, toB: m } = i[l], y = n.lineAt(c, Me.ByPosNoHeight, s.setDoc(r), 0, 0), g = y.to >= p ? y : n.lineAt(p, Me.ByPosNoHeight, s, 0, 0);
      for (m += g.to - p, p = g.to; l > 0 && y.from <= i[l - 1].toA; )
        c = i[l - 1].fromA, d = i[l - 1].fromB, l--, c < y.from && (y = n.lineAt(c, Me.ByPosNoHeight, s, 0, 0));
      d += y.from - c, c = y.from;
      let x = pg.build(s.setDoc(a), e, d, m);
      n = gc(n, n.replace(c, p, x));
    }
    return n.updateHeight(s, 0);
  }
  static empty() {
    return new or(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let r = 0, s = e.length, i = 0, n = 0;
    for (; ; )
      if (r == s)
        if (i > n * 2) {
          let l = e[r - 1];
          l.break ? e.splice(--r, 1, l.left, null, l.right) : e.splice(--r, 1, l.left, l.right), s += 1 + l.break, i -= l.size;
        } else if (n > i * 2) {
          let l = e[s];
          l.break ? e.splice(s, 1, l.left, null, l.right) : e.splice(s, 1, l.left, l.right), s += 2 + l.break, n -= l.size;
        } else
          break;
      else if (i < n) {
        let l = e[r++];
        l && (i += l.size);
      } else {
        let l = e[--s];
        l && (n += l.size);
      }
    let a = 0;
    return e[r - 1] == null ? (a = 1, r--) : e[r] == null && (a = 1, s++), new d_(Lt.of(e.slice(0, r)), a, Lt.of(e.slice(s)));
  }
}
function gc(t, e) {
  return t == e ? t : (t.constructor != e.constructor && (ga = !0), e);
}
Lt.prototype.size = 1;
class Lw extends Lt {
  constructor(e, r, s) {
    super(e, r), this.deco = s;
  }
  blockAt(e, r, s, i) {
    return new ts(i, this.length, s, this.height, this.deco || 0);
  }
  lineAt(e, r, s, i, n) {
    return this.blockAt(0, s, i, n);
  }
  forEachLine(e, r, s, i, n, a) {
    e <= n + this.length && r >= n && a(this.blockAt(0, s, i, n));
  }
  updateHeight(e, r = 0, s = !1, i) {
    return i && i.from <= r && i.more && this.setHeight(i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class or extends Lw {
  constructor(e, r) {
    super(e, r, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, r, s, i) {
    return new ts(i, this.length, s, this.height, this.breaks);
  }
  replace(e, r, s) {
    let i = s[0];
    return s.length == 1 && (i instanceof or || i instanceof gt && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof gt ? i = new or(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : Lt.of(s);
  }
  updateHeight(e, r = 0, s = !1, i) {
    return i && i.from <= r && i.more ? this.setHeight(i.heights[i.index++]) : (s || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class gt extends Lt {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, r) {
    let s = e.doc.lineAt(r).number, i = e.doc.lineAt(r + this.length).number, n = i - s + 1, a, l = 0;
    if (e.lineWrapping) {
      let c = Math.min(this.height, e.lineHeight * n);
      a = c / n, this.length > n + 1 && (l = (this.height - c) / (this.length - n - 1));
    } else
      a = this.height / n;
    return { firstLine: s, lastLine: i, perLine: a, perChar: l };
  }
  blockAt(e, r, s, i) {
    let { firstLine: n, lastLine: a, perLine: l, perChar: c } = this.heightMetrics(r, i);
    if (r.lineWrapping) {
      let p = i + (e < r.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - s) / this.height)) * this.length)), d = r.doc.lineAt(p), m = l + d.length * c, y = Math.max(s, e - m / 2);
      return new ts(d.from, d.length, y, m, 0);
    } else {
      let p = Math.max(0, Math.min(a - n, Math.floor((e - s) / l))), { from: d, length: m } = r.doc.line(n + p);
      return new ts(d, m, s + l * p, l, 0);
    }
  }
  lineAt(e, r, s, i, n) {
    if (r == Me.ByHeight)
      return this.blockAt(e, s, i, n);
    if (r == Me.ByPosNoHeight) {
      let { from: g, to: x } = s.doc.lineAt(e);
      return new ts(g, x - g, 0, 0, 0);
    }
    let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(s, n), p = s.doc.lineAt(e), d = l + p.length * c, m = p.number - a, y = i + l * m + c * (p.from - n - m);
    return new ts(p.from, p.length, Math.max(i, Math.min(y, i + this.height - d)), d, 0);
  }
  forEachLine(e, r, s, i, n, a) {
    e = Math.max(e, n), r = Math.min(r, n + this.length);
    let { firstLine: l, perLine: c, perChar: p } = this.heightMetrics(s, n);
    for (let d = e, m = i; d <= r; ) {
      let y = s.doc.lineAt(d);
      if (d == e) {
        let x = y.number - l;
        m += c * x + p * (e - n - x);
      }
      let g = c + p * y.length;
      a(new ts(y.from, y.length, m, g, 0)), m += g, d = y.to + 1;
    }
  }
  replace(e, r, s) {
    let i = this.length - r;
    if (i > 0) {
      let n = s[s.length - 1];
      n instanceof gt ? s[s.length - 1] = new gt(n.length + i) : s.push(null, new gt(i - 1));
    }
    if (e > 0) {
      let n = s[0];
      n instanceof gt ? s[0] = new gt(e + n.length) : s.unshift(new gt(e - 1), null);
    }
    return Lt.of(s);
  }
  decomposeLeft(e, r) {
    r.push(new gt(e - 1), null);
  }
  decomposeRight(e, r) {
    r.push(null, new gt(this.length - e - 1));
  }
  updateHeight(e, r = 0, s = !1, i) {
    let n = r + this.length;
    if (i && i.from <= r + this.length && i.more) {
      let a = [], l = Math.max(r, i.from), c = -1;
      for (i.from > r && a.push(new gt(i.from - r - 1).updateHeight(e, r)); l <= n && i.more; ) {
        let d = e.doc.lineAt(l).length;
        a.length && a.push(null);
        let m = i.heights[i.index++];
        c == -1 ? c = m : Math.abs(m - c) >= Ru && (c = -2);
        let y = new or(d, m);
        y.outdated = !1, a.push(y), l += d + 1;
      }
      l <= n && a.push(null, new gt(n - l).updateHeight(e, l));
      let p = Lt.of(a);
      return (c < 0 || Math.abs(p.height - this.height) >= Ru || Math.abs(c - this.heightMetrics(e, r).perLine) >= Ru) && (ga = !0), gc(this, p);
    } else (s || this.outdated) && (this.setHeight(e.heightForGap(r, r + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class d_ extends Lt {
  constructor(e, r, s) {
    super(e.length + r + s.length, e.height + s.height, r | (e.outdated || s.outdated ? 2 : 0)), this.left = e, this.right = s, this.size = e.size + s.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, r, s, i) {
    let n = s + this.left.height;
    return e < n ? this.left.blockAt(e, r, s, i) : this.right.blockAt(e, r, n, i + this.left.length + this.break);
  }
  lineAt(e, r, s, i, n) {
    let a = i + this.left.height, l = n + this.left.length + this.break, c = r == Me.ByHeight ? e < a : e < l, p = c ? this.left.lineAt(e, r, s, i, n) : this.right.lineAt(e, r, s, a, l);
    if (this.break || (c ? p.to < l : p.from > l))
      return p;
    let d = r == Me.ByPosNoHeight ? Me.ByPosNoHeight : Me.ByPos;
    return c ? p.join(this.right.lineAt(l, d, s, a, l)) : this.left.lineAt(l, d, s, i, n).join(p);
  }
  forEachLine(e, r, s, i, n, a) {
    let l = i + this.left.height, c = n + this.left.length + this.break;
    if (this.break)
      e < c && this.left.forEachLine(e, r, s, i, n, a), r >= c && this.right.forEachLine(e, r, s, l, c, a);
    else {
      let p = this.lineAt(c, Me.ByPos, s, i, n);
      e < p.from && this.left.forEachLine(e, p.from - 1, s, i, n, a), p.to >= e && p.from <= r && a(p), r > p.to && this.right.forEachLine(p.to + 1, r, s, l, c, a);
    }
  }
  replace(e, r, s) {
    let i = this.left.length + this.break;
    if (r < i)
      return this.balanced(this.left.replace(e, r, s), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, r - i, s));
    let n = [];
    e > 0 && this.decomposeLeft(e, n);
    let a = n.length;
    for (let l of s)
      n.push(l);
    if (e > 0 && f1(n, a - 1), r < this.length) {
      let l = n.length;
      this.decomposeRight(r, n), f1(n, l);
    }
    return Lt.of(n);
  }
  decomposeLeft(e, r) {
    let s = this.left.length;
    if (e <= s)
      return this.left.decomposeLeft(e, r);
    r.push(this.left), this.break && (s++, e >= s && r.push(null)), e > s && this.right.decomposeLeft(e - s, r);
  }
  decomposeRight(e, r) {
    let s = this.left.length, i = s + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, r);
    e < s && this.left.decomposeRight(e, r), this.break && e < i && r.push(null), r.push(this.right);
  }
  balanced(e, r) {
    return e.size > 2 * r.size || r.size > 2 * e.size ? Lt.of(this.break ? [e, null, r] : [e, r]) : (this.left = gc(this.left, e), this.right = gc(this.right, r), this.setHeight(e.height + r.height), this.outdated = e.outdated || r.outdated, this.size = e.size + r.size, this.length = e.length + this.break + r.length, this);
  }
  updateHeight(e, r = 0, s = !1, i) {
    let { left: n, right: a } = this, l = r + n.length + this.break, c = null;
    return i && i.from <= r + n.length && i.more ? c = n = n.updateHeight(e, r, s, i) : n.updateHeight(e, r, s), i && i.from <= l + a.length && i.more ? c = a = a.updateHeight(e, l, s, i) : a.updateHeight(e, l, s), c ? this.balanced(n, a) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function f1(t, e) {
  let r, s;
  t[e] == null && (r = t[e - 1]) instanceof gt && (s = t[e + 1]) instanceof gt && t.splice(e - 1, 3, new gt(r.length + 1 + s.length));
}
const f_ = 5;
class pg {
  constructor(e, r) {
    this.pos = e, this.oracle = r, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, r) {
    if (this.lineStart > -1) {
      let s = Math.min(r, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof or ? i.length += s - this.pos : (s > this.pos || !this.isCovered) && this.nodes.push(new or(s - this.pos, -1)), this.writtenTo = s, r > s && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = r;
  }
  point(e, r, s) {
    if (e < r || s.heightRelevant) {
      let i = s.widget ? s.widget.estimatedHeight : 0, n = s.widget ? s.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let a = r - e;
      s.block ? this.addBlock(new Lw(a, i, s)) : (a || n || i >= f_) && this.addLineDeco(i, n, a);
    } else r > e && this.span(e, r);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: r } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = r, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new or(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, r) {
    let s = new gt(r - e);
    return this.oracle.doc.lineAt(e).to == r && (s.flags |= 4), s;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof or)
      return e;
    let r = new or(0, -1);
    return this.nodes.push(r), r;
  }
  addBlock(e) {
    this.enterLine();
    let r = e.deco;
    r && r.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, r && r.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, r, s) {
    let i = this.ensureLine();
    i.length += s, i.collapsed += s, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += r, this.writtenTo = this.pos = this.pos + s;
  }
  finish(e) {
    let r = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(r instanceof or) && !this.isCovered ? this.nodes.push(new or(0, -1)) : (this.writtenTo < this.pos || r == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let s = e;
    for (let i of this.nodes)
      i instanceof or && i.updateHeight(this.oracle, s), s += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, r, s, i) {
    let n = new pg(s, e);
    return Ce.spans(r, s, i, n, 0), n.finish(s);
  }
}
function m_(t, e, r) {
  let s = new g_();
  return Ce.compare(t, e, r, s, 0), s.changes;
}
class g_ {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, r, s, i) {
    (e < r || s && s.heightRelevant || i && i.heightRelevant) && Lu(e, r, this.changes, 5);
  }
}
function y_(t, e) {
  let r = t.getBoundingClientRect(), s = t.ownerDocument, i = s.defaultView || window, n = Math.max(0, r.left), a = Math.min(i.innerWidth, r.right), l = Math.max(0, r.top), c = Math.min(i.innerHeight, r.bottom);
  for (let p = t.parentNode; p && p != s.body; )
    if (p.nodeType == 1) {
      let d = p, m = window.getComputedStyle(d);
      if ((d.scrollHeight > d.clientHeight || d.scrollWidth > d.clientWidth) && m.overflow != "visible") {
        let y = d.getBoundingClientRect();
        n = Math.max(n, y.left), a = Math.min(a, y.right), l = Math.max(l, y.top), c = Math.min(p == t.parentNode ? i.innerHeight : c, y.bottom);
      }
      p = m.position == "absolute" || m.position == "fixed" ? d.offsetParent : d.parentNode;
    } else if (p.nodeType == 11)
      p = p.host;
    else
      break;
  return {
    left: n - r.left,
    right: Math.max(n, a) - r.left,
    top: l - (r.top + e),
    bottom: Math.max(l, c) - (r.top + e)
  };
}
function O_(t) {
  let e = t.getBoundingClientRect(), r = t.ownerDocument.defaultView || window;
  return e.left < r.innerWidth && e.right > 0 && e.top < r.innerHeight && e.bottom > 0;
}
function x_(t, e) {
  let r = t.getBoundingClientRect();
  return {
    left: 0,
    right: r.right - r.left,
    top: e,
    bottom: r.bottom - (r.top + e)
  };
}
class Ep {
  constructor(e, r, s, i) {
    this.from = e, this.to = r, this.size = s, this.displaySize = i;
  }
  static same(e, r) {
    if (e.length != r.length)
      return !1;
    for (let s = 0; s < e.length; s++) {
      let i = e[s], n = r[s];
      if (i.from != n.from || i.to != n.to || i.size != n.size)
        return !1;
    }
    return !0;
  }
  draw(e, r) {
    return ce.replace({
      widget: new D_(this.displaySize * (r ? e.scaleY : e.scaleX), r)
    }).range(this.from, this.to);
  }
}
class D_ extends ei {
  constructor(e, r) {
    super(), this.size = e, this.vertical = r;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class m1 {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = g1, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = _e.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let r = e.facet(lg).some((s) => typeof s != "function" && s.class == "cm-lineWrapping");
    this.heightOracle = new h_(r), this.stateDeco = e.facet(Uo).filter((s) => typeof s != "function"), this.heightMap = Lt.empty().applyChanges(this.stateDeco, Se.empty, this.heightOracle.setDoc(e.doc), [new Sr(0, 0, 0, e.doc.length)]);
    for (let s = 0; s < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); s++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = ce.set(this.lineGaps.map((s) => s.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: r } = this.state.selection;
    for (let s = 0; s <= 1; s++) {
      let i = s ? r.head : r.anchor;
      if (!e.some(({ from: n, to: a }) => i >= n && i <= a)) {
        let { from: n, to: a } = this.lineBlockAt(i);
        e.push(new uu(n, a));
      }
    }
    return this.viewports = e.sort((s, i) => s.from - i.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? g1 : new dg(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(po(e, this.scaler));
    });
  }
  update(e, r = null) {
    this.state = e.state;
    let s = this.stateDeco;
    this.stateDeco = this.state.facet(Uo).filter((d) => typeof d != "function");
    let i = e.changedRanges, n = Sr.extendWithRanges(i, m_(s, this.stateDeco, e ? e.changes : at.empty(this.state.doc.length))), a = this.heightMap.height, l = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    d1(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), n), (this.heightMap.height != a || ga) && (e.flags |= 2), l ? (this.scrollAnchorPos = e.changes.mapPos(l.from, -1), this.scrollAnchorHeight = l.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = a);
    let c = n.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (r && (r.range.head < c.from || r.range.head > c.to) || !this.viewportIsAppropriate(c)) && (c = this.getViewport(0, r));
    let p = c.from != this.viewport.from || c.to != this.viewport.to;
    this.viewport = c, e.flags |= this.updateForViewport(), (p || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), r && (this.scrollTarget = r), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(Dw) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let r = e.contentDOM, s = window.getComputedStyle(r), i = this.heightOracle, n = s.whiteSpace;
    this.defaultTextDirection = s.direction == "rtl" ? _e.RTL : _e.LTR;
    let a = this.heightOracle.mustRefreshForWrapping(n), l = r.getBoundingClientRect(), c = a || this.mustMeasureContent || this.contentDOMHeight != l.height;
    this.contentDOMHeight = l.height, this.mustMeasureContent = !1;
    let p = 0, d = 0;
    if (l.width && l.height) {
      let { scaleX: Q, scaleY: F } = US(r, l);
      (Q > 5e-3 && Math.abs(this.scaleX - Q) > 5e-3 || F > 5e-3 && Math.abs(this.scaleY - F) > 5e-3) && (this.scaleX = Q, this.scaleY = F, p |= 16, a = c = !0);
    }
    let m = (parseInt(s.paddingTop) || 0) * this.scaleY, y = (parseInt(s.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != m || this.paddingBottom != y) && (this.paddingTop = m, this.paddingBottom = y, p |= 18), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (c = !0), this.editorWidth = e.scrollDOM.clientWidth, p |= 16);
    let g = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != g && (this.scrollAnchorHeight = -1, this.scrollTop = g), this.scrolledToBottom = GS(e.scrollDOM);
    let x = (this.printing ? x_ : y_)(r, this.paddingTop), v = x.top - this.pixelViewport.top, w = x.bottom - this.pixelViewport.bottom;
    this.pixelViewport = x;
    let C = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (C != this.inView && (this.inView = C, C && (c = !0)), !this.inView && !this.scrollTarget && !O_(e.dom))
      return 0;
    let b = l.width;
    if ((this.contentDOMWidth != b || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = l.width, this.editorHeight = e.scrollDOM.clientHeight, p |= 16), c) {
      let Q = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(Q) && (a = !0), a || i.lineWrapping && Math.abs(b - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: F, charWidth: $, textHeight: N } = e.docView.measureTextSize();
        a = F > 0 && i.refresh(n, F, $, N, Math.max(5, b / $), Q), a && (e.docView.minWidth = 0, p |= 16);
      }
      v > 0 && w > 0 ? d = Math.max(v, w) : v < 0 && w < 0 && (d = Math.min(v, w)), d1();
      for (let F of this.viewports) {
        let $ = F.from == this.viewport.from ? Q : e.docView.measureVisibleLineHeights(F);
        this.heightMap = (a ? Lt.empty().applyChanges(this.stateDeco, Se.empty, this.heightOracle, [new Sr(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, a, new p_(F.from, $));
      }
      ga && (p |= 2);
    }
    let k = !this.viewportIsAppropriate(this.viewport, d) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return k && (p & 2 && (p |= this.updateScaler()), this.viewport = this.getViewport(d, this.scrollTarget), p |= this.updateForViewport()), (p & 2 || k) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(a ? [] : this.lineGaps, e)), p |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), p;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, r) {
    let s = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, n = this.heightOracle, { visibleTop: a, visibleBottom: l } = this, c = new uu(i.lineAt(a - s * 1e3, Me.ByHeight, n, 0, 0).from, i.lineAt(l + (1 - s) * 1e3, Me.ByHeight, n, 0, 0).to);
    if (r) {
      let { head: p } = r.range;
      if (p < c.from || p > c.to) {
        let d = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), m = i.lineAt(p, Me.ByPos, n, 0, 0), y;
        r.y == "center" ? y = (m.top + m.bottom) / 2 - d / 2 : r.y == "start" || r.y == "nearest" && p < c.from ? y = m.top : y = m.bottom - d, c = new uu(i.lineAt(y - 1e3 / 2, Me.ByHeight, n, 0, 0).from, i.lineAt(y + d + 1e3 / 2, Me.ByHeight, n, 0, 0).to);
      }
    }
    return c;
  }
  mapViewport(e, r) {
    let s = r.mapPos(e.from, -1), i = r.mapPos(e.to, 1);
    return new uu(this.heightMap.lineAt(s, Me.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, Me.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: r }, s = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(e, Me.ByPos, this.heightOracle, 0, 0), { bottom: n } = this.heightMap.lineAt(r, Me.ByPos, this.heightOracle, 0, 0), { visibleTop: a, visibleBottom: l } = this;
    return (e == 0 || i <= a - Math.max(10, Math.min(
      -s,
      250
      /* VP.MaxCoverMargin */
    ))) && (r == this.state.doc.length || n >= l + Math.max(10, Math.min(
      s,
      250
      /* VP.MaxCoverMargin */
    ))) && i > a - 2 * 1e3 && n < l + 2 * 1e3;
  }
  mapLineGaps(e, r) {
    if (!e.length || r.empty)
      return e;
    let s = [];
    for (let i of e)
      r.touchesRange(i.from, i.to) || s.push(new Ep(r.mapPos(i.from), r.mapPos(i.to), i.size, i.displaySize));
    return s;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, r) {
    let s = this.heightOracle.lineWrapping, i = s ? 1e4 : 2e3, n = i >> 1, a = i << 1;
    if (this.defaultTextDirection != _e.LTR && !s)
      return [];
    let l = [], c = (d, m, y, g) => {
      if (m - d < n)
        return;
      let x = this.state.selection.main, v = [x.from];
      x.empty || v.push(x.to);
      for (let C of v)
        if (C > d && C < m) {
          c(d, C - 10, y, g), c(C + 10, m, y, g);
          return;
        }
      let w = v_(e, (C) => C.from >= y.from && C.to <= y.to && Math.abs(C.from - d) < n && Math.abs(C.to - m) < n && !v.some((b) => C.from < b && C.to > b));
      if (!w) {
        if (m < y.to && r && s && r.visibleRanges.some((k) => k.from <= m && k.to >= m)) {
          let k = r.moveToLineBoundary(L.cursor(m), !1, !0).head;
          k > d && (m = k);
        }
        let C = this.gapSize(y, d, m, g), b = s || C < 2e6 ? C : 2e6;
        w = new Ep(d, m, C, b);
      }
      l.push(w);
    }, p = (d) => {
      if (d.length < a || d.type != Mt.Text)
        return;
      let m = b_(d.from, d.to, this.stateDeco);
      if (m.total < a)
        return;
      let y = this.scrollTarget ? this.scrollTarget.range.head : null, g, x;
      if (s) {
        let v = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, w, C;
        if (y != null) {
          let b = hu(m, y), k = ((this.visibleBottom - this.visibleTop) / 2 + v) / d.height;
          w = b - k, C = b + k;
        } else
          w = (this.visibleTop - d.top - v) / d.height, C = (this.visibleBottom - d.top + v) / d.height;
        g = cu(m, w), x = cu(m, C);
      } else {
        let v = m.total * this.heightOracle.charWidth, w = i * this.heightOracle.charWidth, C = 0;
        if (v > 2e6)
          for (let $ of e)
            $.from >= d.from && $.from < d.to && $.size != $.displaySize && $.from * this.heightOracle.charWidth + C < this.pixelViewport.left && (C = $.size - $.displaySize);
        let b = this.pixelViewport.left + C, k = this.pixelViewport.right + C, Q, F;
        if (y != null) {
          let $ = hu(m, y), N = ((k - b) / 2 + w) / v;
          Q = $ - N, F = $ + N;
        } else
          Q = (b - w) / v, F = (k + w) / v;
        g = cu(m, Q), x = cu(m, F);
      }
      g > d.from && c(d.from, g, d, m), x < d.to && c(x, d.to, d, m);
    };
    for (let d of this.viewportLines)
      Array.isArray(d.type) ? d.type.forEach(p) : p(d);
    return l;
  }
  gapSize(e, r, s, i) {
    let n = hu(i, s) - hu(i, r);
    return this.heightOracle.lineWrapping ? e.height * n : i.total * this.heightOracle.charWidth * n;
  }
  updateLineGaps(e) {
    Ep.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = ce.set(e.map((r) => r.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(e) {
    let r = this.stateDeco;
    this.lineGaps.length && (r = r.concat(this.lineGapDeco));
    let s = [];
    Ce.spans(r, this.viewport.from, this.viewport.to, {
      span(n, a) {
        s.push({ from: n, to: a });
      },
      point() {
      }
    }, 20);
    let i = 0;
    if (s.length != this.visibleRanges.length)
      i = 12;
    else
      for (let n = 0; n < s.length && !(i & 8); n++) {
        let a = this.visibleRanges[n], l = s[n];
        (a.from != l.from || a.to != l.to) && (i |= 4, e && e.mapPos(a.from, -1) == l.from && e.mapPos(a.to, 1) == l.to || (i |= 8));
      }
    return this.visibleRanges = s, i;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((r) => r.from <= e && r.to >= e) || po(this.heightMap.lineAt(e, Me.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((r) => r.top <= e && r.bottom >= e) || po(this.heightMap.lineAt(this.scaler.fromDOM(e), Me.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let r = this.lineBlockAtHeight(e + 8);
    return r.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? r : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return po(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class uu {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
function b_(t, e, r) {
  let s = [], i = t, n = 0;
  return Ce.spans(r, t, e, {
    span() {
    },
    point(a, l) {
      a > i && (s.push({ from: i, to: a }), n += a - i), i = l;
    }
  }, 20), i < e && (s.push({ from: i, to: e }), n += e - i), { total: n, ranges: s };
}
function cu({ total: t, ranges: e }, r) {
  if (r <= 0)
    return e[0].from;
  if (r >= 1)
    return e[e.length - 1].to;
  let s = Math.floor(t * r);
  for (let i = 0; ; i++) {
    let { from: n, to: a } = e[i], l = a - n;
    if (s <= l)
      return n + s;
    s -= l;
  }
}
function hu(t, e) {
  let r = 0;
  for (let { from: s, to: i } of t.ranges) {
    if (e <= i) {
      r += e - s;
      break;
    }
    r += i - s;
  }
  return r / t.total;
}
function v_(t, e) {
  for (let r of t)
    if (e(r))
      return r;
}
const g1 = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1,
  eq(t) {
    return t == this;
  }
};
class dg {
  constructor(e, r, s) {
    let i = 0, n = 0, a = 0;
    this.viewports = s.map(({ from: l, to: c }) => {
      let p = r.lineAt(l, Me.ByPos, e, 0, 0).top, d = r.lineAt(c, Me.ByPos, e, 0, 0).bottom;
      return i += d - p, { from: l, to: c, top: p, bottom: d, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (r.height - i);
    for (let l of this.viewports)
      l.domTop = a + (l.top - n) * this.scale, a = l.domBottom = l.domTop + (l.bottom - l.top), n = l.bottom;
  }
  toDOM(e) {
    for (let r = 0, s = 0, i = 0; ; r++) {
      let n = r < this.viewports.length ? this.viewports[r] : null;
      if (!n || e < n.top)
        return i + (e - s) * this.scale;
      if (e <= n.bottom)
        return n.domTop + (e - n.top);
      s = n.bottom, i = n.domBottom;
    }
  }
  fromDOM(e) {
    for (let r = 0, s = 0, i = 0; ; r++) {
      let n = r < this.viewports.length ? this.viewports[r] : null;
      if (!n || e < n.domTop)
        return s + (e - i) / this.scale;
      if (e <= n.domBottom)
        return n.top + (e - n.domTop);
      s = n.bottom, i = n.domBottom;
    }
  }
  eq(e) {
    return e instanceof dg ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((r, s) => r.from == e.viewports[s].from && r.to == e.viewports[s].to) : !1;
  }
}
function po(t, e) {
  if (e.scale == 1)
    return t;
  let r = e.toDOM(t.top), s = e.toDOM(t.bottom);
  return new ts(t.from, t.length, r, s - r, Array.isArray(t._content) ? t._content.map((i) => po(i, e)) : t._content);
}
const pu = /* @__PURE__ */ re.define({ combine: (t) => t.join(" ") }), pf = /* @__PURE__ */ re.define({ combine: (t) => t.indexOf(!0) > -1 }), df = /* @__PURE__ */ Ci.newName(), _w = /* @__PURE__ */ Ci.newName(), Rw = /* @__PURE__ */ Ci.newName(), qw = { "&light": "." + _w, "&dark": "." + Rw };
function ff(t, e, r) {
  return new Ci(e, {
    finish(s) {
      return /&/.test(s) ? s.replace(/&\w*/, (i) => {
        if (i == "&")
          return t;
        if (!r || !r[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return r[i];
      }) : t + " " + s;
    }
  });
}
const S_ = /* @__PURE__ */ ff("." + df, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": { insetInlineStart: 0 },
  ".cm-gutters-after": { insetInlineEnd: 0 },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": { borderRightWidth: "1px" },
    "&.cm-gutters-after": { borderLeftWidth: "1px" }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, qw), w_ = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, Tp = ee.ie && ee.ie_version <= 11;
class A_ {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new aL(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((r) => {
      for (let s of r)
        this.queue.push(s);
      (ee.ie && ee.ie_version <= 11 || ee.ios && e.composing) && r.some((s) => s.type == "childList" && s.removedNodes.length || s.type == "characterData" && s.oldValue.length > s.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && ee.android && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(ee.chrome && ee.chrome_version < 126) && (this.editContext = new E_(e), e.state.facet(Ts) && (e.contentDOM.editContext = this.editContext.editContext)), Tp && (this.onCharData = (r) => {
      this.queue.push({
        target: r.target,
        type: "characterData",
        oldValue: r.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var r;
      ((r = this.view.docView) === null || r === void 0 ? void 0 : r.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((r) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), r.length > 0 && r[r.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((r) => {
      r.length > 0 && r[r.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((r, s) => r != e[s]))) {
      this.gapIntersection.disconnect();
      for (let r of e)
        this.gapIntersection.observe(r);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let r = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: s } = this, i = this.selectionRange;
    if (s.state.facet(Ts) ? s.root.activeElement != this.dom : !Mu(this.dom, i))
      return;
    let n = i.anchorNode && s.docView.nearest(i.anchorNode);
    if (n && n.ignoreEvent(e)) {
      r || (this.selectionChanged = !1);
      return;
    }
    (ee.ie && ee.ie_version <= 11 || ee.android && ee.chrome) && !s.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && ko(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, r = Vo(e.root);
    if (!r)
      return !1;
    let s = ee.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && C_(this.view, r) || r;
    if (!s || this.selectionRange.eq(s))
      return !1;
    let i = Mu(this.dom, s);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && lL(this.dom, s) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(s), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, r) {
    this.selectionRange.set(e.node, e.offset, r.node, r.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, r = null;
    for (let s = this.dom; s; )
      if (s.nodeType == 1)
        !r && e < this.scrollTargets.length && this.scrollTargets[e] == s ? e++ : r || (r = this.scrollTargets.slice(0, e)), r && r.push(s), s = s.assignedSlot || s.parentNode;
      else if (s.nodeType == 11)
        s = s.host;
      else
        break;
    if (e < this.scrollTargets.length && !r && (r = this.scrollTargets.slice(0, e)), r) {
      for (let s of this.scrollTargets)
        s.removeEventListener("scroll", this.onScroll);
      for (let s of this.scrollTargets = r)
        s.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, w_), Tp && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), Tp && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, r) {
    var s;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let n = this.delayedAndroidKey;
        n && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = n.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && n.force && Hn(this.dom, n.key, n.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: r,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((s = this.delayedAndroidKey) === null || s === void 0) && s.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let r = -1, s = -1, i = !1;
    for (let n of e) {
      let a = this.readMutation(n);
      a && (a.typeOver && (i = !0), r == -1 ? { from: r, to: s } = a : (r = Math.min(a.from, r), s = Math.max(a.to, s)));
    }
    return { from: r, to: s, typeOver: i };
  }
  readChange() {
    let { from: e, to: r, typeOver: s } = this.processRecords(), i = this.selectionChanged && Mu(this.dom, this.selectionRange);
    if (e < 0 && !i)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let n = new XL(this.view, e, r, s);
    return this.view.docView.domChanged = { newSel: n.newSel ? n.newSel.main : null }, n;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let r = this.readChange();
    if (!r)
      return this.view.requestMeasure(), !1;
    let s = this.view.state, i = kw(this.view, r);
    return this.view.state == s && (r.domChanged || r.newSel && !r.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), i;
  }
  readMutation(e) {
    let r = this.view.docView.nearest(e.target);
    if (!r || r.ignoreMutation(e))
      return null;
    if (r.markDirty(e.type == "attributes"), e.type == "attributes" && (r.flags |= 4), e.type == "childList") {
      let s = y1(r, e.previousSibling || e.target.previousSibling, -1), i = y1(r, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: s ? r.posAfter(s) : r.posAtStart,
        to: i ? r.posBefore(i) : r.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: r.posAtStart, to: r.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(Ts) != e.state.facet(Ts) && (e.view.contentDOM.editContext = e.state.facet(Ts) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, r, s;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (r = this.gapIntersection) === null || r === void 0 || r.disconnect(), (s = this.resizeScroll) === null || s === void 0 || s.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function y1(t, e, r) {
  for (; e; ) {
    let s = Ie.get(e);
    if (s && s.parent == t)
      return s;
    let i = e.parentNode;
    e = i != t.dom ? i : r > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function O1(t, e) {
  let r = e.startContainer, s = e.startOffset, i = e.endContainer, n = e.endOffset, a = t.docView.domAtPos(t.state.selection.main.anchor);
  return ko(a.node, a.offset, i, n) && ([r, s, i, n] = [i, n, r, s]), { anchorNode: r, anchorOffset: s, focusNode: i, focusOffset: n };
}
function C_(t, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(t.root)[0];
    if (i)
      return O1(t, i);
  }
  let r = null;
  function s(i) {
    i.preventDefault(), i.stopImmediatePropagation(), r = i.getTargetRanges()[0];
  }
  return t.contentDOM.addEventListener("beforeinput", s, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", s, !0), r ? O1(t, r) : null;
}
class E_ {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
    let r = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (s) => {
      let i = e.state.selection.main, { anchor: n, head: a } = i, l = this.toEditorPos(s.updateRangeStart), c = this.toEditorPos(s.updateRangeEnd);
      e.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: s.updateRangeStart, editorBase: l, drifted: !1 });
      let p = { from: l, to: c, insert: Se.of(s.text.split(`
`)) };
      if (p.from == this.from && n < this.from ? p.from = n : p.to == this.to && n > this.to && (p.to = n), p.from == p.to && !p.insert.length) {
        let d = L.single(this.toEditorPos(s.selectionStart), this.toEditorPos(s.selectionEnd));
        d.main.eq(i) || e.dispatch({ selection: d, userEvent: "select" });
        return;
      }
      if ((ee.mac || ee.android) && p.from == a - 1 && /^\. ?$/.test(s.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (p = { from: l, to: c, insert: Se.of([s.text.replace(".", " ")]) }), this.pendingContextChange = p, !e.state.readOnly) {
        let d = this.to - this.from + (p.to - p.from + p.insert.length);
        hg(e, p, L.single(this.toEditorPos(s.selectionStart, d), this.toEditorPos(s.selectionEnd, d)));
      }
      this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state));
    }, this.handlers.characterboundsupdate = (s) => {
      let i = [], n = null;
      for (let a = this.toEditorPos(s.rangeStart), l = this.toEditorPos(s.rangeEnd); a < l; a++) {
        let c = e.coordsForChar(a);
        n = c && new DOMRect(c.left, c.top, c.right - c.left, c.bottom - c.top) || n || new DOMRect(), i.push(n);
      }
      r.updateCharacterBounds(s.rangeStart, i);
    }, this.handlers.textformatupdate = (s) => {
      let i = [];
      for (let n of s.getTextFormats()) {
        let a = n.underlineStyle, l = n.underlineThickness;
        if (a != "None" && l != "None") {
          let c = this.toEditorPos(n.rangeStart), p = this.toEditorPos(n.rangeEnd);
          if (c < p) {
            let d = `text-decoration: underline ${a == "Dashed" ? "dashed " : a == "Squiggle" ? "wavy " : ""}${l == "Thin" ? 1 : 2}px`;
            i.push(ce.mark({ attributes: { style: d } }).range(c, p));
          }
        }
      }
      e.dispatch({ effects: vw.of(ce.set(i)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: s } = this.composing;
        this.composing = null, s && this.reset(e.state);
      }
    };
    for (let s in this.handlers)
      r.addEventListener(s, this.handlers[s]);
    this.measureReq = { read: (s) => {
      this.editContext.updateControlBounds(s.contentDOM.getBoundingClientRect());
      let i = Vo(s.root);
      i && i.rangeCount && this.editContext.updateSelectionBounds(i.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let r = 0, s = !1, i = this.pendingContextChange;
    return e.changes.iterChanges((n, a, l, c, p) => {
      if (s)
        return;
      let d = p.length - (a - n);
      if (i && a >= i.to)
        if (i.from == n && i.to == a && i.insert.eq(p)) {
          i = this.pendingContextChange = null, r += d, this.to += d;
          return;
        } else
          i = null, this.revertPending(e.state);
      if (n += r, a += r, a <= this.from)
        this.from += d, this.to += d;
      else if (n < this.to) {
        if (n < this.from || a > this.to || this.to - this.from + p.length > 3e4) {
          s = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(n), this.toContextPos(a), p.toString()), this.to += d;
      }
      r += d;
    }), i && !s && this.revertPending(e.state), !s;
  }
  update(e) {
    let r = this.pendingContextChange, s = e.startState.selection.main;
    this.composing && (this.composing.drifted || !e.changes.touchesRange(s.from, s.to) && e.transactions.some((i) => !i.isUserEvent("input.type") && i.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || r) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: r } = e.selection.main;
    this.from = Math.max(
      0,
      r - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      r + 1e4
      /* CxVp.Margin */
    );
  }
  reset(e) {
    this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
  }
  revertPending(e) {
    let r = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(r.from), this.toContextPos(r.from + r.insert.length), e.doc.sliceString(r.from, r.to));
  }
  setSelection(e) {
    let { main: r } = e.selection, s = this.toContextPos(Math.max(this.from, Math.min(this.to, r.anchor))), i = this.toContextPos(r.head);
    (this.editContext.selectionStart != s || this.editContext.selectionEnd != i) && this.editContext.updateSelection(s, i);
  }
  rangeIsValid(e) {
    let { head: r } = e.selection.main;
    return !(this.from > 0 && r - this.from < 500 || this.to < e.doc.length && this.to - r < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e, r = this.to - this.from) {
    e = Math.min(e, r);
    let s = this.composing;
    return s && s.drifted ? s.editorBase + (e - s.contextBase) : e + this.from;
  }
  toContextPos(e) {
    let r = this.composing;
    return r && r.drifted ? r.contextBase + (e - r.editorBase) : e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
class J {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    var r;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: s } = e;
    this.dispatchTransactions = e.dispatchTransactions || s && ((i) => i.forEach((n) => s(n, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || oL(e.parent) || document, this.viewState = new m1(e.state || we.create(e)), e.scrollTo && e.scrollTo.is(au) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(zn).map((i) => new wp(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new A_(this), this.inputState = new YL(this), this.inputState.ensureHandlers(this.plugins), this.docView = new G0(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((r = document.fonts) === null || r === void 0) && r.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...e) {
    let r = e.length == 1 && e[0] instanceof tt ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(r, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let r = !1, s = !1, i, n = this.state;
    for (let y of e) {
      if (y.startState != n)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      n = y.state;
    }
    if (this.destroyed) {
      this.viewState.state = n;
      return;
    }
    let a = this.hasFocus, l = 0, c = null;
    e.some((y) => y.annotation(Iw)) ? (this.inputState.notifiedFocused = a, l = 1) : a != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = a, c = Nw(n, a), c || (l = 1));
    let p = this.observer.delayedAndroidKey, d = null;
    if (p ? (this.observer.clearDelayedAndroidKey(), d = this.observer.readChange(), (d && !this.state.doc.eq(n.doc) || !this.state.selection.eq(n.selection)) && (d = null)) : this.observer.clear(), n.facet(we.phrases) != this.state.facet(we.phrases))
      return this.setState(n);
    i = mc.create(this, n, e), i.flags |= l;
    let m = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let y of e) {
        if (m && (m = m.map(y.changes)), y.scrollIntoView) {
          let { main: g } = y.state.selection;
          m = new Jn(g.empty ? g : L.cursor(g.head, g.head > g.anchor ? -1 : 1));
        }
        for (let g of y.effects)
          g.is(au) && (m = g.value.clip(this.state));
      }
      this.viewState.update(i, m), this.bidiCache = yc.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), r = this.docView.update(i), this.state.facet(co) != this.styleModules && this.mountStyles(), s = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(r, e.some((y) => y.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(pu) != i.state.facet(pu) && (this.viewState.mustMeasureContent = !0), (r || s || m || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), r && this.docViewUpdate(), !i.empty)
      for (let y of this.state.facet(lf))
        try {
          y(i);
        } catch (g) {
          Ut(this.state, g, "update listener");
        }
    (c || d) && Promise.resolve().then(() => {
      c && this.state == c.startState && this.dispatch(c), d && !kw(this, d) && p.force && Hn(this.contentDOM, p.key, p.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let r = this.hasFocus;
    try {
      for (let s of this.plugins)
        s.destroy(this);
      this.viewState = new m1(e), this.plugins = e.facet(zn).map((s) => new wp(s)), this.pluginMap.clear();
      for (let s of this.plugins)
        s.update(this);
      this.docView.destroy(), this.docView = new G0(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    r && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let r = e.startState.facet(zn), s = e.state.facet(zn);
    if (r != s) {
      let i = [];
      for (let n of s) {
        let a = r.indexOf(n);
        if (a < 0)
          i.push(new wp(n));
        else {
          let l = this.plugins[a];
          l.mustUpdate = e, i.push(l);
        }
      }
      for (let n of this.plugins)
        n.mustUpdate != e && n.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    r != s && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let r = e.value;
      if (r && r.docViewUpdate)
        try {
          r.docViewUpdate(this);
        } catch (s) {
          Ut(this.state, s, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let r = null, s = this.scrollDOM, i = s.scrollTop * this.scaleY, { scrollAnchorPos: n, scrollAnchorHeight: a } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (a = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let l = 0; ; l++) {
        if (a < 0)
          if (GS(s))
            n = -1, a = this.viewState.heightMap.height;
          else {
            let g = this.viewState.scrollAnchorAt(i);
            n = g.from, a = g.top;
          }
        this.updateState = 1;
        let c = this.viewState.measure(this);
        if (!c && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (l > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let p = [];
        c & 4 || ([this.measureRequests, p] = [p, this.measureRequests]);
        let d = p.map((g) => {
          try {
            return g.read(this);
          } catch (x) {
            return Ut(this.state, x), x1;
          }
        }), m = mc.create(this, this.state, []), y = !1;
        m.flags |= c, r ? r.flags |= c : r = m, this.updateState = 2, m.empty || (this.updatePlugins(m), this.inputState.update(m), this.updateAttrs(), y = this.docView.update(m), y && this.docViewUpdate());
        for (let g = 0; g < p.length; g++)
          if (d[g] != x1)
            try {
              let x = p[g];
              x.write && x.write(d[g], this);
            } catch (x) {
              Ut(this.state, x);
            }
        if (y && this.docView.updateSelection(!0), !m.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, a = -1;
              continue;
            } else {
              let g = (n < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(n).top) - a;
              if (g > 1 || g < -1) {
                i = i + g, s.scrollTop = i / this.scaleY, a = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (r && !r.empty)
      for (let l of this.state.facet(lf))
        l(r);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return df + " " + (this.state.facet(pf) ? Rw : _w) + " " + this.state.facet(pu);
  }
  updateAttrs() {
    let e = D1(this, Sw, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), r = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(Ts) ? "true" : "false",
      class: "cm-content",
      style: `${ee.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (r["aria-readonly"] = "true"), D1(this, lg, r);
    let s = this.observer.ignore(() => {
      let i = rf(this.contentDOM, this.contentAttrs, r), n = rf(this.dom, this.editorAttrs, e);
      return i || n;
    });
    return this.editorAttrs = e, this.contentAttrs = r, s;
  }
  showAnnouncements(e) {
    let r = !0;
    for (let s of e)
      for (let i of s.effects)
        if (i.is(J.announce)) {
          r && (this.announceDOM.textContent = ""), r = !1;
          let n = this.announceDOM.appendChild(document.createElement("div"));
          n.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(co);
    let e = this.state.facet(J.cspNonce);
    Ci.mount(this.root, this.styleModules.concat(S_).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let r = 0; r < this.measureRequests.length; r++)
          if (this.measureRequests[r].key === e.key) {
            this.measureRequests[r] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let r = this.pluginMap.get(e);
    return (r === void 0 || r && r.plugin != e) && this.pluginMap.set(e, r = this.plugins.find((s) => s.plugin == e) || null), r && r.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, r, s) {
    return Cp(this, e, t1(this, e, r, s));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, r) {
    return Cp(this, e, t1(this, e, r, (s) => _L(this, e.head, s)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, r) {
    let s = this.bidiSpans(e), i = this.textDirectionAt(e.from), n = s[r ? s.length - 1 : 0];
    return L.cursor(n.side(r, i) + e.from, n.forward(!r, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, r, s = !0) {
    return LL(this, e, r, s);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, r, s) {
    return Cp(this, e, RL(this, e, r, s));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, r = 0) {
    return this.docView.posFromDOM(e, r);
  }
  posAtCoords(e, r = !0) {
    return this.readMeasured(), Tw(this, e, r);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, r = 1) {
    this.readMeasured();
    let s = this.docView.coordsAt(e, r);
    if (!s || s.left == s.right)
      return s;
    let i = this.state.doc.lineAt(e), n = this.bidiSpans(i), a = n[xi.find(n, e - i.from, -1, r)];
    return mh(s, a.dir == _e.LTR == r > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(xw) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > T_)
      return hw(e.length);
    let r = this.textDirectionAt(e.from), s;
    for (let n of this.bidiCache)
      if (n.from == e.from && n.dir == r && (n.fresh || cw(n.isolates, s = W0(this, e))))
        return n.order;
    s || (s = W0(this, e));
    let i = vL(e.text, r, s);
    return this.bidiCache.push(new yc(e.from, e.to, r, s, !0, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || ee.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      YS(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, r = {}) {
    return au.of(new Jn(typeof e == "number" ? L.cursor(e) : e, r.y, r.x, r.yMargin, r.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: r } = this.scrollDOM, s = this.viewState.scrollAnchorAt(e);
    return au.of(new Jn(L.cursor(s.from), "start", "start", s.top - e, r, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return st.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return st.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
  addedneed to be explicitly differentiated by adding an `&` to
  the selector for that elementfor example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, r) {
    let s = Ci.newName(), i = [pu.of(s), co.of(ff(`.${s}`, e))];
    return r && r.dark && i.push(pf.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return Li.lowest(co.of(ff("." + df, e, qw)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var r;
    let s = e.querySelector(".cm-content"), i = s && Ie.get(s) || Ie.get(e);
    return ((r = i == null ? void 0 : i.rootView) === null || r === void 0 ? void 0 : r.view) || null;
  }
}
J.styleModule = co;
J.inputHandler = yw;
J.clipboardInputFilter = ag;
J.clipboardOutputFilter = og;
J.scrollHandler = bw;
J.focusChangeEffect = Ow;
J.perLineTextDirection = xw;
J.exceptionSink = gw;
J.updateListener = lf;
J.editable = Ts;
J.mouseSelectionStyle = mw;
J.dragMovesSelection = fw;
J.clickAddsSelectionRange = dw;
J.decorations = Uo;
J.outerDecorations = ww;
J.atomicRanges = ug;
J.bidiIsolatedRanges = Aw;
J.scrollMargins = Cw;
J.darkTheme = pf;
J.cspNonce = /* @__PURE__ */ re.define({ combine: (t) => t.length ? t[0] : "" });
J.contentAttributes = lg;
J.editorAttributes = Sw;
J.lineWrapping = /* @__PURE__ */ J.contentAttributes.of({ class: "cm-lineWrapping" });
J.announce = /* @__PURE__ */ pe.define();
const T_ = 4096, x1 = {};
class yc {
  constructor(e, r, s, i, n, a) {
    this.from = e, this.to = r, this.dir = s, this.isolates = i, this.fresh = n, this.order = a;
  }
  static update(e, r) {
    if (r.empty && !e.some((n) => n.fresh))
      return e;
    let s = [], i = e.length ? e[e.length - 1].dir : _e.LTR;
    for (let n = Math.max(0, e.length - 10); n < e.length; n++) {
      let a = e[n];
      a.dir == i && !r.touchesRange(a.from, a.to) && s.push(new yc(r.mapPos(a.from, 1), r.mapPos(a.to, -1), a.dir, a.isolates, !1, a.order));
    }
    return s;
  }
}
function D1(t, e, r) {
  for (let s = t.state.facet(e), i = s.length - 1; i >= 0; i--) {
    let n = s[i], a = typeof n == "function" ? n(t) : n;
    a && tf(a, r);
  }
  return r;
}
const k_ = ee.mac ? "mac" : ee.windows ? "win" : ee.linux ? "linux" : "key";
function P_(t, e) {
  const r = t.split(/-(?!$)/);
  let s = r[r.length - 1];
  s == "Space" && (s = " ");
  let i, n, a, l;
  for (let c = 0; c < r.length - 1; ++c) {
    const p = r[c];
    if (/^(cmd|meta|m)$/i.test(p))
      l = !0;
    else if (/^a(lt)?$/i.test(p))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(p))
      n = !0;
    else if (/^s(hift)?$/i.test(p))
      a = !0;
    else if (/^mod$/i.test(p))
      e == "mac" ? l = !0 : n = !0;
    else
      throw new Error("Unrecognized modifier name: " + p);
  }
  return i && (s = "Alt-" + s), n && (s = "Ctrl-" + s), l && (s = "Meta-" + s), a && (s = "Shift-" + s), s;
}
function du(t, e, r) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), r !== !1 && e.shiftKey && (t = "Shift-" + t), t;
}
const F_ = /* @__PURE__ */ Li.default(/* @__PURE__ */ J.domEventHandlers({
  keydown(t, e) {
    return Xw(jw(e.state), t, e, "editor");
  }
})), Cl = /* @__PURE__ */ re.define({ enables: F_ }), b1 = /* @__PURE__ */ new WeakMap();
function jw(t) {
  let e = t.facet(Cl), r = b1.get(e);
  return r || b1.set(e, r = B_(e.reduce((s, i) => s.concat(i), []))), r;
}
function $_(t, e, r) {
  return Xw(jw(t.state), e, t, r);
}
let pi = null;
const Q_ = 4e3;
function B_(t, e = k_) {
  let r = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ Object.create(null), i = (a, l) => {
    let c = s[a];
    if (c == null)
      s[a] = l;
    else if (c != l)
      throw new Error("Key binding " + a + " is used both as a regular binding and as a multi-stroke prefix");
  }, n = (a, l, c, p, d) => {
    var m, y;
    let g = r[a] || (r[a] = /* @__PURE__ */ Object.create(null)), x = l.split(/ (?!$)/).map((C) => P_(C, e));
    for (let C = 1; C < x.length; C++) {
      let b = x.slice(0, C).join(" ");
      i(b, !0), g[b] || (g[b] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(k) => {
          let Q = pi = { view: k, prefix: b, scope: a };
          return setTimeout(() => {
            pi == Q && (pi = null);
          }, Q_), !0;
        }]
      });
    }
    let v = x.join(" ");
    i(v, !1);
    let w = g[v] || (g[v] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((y = (m = g._any) === null || m === void 0 ? void 0 : m.run) === null || y === void 0 ? void 0 : y.slice()) || []
    });
    c && w.run.push(c), p && (w.preventDefault = !0), d && (w.stopPropagation = !0);
  };
  for (let a of t) {
    let l = a.scope ? a.scope.split(" ") : ["editor"];
    if (a.any)
      for (let p of l) {
        let d = r[p] || (r[p] = /* @__PURE__ */ Object.create(null));
        d._any || (d._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: m } = a;
        for (let y in d)
          d[y].run.push((g) => m(g, mf));
      }
    let c = a[e] || a.key;
    if (c)
      for (let p of l)
        n(p, c, a.run, a.preventDefault, a.stopPropagation), a.shift && n(p, "Shift-" + c, a.shift, a.preventDefault, a.stopPropagation);
  }
  return r;
}
let mf = null;
function Xw(t, e, r, s) {
  mf = e;
  let i = rL(e), n = Zt(i, 0), a = es(n) == i.length && i != " ", l = "", c = !1, p = !1, d = !1;
  pi && pi.view == r && pi.scope == s && (l = pi.prefix + " ", Fw.indexOf(e.keyCode) < 0 && (p = !0, pi = null));
  let m = /* @__PURE__ */ new Set(), y = (w) => {
    if (w) {
      for (let C of w.run)
        if (!m.has(C) && (m.add(C), C(r)))
          return w.stopPropagation && (d = !0), !0;
      w.preventDefault && (w.stopPropagation && (d = !0), p = !0);
    }
    return !1;
  }, g = t[s], x, v;
  return g && (y(g[l + du(i, e, !a)]) ? c = !0 : a && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(ee.windows && e.ctrlKey && e.altKey) && // Alt-combinations on macOS tend to be typed characters
  !(ee.mac && e.altKey && !e.ctrlKey) && (x = Ei[e.keyCode]) && x != i ? (y(g[l + du(x, e, !0)]) || e.shiftKey && (v = Zo[e.keyCode]) != i && v != x && y(g[l + du(v, e, !1)])) && (c = !0) : a && e.shiftKey && y(g[l + du(i, e, !0)]) && (c = !0), !c && y(g._any) && (c = !0)), p && (c = !0), c && d && e.stopPropagation(), mf = null, c;
}
class El {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, r, s, i, n) {
    this.className = e, this.left = r, this.top = s, this.width = i, this.height = n;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, r) {
    return r.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, r, s) {
    if (s.empty) {
      let i = e.coordsAtPos(s.head, s.assoc || 1);
      if (!i)
        return [];
      let n = Zw(e);
      return [new El(r, i.left - n.left, i.top - n.top, null, i.bottom - i.top)];
    } else
      return I_(e, r, s);
  }
}
function Zw(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return { left: (t.textDirection == _e.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY };
}
function v1(t, e, r, s) {
  let i = t.coordsAtPos(e, r * 2);
  if (!i)
    return s;
  let n = t.dom.getBoundingClientRect(), a = (i.top + i.bottom) / 2, l = t.posAtCoords({ x: n.left + 1, y: a }), c = t.posAtCoords({ x: n.right - 1, y: a });
  return l == null || c == null ? s : { from: Math.max(s.from, Math.min(l, c)), to: Math.min(s.to, Math.max(l, c)) };
}
function I_(t, e, r) {
  if (r.to <= t.viewport.from || r.from >= t.viewport.to)
    return [];
  let s = Math.max(r.from, t.viewport.from), i = Math.min(r.to, t.viewport.to), n = t.textDirection == _e.LTR, a = t.contentDOM, l = a.getBoundingClientRect(), c = Zw(t), p = a.querySelector(".cm-line"), d = p && window.getComputedStyle(p), m = l.left + (d ? parseInt(d.paddingLeft) + Math.min(0, parseInt(d.textIndent)) : 0), y = l.right - (d ? parseInt(d.paddingRight) : 0), g = cf(t, s, 1), x = cf(t, i, -1), v = g.type == Mt.Text ? g : null, w = x.type == Mt.Text ? x : null;
  if (v && (t.lineWrapping || g.widgetLineBreaks) && (v = v1(t, s, 1, v)), w && (t.lineWrapping || x.widgetLineBreaks) && (w = v1(t, i, -1, w)), v && w && v.from == w.from && v.to == w.to)
    return b(k(r.from, r.to, v));
  {
    let F = v ? k(r.from, null, v) : Q(g, !1), $ = w ? k(null, r.to, w) : Q(x, !0), N = [];
    return (v || g).to < (w || x).from - (v && w ? 1 : 0) || g.widgetLineBreaks > 1 && F.bottom + t.defaultLineHeight / 2 < $.top ? N.push(C(m, F.bottom, y, $.top)) : F.bottom < $.top && t.elementAtHeight((F.bottom + $.top) / 2).type == Mt.Text && (F.bottom = $.top = (F.bottom + $.top) / 2), b(F).concat(N).concat(b($));
  }
  function C(F, $, N, _) {
    return new El(e, F - c.left, $ - c.top, N - F, _ - $);
  }
  function b({ top: F, bottom: $, horizontal: N }) {
    let _ = [];
    for (let W = 0; W < N.length; W += 2)
      _.push(C(N[W], F, N[W + 1], $));
    return _;
  }
  function k(F, $, N) {
    let _ = 1e9, W = -1e9, V = [];
    function j(oe, he, Re, $e, ft) {
      let le = t.coordsAtPos(oe, oe == N.to ? -2 : 2), ve = t.coordsAtPos(Re, Re == N.from ? 2 : -2);
      !le || !ve || (_ = Math.min(le.top, ve.top, _), W = Math.max(le.bottom, ve.bottom, W), ft == _e.LTR ? V.push(n && he ? m : le.left, n && $e ? y : ve.right) : V.push(!n && $e ? m : ve.left, !n && he ? y : le.right));
    }
    let B = F != null ? F : N.from, U = $ != null ? $ : N.to;
    for (let oe of t.visibleRanges)
      if (oe.to > B && oe.from < U)
        for (let he = Math.max(oe.from, B), Re = Math.min(oe.to, U); ; ) {
          let $e = t.state.doc.lineAt(he);
          for (let ft of t.bidiSpans($e)) {
            let le = ft.from + $e.from, ve = ft.to + $e.from;
            if (le >= Re)
              break;
            ve > he && j(Math.max(le, he), F == null && le <= B, Math.min(ve, Re), $ == null && ve >= U, ft.dir);
          }
          if (he = $e.to + 1, he >= Re)
            break;
        }
    return V.length == 0 && j(B, F == null, U, $ == null, t.textDirection), { top: _, bottom: W, horizontal: V };
  }
  function Q(F, $) {
    let N = l.top + ($ ? F.top : F.bottom);
    return { top: N, bottom: N, horizontal: [] };
  }
}
function N_(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class M_ {
  constructor(e, r) {
    this.view = e, this.layer = r, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), r.above && this.dom.classList.add("cm-layer-above"), r.class && this.dom.classList.add(r.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), r.mount && r.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(qu) != e.state.facet(qu) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let r = 0, s = e.facet(qu);
    for (; r < s.length && s[r] != this.layer; )
      r++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - r);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: r } = this.view;
    (e != this.scaleX || r != this.scaleY) && (this.scaleX = e, this.scaleY = r, this.dom.style.transform = `scale(${1 / e}, ${1 / r})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((r, s) => !N_(r, this.drawn[s]))) {
      let r = this.dom.firstChild, s = 0;
      for (let i of e)
        i.update && r && i.constructor && this.drawn[s].constructor && i.update(r, this.drawn[s]) ? (r = r.nextSibling, s++) : this.dom.insertBefore(i.draw(), r);
      for (; r; ) {
        let i = r.nextSibling;
        r.remove(), r = i;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const qu = /* @__PURE__ */ re.define();
function Vw(t) {
  return [
    st.define((e) => new M_(e, t)),
    qu.of(t)
  ];
}
const Yo = /* @__PURE__ */ re.define({
  combine(t) {
    return Os(t, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, r) => Math.min(e, r),
      drawRangeCursor: (e, r) => e || r
    });
  }
});
function L_(t = {}) {
  return [
    Yo.of(t),
    __,
    R_,
    q_,
    Dw.of(!0)
  ];
}
function zw(t) {
  return t.startState.facet(Yo) != t.state.facet(Yo);
}
const __ = /* @__PURE__ */ Vw({
  above: !0,
  markers(t) {
    let { state: e } = t, r = e.facet(Yo), s = [];
    for (let i of e.selection.ranges) {
      let n = i == e.selection.main;
      if (i.empty || r.drawRangeCursor) {
        let a = n ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", l = i.empty ? i : L.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let c of El.forRange(t, a, l))
          s.push(c);
      }
    }
    return s;
  },
  update(t, e) {
    t.transactions.some((s) => s.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let r = zw(t);
    return r && S1(t.state, e), t.docChanged || t.selectionSet || r;
  },
  mount(t, e) {
    S1(e.state, t);
  },
  class: "cm-cursorLayer"
});
function S1(t, e) {
  e.style.animationDuration = t.facet(Yo).cursorBlinkRate + "ms";
}
const R_ = /* @__PURE__ */ Vw({
  above: !1,
  markers(t) {
    return t.state.selection.ranges.map((e) => e.empty ? [] : El.forRange(t, "cm-selectionBackground", e)).reduce((e, r) => e.concat(r));
  },
  update(t, e) {
    return t.docChanged || t.selectionSet || t.viewportChanged || zw(t);
  },
  class: "cm-selectionLayer"
}), q_ = /* @__PURE__ */ Li.highest(/* @__PURE__ */ J.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
})), Uw = /* @__PURE__ */ pe.define({
  map(t, e) {
    return t == null ? null : e.mapPos(t);
  }
}), fo = /* @__PURE__ */ ut.define({
  create() {
    return null;
  },
  update(t, e) {
    return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((r, s) => s.is(Uw) ? s.value : r, t);
  }
}), j_ = /* @__PURE__ */ st.fromClass(class {
  constructor(t) {
    this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(t) {
    var e;
    let r = t.state.field(fo);
    r == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(fo) != r || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: t } = this, e = t.state.field(fo), r = e != null && t.coordsAtPos(e);
    if (!r)
      return null;
    let s = t.scrollDOM.getBoundingClientRect();
    return {
      left: r.left - s.left + t.scrollDOM.scrollLeft * t.scaleX,
      top: r.top - s.top + t.scrollDOM.scrollTop * t.scaleY,
      height: r.bottom - r.top
    };
  }
  drawCursor(t) {
    if (this.cursor) {
      let { scaleX: e, scaleY: r } = this.view;
      t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / r + "px", this.cursor.style.height = t.height / r + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(t) {
    this.view.state.field(fo) != t && this.view.dispatch({ effects: Uw.of(t) });
  }
}, {
  eventObservers: {
    dragover(t) {
      this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
    },
    dragleave(t) {
      (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function X_() {
  return [fo, j_];
}
function w1(t, e, r, s, i) {
  e.lastIndex = 0;
  for (let n = t.iterRange(r, s), a = r, l; !n.next().done; a += n.value.length)
    if (!n.lineBreak)
      for (; l = e.exec(n.value); )
        i(a + l.index, l);
}
function Z_(t, e) {
  let r = t.visibleRanges;
  if (r.length == 1 && r[0].from == t.viewport.from && r[0].to == t.viewport.to)
    return r;
  let s = [];
  for (let { from: i, to: n } of r)
    i = Math.max(t.state.doc.lineAt(i).from, i - e), n = Math.min(t.state.doc.lineAt(n).to, n + e), s.length && s[s.length - 1].to >= i ? s[s.length - 1].to = n : s.push({ from: i, to: n });
  return s;
}
class V_ {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: r, decoration: s, decorate: i, boundary: n, maxLength: a = 1e3 } = e;
    if (!r.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = r, i)
      this.addMatch = (l, c, p, d) => i(d, p, p + l[0].length, l, c);
    else if (typeof s == "function")
      this.addMatch = (l, c, p, d) => {
        let m = s(l, c, p);
        m && d(p, p + l[0].length, m);
      };
    else if (s)
      this.addMatch = (l, c, p, d) => d(p, p + l[0].length, s);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = n, this.maxLength = a;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let r = new _s(), s = r.add.bind(r);
    for (let { from: i, to: n } of Z_(e, this.maxLength))
      w1(e.state.doc, this.regexp, i, n, (a, l) => this.addMatch(l, e, a, s));
    return r.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, r) {
    let s = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((n, a, l, c) => {
      c >= e.view.viewport.from && l <= e.view.viewport.to && (s = Math.min(l, s), i = Math.max(c, i));
    }), e.viewportMoved || i - s > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, r.map(e.changes), s, i) : r;
  }
  updateRange(e, r, s, i) {
    for (let n of e.visibleRanges) {
      let a = Math.max(n.from, s), l = Math.min(n.to, i);
      if (l >= a) {
        let c = e.state.doc.lineAt(a), p = c.to < l ? e.state.doc.lineAt(l) : c, d = Math.max(n.from, c.from), m = Math.min(n.to, p.to);
        if (this.boundary) {
          for (; a > c.from; a--)
            if (this.boundary.test(c.text[a - 1 - c.from])) {
              d = a;
              break;
            }
          for (; l < p.to; l++)
            if (this.boundary.test(p.text[l - p.from])) {
              m = l;
              break;
            }
        }
        let y = [], g, x = (v, w, C) => y.push(C.range(v, w));
        if (c == p)
          for (this.regexp.lastIndex = d - c.from; (g = this.regexp.exec(c.text)) && g.index < m - c.from; )
            this.addMatch(g, e, g.index + c.from, x);
        else
          w1(e.state.doc, this.regexp, d, m, (v, w) => this.addMatch(w, e, v, x));
        r = r.update({ filterFrom: d, filterTo: m, filter: (v, w) => v < d || w > m, add: y });
      }
    }
    return r;
  }
}
const gf = /x/.unicode != null ? "gu" : "g", z_ = /* @__PURE__ */ new RegExp(`[\0-\b
--\u2028\u2029\uFEFF-]`, gf), U_ = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let kp = null;
function Y_() {
  var t;
  if (kp == null && typeof document != "undefined" && document.body) {
    let e = document.body.style;
    kp = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return kp || !1;
}
const ju = /* @__PURE__ */ re.define({
  combine(t) {
    let e = Os(t, {
      render: null,
      specialChars: z_,
      addSpecialChars: null
    });
    return (e.replaceTabs = !Y_()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, gf)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, gf)), e;
  }
});
function W_(t = {}) {
  return [ju.of(t), G_()];
}
let A1 = null;
function G_() {
  return A1 || (A1 = st.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = ce.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(ju)), this.decorations = this.decorator.createDeco(t);
    }
    makeDecorator(t) {
      return new V_({
        regexp: t.specialChars,
        decoration: (e, r, s) => {
          let { doc: i } = r.state, n = Zt(e[0], 0);
          if (n == 9) {
            let a = i.lineAt(s), l = r.state.tabSize, c = Ma(a.text, l, s - a.from);
            return ce.replace({
              widget: new eR((l - c % l) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[n] || (this.decorationCache[n] = ce.replace({ widget: new K_(t, n) }));
        },
        boundary: t.replaceTabs ? void 0 : /[^]/
      });
    }
    update(t) {
      let e = t.state.facet(ju);
      t.startState.facet(ju) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
    }
  }, {
    decorations: (t) => t.decorations
  }));
}
const H_ = "";
function J_(t) {
  return t >= 32 ? H_ : t == 10 ? "" : String.fromCharCode(9216 + t);
}
class K_ extends ei {
  constructor(e, r) {
    super(), this.options = e, this.code = r;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let r = J_(this.code), s = e.state.phrase("Control character") + " " + (U_[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, s, r);
    if (i)
      return i;
    let n = document.createElement("span");
    return n.textContent = r, n.title = s, n.setAttribute("aria-label", s), n.className = "cm-specialChar", n;
  }
  ignoreEvent() {
    return !1;
  }
}
class eR extends ei {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function tR() {
  return sR;
}
const rR = /* @__PURE__ */ ce.line({ class: "cm-activeLine" }), sR = /* @__PURE__ */ st.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = -1, r = [];
    for (let s of t.state.selection.ranges) {
      let i = t.lineBlockAt(s.head);
      i.from > e && (r.push(rR.range(i.from)), e = i.from);
    }
    return ce.set(r);
  }
}, {
  decorations: (t) => t.decorations
}), yf = 2e3;
function iR(t, e, r) {
  let s = Math.min(e.line, r.line), i = Math.max(e.line, r.line), n = [];
  if (e.off > yf || r.off > yf || e.col < 0 || r.col < 0) {
    let a = Math.min(e.off, r.off), l = Math.max(e.off, r.off);
    for (let c = s; c <= i; c++) {
      let p = t.doc.line(c);
      p.length <= l && n.push(L.range(p.from + a, p.to + l));
    }
  } else {
    let a = Math.min(e.col, r.col), l = Math.max(e.col, r.col);
    for (let c = s; c <= i; c++) {
      let p = t.doc.line(c), d = Yd(p.text, a, t.tabSize, !0);
      if (d < 0)
        n.push(L.cursor(p.to));
      else {
        let m = Yd(p.text, l, t.tabSize);
        n.push(L.range(p.from + d, p.from + m));
      }
    }
  }
  return n;
}
function nR(t, e) {
  let r = t.coordsAtPos(t.viewport.from);
  return r ? Math.round(Math.abs((r.left - e) / t.defaultCharacterWidth)) : -1;
}
function C1(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), s = t.state.doc.lineAt(r), i = r - s.from, n = i > yf ? -1 : i == s.length ? nR(t, e.clientX) : Ma(s.text, t.state.tabSize, r - s.from);
  return { line: s.number, col: n, off: i };
}
function aR(t, e) {
  let r = C1(t, e), s = t.state.selection;
  return r ? {
    update(i) {
      if (i.docChanged) {
        let n = i.changes.mapPos(i.startState.doc.line(r.line).from), a = i.state.doc.lineAt(n);
        r = { line: a.number, col: r.col, off: Math.min(r.off, a.length) }, s = s.map(i.changes);
      }
    },
    get(i, n, a) {
      let l = C1(t, i);
      if (!l)
        return s;
      let c = iR(t.state, r, l);
      return c.length ? a ? L.create(c.concat(s.ranges)) : L.create(c) : s;
    }
  } : null;
}
function oR(t) {
  let e = (r) => r.altKey && r.button == 0;
  return J.mouseSelectionStyle.of((r, s) => e(s) ? aR(r, s) : null);
}
const lR = {
  Alt: [18, (t) => !!t.altKey],
  Control: [17, (t) => !!t.ctrlKey],
  Shift: [16, (t) => !!t.shiftKey],
  Meta: [91, (t) => !!t.metaKey]
}, uR = { style: "cursor: crosshair" };
function cR(t = {}) {
  let [e, r] = lR[t.key || "Alt"], s = st.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == e || r(i));
      },
      keyup(i) {
        (i.keyCode == e || !r(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(r(i));
      }
    }
  });
  return [
    s,
    J.contentAttributes.of((i) => {
      var n;
      return !((n = i.plugin(s)) === null || n === void 0) && n.isDown ? uR : null;
    })
  ];
}
const ro = "-10000px";
class Yw {
  constructor(e, r, s, i) {
    this.facet = r, this.createTooltipView = s, this.removeTooltipView = i, this.input = e.state.facet(r), this.tooltips = this.input.filter((a) => a);
    let n = null;
    this.tooltipViews = this.tooltips.map((a) => n = s(a, n));
  }
  update(e, r) {
    var s;
    let i = e.state.facet(this.facet), n = i.filter((c) => c);
    if (i === this.input) {
      for (let c of this.tooltipViews)
        c.update && c.update(e);
      return !1;
    }
    let a = [], l = r ? [] : null;
    for (let c = 0; c < n.length; c++) {
      let p = n[c], d = -1;
      if (p) {
        for (let m = 0; m < this.tooltips.length; m++) {
          let y = this.tooltips[m];
          y && y.create == p.create && (d = m);
        }
        if (d < 0)
          a[c] = this.createTooltipView(p, c ? a[c - 1] : null), l && (l[c] = !!p.above);
        else {
          let m = a[c] = this.tooltipViews[d];
          l && (l[c] = r[d]), m.update && m.update(e);
        }
      }
    }
    for (let c of this.tooltipViews)
      a.indexOf(c) < 0 && (this.removeTooltipView(c), (s = c.destroy) === null || s === void 0 || s.call(c));
    return r && (l.forEach((c, p) => r[p] = c), r.length = l.length), this.input = i, this.tooltips = n, this.tooltipViews = a, !0;
  }
}
function hR(t) {
  let e = t.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: e.clientHeight, right: e.clientWidth };
}
const Pp = /* @__PURE__ */ re.define({
  combine: (t) => {
    var e, r, s;
    return {
      position: ee.ios ? "absolute" : ((e = t.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((r = t.find((i) => i.parent)) === null || r === void 0 ? void 0 : r.parent) || null,
      tooltipSpace: ((s = t.find((i) => i.tooltipSpace)) === null || s === void 0 ? void 0 : s.tooltipSpace) || hR
    };
  }
}), E1 = /* @__PURE__ */ new WeakMap(), fg = /* @__PURE__ */ st.fromClass(class {
  constructor(t) {
    this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t.state.facet(Pp);
    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new Yw(t, mg, (r, s) => this.createTooltip(r, s), (r) => {
      this.resizeObserver && this.resizeObserver.unobserve(r.dom), r.dom.remove();
    }), this.above = this.manager.tooltips.map((r) => !!r.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((r) => {
      Date.now() > this.lastTransaction - 50 && r.length > 0 && r[r.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t of this.manager.tooltipViews)
        this.intersectionObserver.observe(t.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t) {
    t.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t, this.above);
    e && this.observeIntersection();
    let r = e || t.geometryChanged, s = t.state.facet(Pp);
    if (s.position != this.position && !this.madeAbsolute) {
      this.position = s.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      r = !0;
    }
    if (s.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = s.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      r = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    r && this.maybeMeasure();
  }
  createTooltip(t, e) {
    let r = t.create(this.view), s = e ? e.dom : null;
    if (r.dom.classList.add("cm-tooltip"), t.arrow && !r.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", r.dom.appendChild(i);
    }
    return r.dom.style.position = this.position, r.dom.style.top = ro, r.dom.style.left = "0px", this.container.insertBefore(r.dom, s), r.mount && r.mount(this.view), this.resizeObserver && this.resizeObserver.observe(r.dom), r;
  }
  destroy() {
    var t, e, r;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let s of this.manager.tooltipViews)
      s.dom.remove(), (t = s.destroy) === null || t === void 0 || t.call(s);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (r = this.intersectionObserver) === null || r === void 0 || r.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t = 1, e = 1, r = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: n } = this.manager.tooltipViews[0];
      if (ee.gecko)
        r = n.offsetParent != this.container.ownerDocument.body;
      else if (n.style.top == ro && n.style.left == "0px") {
        let a = n.getBoundingClientRect();
        r = Math.abs(a.top + 1e4) > 1 || Math.abs(a.left) > 1;
      }
    }
    if (r || this.position == "absolute")
      if (this.parent) {
        let n = this.parent.getBoundingClientRect();
        n.width && n.height && (t = n.width / this.parent.offsetWidth, e = n.height / this.parent.offsetHeight);
      } else
        ({ scaleX: t, scaleY: e } = this.view.viewState);
    let s = this.view.scrollDOM.getBoundingClientRect(), i = cg(this.view);
    return {
      visible: {
        left: s.left + i.left,
        top: s.top + i.top,
        right: s.right - i.right,
        bottom: s.bottom - i.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((n, a) => {
        let l = this.manager.tooltipViews[a];
        return l.getCoords ? l.getCoords(n.pos) : this.view.coordsAtPos(n.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: n }) => n.getBoundingClientRect()),
      space: this.view.state.facet(Pp).tooltipSpace(this.view),
      scaleX: t,
      scaleY: e,
      makeAbsolute: r
    };
  }
  writeMeasure(t) {
    var e;
    if (t.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let l of this.manager.tooltipViews)
        l.dom.style.position = "absolute";
    }
    let { visible: r, space: s, scaleX: i, scaleY: n } = t, a = [];
    for (let l = 0; l < this.manager.tooltips.length; l++) {
      let c = this.manager.tooltips[l], p = this.manager.tooltipViews[l], { dom: d } = p, m = t.pos[l], y = t.size[l];
      if (!m || c.clip !== !1 && (m.bottom <= Math.max(r.top, s.top) || m.top >= Math.min(r.bottom, s.bottom) || m.right < Math.max(r.left, s.left) - 0.1 || m.left > Math.min(r.right, s.right) + 0.1)) {
        d.style.top = ro;
        continue;
      }
      let g = c.arrow ? p.dom.querySelector(".cm-tooltip-arrow") : null, x = g ? 7 : 0, v = y.right - y.left, w = (e = E1.get(p)) !== null && e !== void 0 ? e : y.bottom - y.top, C = p.offset || dR, b = this.view.textDirection == _e.LTR, k = y.width > s.right - s.left ? b ? s.left : s.right - y.width : b ? Math.max(s.left, Math.min(m.left - (g ? 14 : 0) + C.x, s.right - v)) : Math.min(Math.max(s.left, m.left - v + (g ? 14 : 0) - C.x), s.right - v), Q = this.above[l];
      !c.strictSide && (Q ? m.top - w - x - C.y < s.top : m.bottom + w + x + C.y > s.bottom) && Q == s.bottom - m.bottom > m.top - s.top && (Q = this.above[l] = !Q);
      let F = (Q ? m.top - s.top : s.bottom - m.bottom) - x;
      if (F < w && p.resize !== !1) {
        if (F < this.view.defaultLineHeight) {
          d.style.top = ro;
          continue;
        }
        E1.set(p, w), d.style.height = (w = F) / n + "px";
      } else d.style.height && (d.style.height = "");
      let $ = Q ? m.top - w - x - C.y : m.bottom + x + C.y, N = k + v;
      if (p.overlap !== !0)
        for (let _ of a)
          _.left < N && _.right > k && _.top < $ + w && _.bottom > $ && ($ = Q ? _.top - w - 2 - x : _.bottom + x + 2);
      if (this.position == "absolute" ? (d.style.top = ($ - t.parent.top) / n + "px", T1(d, (k - t.parent.left) / i)) : (d.style.top = $ / n + "px", T1(d, k / i)), g) {
        let _ = m.left + (b ? C.x : -C.x) - (k + 14 - 7);
        g.style.left = _ / i + "px";
      }
      p.overlap !== !0 && a.push({ left: k, top: $, right: N, bottom: $ + w }), d.classList.toggle("cm-tooltip-above", Q), d.classList.toggle("cm-tooltip-below", !Q), p.positioned && p.positioned(t.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t of this.manager.tooltipViews)
        t.dom.style.top = ro;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function T1(t, e) {
  let r = parseInt(t.style.left, 10);
  (isNaN(r) || Math.abs(e - r) > 1) && (t.style.left = e + "px");
}
const pR = /* @__PURE__ */ J.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: "14px",
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), dR = { x: 0, y: 0 }, mg = /* @__PURE__ */ re.define({
  enables: [fg, pR]
}), Oc = /* @__PURE__ */ re.define({
  combine: (t) => t.reduce((e, r) => e.concat(r), [])
});
class Oh {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Oh(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new Yw(e, Oc, (r, s) => this.createHostedView(r, s), (r) => r.dom.remove());
  }
  createHostedView(e, r) {
    let s = e.create(this.view);
    return s.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(s.dom, r ? r.dom.nextSibling : this.dom.firstChild), this.mounted && s.mount && s.mount(this.view), s;
  }
  mount(e) {
    for (let r of this.manager.tooltipViews)
      r.mount && r.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let r of this.manager.tooltipViews)
      r.positioned && r.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let r of this.manager.tooltipViews)
      (e = r.destroy) === null || e === void 0 || e.call(r);
  }
  passProp(e) {
    let r;
    for (let s of this.manager.tooltipViews) {
      let i = s[e];
      if (i !== void 0) {
        if (r === void 0)
          r = i;
        else if (r !== i)
          return;
      }
    }
    return r;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const fR = /* @__PURE__ */ mg.compute([Oc], (t) => {
  let e = t.facet(Oc);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((r) => r.pos)),
    end: Math.max(...e.map((r) => {
      var s;
      return (s = r.end) !== null && s !== void 0 ? s : r.pos;
    })),
    create: Oh.create,
    above: e[0].above,
    arrow: e.some((r) => r.arrow)
  };
});
class mR {
  constructor(e, r, s, i, n) {
    this.view = e, this.source = r, this.field = s, this.setHover = i, this.hoverTime = n, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: r } = this, s = e.docView.nearest(r.target);
    if (!s)
      return;
    let i, n = 1;
    if (s instanceof Oi)
      i = s.posAtStart;
    else {
      if (i = e.posAtCoords(r), i == null)
        return;
      let l = e.coordsAtPos(i);
      if (!l || r.y < l.top || r.y > l.bottom || r.x < l.left - e.defaultCharacterWidth || r.x > l.right + e.defaultCharacterWidth)
        return;
      let c = e.bidiSpans(e.state.doc.lineAt(i)).find((d) => d.from <= i && d.to >= i), p = c && c.dir == _e.RTL ? -1 : 1;
      n = r.x < l.left ? -p : p;
    }
    let a = this.source(e, i, n);
    if (a != null && a.then) {
      let l = this.pending = { pos: i };
      a.then((c) => {
        this.pending == l && (this.pending = null, c && !(Array.isArray(c) && !c.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(c) ? c : [c]) }));
      }, (c) => Ut(e.state, c, "hover tooltip"));
    } else a && !(Array.isArray(a) && !a.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(a) ? a : [a]) });
  }
  get tooltip() {
    let e = this.view.plugin(fg), r = e ? e.manager.tooltips.findIndex((s) => s.create == Oh.create) : -1;
    return r > -1 ? e.manager.tooltipViews[r] : null;
  }
  mousemove(e) {
    var r, s;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: n } = this;
    if (i.length && n && !gR(n.dom, e) || this.pending) {
      let { pos: a } = i[0] || this.pending, l = (s = (r = i[0]) === null || r === void 0 ? void 0 : r.end) !== null && s !== void 0 ? s : a;
      (a == l ? this.view.posAtCoords(this.lastMove) != a : !yR(this.view, a, l, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: r } = this;
    if (r.length) {
      let { tooltip: s } = this;
      s && s.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(s.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let r = (s) => {
      e.removeEventListener("mouseleave", r), this.active.length && !this.view.dom.contains(s.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", r);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const fu = 4;
function gR(t, e) {
  let { left: r, right: s, top: i, bottom: n } = t.getBoundingClientRect(), a;
  if (a = t.querySelector(".cm-tooltip-arrow")) {
    let l = a.getBoundingClientRect();
    i = Math.min(l.top, i), n = Math.max(l.bottom, n);
  }
  return e.clientX >= r - fu && e.clientX <= s + fu && e.clientY >= i - fu && e.clientY <= n + fu;
}
function yR(t, e, r, s, i, n) {
  let a = t.scrollDOM.getBoundingClientRect(), l = t.documentTop + t.documentPadding.top + t.contentHeight;
  if (a.left > s || a.right < s || a.top > i || Math.min(a.bottom, l) < i)
    return !1;
  let c = t.posAtCoords({ x: s, y: i }, !1);
  return c >= e && c <= r;
}
function OR(t, e = {}) {
  let r = pe.define(), s = ut.define({
    create() {
      return [];
    },
    update(i, n) {
      if (i.length && (e.hideOnChange && (n.docChanged || n.selection) ? i = [] : e.hideOn && (i = i.filter((a) => !e.hideOn(n, a))), n.docChanged)) {
        let a = [];
        for (let l of i) {
          let c = n.changes.mapPos(l.pos, -1, Ot.TrackDel);
          if (c != null) {
            let p = Object.assign(/* @__PURE__ */ Object.create(null), l);
            p.pos = c, p.end != null && (p.end = n.changes.mapPos(p.end)), a.push(p);
          }
        }
        i = a;
      }
      for (let a of n.effects)
        a.is(r) && (i = a.value), a.is(xR) && (i = []);
      return i;
    },
    provide: (i) => Oc.from(i)
  });
  return {
    active: s,
    extension: [
      s,
      st.define((i) => new mR(
        i,
        t,
        s,
        r,
        e.hoverTime || 300
        /* Hover.Time */
      )),
      fR
    ]
  };
}
function Ww(t, e) {
  let r = t.plugin(fg);
  if (!r)
    return null;
  let s = r.manager.tooltips.indexOf(e);
  return s < 0 ? null : r.manager.tooltipViews[s];
}
const xR = /* @__PURE__ */ pe.define(), k1 = /* @__PURE__ */ re.define({
  combine(t) {
    let e, r;
    for (let s of t)
      e = e || s.topContainer, r = r || s.bottomContainer;
    return { topContainer: e, bottomContainer: r };
  }
});
function Wo(t, e) {
  let r = t.plugin(Gw), s = r ? r.specs.indexOf(e) : -1;
  return s > -1 ? r.panels[s] : null;
}
const Gw = /* @__PURE__ */ st.fromClass(class {
  constructor(t) {
    this.input = t.state.facet(Go), this.specs = this.input.filter((r) => r), this.panels = this.specs.map((r) => r(t));
    let e = t.state.facet(k1);
    this.top = new mu(t, !0, e.topContainer), this.bottom = new mu(t, !1, e.bottomContainer), this.top.sync(this.panels.filter((r) => r.top)), this.bottom.sync(this.panels.filter((r) => !r.top));
    for (let r of this.panels)
      r.dom.classList.add("cm-panel"), r.mount && r.mount();
  }
  update(t) {
    let e = t.state.facet(k1);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new mu(t.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new mu(t.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let r = t.state.facet(Go);
    if (r != this.input) {
      let s = r.filter((c) => c), i = [], n = [], a = [], l = [];
      for (let c of s) {
        let p = this.specs.indexOf(c), d;
        p < 0 ? (d = c(t.view), l.push(d)) : (d = this.panels[p], d.update && d.update(t)), i.push(d), (d.top ? n : a).push(d);
      }
      this.specs = s, this.panels = i, this.top.sync(n), this.bottom.sync(a);
      for (let c of l)
        c.dom.classList.add("cm-panel"), c.mount && c.mount();
    } else
      for (let s of this.panels)
        s.update && s.update(t);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (t) => J.scrollMargins.of((e) => {
    let r = e.plugin(t);
    return r && { top: r.top.scrollMargin(), bottom: r.bottom.scrollMargin() };
  })
});
class mu {
  constructor(e, r, s) {
    this.view = e, this.top = r, this.container = s, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let r of this.panels)
      r.destroy && e.indexOf(r) < 0 && r.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let r = this.container || this.view.dom;
      r.insertBefore(this.dom, this.top ? r.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let r of this.panels)
      if (r.dom.parentNode == this.dom) {
        for (; e != r.dom; )
          e = P1(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(r.dom, e);
    for (; e; )
      e = P1(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function P1(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const Go = /* @__PURE__ */ re.define({
  enables: Gw
});
class qs extends dn {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
qs.prototype.elementClass = "";
qs.prototype.toDOM = void 0;
qs.prototype.mapMode = Ot.TrackBefore;
qs.prototype.startSide = qs.prototype.endSide = -1;
qs.prototype.point = !0;
const Xu = /* @__PURE__ */ re.define(), DR = /* @__PURE__ */ re.define(), bR = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => Ce.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {},
  side: "before"
}, Fo = /* @__PURE__ */ re.define();
function vR(t) {
  return [Hw(), Fo.of({ ...bR, ...t })];
}
const F1 = /* @__PURE__ */ re.define({
  combine: (t) => t.some((e) => e)
});
function Hw(t) {
  return [
    SR
  ];
}
const SR = /* @__PURE__ */ st.fromClass(class {
  constructor(t) {
    this.view = t, this.domAfter = null, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters cm-gutters-before", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(Fo).map((e) => new Q1(t, e)), this.fixed = !t.state.facet(F1);
    for (let e of this.gutters)
      e.config.side == "after" ? this.getDOMAfter().appendChild(e.dom) : this.dom.appendChild(e.dom);
    this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
  }
  getDOMAfter() {
    return this.domAfter || (this.domAfter = document.createElement("div"), this.domAfter.className = "cm-gutters cm-gutters-after", this.domAfter.setAttribute("aria-hidden", "true"), this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.domAfter.style.position = this.fixed ? "sticky" : "", this.view.scrollDOM.appendChild(this.domAfter)), this.domAfter;
  }
  update(t) {
    if (this.updateGutters(t)) {
      let e = this.prevViewport, r = t.view.viewport, s = Math.min(e.to, r.to) - Math.max(e.from, r.from);
      this.syncGutters(s < (r.to - r.from) * 0.8);
    }
    if (t.geometryChanged) {
      let e = this.view.contentHeight / this.view.scaleY + "px";
      this.dom.style.minHeight = e, this.domAfter && (this.domAfter.style.minHeight = e);
    }
    this.view.state.facet(F1) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : "", this.domAfter && (this.domAfter.style.position = this.fixed ? "sticky" : "")), this.prevViewport = t.view.viewport;
  }
  syncGutters(t) {
    let e = this.dom.nextSibling;
    t && (this.dom.remove(), this.domAfter && this.domAfter.remove());
    let r = Ce.iter(this.view.state.facet(Xu), this.view.viewport.from), s = [], i = this.gutters.map((n) => new wR(n, this.view.viewport, -this.view.documentPadding.top));
    for (let n of this.view.viewportLineBlocks)
      if (s.length && (s = []), Array.isArray(n.type)) {
        let a = !0;
        for (let l of n.type)
          if (l.type == Mt.Text && a) {
            Of(r, s, l.from);
            for (let c of i)
              c.line(this.view, l, s);
            a = !1;
          } else if (l.widget)
            for (let c of i)
              c.widget(this.view, l);
      } else if (n.type == Mt.Text) {
        Of(r, s, n.from);
        for (let a of i)
          a.line(this.view, n, s);
      } else if (n.widget)
        for (let a of i)
          a.widget(this.view, n);
    for (let n of i)
      n.finish();
    t && (this.view.scrollDOM.insertBefore(this.dom, e), this.domAfter && this.view.scrollDOM.appendChild(this.domAfter));
  }
  updateGutters(t) {
    let e = t.startState.facet(Fo), r = t.state.facet(Fo), s = t.docChanged || t.heightChanged || t.viewportChanged || !Ce.eq(t.startState.facet(Xu), t.state.facet(Xu), t.view.viewport.from, t.view.viewport.to);
    if (e == r)
      for (let i of this.gutters)
        i.update(t) && (s = !0);
    else {
      s = !0;
      let i = [];
      for (let n of r) {
        let a = e.indexOf(n);
        a < 0 ? i.push(new Q1(this.view, n)) : (this.gutters[a].update(t), i.push(this.gutters[a]));
      }
      for (let n of this.gutters)
        n.dom.remove(), i.indexOf(n) < 0 && n.destroy();
      for (let n of i)
        n.config.side == "after" ? this.getDOMAfter().appendChild(n.dom) : this.dom.appendChild(n.dom);
      this.gutters = i;
    }
    return s;
  }
  destroy() {
    for (let t of this.gutters)
      t.destroy();
    this.dom.remove(), this.domAfter && this.domAfter.remove();
  }
}, {
  provide: (t) => J.scrollMargins.of((e) => {
    let r = e.plugin(t);
    if (!r || r.gutters.length == 0 || !r.fixed)
      return null;
    let s = r.dom.offsetWidth * e.scaleX, i = r.domAfter ? r.domAfter.offsetWidth * e.scaleX : 0;
    return e.textDirection == _e.LTR ? { left: s, right: i } : { right: s, left: i };
  })
});
function $1(t) {
  return Array.isArray(t) ? t : [t];
}
function Of(t, e, r) {
  for (; t.value && t.from <= r; )
    t.from == r && e.push(t.value), t.next();
}
class wR {
  constructor(e, r, s) {
    this.gutter = e, this.height = s, this.i = 0, this.cursor = Ce.iter(e.markers, r.from);
  }
  addElement(e, r, s) {
    let { gutter: i } = this, n = (r.top - this.height) / e.scaleY, a = r.height / e.scaleY;
    if (this.i == i.elements.length) {
      let l = new Jw(e, a, n, s);
      i.elements.push(l), i.dom.appendChild(l.dom);
    } else
      i.elements[this.i].update(e, a, n, s);
    this.height = r.bottom, this.i++;
  }
  line(e, r, s) {
    let i = [];
    Of(this.cursor, i, r.from), s.length && (i = i.concat(s));
    let n = this.gutter.config.lineMarker(e, r, i);
    n && i.unshift(n);
    let a = this.gutter;
    i.length == 0 && !a.config.renderEmptyElements || this.addElement(e, r, i);
  }
  widget(e, r) {
    let s = this.gutter.config.widgetMarker(e, r.widget, r), i = s ? [s] : null;
    for (let n of e.state.facet(DR)) {
      let a = n(e, r.widget, r);
      a && (i || (i = [])).push(a);
    }
    i && this.addElement(e, r, i);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let r = e.elements.pop();
      e.dom.removeChild(r.dom), r.destroy();
    }
  }
}
class Q1 {
  constructor(e, r) {
    this.view = e, this.config = r, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let s in r.domEventHandlers)
      this.dom.addEventListener(s, (i) => {
        let n = i.target, a;
        if (n != this.dom && this.dom.contains(n)) {
          for (; n.parentNode != this.dom; )
            n = n.parentNode;
          let c = n.getBoundingClientRect();
          a = (c.top + c.bottom) / 2;
        } else
          a = i.clientY;
        let l = e.lineBlockAtHeight(a - e.documentTop);
        r.domEventHandlers[s](e, l, i) && i.preventDefault();
      });
    this.markers = $1(r.markers(e)), r.initialSpacer && (this.spacer = new Jw(e, 0, 0, [r.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let r = this.markers;
    if (this.markers = $1(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let s = e.view.viewport;
    return !Ce.eq(this.markers, r, s.from, s.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class Jw {
  constructor(e, r, s, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, r, s, i);
  }
  update(e, r, s, i) {
    this.height != r && (this.height = r, this.dom.style.height = r + "px"), this.above != s && (this.dom.style.marginTop = (this.above = s) ? s + "px" : ""), AR(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, r) {
    let s = "cm-gutterElement", i = this.dom.firstChild;
    for (let n = 0, a = 0; ; ) {
      let l = a, c = n < r.length ? r[n++] : null, p = !1;
      if (c) {
        let d = c.elementClass;
        d && (s += " " + d);
        for (let m = a; m < this.markers.length; m++)
          if (this.markers[m].compare(c)) {
            l = m, p = !0;
            break;
          }
      } else
        l = this.markers.length;
      for (; a < l; ) {
        let d = this.markers[a++];
        if (d.toDOM) {
          d.destroy(i);
          let m = i.nextSibling;
          i.remove(), i = m;
        }
      }
      if (!c)
        break;
      c.toDOM && (p ? i = i.nextSibling : this.dom.insertBefore(c.toDOM(e), i)), p && a++;
    }
    this.dom.className = s, this.markers = r;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function AR(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (!t[r].compare(e[r]))
      return !1;
  return !0;
}
const CR = /* @__PURE__ */ re.define(), ER = /* @__PURE__ */ re.define(), Un = /* @__PURE__ */ re.define({
  combine(t) {
    return Os(t, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, r) {
        let s = Object.assign({}, e);
        for (let i in r) {
          let n = s[i], a = r[i];
          s[i] = n ? (l, c, p) => n(l, c, p) || a(l, c, p) : a;
        }
        return s;
      }
    });
  }
});
class Fp extends qs {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function $p(t, e) {
  return t.state.facet(Un).formatNumber(e, t.state);
}
const TR = /* @__PURE__ */ Fo.compute([Un], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(CR);
  },
  lineMarker(e, r, s) {
    return s.some((i) => i.toDOM) ? null : new Fp($p(e, e.state.doc.lineAt(r.from).number));
  },
  widgetMarker: (e, r, s) => {
    for (let i of e.state.facet(ER)) {
      let n = i(e, r, s);
      if (n)
        return n;
    }
    return null;
  },
  lineMarkerChange: (e) => e.startState.facet(Un) != e.state.facet(Un),
  initialSpacer(e) {
    return new Fp($p(e, B1(e.state.doc.lines)));
  },
  updateSpacer(e, r) {
    let s = $p(r.view, B1(r.view.state.doc.lines));
    return s == e.number ? e : new Fp(s);
  },
  domEventHandlers: t.facet(Un).domEventHandlers,
  side: "before"
}));
function kR(t = {}) {
  return [
    Un.of(t),
    Hw(),
    TR
  ];
}
function B1(t) {
  let e = 9;
  for (; e < t; )
    e = e * 10 + 9;
  return e;
}
const PR = /* @__PURE__ */ new class extends qs {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), FR = /* @__PURE__ */ Xu.compute(["selection"], (t) => {
  let e = [], r = -1;
  for (let s of t.selection.ranges) {
    let i = t.doc.lineAt(s.head).from;
    i > r && (r = i, e.push(PR.range(i)));
  }
  return Ce.of(e);
});
function $R() {
  return FR;
}
const Kw = 1024;
let QR = 0;
class Dr {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
class ge {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = QR++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = _t.match(e)), (r) => {
      let s = e(r);
      return s === void 0 ? null : [this, s];
    };
  }
}
ge.closedBy = new ge({ deserialize: (t) => t.split(" ") });
ge.openedBy = new ge({ deserialize: (t) => t.split(" ") });
ge.group = new ge({ deserialize: (t) => t.split(" ") });
ge.isolate = new ge({ deserialize: (t) => {
  if (t && t != "rtl" && t != "ltr" && t != "auto")
    throw new RangeError("Invalid value for isolate: " + t);
  return t || "auto";
} });
ge.contextHash = new ge({ perNode: !0 });
ge.lookAhead = new ge({ perNode: !0 });
ge.mounted = new ge({ perNode: !0 });
class Ho {
  constructor(e, r, s) {
    this.tree = e, this.overlay = r, this.parser = s;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[ge.mounted.id];
  }
}
const BR = /* @__PURE__ */ Object.create(null);
class _t {
  /**
  @internal
  */
  constructor(e, r, s, i = 0) {
    this.name = e, this.props = r, this.id = s, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let r = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : BR, s = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new _t(e.name || "", r, e.id, s);
    if (e.props) {
      for (let n of e.props)
        if (Array.isArray(n) || (n = n(i)), n) {
          if (n[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          r[n[0].id] = n[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let r = this.prop(ge.group);
      return r ? r.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let r = /* @__PURE__ */ Object.create(null);
    for (let s in e)
      for (let i of s.split(" "))
        r[i] = e[s];
    return (s) => {
      for (let i = s.prop(ge.group), n = -1; n < (i ? i.length : 0); n++) {
        let a = r[n < 0 ? s.name : i[n]];
        if (a)
          return a;
      }
    };
  }
}
_t.none = new _t(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class gg {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let r = 0; r < e.length; r++)
      if (e[r].id != r)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let r = [];
    for (let s of this.types) {
      let i = null;
      for (let n of e) {
        let a = n(s);
        a && (i || (i = Object.assign({}, s.props)), i[a[0].id] = a[1]);
      }
      r.push(i ? new _t(s.name, i, s.id, s.flags) : s);
    }
    return new gg(r);
  }
}
const gu = /* @__PURE__ */ new WeakMap(), I1 = /* @__PURE__ */ new WeakMap();
var Ne;
(function(t) {
  t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Ne || (Ne = {}));
class Ze {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, r, s, i, n) {
    if (this.type = e, this.children = r, this.positions = s, this.length = i, this.props = null, n && n.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [a, l] of n)
        this.props[typeof a == "number" ? a : a.id] = l;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = Ho.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let r = "";
    for (let s of this.children) {
      let i = s.toString();
      i && (r && (r += ","), r += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (r.length ? "(" + r + ")" : "") : r;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new xc(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, r = 0, s = 0) {
    let i = gu.get(this) || this.topNode, n = new xc(i);
    return n.moveTo(e, r), gu.set(this, n._tree), n;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new kt(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, r = 0) {
    let s = Jo(gu.get(this) || this.topNode, e, r, !1);
    return gu.set(this, s), s;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, r = 0) {
    let s = Jo(I1.get(this) || this.topNode, e, r, !0);
    return I1.set(this, s), s;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, r = 0) {
    return MR(this, e, r);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: r, leave: s, from: i = 0, to: n = this.length } = e, a = e.mode || 0, l = (a & Ne.IncludeAnonymous) > 0;
    for (let c = this.cursor(a | Ne.IncludeAnonymous); ; ) {
      let p = !1;
      if (c.from <= n && c.to >= i && (!l && c.type.isAnonymous || r(c) !== !1)) {
        if (c.firstChild())
          continue;
        p = !0;
      }
      for (; p && s && (l || !c.type.isAnonymous) && s(c), !c.nextSibling(); ) {
        if (!c.parent())
          return;
        p = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let r in this.props)
        e.push([+r, this.props[r]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : xg(_t.none, this.children, this.positions, 0, this.children.length, 0, this.length, (r, s, i) => new Ze(this.type, r, s, i, this.propValues), e.makeTree || ((r, s, i) => new Ze(_t.none, r, s, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return LR(e);
  }
}
Ze.empty = new Ze(_t.none, [], [], 0);
class yg {
  constructor(e, r) {
    this.buffer = e, this.index = r;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new yg(this.buffer, this.index);
  }
}
class ki {
  /**
  Create a tree buffer.
  */
  constructor(e, r, s) {
    this.buffer = e, this.length = r, this.set = s;
  }
  /**
  @internal
  */
  get type() {
    return _t.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let r = 0; r < this.buffer.length; )
      e.push(this.childString(r)), r = this.buffer[r + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let r = this.buffer[e], s = this.buffer[e + 3], i = this.set.types[r], n = i.name;
    if (/\W/.test(n) && !i.isError && (n = JSON.stringify(n)), e += 4, s == e)
      return n;
    let a = [];
    for (; e < s; )
      a.push(this.childString(e)), e = this.buffer[e + 3];
    return n + "(" + a.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, r, s, i, n) {
    let { buffer: a } = this, l = -1;
    for (let c = e; c != r && !(eA(n, i, a[c + 1], a[c + 2]) && (l = c, s > 0)); c = a[c + 3])
      ;
    return l;
  }
  /**
  @internal
  */
  slice(e, r, s) {
    let i = this.buffer, n = new Uint16Array(r - e), a = 0;
    for (let l = e, c = 0; l < r; ) {
      n[c++] = i[l++], n[c++] = i[l++] - s;
      let p = n[c++] = i[l++] - s;
      n[c++] = i[l++] - e, a = Math.max(a, p);
    }
    return new ki(n, a, this.set);
  }
}
function eA(t, e, r, s) {
  switch (t) {
    case -2:
      return r < e;
    case -1:
      return s >= e && r < e;
    case 0:
      return r < e && s > e;
    case 1:
      return r <= e && s > e;
    case 2:
      return s > e;
    case 4:
      return !0;
  }
}
function Jo(t, e, r, s) {
  for (var i; t.from == t.to || (r < 1 ? t.from >= e : t.from > e) || (r > -1 ? t.to <= e : t.to < e); ) {
    let a = !s && t instanceof kt && t.index < 0 ? null : t.parent;
    if (!a)
      return t;
    t = a;
  }
  let n = s ? 0 : Ne.IgnoreOverlays;
  if (s)
    for (let a = t, l = a.parent; l; a = l, l = a.parent)
      a instanceof kt && a.index < 0 && ((i = l.enter(e, r, n)) === null || i === void 0 ? void 0 : i.from) != a.from && (t = l);
  for (; ; ) {
    let a = t.enter(e, r, n);
    if (!a)
      return t;
    t = a;
  }
}
class tA {
  cursor(e = 0) {
    return new xc(this, e);
  }
  getChild(e, r = null, s = null) {
    let i = N1(this, e, r, s);
    return i.length ? i[0] : null;
  }
  getChildren(e, r = null, s = null) {
    return N1(this, e, r, s);
  }
  resolve(e, r = 0) {
    return Jo(this, e, r, !1);
  }
  resolveInner(e, r = 0) {
    return Jo(this, e, r, !0);
  }
  matchContext(e) {
    return xf(this.parent, e);
  }
  enterUnfinishedNodesBefore(e) {
    let r = this.childBefore(e), s = this;
    for (; r; ) {
      let i = r.lastChild;
      if (!i || i.to != r.to)
        break;
      i.type.isError && i.from == i.to ? (s = r, r = i.prevSibling) : r = i;
    }
    return s;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class kt extends tA {
  constructor(e, r, s, i) {
    super(), this._tree = e, this.from = r, this.index = s, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, r, s, i, n = 0) {
    for (let a = this; ; ) {
      for (let { children: l, positions: c } = a._tree, p = r > 0 ? l.length : -1; e != p; e += r) {
        let d = l[e], m = c[e] + a.from;
        if (eA(i, s, m, m + d.length)) {
          if (d instanceof ki) {
            if (n & Ne.ExcludeBuffers)
              continue;
            let y = d.findChild(0, d.buffer.length, r, s - m, i);
            if (y > -1)
              return new is(new IR(a, d, e, m), null, y);
          } else if (n & Ne.IncludeAnonymous || !d.type.isAnonymous || Og(d)) {
            let y;
            if (!(n & Ne.IgnoreMounts) && (y = Ho.get(d)) && !y.overlay)
              return new kt(y.tree, m, e, a);
            let g = new kt(d, m, e, a);
            return n & Ne.IncludeAnonymous || !g.type.isAnonymous ? g : g.nextChild(r < 0 ? d.children.length - 1 : 0, r, s, i);
          }
        }
      }
      if (n & Ne.IncludeAnonymous || !a.type.isAnonymous || (a.index >= 0 ? e = a.index + r : e = r < 0 ? -1 : a._parent._tree.children.length, a = a._parent, !a))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, s = 0) {
    let i;
    if (!(s & Ne.IgnoreOverlays) && (i = Ho.get(this._tree)) && i.overlay) {
      let n = e - this.from;
      for (let { from: a, to: l } of i.overlay)
        if ((r > 0 ? a <= n : a < n) && (r < 0 ? l >= n : l > n))
          return new kt(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, r, s);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function N1(t, e, r, s) {
  let i = t.cursor(), n = [];
  if (!i.firstChild())
    return n;
  if (r != null) {
    for (let a = !1; !a; )
      if (a = i.type.is(r), !i.nextSibling())
        return n;
  }
  for (; ; ) {
    if (s != null && i.type.is(s))
      return n;
    if (i.type.is(e) && n.push(i.node), !i.nextSibling())
      return s == null ? n : [];
  }
}
function xf(t, e, r = e.length - 1) {
  for (let s = t; r >= 0; s = s.parent) {
    if (!s)
      return !1;
    if (!s.type.isAnonymous) {
      if (e[r] && e[r] != s.name)
        return !1;
      r--;
    }
  }
  return !0;
}
class IR {
  constructor(e, r, s, i) {
    this.parent = e, this.buffer = r, this.index = s, this.start = i;
  }
}
class is extends tA {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, r, s) {
    super(), this.context = e, this._parent = r, this.index = s, this.type = e.buffer.set.types[e.buffer.buffer[s]];
  }
  child(e, r, s) {
    let { buffer: i } = this.context, n = i.findChild(this.index + 4, i.buffer[this.index + 3], e, r - this.context.start, s);
    return n < 0 ? null : new is(this.context, this, n);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, s = 0) {
    if (s & Ne.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, n = i.findChild(this.index + 4, i.buffer[this.index + 3], r > 0 ? 1 : -1, e - this.context.start, r);
    return n < 0 ? null : new is(this.context, this, n);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, r = e.buffer[this.index + 3];
    return r < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new is(this.context, this._parent, r) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, r = this._parent ? this._parent.index + 4 : 0;
    return this.index == r ? this.externalSibling(-1) : new is(this.context, this._parent, e.findChild(
      r,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], r = [], { buffer: s } = this.context, i = this.index + 4, n = s.buffer[this.index + 3];
    if (n > i) {
      let a = s.buffer[this.index + 1];
      e.push(s.slice(i, n, a)), r.push(0);
    }
    return new Ze(this.type, e, r, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function rA(t) {
  if (!t.length)
    return null;
  let e = 0, r = t[0];
  for (let n = 1; n < t.length; n++) {
    let a = t[n];
    (a.from > r.from || a.to < r.to) && (r = a, e = n);
  }
  let s = r instanceof kt && r.index < 0 ? null : r.parent, i = t.slice();
  return s ? i[e] = s : i.splice(e, 1), new NR(i, r);
}
class NR {
  constructor(e, r) {
    this.heads = e, this.node = r;
  }
  get next() {
    return rA(this.heads);
  }
}
function MR(t, e, r) {
  let s = t.resolveInner(e, r), i = null;
  for (let n = s instanceof kt ? s : s.context.parent; n; n = n.parent)
    if (n.index < 0) {
      let a = n.parent;
      (i || (i = [s])).push(a.resolve(e, r)), n = a;
    } else {
      let a = Ho.get(n.tree);
      if (a && a.overlay && a.overlay[0].from <= e && a.overlay[a.overlay.length - 1].to >= e) {
        let l = new kt(a.tree, a.overlay[0].from + n.from, -1, n);
        (i || (i = [s])).push(Jo(l, e, r, !1));
      }
    }
  return i ? rA(i) : s;
}
class xc {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, r = 0) {
    if (this.mode = r, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof kt)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let s = e._parent; s; s = s._parent)
        this.stack.unshift(s.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, r) {
    this.index = e;
    let { start: s, buffer: i } = this.buffer;
    return this.type = r || i.set.types[i.buffer[e]], this.from = s + i.buffer[e + 1], this.to = s + i.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof kt ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, r, s) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, r, s, this.mode));
    let { buffer: i } = this.buffer, n = i.findChild(this.index + 4, i.buffer[this.index + 3], e, r - this.buffer.start, s);
    return n < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(n));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, r, s = this.mode) {
    return this.buffer ? s & Ne.ExcludeBuffers ? !1 : this.enterChild(1, e, r) : this.yield(this._tree.enter(e, r, s));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Ne.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Ne.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: r } = this.buffer, s = this.stack.length - 1;
    if (e < 0) {
      let i = s < 0 ? 0 : this.stack[s] + 4;
      if (this.index != i)
        return this.yieldBuf(r.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = r.buffer[this.index + 3];
      if (i < (s < 0 ? r.buffer.length : r.buffer[this.stack[s] + 3]))
        return this.yieldBuf(i);
    }
    return s < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let r, s, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let n = 0; n < this.index; n++)
          if (i.buffer.buffer[n + 3] < this.index)
            return !1;
      ({ index: r, parent: s } = i);
    } else
      ({ index: r, _parent: s } = this._tree);
    for (; s; { index: r, _parent: s } = s)
      if (r > -1)
        for (let n = r + e, a = e < 0 ? -1 : s._tree.children.length; n != a; n += e) {
          let l = s._tree.children[n];
          if (this.mode & Ne.IncludeAnonymous || l instanceof ki || !l.type.isAnonymous || Og(l))
            return !1;
        }
    return !0;
  }
  move(e, r) {
    if (r && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, r = 0) {
    for (; (this.from == this.to || (r < 1 ? this.from >= e : this.from > e) || (r > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, r); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, r = null, s = 0;
    if (e && e.context == this.buffer)
      e: for (let i = this.index, n = this.stack.length; n >= 0; ) {
        for (let a = e; a; a = a._parent)
          if (a.index == i) {
            if (i == this.index)
              return a;
            r = a, s = n + 1;
            break e;
          }
        i = this.stack[--n];
      }
    for (let i = s; i < this.stack.length; i++)
      r = new is(this.buffer, r, this.stack[i]);
    return this.bufferNode = new is(this.buffer, r, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, r) {
    for (let s = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          s++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; ; ) {
        if (i && r && r(this), i = this.type.isAnonymous, !s)
          return;
        if (this.nextSibling())
          break;
        this.parent(), s--, i = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contexta sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return xf(this.node.parent, e);
    let { buffer: r } = this.buffer, { types: s } = r.set;
    for (let i = e.length - 1, n = this.stack.length - 1; i >= 0; n--) {
      if (n < 0)
        return xf(this._tree, e, i);
      let a = s[r.buffer[this.stack[n]]];
      if (!a.isAnonymous) {
        if (e[i] && e[i] != a.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function Og(t) {
  return t.children.some((e) => e instanceof ki || !e.type.isAnonymous || Og(e));
}
function LR(t) {
  var e;
  let { buffer: r, nodeSet: s, maxBufferLength: i = Kw, reused: n = [], minRepeatType: a = s.types.length } = t, l = Array.isArray(r) ? new yg(r, r.length) : r, c = s.types, p = 0, d = 0;
  function m(F, $, N, _, W, V) {
    let { id: j, start: B, end: U, size: oe } = l, he = d, Re = p;
    for (; oe < 0; )
      if (l.next(), oe == -1) {
        let ct = n[j];
        N.push(ct), _.push(B - F);
        return;
      } else if (oe == -3) {
        p = j;
        return;
      } else if (oe == -4) {
        d = j;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${oe}`);
    let $e = c[j], ft, le, ve = B - F;
    if (U - B <= i && (le = w(l.pos - $, W))) {
      let ct = new Uint16Array(le.size - le.skip), qe = l.pos - le.size, it = ct.length;
      for (; l.pos > qe; )
        it = C(le.start, ct, it);
      ft = new ki(ct, U - le.start, s), ve = le.start - F;
    } else {
      let ct = l.pos - oe;
      l.next();
      let qe = [], it = [], Kt = j >= a ? j : -1, er = 0, zr = U;
      for (; l.pos > ct; )
        Kt >= 0 && l.id == Kt && l.size >= 0 ? (l.end <= zr - i && (x(qe, it, B, er, l.end, zr, Kt, he, Re), er = qe.length, zr = l.end), l.next()) : V > 2500 ? y(B, ct, qe, it) : m(B, ct, qe, it, Kt, V + 1);
      if (Kt >= 0 && er > 0 && er < qe.length && x(qe, it, B, er, B, zr, Kt, he, Re), qe.reverse(), it.reverse(), Kt > -1 && er > 0) {
        let Pr = g($e, Re);
        ft = xg($e, qe, it, 0, qe.length, 0, U - B, Pr, Pr);
      } else
        ft = v($e, qe, it, U - B, he - U, Re);
    }
    N.push(ft), _.push(ve);
  }
  function y(F, $, N, _) {
    let W = [], V = 0, j = -1;
    for (; l.pos > $; ) {
      let { id: B, start: U, end: oe, size: he } = l;
      if (he > 4)
        l.next();
      else {
        if (j > -1 && U < j)
          break;
        j < 0 && (j = oe - i), W.push(B, U, oe), V++, l.next();
      }
    }
    if (V) {
      let B = new Uint16Array(V * 4), U = W[W.length - 2];
      for (let oe = W.length - 3, he = 0; oe >= 0; oe -= 3)
        B[he++] = W[oe], B[he++] = W[oe + 1] - U, B[he++] = W[oe + 2] - U, B[he++] = he;
      N.push(new ki(B, W[2] - U, s)), _.push(U - F);
    }
  }
  function g(F, $) {
    return (N, _, W) => {
      let V = 0, j = N.length - 1, B, U;
      if (j >= 0 && (B = N[j]) instanceof Ze) {
        if (!j && B.type == F && B.length == W)
          return B;
        (U = B.prop(ge.lookAhead)) && (V = _[j] + B.length + U);
      }
      return v(F, N, _, W, V, $);
    };
  }
  function x(F, $, N, _, W, V, j, B, U) {
    let oe = [], he = [];
    for (; F.length > _; )
      oe.push(F.pop()), he.push($.pop() + N - W);
    F.push(v(s.types[j], oe, he, V - W, B - V, U)), $.push(W - N);
  }
  function v(F, $, N, _, W, V, j) {
    if (V) {
      let B = [ge.contextHash, V];
      j = j ? [B].concat(j) : [B];
    }
    if (W > 25) {
      let B = [ge.lookAhead, W];
      j = j ? [B].concat(j) : [B];
    }
    return new Ze(F, $, N, _, j);
  }
  function w(F, $) {
    let N = l.fork(), _ = 0, W = 0, V = 0, j = N.end - i, B = { size: 0, start: 0, skip: 0 };
    e: for (let U = N.pos - F; N.pos > U; ) {
      let oe = N.size;
      if (N.id == $ && oe >= 0) {
        B.size = _, B.start = W, B.skip = V, V += 4, _ += 4, N.next();
        continue;
      }
      let he = N.pos - oe;
      if (oe < 0 || he < U || N.start < j)
        break;
      let Re = N.id >= a ? 4 : 0, $e = N.start;
      for (N.next(); N.pos > he; ) {
        if (N.size < 0)
          if (N.size == -3)
            Re += 4;
          else
            break e;
        else N.id >= a && (Re += 4);
        N.next();
      }
      W = $e, _ += oe, V += Re;
    }
    return ($ < 0 || _ == F) && (B.size = _, B.start = W, B.skip = V), B.size > 4 ? B : void 0;
  }
  function C(F, $, N) {
    let { id: _, start: W, end: V, size: j } = l;
    if (l.next(), j >= 0 && _ < a) {
      let B = N;
      if (j > 4) {
        let U = l.pos - (j - 4);
        for (; l.pos > U; )
          N = C(F, $, N);
      }
      $[--N] = B, $[--N] = V - F, $[--N] = W - F, $[--N] = _;
    } else j == -3 ? p = _ : j == -4 && (d = _);
    return N;
  }
  let b = [], k = [];
  for (; l.pos > 0; )
    m(t.start || 0, t.bufferStart || 0, b, k, -1, 0);
  let Q = (e = t.length) !== null && e !== void 0 ? e : b.length ? k[0] + b[0].length : 0;
  return new Ze(c[t.topID], b.reverse(), k.reverse(), Q);
}
const M1 = /* @__PURE__ */ new WeakMap();
function Zu(t, e) {
  if (!t.isAnonymous || e instanceof ki || e.type != t)
    return 1;
  let r = M1.get(e);
  if (r == null) {
    r = 1;
    for (let s of e.children) {
      if (s.type != t || !(s instanceof Ze)) {
        r = 1;
        break;
      }
      r += Zu(t, s);
    }
    M1.set(e, r);
  }
  return r;
}
function xg(t, e, r, s, i, n, a, l, c) {
  let p = 0;
  for (let x = s; x < i; x++)
    p += Zu(t, e[x]);
  let d = Math.ceil(
    p * 1.5 / 8
    /* Balance.BranchFactor */
  ), m = [], y = [];
  function g(x, v, w, C, b) {
    for (let k = w; k < C; ) {
      let Q = k, F = v[k], $ = Zu(t, x[k]);
      for (k++; k < C; k++) {
        let N = Zu(t, x[k]);
        if ($ + N >= d)
          break;
        $ += N;
      }
      if (k == Q + 1) {
        if ($ > d) {
          let N = x[Q];
          g(N.children, N.positions, 0, N.children.length, v[Q] + b);
          continue;
        }
        m.push(x[Q]);
      } else {
        let N = v[k - 1] + x[k - 1].length - F;
        m.push(xg(t, x, v, Q, k, F, N, null, c));
      }
      y.push(F + b - n);
    }
  }
  return g(e, r, s, i, 0), (l || c)(m, y, a);
}
class sA {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, r, s) {
    let i = this.map.get(e);
    i || this.map.set(e, i = /* @__PURE__ */ new Map()), i.set(r, s);
  }
  getBuffer(e, r) {
    let s = this.map.get(e);
    return s && s.get(r);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, r) {
    e instanceof is ? this.setBuffer(e.context.buffer, e.index, r) : e instanceof kt && this.map.set(e.tree, r);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof is ? this.getBuffer(e.context.buffer, e.index) : e instanceof kt ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, r) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, r) : this.map.set(e.tree, r);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class Fs {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, r, s, i, n = !1, a = !1) {
    this.from = e, this.to = r, this.tree = s, this.offset = i, this.open = (n ? 1 : 0) | (a ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, r = [], s = !1) {
    let i = [new Fs(0, e.length, e, 0, !1, s)];
    for (let n of r)
      n.to > e.length && i.push(n);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, r, s = 128) {
    if (!r.length)
      return e;
    let i = [], n = 1, a = e.length ? e[0] : null;
    for (let l = 0, c = 0, p = 0; ; l++) {
      let d = l < r.length ? r[l] : null, m = d ? d.fromA : 1e9;
      if (m - c >= s)
        for (; a && a.from < m; ) {
          let y = a;
          if (c >= y.from || m <= y.to || p) {
            let g = Math.max(y.from, c) - p, x = Math.min(y.to, m) - p;
            y = g >= x ? null : new Fs(g, x, y.tree, y.offset + p, l > 0, !!d);
          }
          if (y && i.push(y), a.to > m)
            break;
          a = n < e.length ? e[n++] : null;
        }
      if (!d)
        break;
      c = d.toA, p = d.toA - d.toB;
    }
    return i;
  }
}
class iA {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, r, s) {
    return typeof e == "string" && (e = new _R(e)), s = s ? s.length ? s.map((i) => new Dr(i.from, i.to)) : [new Dr(0, 0)] : [new Dr(0, e.length)], this.createParse(e, r || [], s);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, r, s) {
    let i = this.startParse(e, r, s);
    for (; ; ) {
      let n = i.advance();
      if (n)
        return n;
    }
  }
}
class _R {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, r) {
    return this.string.slice(e, r);
  }
}
function RR(t) {
  return (e, r, s, i) => new jR(e, t, r, s, i);
}
class L1 {
  constructor(e, r, s, i, n) {
    this.parser = e, this.parse = r, this.overlay = s, this.target = i, this.from = n;
  }
}
function _1(t) {
  if (!t.length || t.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(t));
}
class qR {
  constructor(e, r, s, i, n, a, l) {
    this.parser = e, this.predicate = r, this.mounts = s, this.index = i, this.start = n, this.target = a, this.prev = l, this.depth = 0, this.ranges = [];
  }
}
const Df = new ge({ perNode: !0 });
class jR {
  constructor(e, r, s, i, n) {
    this.nest = r, this.input = s, this.fragments = i, this.ranges = n, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let s = this.baseParse.advance();
      if (!s)
        return null;
      if (this.baseParse = null, this.baseTree = s, this.startInner(), this.stoppedAt != null)
        for (let i of this.inner)
          i.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let s = this.baseTree;
      return this.stoppedAt != null && (s = new Ze(s.type, s.children, s.positions, s.length, s.propValues.concat([[Df, this.stoppedAt]]))), s;
    }
    let e = this.inner[this.innerDone], r = e.parse.advance();
    if (r) {
      this.innerDone++;
      let s = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      s[ge.mounted.id] = new Ho(r, e.overlay, e.parser), e.target.props = s;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let r = this.innerDone; r < this.inner.length; r++)
      this.inner[r].from < e && (e = Math.min(e, this.inner[r].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let r = this.innerDone; r < this.inner.length; r++)
        this.inner[r].parse.stopAt(e);
  }
  startInner() {
    let e = new VR(this.fragments), r = null, s = null, i = new xc(new kt(this.baseTree, this.ranges[0].from, 0, null), Ne.IncludeAnonymous | Ne.IgnoreMounts);
    e: for (let n, a; ; ) {
      let l = !0, c;
      if (this.stoppedAt != null && i.from >= this.stoppedAt)
        l = !1;
      else if (e.hasNode(i)) {
        if (r) {
          let p = r.mounts.find((d) => d.frag.from <= i.from && d.frag.to >= i.to && d.mount.overlay);
          if (p)
            for (let d of p.mount.overlay) {
              let m = d.from + p.pos, y = d.to + p.pos;
              m >= i.from && y <= i.to && !r.ranges.some((g) => g.from < y && g.to > m) && r.ranges.push({ from: m, to: y });
            }
        }
        l = !1;
      } else if (s && (a = XR(s.ranges, i.from, i.to)))
        l = a != 2;
      else if (!i.type.isAnonymous && (n = this.nest(i, this.input)) && (i.from < i.to || !n.overlay)) {
        i.tree || ZR(i);
        let p = e.findMounts(i.from, n.parser);
        if (typeof n.overlay == "function")
          r = new qR(n.parser, n.overlay, p, this.inner.length, i.from, i.tree, r);
        else {
          let d = j1(this.ranges, n.overlay || (i.from < i.to ? [new Dr(i.from, i.to)] : []));
          d.length && _1(d), (d.length || !n.overlay) && this.inner.push(new L1(n.parser, d.length ? n.parser.startParse(this.input, X1(p, d), d) : n.parser.startParse(""), n.overlay ? n.overlay.map((m) => new Dr(m.from - i.from, m.to - i.from)) : null, i.tree, d.length ? d[0].from : i.from)), n.overlay ? d.length && (s = { ranges: d, depth: 0, prev: s }) : l = !1;
        }
      } else if (r && (c = r.predicate(i)) && (c === !0 && (c = new Dr(i.from, i.to)), c.from < c.to)) {
        let p = r.ranges.length - 1;
        p >= 0 && r.ranges[p].to == c.from ? r.ranges[p] = { from: r.ranges[p].from, to: c.to } : r.ranges.push(c);
      }
      if (l && i.firstChild())
        r && r.depth++, s && s.depth++;
      else
        for (; !i.nextSibling(); ) {
          if (!i.parent())
            break e;
          if (r && !--r.depth) {
            let p = j1(this.ranges, r.ranges);
            p.length && (_1(p), this.inner.splice(r.index, 0, new L1(r.parser, r.parser.startParse(this.input, X1(r.mounts, p), p), r.ranges.map((d) => new Dr(d.from - r.start, d.to - r.start)), r.target, p[0].from))), r = r.prev;
          }
          s && !--s.depth && (s = s.prev);
        }
    }
  }
}
function XR(t, e, r) {
  for (let s of t) {
    if (s.from >= r)
      break;
    if (s.to > e)
      return s.from <= e && s.to >= r ? 2 : 1;
  }
  return 0;
}
function R1(t, e, r, s, i, n) {
  if (e < r) {
    let a = t.buffer[e + 1];
    s.push(t.slice(e, r, a)), i.push(a - n);
  }
}
function ZR(t) {
  let { node: e } = t, r = [], s = e.context.buffer;
  do
    r.push(t.index), t.parent();
  while (!t.tree);
  let i = t.tree, n = i.children.indexOf(s), a = i.children[n], l = a.buffer, c = [n];
  function p(d, m, y, g, x, v) {
    let w = r[v], C = [], b = [];
    R1(a, d, w, C, b, g);
    let k = l[w + 1], Q = l[w + 2];
    c.push(C.length);
    let F = v ? p(w + 4, l[w + 3], a.set.types[l[w]], k, Q - k, v - 1) : e.toTree();
    return C.push(F), b.push(k - g), R1(a, l[w + 3], m, C, b, g), new Ze(y, C, b, x);
  }
  i.children[n] = p(0, l.length, _t.none, 0, a.length, r.length - 1);
  for (let d of c) {
    let m = t.tree.children[d], y = t.tree.positions[d];
    t.yield(new kt(m, y + t.from, d, t._tree));
  }
}
class q1 {
  constructor(e, r) {
    this.offset = r, this.done = !1, this.cursor = e.cursor(Ne.IncludeAnonymous | Ne.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: r } = this, s = e - this.offset;
    for (; !this.done && r.from < s; )
      r.to >= e && r.enter(s, 1, Ne.IgnoreOverlays | Ne.ExcludeBuffers) || r.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let r = this.cursor.tree; ; ) {
        if (r == e.tree)
          return !0;
        if (r.children.length && r.positions[0] == 0 && r.children[0] instanceof Ze)
          r = r.children[0];
        else
          break;
      }
    return !1;
  }
}
let VR = class {
  constructor(t) {
    var e;
    if (this.fragments = t, this.curTo = 0, this.fragI = 0, t.length) {
      let r = this.curFrag = t[0];
      this.curTo = (e = r.tree.prop(Df)) !== null && e !== void 0 ? e : r.to, this.inner = new q1(r.tree, -r.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(t) {
    for (; this.curFrag && t.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= t.from && this.curTo >= t.to && this.inner.hasNode(t);
  }
  nextFrag() {
    var t;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let e = this.curFrag = this.fragments[this.fragI];
      this.curTo = (t = e.tree.prop(Df)) !== null && t !== void 0 ? t : e.to, this.inner = new q1(e.tree, -e.offset);
    }
  }
  findMounts(t, e) {
    var r;
    let s = [];
    if (this.inner) {
      this.inner.cursor.moveTo(t, 1);
      for (let i = this.inner.cursor.node; i; i = i.parent) {
        let n = (r = i.tree) === null || r === void 0 ? void 0 : r.prop(ge.mounted);
        if (n && n.parser == e)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let l = this.fragments[a];
            if (l.from >= i.to)
              break;
            l.tree == this.curFrag.tree && s.push({
              frag: l,
              pos: i.from - l.offset,
              mount: n
            });
          }
      }
    }
    return s;
  }
};
function j1(t, e) {
  let r = null, s = e;
  for (let i = 1, n = 0; i < t.length; i++) {
    let a = t[i - 1].to, l = t[i].from;
    for (; n < s.length; n++) {
      let c = s[n];
      if (c.from >= l)
        break;
      c.to <= a || (r || (s = r = e.slice()), c.from < a ? (r[n] = new Dr(c.from, a), c.to > l && r.splice(n + 1, 0, new Dr(l, c.to))) : c.to > l ? r[n--] = new Dr(l, c.to) : r.splice(n--, 1));
    }
  }
  return s;
}
function zR(t, e, r, s) {
  let i = 0, n = 0, a = !1, l = !1, c = -1e9, p = [];
  for (; ; ) {
    let d = i == t.length ? 1e9 : a ? t[i].to : t[i].from, m = n == e.length ? 1e9 : l ? e[n].to : e[n].from;
    if (a != l) {
      let y = Math.max(c, r), g = Math.min(d, m, s);
      y < g && p.push(new Dr(y, g));
    }
    if (c = Math.min(d, m), c == 1e9)
      break;
    d == c && (a ? (a = !1, i++) : a = !0), m == c && (l ? (l = !1, n++) : l = !0);
  }
  return p;
}
function X1(t, e) {
  let r = [];
  for (let { pos: s, mount: i, frag: n } of t) {
    let a = s + (i.overlay ? i.overlay[0].from : 0), l = a + i.tree.length, c = Math.max(n.from, a), p = Math.min(n.to, l);
    if (i.overlay) {
      let d = i.overlay.map((y) => new Dr(y.from + s, y.to + s)), m = zR(e, d, c, p);
      for (let y = 0, g = c; ; y++) {
        let x = y == m.length, v = x ? p : m[y].from;
        if (v > g && r.push(new Fs(g, v, i.tree, -a, n.from >= g || n.openStart, n.to <= v || n.openEnd)), x)
          break;
        g = m[y].to;
      }
    } else
      r.push(new Fs(c, p, i.tree, -a, n.from >= a || n.openStart, n.to <= l || n.openEnd));
  }
  return r;
}
let UR = 0;
class yr {
  /**
  @internal
  */
  constructor(e, r, s, i) {
    this.name = e, this.set = r, this.base = s, this.modified = i, this.id = UR++;
  }
  toString() {
    let { name: e } = this;
    for (let r of this.modified)
      r.name && (e = `${r.name}(${e})`);
    return e;
  }
  static define(e, r) {
    let s = typeof e == "string" ? e : "?";
    if (e instanceof yr && (r = e), r != null && r.base)
      throw new Error("Can not derive from a modified tag");
    let i = new yr(s, [], null, []);
    if (i.set.push(i), r)
      for (let n of r.set)
        i.set.push(n);
    return i;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(e) {
    let r = new Dc(e);
    return (s) => s.modified.indexOf(r) > -1 ? s : Dc.get(s.base || s, s.modified.concat(r).sort((i, n) => i.id - n.id));
  }
}
let YR = 0;
class Dc {
  constructor(e) {
    this.name = e, this.instances = [], this.id = YR++;
  }
  static get(e, r) {
    if (!r.length)
      return e;
    let s = r[0].instances.find((l) => l.base == e && WR(r, l.modified));
    if (s)
      return s;
    let i = [], n = new yr(e.name, i, e, r);
    for (let l of r)
      l.instances.push(n);
    let a = GR(r);
    for (let l of e.set)
      if (!l.modified.length)
        for (let c of a)
          i.push(Dc.get(l, c));
    return n;
  }
}
function WR(t, e) {
  return t.length == e.length && t.every((r, s) => r == e[s]);
}
function GR(t) {
  let e = [[]];
  for (let r = 0; r < t.length; r++)
    for (let s = 0, i = e.length; s < i; s++)
      e.push(e[s].concat(t[r]));
  return e.sort((r, s) => s.length - r.length);
}
function xh(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let s = t[r];
    Array.isArray(s) || (s = [s]);
    for (let i of r.split(" "))
      if (i) {
        let n = [], a = 2, l = i;
        for (let m = 0; ; ) {
          if (l == "..." && m > 0 && m + 3 == i.length) {
            a = 1;
            break;
          }
          let y = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(l);
          if (!y)
            throw new RangeError("Invalid path: " + i);
          if (n.push(y[0] == "*" ? "" : y[0][0] == '"' ? JSON.parse(y[0]) : y[0]), m += y[0].length, m == i.length)
            break;
          let g = i[m++];
          if (m == i.length && g == "!") {
            a = 0;
            break;
          }
          if (g != "/")
            throw new RangeError("Invalid path: " + i);
          l = i.slice(m);
        }
        let c = n.length - 1, p = n[c];
        if (!p)
          throw new RangeError("Invalid path: " + i);
        let d = new bc(s, a, c > 0 ? n.slice(0, c) : null);
        e[p] = d.sort(e[p]);
      }
  }
  return nA.add(e);
}
const nA = new ge();
class bc {
  constructor(e, r, s, i) {
    this.tags = e, this.mode = r, this.context = s, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
bc.empty = new bc([], 2, null);
function aA(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let n of t)
    if (!Array.isArray(n.tag))
      r[n.tag.id] = n.class;
    else
      for (let a of n.tag)
        r[a.id] = n.class;
  let { scope: s, all: i = null } = e || {};
  return {
    style: (n) => {
      let a = i;
      for (let l of n)
        for (let c of l.set) {
          let p = r[c.id];
          if (p) {
            a = a ? a + " " + p : p;
            break;
          }
        }
      return a;
    },
    scope: s
  };
}
function HR(t, e) {
  let r = null;
  for (let s of t) {
    let i = s.style(e);
    i && (r = r ? r + " " + i : i);
  }
  return r;
}
function JR(t, e, r, s = 0, i = t.length) {
  let n = new KR(s, Array.isArray(e) ? e : [e], r);
  n.highlightRange(t.cursor(), s, i, "", n.highlighters), n.flush(i);
}
class KR {
  constructor(e, r, s) {
    this.at = e, this.highlighters = r, this.span = s, this.class = "";
  }
  startSpan(e, r) {
    r != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = r);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, r, s, i, n) {
    let { type: a, from: l, to: c } = e;
    if (l >= s || c <= r)
      return;
    a.isTop && (n = this.highlighters.filter((g) => !g.scope || g.scope(a)));
    let p = i, d = eq(e) || bc.empty, m = HR(n, d.tags);
    if (m && (p && (p += " "), p += m, d.mode == 1 && (i += (i ? " " : "") + m)), this.startSpan(Math.max(r, l), p), d.opaque)
      return;
    let y = e.tree && e.tree.prop(ge.mounted);
    if (y && y.overlay) {
      let g = e.node.enter(y.overlay[0].from + l, 1), x = this.highlighters.filter((w) => !w.scope || w.scope(y.tree.type)), v = e.firstChild();
      for (let w = 0, C = l; ; w++) {
        let b = w < y.overlay.length ? y.overlay[w] : null, k = b ? b.from + l : c, Q = Math.max(r, C), F = Math.min(s, k);
        if (Q < F && v)
          for (; e.from < F && (this.highlightRange(e, Q, F, i, n), this.startSpan(Math.min(F, e.to), p), !(e.to >= k || !e.nextSibling())); )
            ;
        if (!b || k > s)
          break;
        C = b.to + l, C > r && (this.highlightRange(g.cursor(), Math.max(r, b.from + l), Math.min(s, C), "", x), this.startSpan(Math.min(s, C), p));
      }
      v && e.parent();
    } else if (e.firstChild()) {
      y && (i = "");
      do
        if (!(e.to <= r)) {
          if (e.from >= s)
            break;
          this.highlightRange(e, r, s, i, n), this.startSpan(Math.min(s, e.to), p);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function eq(t) {
  let e = t.type.prop(nA);
  for (; e && e.context && !t.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const G = yr.define, yu = G(), ci = G(), Z1 = G(ci), V1 = G(ci), hi = G(), Ou = G(hi), Qp = G(hi), Jr = G(), qi = G(Jr), Yr = G(), Wr = G(), bf = G(), so = G(bf), xu = G(), T = {
  /**
  A comment.
  */
  comment: yu,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: G(yu),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: G(yu),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: G(yu),
  /**
  Any kind of identifier.
  */
  name: ci,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: G(ci),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: Z1,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: G(Z1),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: V1,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: G(V1),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: G(ci),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: G(ci),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: G(ci),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: G(ci),
  /**
  A literal value.
  */
  literal: hi,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Ou,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: G(Ou),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: G(Ou),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: G(Ou),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: Qp,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: G(Qp),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: G(Qp),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: G(hi),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: G(hi),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: G(hi),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: G(hi),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: G(hi),
  /**
  A language keyword.
  */
  keyword: Yr,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: G(Yr),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: G(Yr),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: G(Yr),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: G(Yr),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: G(Yr),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: G(Yr),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: G(Yr),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: G(Yr),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: G(Yr),
  /**
  An operator.
  */
  operator: Wr,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: G(Wr),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: G(Wr),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: G(Wr),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: G(Wr),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: G(Wr),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: G(Wr),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: G(Wr),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: G(Wr),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: G(Wr),
  /**
  Program or markup punctuation.
  */
  punctuation: bf,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: G(bf),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: so,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: G(so),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: G(so),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: G(so),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: G(so),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Jr,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: qi,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: G(qi),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: G(qi),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: G(qi),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: G(qi),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: G(qi),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: G(qi),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: G(Jr),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: G(Jr),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: G(Jr),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: G(Jr),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: G(Jr),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: G(Jr),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: G(Jr),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: G(Jr),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: G(),
  /**
  Deleted text.
  */
  deleted: G(),
  /**
  Changed text.
  */
  changed: G(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: G(),
  /**
  Metadata or meta-instruction.
  */
  meta: xu,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: G(xu),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: G(xu),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: G(xu),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: yr.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: yr.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: yr.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: yr.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: yr.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: yr.defineModifier("special")
};
for (let t in T) {
  let e = T[t];
  e instanceof yr && (e.name = t);
}
aA([
  { tag: T.link, class: "tok-link" },
  { tag: T.heading, class: "tok-heading" },
  { tag: T.emphasis, class: "tok-emphasis" },
  { tag: T.strong, class: "tok-strong" },
  { tag: T.keyword, class: "tok-keyword" },
  { tag: T.atom, class: "tok-atom" },
  { tag: T.bool, class: "tok-bool" },
  { tag: T.url, class: "tok-url" },
  { tag: T.labelName, class: "tok-labelName" },
  { tag: T.inserted, class: "tok-inserted" },
  { tag: T.deleted, class: "tok-deleted" },
  { tag: T.literal, class: "tok-literal" },
  { tag: T.string, class: "tok-string" },
  { tag: T.number, class: "tok-number" },
  { tag: [T.regexp, T.escape, T.special(T.string)], class: "tok-string2" },
  { tag: T.variableName, class: "tok-variableName" },
  { tag: T.local(T.variableName), class: "tok-variableName tok-local" },
  { tag: T.definition(T.variableName), class: "tok-variableName tok-definition" },
  { tag: T.special(T.variableName), class: "tok-variableName2" },
  { tag: T.definition(T.propertyName), class: "tok-propertyName tok-definition" },
  { tag: T.typeName, class: "tok-typeName" },
  { tag: T.namespace, class: "tok-namespace" },
  { tag: T.className, class: "tok-className" },
  { tag: T.macroName, class: "tok-macroName" },
  { tag: T.propertyName, class: "tok-propertyName" },
  { tag: T.operator, class: "tok-operator" },
  { tag: T.comment, class: "tok-comment" },
  { tag: T.meta, class: "tok-meta" },
  { tag: T.invalid, class: "tok-invalid" },
  { tag: T.punctuation, class: "tok-punctuation" }
]);
var Bp;
const Yn = /* @__PURE__ */ new ge();
function oA(t) {
  return re.define({
    combine: t ? (e) => e.concat(t) : void 0
  });
}
const Dg = /* @__PURE__ */ new ge();
class Lr {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, r, s = [], i = "") {
    this.data = e, this.name = i, we.prototype.hasOwnProperty("tree") || Object.defineProperty(we.prototype, "tree", { get() {
      return Ue(this);
    } }), this.parser = r, this.extension = [
      Pi.of(this),
      we.languageData.of((n, a, l) => {
        let c = z1(n, a, l), p = c.type.prop(Yn);
        if (!p)
          return [];
        let d = n.facet(p), m = c.type.prop(Dg);
        if (m) {
          let y = c.resolve(a - c.from, l);
          for (let g of m)
            if (g.test(y, n)) {
              let x = n.facet(g.facet);
              return g.type == "replace" ? x : x.concat(d);
            }
        }
        return d;
      })
    ].concat(s);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, r, s = -1) {
    return z1(e, r, s).type.prop(Yn) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let r = e.facet(Pi);
    if ((r == null ? void 0 : r.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!r || !r.allowsNesting)
      return [];
    let s = [], i = (n, a) => {
      if (n.prop(Yn) == this.data) {
        s.push({ from: a, to: a + n.length });
        return;
      }
      let l = n.prop(ge.mounted);
      if (l) {
        if (l.tree.prop(Yn) == this.data) {
          if (l.overlay)
            for (let c of l.overlay)
              s.push({ from: c.from + a, to: c.to + a });
          else
            s.push({ from: a, to: a + n.length });
          return;
        } else if (l.overlay) {
          let c = s.length;
          if (i(l.tree, l.overlay[0].from + a), s.length > c)
            return;
        }
      }
      for (let c = 0; c < n.children.length; c++) {
        let p = n.children[c];
        p instanceof Ze && i(p, n.positions[c] + a);
      }
    };
    return i(Ue(e), 0), s;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
Lr.setState = /* @__PURE__ */ pe.define();
function z1(t, e, r) {
  let s = t.facet(Pi), i = Ue(t).topNode;
  if (!s || s.allowsNesting)
    for (let n = i; n; n = n.enter(e, r, Ne.ExcludeBuffers))
      n.type.isTop && (i = n);
  return i;
}
class ya extends Lr {
  constructor(e, r, s) {
    super(e, r, [], s), this.parser = r;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let r = oA(e.languageData);
    return new ya(r, e.parser.configure({
      props: [Yn.add((s) => s.isTop ? r : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, r) {
    return new ya(this.data, this.parser.configure(e), r || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function Ue(t) {
  let e = t.field(Lr.state, !1);
  return e ? e.tree : Ze.empty;
}
class tq {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, r) {
    let s = this.cursorPos - this.string.length;
    return e < s || r >= this.cursorPos ? this.doc.sliceString(e, r) : this.string.slice(e - s, r - s);
  }
}
let io = null;
class vc {
  constructor(e, r, s = [], i, n, a, l, c) {
    this.parser = e, this.state = r, this.fragments = s, this.tree = i, this.treeLen = n, this.viewport = a, this.skipped = l, this.scheduleOn = c, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, r, s) {
    return new vc(e, r, [], Ze.empty, 0, s, [], null);
  }
  startParse() {
    return this.parser.startParse(new tq(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, r) {
    return r != null && r >= this.state.doc.length && (r = void 0), this.tree != Ze.empty && this.isDone(r != null ? r : this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var s;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), r != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > r) && r < this.state.doc.length && this.parse.stopAt(r); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(Fs.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (s = this.parse.stoppedAt) !== null && s !== void 0 ? s : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (r != null ? r : this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, r;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(r = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = r, this.fragments = this.withoutTempSkipped(Fs.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let r = io;
    io = this;
    try {
      return e();
    } finally {
      io = r;
    }
  }
  withoutTempSkipped(e) {
    for (let r; r = this.tempSkipped.pop(); )
      e = U1(e, r.from, r.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, r) {
    let { fragments: s, tree: i, treeLen: n, viewport: a, skipped: l } = this;
    if (this.takeTree(), !e.empty) {
      let c = [];
      if (e.iterChangedRanges((p, d, m, y) => c.push({ fromA: p, toA: d, fromB: m, toB: y })), s = Fs.applyChanges(s, c), i = Ze.empty, n = 0, a = { from: e.mapPos(a.from, -1), to: e.mapPos(a.to, 1) }, this.skipped.length) {
        l = [];
        for (let p of this.skipped) {
          let d = e.mapPos(p.from, 1), m = e.mapPos(p.to, -1);
          d < m && l.push({ from: d, to: m });
        }
      }
    }
    return new vc(this.parser, r, s, i, n, a, l, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let r = this.skipped.length;
    for (let s = 0; s < this.skipped.length; s++) {
      let { from: i, to: n } = this.skipped[s];
      i < e.to && n > e.from && (this.fragments = U1(this.fragments, i, n), this.skipped.splice(s--, 1));
    }
    return this.skipped.length >= r ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, r) {
    this.skipped.push({ from: e, to: r });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends iA {
      createParse(r, s, i) {
        let n = i[0].from, a = i[i.length - 1].to;
        return {
          parsedPos: n,
          advance() {
            let l = io;
            if (l) {
              for (let c of i)
                l.tempSkipped.push(c);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = a, new Ze(_t.none, [], [], a - n);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let r = this.fragments;
    return this.treeLen >= e && r.length && r[0].from == 0 && r[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return io;
  }
}
function U1(t, e, r) {
  return Fs.applyChanges(t, [{ fromA: e, toA: r, fromB: e, toB: r }]);
}
class Oa {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let r = this.context.changes(e.changes, e.state), s = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), r.viewport.to);
    return r.work(20, s) || r.takeTree(), new Oa(r);
  }
  static init(e) {
    let r = Math.min(3e3, e.doc.length), s = vc.create(e.facet(Pi).parser, e, { from: 0, to: r });
    return s.work(20, r) || s.takeTree(), new Oa(s);
  }
}
Lr.state = /* @__PURE__ */ ut.define({
  create: Oa.init,
  update(t, e) {
    for (let r of e.effects)
      if (r.is(Lr.setState))
        return r.value;
    return e.startState.facet(Pi) != e.state.facet(Pi) ? Oa.init(e.state) : t.apply(e);
  }
});
let lA = (t) => {
  let e = setTimeout(
    () => t(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback != "undefined" && (lA = (t) => {
  let e = -1, r = setTimeout(
    () => {
      e = requestIdleCallback(t, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(r) : cancelIdleCallback(e);
});
const Ip = typeof navigator != "undefined" && !((Bp = navigator.scheduling) === null || Bp === void 0) && Bp.isInputPending ? () => navigator.scheduling.isInputPending() : null, rq = /* @__PURE__ */ st.fromClass(class {
  constructor(t) {
    this.view = t, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(t) {
    let e = this.view.state.field(Lr.state).context;
    (e.updateViewport(t.view.viewport) || this.view.viewport.to > e.treeLen) && this.scheduleWork(), (t.docChanged || t.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(e);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: t } = this.view, e = t.field(Lr.state);
    (e.tree != e.context.tree || !e.context.isDone(t.doc.length)) && (this.working = lA(this.work));
  }
  work(t) {
    this.working = null;
    let e = Date.now();
    if (this.chunkEnd < e && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = e + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: s } } = this.view, i = r.field(Lr.state);
    if (i.tree == i.context.tree && i.context.isDone(
      s + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let n = Date.now() + Math.min(this.chunkBudget, 100, t && !Ip ? Math.max(25, t.timeRemaining() - 5) : 1e9), a = i.context.treeLen < s && r.doc.length > s + 1e3, l = i.context.work(() => Ip && Ip() || Date.now() > n, s + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - e, (l || this.chunkBudget <= 0) && (i.context.takeTree(), this.view.dispatch({ effects: Lr.setState.of(new Oa(i.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(i.context);
  }
  checkAsyncSchedule(t) {
    t.scheduleOn && (this.workScheduled++, t.scheduleOn.then(() => this.scheduleWork()).catch((e) => Ut(this.view.state, e)).then(() => this.workScheduled--), t.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Pi = /* @__PURE__ */ re.define({
  combine(t) {
    return t.length ? t[0] : null;
  },
  enables: (t) => [
    Lr.state,
    rq,
    J.contentAttributes.compute([t], (e) => {
      let r = e.facet(t);
      return r && r.name ? { "data-language": r.name } : {};
    })
  ]
});
class bg {
  /**
  Create a language support object.
  */
  constructor(e, r = []) {
    this.language = e, this.support = r, this.extension = [e, r];
  }
}
const sq = /* @__PURE__ */ re.define(), Dh = /* @__PURE__ */ re.define({
  combine: (t) => {
    if (!t.length)
      return "  ";
    let e = t[0];
    if (!e || /\S/.test(e) || Array.from(e).some((r) => r != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
    return e;
  }
});
function Sc(t) {
  let e = t.facet(Dh);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function Ko(t, e) {
  let r = "", s = t.tabSize, i = t.facet(Dh)[0];
  if (i == "	") {
    for (; e >= s; )
      r += "	", e -= s;
    i = " ";
  }
  for (let n = 0; n < e; n++)
    r += i;
  return r;
}
function vg(t, e) {
  t instanceof we && (t = new bh(t));
  for (let s of t.state.facet(sq)) {
    let i = s(t, e);
    if (i !== void 0)
      return i;
  }
  let r = Ue(t.state);
  return r.length >= e ? iq(t, r, e) : null;
}
class bh {
  /**
  Create an indent context.
  */
  constructor(e, r = {}) {
    this.state = e, this.options = r, this.unit = Sc(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, r = 1) {
    let s = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: n } = this.options;
    return i != null && i >= s.from && i <= s.to ? n && i == e ? { text: "", from: e } : (r < 0 ? i < e : i <= e) ? { text: s.text.slice(i - s.from), from: i } : { text: s.text.slice(0, i - s.from), from: s.from } : s;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, r = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: s, from: i } = this.lineAt(e, r);
    return s.slice(e - i, Math.min(s.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, r = 1) {
    let { text: s, from: i } = this.lineAt(e, r), n = this.countColumn(s, e - i), a = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return a > -1 && (n += a - this.countColumn(s, s.search(/\S|$/))), n;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, r = e.length) {
    return Ma(e, this.state.tabSize, r);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, r = 1) {
    let { text: s, from: i } = this.lineAt(e, r), n = this.options.overrideIndentation;
    if (n) {
      let a = n(i);
      if (a > -1)
        return a;
    }
    return this.countColumn(s, s.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const vh = /* @__PURE__ */ new ge();
function iq(t, e, r) {
  let s = e.resolveStack(r), i = e.resolveInner(r, -1).resolve(r, 0).enterUnfinishedNodesBefore(r);
  if (i != s.node) {
    let n = [];
    for (let a = i; a && !(a.from < s.node.from || a.to > s.node.to || a.from == s.node.from && a.type == s.node.type); a = a.parent)
      n.push(a);
    for (let a = n.length - 1; a >= 0; a--)
      s = { node: n[a], next: s };
  }
  return uA(s, t, r);
}
function uA(t, e, r) {
  for (let s = t; s; s = s.next) {
    let i = aq(s.node);
    if (i)
      return i(Sg.create(e, r, s));
  }
  return 0;
}
function nq(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function aq(t) {
  let e = t.type.prop(vh);
  if (e)
    return e;
  let r = t.firstChild, s;
  if (r && (s = r.type.prop(ge.closedBy))) {
    let i = t.lastChild, n = i && s.indexOf(i.name) > -1;
    return (a) => cA(a, !0, 1, void 0, n && !nq(a) ? i.from : void 0);
  }
  return t.parent == null ? oq : null;
}
function oq() {
  return 0;
}
class Sg extends bh {
  constructor(e, r, s) {
    super(e.state, e.options), this.base = e, this.pos = r, this.context = s;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, r, s) {
    return new Sg(e, r, s);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let r = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let s = e.resolve(r.from);
      for (; s.parent && s.parent.from == s.from; )
        s = s.parent;
      if (lq(s, e))
        break;
      r = this.state.doc.lineAt(s.from);
    }
    return this.lineIndent(r.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return uA(this.context.next, this.base, this.pos);
  }
}
function lq(t, e) {
  for (let r = e; r; r = r.parent)
    if (t == r)
      return !0;
  return !1;
}
function uq(t) {
  let e = t.node, r = e.childAfter(e.from), s = e.lastChild;
  if (!r)
    return null;
  let i = t.options.simulateBreak, n = t.state.doc.lineAt(r.from), a = i == null || i <= n.from ? n.to : Math.min(n.to, i);
  for (let l = r.to; ; ) {
    let c = e.childAfter(l);
    if (!c || c == s)
      return null;
    if (!c.type.isSkipped) {
      if (c.from >= a)
        return null;
      let p = /^ */.exec(n.text.slice(r.to - n.from))[0].length;
      return { from: r.from, to: r.to + p };
    }
    l = c.to;
  }
}
function cq({ closing: t, align: e = !0, units: r = 1 }) {
  return (s) => cA(s, e, r, t);
}
function cA(t, e, r, s, i) {
  let n = t.textAfter, a = n.match(/^\s*/)[0].length, l = s && n.slice(a, a + s.length) == s || i == t.pos + a, c = e ? uq(t) : null;
  return c ? l ? t.column(c.from) : t.column(c.to) : t.baseIndent + (l ? 0 : t.unit * r);
}
const hq = (t) => t.baseIndent;
function Vu({ except: t, units: e = 1 } = {}) {
  return (r) => {
    let s = t && t.test(r.textAfter);
    return r.baseIndent + (s ? 0 : e * r.unit);
  };
}
const pq = 200;
function dq() {
  return we.transactionFilter.of((t) => {
    if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
      return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length)
      return t;
    let r = t.newDoc, { head: s } = t.newSelection.main, i = r.lineAt(s);
    if (s > i.from + pq)
      return t;
    let n = r.sliceString(i.from, s);
    if (!e.some((p) => p.test(n)))
      return t;
    let { state: a } = t, l = -1, c = [];
    for (let { head: p } of a.selection.ranges) {
      let d = a.doc.lineAt(p);
      if (d.from == l)
        continue;
      l = d.from;
      let m = vg(a, d.from);
      if (m == null)
        continue;
      let y = /^\s*/.exec(d.text)[0], g = Ko(a, m);
      y != g && c.push({ from: d.from, to: d.from + y.length, insert: g });
    }
    return c.length ? [t, { changes: c, sequential: !0 }] : t;
  });
}
const fq = /* @__PURE__ */ re.define(), Sh = /* @__PURE__ */ new ge();
function hA(t) {
  let e = t.firstChild, r = t.lastChild;
  return e && e.to < r.from ? { from: e.to, to: r.type.isError ? t.to : r.from } : null;
}
function mq(t, e, r) {
  let s = Ue(t);
  if (s.length < r)
    return null;
  let i = s.resolveStack(r, 1), n = null;
  for (let a = i; a; a = a.next) {
    let l = a.node;
    if (l.to <= r || l.from > r)
      continue;
    if (n && l.from < e)
      break;
    let c = l.type.prop(Sh);
    if (c && (l.to < s.length - 50 || s.length == t.doc.length || !gq(l))) {
      let p = c(l, t);
      p && p.from <= r && p.from >= e && p.to > r && (n = p);
    }
  }
  return n;
}
function gq(t) {
  let e = t.lastChild;
  return e && e.to == t.to && e.type.isError;
}
function wc(t, e, r) {
  for (let s of t.facet(fq)) {
    let i = s(t, e, r);
    if (i)
      return i;
  }
  return mq(t, e, r);
}
function pA(t, e) {
  let r = e.mapPos(t.from, 1), s = e.mapPos(t.to, -1);
  return r >= s ? void 0 : { from: r, to: s };
}
const wh = /* @__PURE__ */ pe.define({ map: pA }), Tl = /* @__PURE__ */ pe.define({ map: pA });
function dA(t) {
  let e = [];
  for (let { head: r } of t.state.selection.ranges)
    e.some((s) => s.from <= r && s.to >= r) || e.push(t.lineBlockAt(r));
  return e;
}
const yn = /* @__PURE__ */ ut.define({
  create() {
    return ce.none;
  },
  update(t, e) {
    e.isUserEvent("delete") && e.changes.iterChangedRanges((r, s) => t = Y1(t, r, s)), t = t.map(e.changes);
    for (let r of e.effects)
      if (r.is(wh) && !yq(t, r.value.from, r.value.to)) {
        let { preparePlaceholder: s } = e.state.facet(gA), i = s ? ce.replace({ widget: new wq(s(e.state, r.value)) }) : W1;
        t = t.update({ add: [i.range(r.value.from, r.value.to)] });
      } else r.is(Tl) && (t = t.update({
        filter: (s, i) => r.value.from != s || r.value.to != i,
        filterFrom: r.value.from,
        filterTo: r.value.to
      }));
    return e.selection && (t = Y1(t, e.selection.main.head)), t;
  },
  provide: (t) => J.decorations.from(t),
  toJSON(t, e) {
    let r = [];
    return t.between(0, e.doc.length, (s, i) => {
      r.push(s, i);
    }), r;
  },
  fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let r = 0; r < t.length; ) {
      let s = t[r++], i = t[r++];
      if (typeof s != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(W1.range(s, i));
    }
    return ce.set(e, !0);
  }
});
function Y1(t, e, r = e) {
  let s = !1;
  return t.between(e, r, (i, n) => {
    i < r && n > e && (s = !0);
  }), s ? t.update({
    filterFrom: e,
    filterTo: r,
    filter: (i, n) => i >= r || n <= e
  }) : t;
}
function Ac(t, e, r) {
  var s;
  let i = null;
  return (s = t.field(yn, !1)) === null || s === void 0 || s.between(e, r, (n, a) => {
    (!i || i.from > n) && (i = { from: n, to: a });
  }), i;
}
function yq(t, e, r) {
  let s = !1;
  return t.between(e, e, (i, n) => {
    i == e && n == r && (s = !0);
  }), s;
}
function fA(t, e) {
  return t.field(yn, !1) ? e : e.concat(pe.appendConfig.of(yA()));
}
const Oq = (t) => {
  for (let e of dA(t)) {
    let r = wc(t.state, e.from, e.to);
    if (r)
      return t.dispatch({ effects: fA(t.state, [wh.of(r), mA(t, r)]) }), !0;
  }
  return !1;
}, xq = (t) => {
  if (!t.state.field(yn, !1))
    return !1;
  let e = [];
  for (let r of dA(t)) {
    let s = Ac(t.state, r.from, r.to);
    s && e.push(Tl.of(s), mA(t, s, !1));
  }
  return e.length && t.dispatch({ effects: e }), e.length > 0;
};
function mA(t, e, r = !0) {
  let s = t.state.doc.lineAt(e.from).number, i = t.state.doc.lineAt(e.to).number;
  return J.announce.of(`${t.state.phrase(r ? "Folded lines" : "Unfolded lines")} ${s} ${t.state.phrase("to")} ${i}.`);
}
const Dq = (t) => {
  let { state: e } = t, r = [];
  for (let s = 0; s < e.doc.length; ) {
    let i = t.lineBlockAt(s), n = wc(e, i.from, i.to);
    n && r.push(wh.of(n)), s = (n ? t.lineBlockAt(n.to) : i).to + 1;
  }
  return r.length && t.dispatch({ effects: fA(t.state, r) }), !!r.length;
}, bq = (t) => {
  let e = t.state.field(yn, !1);
  if (!e || !e.size)
    return !1;
  let r = [];
  return e.between(0, t.state.doc.length, (s, i) => {
    r.push(Tl.of({ from: s, to: i }));
  }), t.dispatch({ effects: r }), !0;
}, vq = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: Oq },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: xq },
  { key: "Ctrl-Alt-[", run: Dq },
  { key: "Ctrl-Alt-]", run: bq }
], Sq = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: ""
}, gA = /* @__PURE__ */ re.define({
  combine(t) {
    return Os(t, Sq);
  }
});
function yA(t) {
  return [yn, Eq];
}
function OA(t, e) {
  let { state: r } = t, s = r.facet(gA), i = (a) => {
    let l = t.lineBlockAt(t.posAtDOM(a.target)), c = Ac(t.state, l.from, l.to);
    c && t.dispatch({ effects: Tl.of(c) }), a.preventDefault();
  };
  if (s.placeholderDOM)
    return s.placeholderDOM(t, i, e);
  let n = document.createElement("span");
  return n.textContent = s.placeholderText, n.setAttribute("aria-label", r.phrase("folded code")), n.title = r.phrase("unfold"), n.className = "cm-foldPlaceholder", n.onclick = i, n;
}
const W1 = /* @__PURE__ */ ce.replace({ widget: /* @__PURE__ */ new class extends ei {
  toDOM(t) {
    return OA(t, null);
  }
}() });
class wq extends ei {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return OA(e, this.value);
  }
}
const Aq = {
  openText: "",
  closedText: "",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class Np extends qs {
  constructor(e, r) {
    super(), this.config = e, this.open = r;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let r = document.createElement("span");
    return r.textContent = this.open ? this.config.openText : this.config.closedText, r.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), r;
  }
}
function Cq(t = {}) {
  let e = { ...Aq, ...t }, r = new Np(e, !0), s = new Np(e, !1), i = st.fromClass(class {
    constructor(a) {
      this.from = a.viewport.from, this.markers = this.buildMarkers(a);
    }
    update(a) {
      (a.docChanged || a.viewportChanged || a.startState.facet(Pi) != a.state.facet(Pi) || a.startState.field(yn, !1) != a.state.field(yn, !1) || Ue(a.startState) != Ue(a.state) || e.foldingChanged(a)) && (this.markers = this.buildMarkers(a.view));
    }
    buildMarkers(a) {
      let l = new _s();
      for (let c of a.viewportLineBlocks) {
        let p = Ac(a.state, c.from, c.to) ? s : wc(a.state, c.from, c.to) ? r : null;
        p && l.add(c.from, c.from, p);
      }
      return l.finish();
    }
  }), { domEventHandlers: n } = e;
  return [
    i,
    vR({
      class: "cm-foldGutter",
      markers(a) {
        var l;
        return ((l = a.plugin(i)) === null || l === void 0 ? void 0 : l.markers) || Ce.empty;
      },
      initialSpacer() {
        return new Np(e, !1);
      },
      domEventHandlers: {
        ...n,
        click: (a, l, c) => {
          if (n.click && n.click(a, l, c))
            return !0;
          let p = Ac(a.state, l.from, l.to);
          if (p)
            return a.dispatch({ effects: Tl.of(p) }), !0;
          let d = wc(a.state, l.from, l.to);
          return d ? (a.dispatch({ effects: wh.of(d) }), !0) : !1;
        }
      }
    }),
    yA()
  ];
}
const Eq = /* @__PURE__ */ J.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class kl {
  constructor(e, r) {
    this.specs = e;
    let s;
    function i(l) {
      let c = Ci.newName();
      return (s || (s = /* @__PURE__ */ Object.create(null)))["." + c] = l, c;
    }
    const n = typeof r.all == "string" ? r.all : r.all ? i(r.all) : void 0, a = r.scope;
    this.scope = a instanceof Lr ? (l) => l.prop(Yn) == a.data : a ? (l) => l == a : void 0, this.style = aA(e.map((l) => ({
      tag: l.tag,
      class: l.class || i(Object.assign({}, l, { tag: null }))
    })), {
      all: n
    }).style, this.module = s ? new Ci(s) : null, this.themeType = r.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, r) {
    return new kl(e, r || {});
  }
}
const vf = /* @__PURE__ */ re.define(), xA = /* @__PURE__ */ re.define({
  combine(t) {
    return t.length ? [t[0]] : null;
  }
});
function Mp(t) {
  let e = t.facet(vf);
  return e.length ? e : t.facet(xA);
}
function DA(t, e) {
  let r = [kq], s;
  return t instanceof kl && (t.module && r.push(J.styleModule.of(t.module)), s = t.themeType), e != null && e.fallback ? r.push(xA.of(t)) : s ? r.push(vf.computeN([J.darkTheme], (i) => i.facet(J.darkTheme) == (s == "dark") ? [t] : [])) : r.push(vf.of(t)), r;
}
class Tq {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Ue(e.state), this.decorations = this.buildDeco(e, Mp(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let r = Ue(e.state), s = Mp(e.state), i = s != Mp(e.startState), { viewport: n } = e.view, a = e.changes.mapPos(this.decoratedTo, 1);
    r.length < n.to && !i && r.type == this.tree.type && a >= n.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = a) : (r != this.tree || e.viewportChanged || i) && (this.tree = r, this.decorations = this.buildDeco(e.view, s), this.decoratedTo = n.to);
  }
  buildDeco(e, r) {
    if (!r || !this.tree.length)
      return ce.none;
    let s = new _s();
    for (let { from: i, to: n } of e.visibleRanges)
      JR(this.tree, r, (a, l, c) => {
        s.add(a, l, this.markCache[c] || (this.markCache[c] = ce.mark({ class: c })));
      }, i, n);
    return s.finish();
  }
}
const kq = /* @__PURE__ */ Li.high(/* @__PURE__ */ st.fromClass(Tq, {
  decorations: (t) => t.decorations
})), Pq = /* @__PURE__ */ kl.define([
  {
    tag: T.meta,
    color: "#404740"
  },
  {
    tag: T.link,
    textDecoration: "underline"
  },
  {
    tag: T.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: T.emphasis,
    fontStyle: "italic"
  },
  {
    tag: T.strong,
    fontWeight: "bold"
  },
  {
    tag: T.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: T.keyword,
    color: "#708"
  },
  {
    tag: [T.atom, T.bool, T.url, T.contentSeparator, T.labelName],
    color: "#219"
  },
  {
    tag: [T.literal, T.inserted],
    color: "#164"
  },
  {
    tag: [T.string, T.deleted],
    color: "#a11"
  },
  {
    tag: [T.regexp, T.escape, /* @__PURE__ */ T.special(T.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ T.definition(T.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ T.local(T.variableName),
    color: "#30a"
  },
  {
    tag: [T.typeName, T.namespace],
    color: "#085"
  },
  {
    tag: T.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ T.special(T.variableName), T.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ T.definition(T.propertyName),
    color: "#00c"
  },
  {
    tag: T.comment,
    color: "#940"
  },
  {
    tag: T.invalid,
    color: "#f00"
  }
]), Fq = /* @__PURE__ */ J.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), bA = 1e4, vA = "()[]{}", SA = /* @__PURE__ */ re.define({
  combine(t) {
    return Os(t, {
      afterCursor: !0,
      brackets: vA,
      maxScanDistance: bA,
      renderMatch: Bq
    });
  }
}), $q = /* @__PURE__ */ ce.mark({ class: "cm-matchingBracket" }), Qq = /* @__PURE__ */ ce.mark({ class: "cm-nonmatchingBracket" });
function Bq(t) {
  let e = [], r = t.matched ? $q : Qq;
  return e.push(r.range(t.start.from, t.start.to)), t.end && e.push(r.range(t.end.from, t.end.to)), e;
}
const Iq = /* @__PURE__ */ ut.define({
  create() {
    return ce.none;
  },
  update(t, e) {
    if (!e.docChanged && !e.selection)
      return t;
    let r = [], s = e.state.facet(SA);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let n = ns(e.state, i.head, -1, s) || i.head > 0 && ns(e.state, i.head - 1, 1, s) || s.afterCursor && (ns(e.state, i.head, 1, s) || i.head < e.state.doc.length && ns(e.state, i.head + 1, -1, s));
      n && (r = r.concat(s.renderMatch(n, e.state)));
    }
    return ce.set(r, !0);
  },
  provide: (t) => J.decorations.from(t)
}), Nq = [
  Iq,
  Fq
];
function Mq(t = {}) {
  return [SA.of(t), Nq];
}
const wA = /* @__PURE__ */ new ge();
function Sf(t, e, r) {
  let s = t.prop(e < 0 ? ge.openedBy : ge.closedBy);
  if (s)
    return s;
  if (t.name.length == 1) {
    let i = r.indexOf(t.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [r[i + e]];
  }
  return null;
}
function wf(t) {
  let e = t.type.prop(wA);
  return e ? e(t.node) : t;
}
function ns(t, e, r, s = {}) {
  let i = s.maxScanDistance || bA, n = s.brackets || vA, a = Ue(t), l = a.resolveInner(e, r);
  for (let c = l; c; c = c.parent) {
    let p = Sf(c.type, r, n);
    if (p && c.from < c.to) {
      let d = wf(c);
      if (d && (r > 0 ? e >= d.from && e < d.to : e > d.from && e <= d.to))
        return Lq(t, e, r, c, d, p, n);
    }
  }
  return _q(t, e, r, a, l.type, i, n);
}
function Lq(t, e, r, s, i, n, a) {
  let l = s.parent, c = { from: i.from, to: i.to }, p = 0, d = l == null ? void 0 : l.cursor();
  if (d && (r < 0 ? d.childBefore(s.from) : d.childAfter(s.to)))
    do
      if (r < 0 ? d.to <= s.from : d.from >= s.to) {
        if (p == 0 && n.indexOf(d.type.name) > -1 && d.from < d.to) {
          let m = wf(d);
          return { start: c, end: m ? { from: m.from, to: m.to } : void 0, matched: !0 };
        } else if (Sf(d.type, r, a))
          p++;
        else if (Sf(d.type, -r, a)) {
          if (p == 0) {
            let m = wf(d);
            return {
              start: c,
              end: m && m.from < m.to ? { from: m.from, to: m.to } : void 0,
              matched: !1
            };
          }
          p--;
        }
      }
    while (r < 0 ? d.prevSibling() : d.nextSibling());
  return { start: c, matched: !1 };
}
function _q(t, e, r, s, i, n, a) {
  let l = r < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), c = a.indexOf(l);
  if (c < 0 || c % 2 == 0 != r > 0)
    return null;
  let p = { from: r < 0 ? e - 1 : e, to: r > 0 ? e + 1 : e }, d = t.doc.iterRange(e, r > 0 ? t.doc.length : 0), m = 0;
  for (let y = 0; !d.next().done && y <= n; ) {
    let g = d.value;
    r < 0 && (y += g.length);
    let x = e + y * r;
    for (let v = r > 0 ? 0 : g.length - 1, w = r > 0 ? g.length : -1; v != w; v += r) {
      let C = a.indexOf(g[v]);
      if (!(C < 0 || s.resolveInner(x + v, 1).type != i))
        if (C % 2 == 0 == r > 0)
          m++;
        else {
          if (m == 1)
            return { start: p, end: { from: x + v, to: x + v + 1 }, matched: C >> 1 == c >> 1 };
          m--;
        }
    }
    r > 0 && (y += g.length);
  }
  return d.done ? { start: p, matched: !1 } : null;
}
const Rq = /* @__PURE__ */ Object.create(null), G1 = [_t.none], H1 = [], J1 = /* @__PURE__ */ Object.create(null), qq = /* @__PURE__ */ Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  qq[t] = /* @__PURE__ */ jq(Rq, e);
function Lp(t, e) {
  H1.indexOf(t) > -1 || (H1.push(t), console.warn(e));
}
function jq(t, e) {
  let r = [];
  for (let l of e.split(" ")) {
    let c = [];
    for (let p of l.split(".")) {
      let d = t[p] || T[p];
      d ? typeof d == "function" ? c.length ? c = c.map(d) : Lp(p, `Modifier ${p} used at start of tag`) : c.length ? Lp(p, `Tag ${p} used as modifier`) : c = Array.isArray(d) ? d : [d] : Lp(p, `Unknown highlighting tag ${p}`);
    }
    for (let p of c)
      r.push(p);
  }
  if (!r.length)
    return 0;
  let s = e.replace(/ /g, "_"), i = s + " " + r.map((l) => l.id), n = J1[i];
  if (n)
    return n.id;
  let a = J1[i] = _t.define({
    id: G1.length,
    name: s,
    props: [xh({ [s]: r })]
  });
  return G1.push(a), a.id;
}
_e.RTL, _e.LTR;
const Xq = (t) => {
  let { state: e } = t, r = e.doc.lineAt(e.selection.main.from), s = Ag(t.state, r.from);
  return s.line ? Zq(t) : s.block ? zq(t) : !1;
};
function wg(t, e) {
  return ({ state: r, dispatch: s }) => {
    if (r.readOnly)
      return !1;
    let i = t(e, r);
    return i ? (s(r.update(i)), !0) : !1;
  };
}
const Zq = /* @__PURE__ */ wg(
  Wq,
  0
  /* CommentOption.Toggle */
), Vq = /* @__PURE__ */ wg(
  AA,
  0
  /* CommentOption.Toggle */
), zq = /* @__PURE__ */ wg(
  (t, e) => AA(t, e, Yq(e)),
  0
  /* CommentOption.Toggle */
);
function Ag(t, e) {
  let r = t.languageDataAt("commentTokens", e, 1);
  return r.length ? r[0] : {};
}
const no = 50;
function Uq(t, { open: e, close: r }, s, i) {
  let n = t.sliceDoc(s - no, s), a = t.sliceDoc(i, i + no), l = /\s*$/.exec(n)[0].length, c = /^\s*/.exec(a)[0].length, p = n.length - l;
  if (n.slice(p - e.length, p) == e && a.slice(c, c + r.length) == r)
    return {
      open: { pos: s - l, margin: l && 1 },
      close: { pos: i + c, margin: c && 1 }
    };
  let d, m;
  i - s <= 2 * no ? d = m = t.sliceDoc(s, i) : (d = t.sliceDoc(s, s + no), m = t.sliceDoc(i - no, i));
  let y = /^\s*/.exec(d)[0].length, g = /\s*$/.exec(m)[0].length, x = m.length - g - r.length;
  return d.slice(y, y + e.length) == e && m.slice(x, x + r.length) == r ? {
    open: {
      pos: s + y + e.length,
      margin: /\s/.test(d.charAt(y + e.length)) ? 1 : 0
    },
    close: {
      pos: i - g - r.length,
      margin: /\s/.test(m.charAt(x - 1)) ? 1 : 0
    }
  } : null;
}
function Yq(t) {
  let e = [];
  for (let r of t.selection.ranges) {
    let s = t.doc.lineAt(r.from), i = r.to <= s.to ? s : t.doc.lineAt(r.to);
    i.from > s.from && i.from == r.to && (i = r.to == s.to + 1 ? s : t.doc.lineAt(r.to - 1));
    let n = e.length - 1;
    n >= 0 && e[n].to > s.from ? e[n].to = i.to : e.push({ from: s.from + /^\s*/.exec(s.text)[0].length, to: i.to });
  }
  return e;
}
function AA(t, e, r = e.selection.ranges) {
  let s = r.map((n) => Ag(e, n.from).block);
  if (!s.every((n) => n))
    return null;
  let i = r.map((n, a) => Uq(e, s[a], n.from, n.to));
  if (t != 2 && !i.every((n) => n))
    return { changes: e.changes(r.map((n, a) => i[a] ? [] : [{ from: n.from, insert: s[a].open + " " }, { from: n.to, insert: " " + s[a].close }])) };
  if (t != 1 && i.some((n) => n)) {
    let n = [];
    for (let a = 0, l; a < i.length; a++)
      if (l = i[a]) {
        let c = s[a], { open: p, close: d } = l;
        n.push({ from: p.pos - c.open.length, to: p.pos + p.margin }, { from: d.pos - d.margin, to: d.pos + c.close.length });
      }
    return { changes: n };
  }
  return null;
}
function Wq(t, e, r = e.selection.ranges) {
  let s = [], i = -1;
  for (let { from: n, to: a } of r) {
    let l = s.length, c = 1e9, p = Ag(e, n).line;
    if (p) {
      for (let d = n; d <= a; ) {
        let m = e.doc.lineAt(d);
        if (m.from > i && (n == a || a > m.from)) {
          i = m.from;
          let y = /^\s*/.exec(m.text)[0].length, g = y == m.length, x = m.text.slice(y, y + p.length) == p ? y : -1;
          y < m.text.length && y < c && (c = y), s.push({ line: m, comment: x, token: p, indent: y, empty: g, single: !1 });
        }
        d = m.to + 1;
      }
      if (c < 1e9)
        for (let d = l; d < s.length; d++)
          s[d].indent < s[d].line.text.length && (s[d].indent = c);
      s.length == l + 1 && (s[l].single = !0);
    }
  }
  if (t != 2 && s.some((n) => n.comment < 0 && (!n.empty || n.single))) {
    let n = [];
    for (let { line: l, token: c, indent: p, empty: d, single: m } of s)
      (m || !d) && n.push({ from: l.from + p, insert: c + " " });
    let a = e.changes(n);
    return { changes: a, selection: e.selection.map(a, 1) };
  } else if (t != 1 && s.some((n) => n.comment >= 0)) {
    let n = [];
    for (let { line: a, comment: l, token: c } of s)
      if (l >= 0) {
        let p = a.from + l, d = p + c.length;
        a.text[d - a.from] == " " && d++, n.push({ from: p, to: d });
      }
    return { changes: n };
  }
  return null;
}
const Af = /* @__PURE__ */ Ks.define(), Gq = /* @__PURE__ */ Ks.define(), Hq = /* @__PURE__ */ re.define(), CA = /* @__PURE__ */ re.define({
  combine(t) {
    return Os(t, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, r) => r
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, r) => (s, i) => e(s, i) || r(s, i)
    });
  }
}), EA = /* @__PURE__ */ ut.define({
  create() {
    return as.empty;
  },
  update(t, e) {
    let r = e.state.facet(CA), s = e.annotation(Af);
    if (s) {
      let c = Yt.fromTransaction(e, s.selection), p = s.side, d = p == 0 ? t.undone : t.done;
      return c ? d = Cc(d, d.length, r.minDepth, c) : d = PA(d, e.startState.selection), new as(p == 0 ? s.rest : d, p == 0 ? d : s.rest);
    }
    let i = e.annotation(Gq);
    if ((i == "full" || i == "before") && (t = t.isolate()), e.annotation(tt.addToHistory) === !1)
      return e.changes.empty ? t : t.addMapping(e.changes.desc);
    let n = Yt.fromTransaction(e), a = e.annotation(tt.time), l = e.annotation(tt.userEvent);
    return n ? t = t.addChanges(n, a, l, r, e) : e.selection && (t = t.addSelection(e.startState.selection, a, l, r.newGroupDelay)), (i == "full" || i == "after") && (t = t.isolate()), t;
  },
  toJSON(t) {
    return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t) {
    return new as(t.done.map(Yt.fromJSON), t.undone.map(Yt.fromJSON));
  }
});
function Jq(t = {}) {
  return [
    EA,
    CA.of(t),
    J.domEventHandlers({
      beforeinput(e, r) {
        let s = e.inputType == "historyUndo" ? TA : e.inputType == "historyRedo" ? Cf : null;
        return s ? (e.preventDefault(), s(r)) : !1;
      }
    })
  ];
}
function Ah(t, e) {
  return function({ state: r, dispatch: s }) {
    if (!e && r.readOnly)
      return !1;
    let i = r.field(EA, !1);
    if (!i)
      return !1;
    let n = i.pop(t, r, e);
    return n ? (s(n), !0) : !1;
  };
}
const TA = /* @__PURE__ */ Ah(0, !1), Cf = /* @__PURE__ */ Ah(1, !1), Kq = /* @__PURE__ */ Ah(0, !0), ej = /* @__PURE__ */ Ah(1, !0);
class Yt {
  constructor(e, r, s, i, n) {
    this.changes = e, this.effects = r, this.mapped = s, this.startSelection = i, this.selectionsAfter = n;
  }
  setSelAfter(e) {
    return new Yt(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, r, s;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (r = this.mapped) === null || r === void 0 ? void 0 : r.toJSON(),
      startSelection: (s = this.startSelection) === null || s === void 0 ? void 0 : s.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(e) {
    return new Yt(e.changes && at.fromJSON(e.changes), [], e.mapped && cs.fromJSON(e.mapped), e.startSelection && L.fromJSON(e.startSelection), e.selectionsAfter.map(L.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, r) {
    let s = br;
    for (let i of e.startState.facet(Hq)) {
      let n = i(e);
      n.length && (s = s.concat(n));
    }
    return !s.length && e.changes.empty ? null : new Yt(e.changes.invert(e.startState.doc), s, void 0, r || e.startState.selection, br);
  }
  static selection(e) {
    return new Yt(void 0, br, void 0, void 0, e);
  }
}
function Cc(t, e, r, s) {
  let i = e + 1 > r + 20 ? e - r - 1 : 0, n = t.slice(i, e);
  return n.push(s), n;
}
function tj(t, e) {
  let r = [], s = !1;
  return t.iterChangedRanges((i, n) => r.push(i, n)), e.iterChangedRanges((i, n, a, l) => {
    for (let c = 0; c < r.length; ) {
      let p = r[c++], d = r[c++];
      l >= p && a <= d && (s = !0);
    }
  }), s;
}
function rj(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((r, s) => r.empty != e.ranges[s].empty).length === 0;
}
function kA(t, e) {
  return t.length ? e.length ? t.concat(e) : t : e;
}
const br = [], sj = 200;
function PA(t, e) {
  if (t.length) {
    let r = t[t.length - 1], s = r.selectionsAfter.slice(Math.max(0, r.selectionsAfter.length - sj));
    return s.length && s[s.length - 1].eq(e) ? t : (s.push(e), Cc(t, t.length - 1, 1e9, r.setSelAfter(s)));
  } else
    return [Yt.selection([e])];
}
function ij(t) {
  let e = t[t.length - 1], r = t.slice();
  return r[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), r;
}
function _p(t, e) {
  if (!t.length)
    return t;
  let r = t.length, s = br;
  for (; r; ) {
    let i = nj(t[r - 1], e, s);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let n = t.slice(0, r);
      return n[r - 1] = i, n;
    } else
      e = i.mapped, r--, s = i.selectionsAfter;
  }
  return s.length ? [Yt.selection(s)] : br;
}
function nj(t, e, r) {
  let s = kA(t.selectionsAfter.length ? t.selectionsAfter.map((l) => l.map(e)) : br, r);
  if (!t.changes)
    return Yt.selection(s);
  let i = t.changes.map(e), n = e.mapDesc(t.changes, !0), a = t.mapped ? t.mapped.composeDesc(n) : n;
  return new Yt(i, pe.mapEffects(t.effects, e), a, t.startSelection.map(n), s);
}
const aj = /^(input\.type|delete)($|\.)/;
class as {
  constructor(e, r, s = 0, i = void 0) {
    this.done = e, this.undone = r, this.prevTime = s, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new as(this.done, this.undone) : this;
  }
  addChanges(e, r, s, i, n) {
    let a = this.done, l = a[a.length - 1];
    return l && l.changes && !l.changes.empty && e.changes && (!s || aj.test(s)) && (!l.selectionsAfter.length && r - this.prevTime < i.newGroupDelay && i.joinToEvent(n, tj(l.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    s == "input.type.compose") ? a = Cc(a, a.length - 1, i.minDepth, new Yt(e.changes.compose(l.changes), kA(pe.mapEffects(e.effects, l.changes), l.effects), l.mapped, l.startSelection, br)) : a = Cc(a, a.length, i.minDepth, e), new as(a, br, r, s);
  }
  addSelection(e, r, s, i) {
    let n = this.done.length ? this.done[this.done.length - 1].selectionsAfter : br;
    return n.length > 0 && r - this.prevTime < i && s == this.prevUserEvent && s && /^select($|\.)/.test(s) && rj(n[n.length - 1], e) ? this : new as(PA(this.done, e), this.undone, r, s);
  }
  addMapping(e) {
    return new as(_p(this.done, e), _p(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, r, s) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let n = i[i.length - 1], a = n.selectionsAfter[0] || r.selection;
    if (s && n.selectionsAfter.length)
      return r.update({
        selection: n.selectionsAfter[n.selectionsAfter.length - 1],
        annotations: Af.of({ side: e, rest: ij(i), selection: a }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (n.changes) {
      let l = i.length == 1 ? br : i.slice(0, i.length - 1);
      return n.mapped && (l = _p(l, n.mapped)), r.update({
        changes: n.changes,
        selection: n.startSelection,
        effects: n.effects,
        annotations: Af.of({ side: e, rest: l, selection: a }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
as.empty = /* @__PURE__ */ new as(br, br);
const oj = [
  { key: "Mod-z", run: TA, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: Cf, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: Cf, preventDefault: !0 },
  { key: "Mod-u", run: Kq, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: ej, preventDefault: !0 }
];
function La(t, e) {
  return L.create(t.ranges.map(e), t.mainIndex);
}
function xs(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function Vr({ state: t, dispatch: e }, r) {
  let s = La(t.selection, r);
  return s.eq(t.selection, !0) ? !1 : (e(xs(t, s)), !0);
}
function Ch(t, e) {
  return L.cursor(e ? t.to : t.from);
}
function FA(t, e) {
  return Vr(t, (r) => r.empty ? t.moveByChar(r, e) : Ch(r, e));
}
function $t(t) {
  return t.textDirectionAt(t.state.selection.main.head) == _e.LTR;
}
const $A = (t) => FA(t, !$t(t)), QA = (t) => FA(t, $t(t));
function BA(t, e) {
  return Vr(t, (r) => r.empty ? t.moveByGroup(r, e) : Ch(r, e));
}
const lj = (t) => BA(t, !$t(t)), uj = (t) => BA(t, $t(t));
function cj(t, e, r) {
  if (e.type.prop(r))
    return !0;
  let s = e.to - e.from;
  return s && (s > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
}
function Eh(t, e, r) {
  let s = Ue(t).resolveInner(e.head), i = r ? ge.closedBy : ge.openedBy;
  for (let c = e.head; ; ) {
    let p = r ? s.childAfter(c) : s.childBefore(c);
    if (!p)
      break;
    cj(t, p, i) ? s = p : c = r ? p.to : p.from;
  }
  let n = s.type.prop(i), a, l;
  return n && (a = r ? ns(t, s.from, 1) : ns(t, s.to, -1)) && a.matched ? l = r ? a.end.to : a.end.from : l = r ? s.to : s.from, L.cursor(l, r ? -1 : 1);
}
const hj = (t) => Vr(t, (e) => Eh(t.state, e, !$t(t))), pj = (t) => Vr(t, (e) => Eh(t.state, e, $t(t)));
function IA(t, e) {
  return Vr(t, (r) => {
    if (!r.empty)
      return Ch(r, e);
    let s = t.moveVertically(r, e);
    return s.head != r.head ? s : t.moveToLineBoundary(r, e);
  });
}
const NA = (t) => IA(t, !1), MA = (t) => IA(t, !0);
function LA(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, r = 0, s = 0, i;
  if (e) {
    for (let n of t.state.facet(J.scrollMargins)) {
      let a = n(t);
      a != null && a.top && (r = Math.max(a == null ? void 0 : a.top, r)), a != null && a.bottom && (s = Math.max(a == null ? void 0 : a.bottom, s));
    }
    i = t.scrollDOM.clientHeight - r - s;
  } else
    i = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: r,
    marginBottom: s,
    selfScroll: e,
    height: Math.max(t.defaultLineHeight, i - 5)
  };
}
function _A(t, e) {
  let r = LA(t), { state: s } = t, i = La(s.selection, (a) => a.empty ? t.moveVertically(a, e, r.height) : Ch(a, e));
  if (i.eq(s.selection))
    return !1;
  let n;
  if (r.selfScroll) {
    let a = t.coordsAtPos(s.selection.main.head), l = t.scrollDOM.getBoundingClientRect(), c = l.top + r.marginTop, p = l.bottom - r.marginBottom;
    a && a.top > c && a.bottom < p && (n = J.scrollIntoView(i.main.head, { y: "start", yMargin: a.top - c }));
  }
  return t.dispatch(xs(s, i), { effects: n }), !0;
}
const K1 = (t) => _A(t, !1), Ef = (t) => _A(t, !0);
function _i(t, e, r) {
  let s = t.lineBlockAt(e.head), i = t.moveToLineBoundary(e, r);
  if (i.head == e.head && i.head != (r ? s.to : s.from) && (i = t.moveToLineBoundary(e, r, !1)), !r && i.head == s.from && s.length) {
    let n = /^\s*/.exec(t.state.sliceDoc(s.from, Math.min(s.from + 100, s.to)))[0].length;
    n && e.head != s.from + n && (i = L.cursor(s.from + n));
  }
  return i;
}
const dj = (t) => Vr(t, (e) => _i(t, e, !0)), fj = (t) => Vr(t, (e) => _i(t, e, !1)), mj = (t) => Vr(t, (e) => _i(t, e, !$t(t))), gj = (t) => Vr(t, (e) => _i(t, e, $t(t))), yj = (t) => Vr(t, (e) => L.cursor(t.lineBlockAt(e.head).from, 1)), Oj = (t) => Vr(t, (e) => L.cursor(t.lineBlockAt(e.head).to, -1));
function xj(t, e, r) {
  let s = !1, i = La(t.selection, (n) => {
    let a = ns(t, n.head, -1) || ns(t, n.head, 1) || n.head > 0 && ns(t, n.head - 1, 1) || n.head < t.doc.length && ns(t, n.head + 1, -1);
    if (!a || !a.end)
      return n;
    s = !0;
    let l = a.start.from == n.head ? a.end.to : a.end.from;
    return L.cursor(l);
  });
  return s ? (e(xs(t, i)), !0) : !1;
}
const Dj = ({ state: t, dispatch: e }) => xj(t, e);
function kr(t, e) {
  let r = La(t.state.selection, (s) => {
    let i = e(s);
    return L.range(s.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return r.eq(t.state.selection) ? !1 : (t.dispatch(xs(t.state, r)), !0);
}
function RA(t, e) {
  return kr(t, (r) => t.moveByChar(r, e));
}
const qA = (t) => RA(t, !$t(t)), jA = (t) => RA(t, $t(t));
function XA(t, e) {
  return kr(t, (r) => t.moveByGroup(r, e));
}
const bj = (t) => XA(t, !$t(t)), vj = (t) => XA(t, $t(t)), Sj = (t) => kr(t, (e) => Eh(t.state, e, !$t(t))), wj = (t) => kr(t, (e) => Eh(t.state, e, $t(t)));
function ZA(t, e) {
  return kr(t, (r) => t.moveVertically(r, e));
}
const VA = (t) => ZA(t, !1), zA = (t) => ZA(t, !0);
function UA(t, e) {
  return kr(t, (r) => t.moveVertically(r, e, LA(t).height));
}
const ex = (t) => UA(t, !1), tx = (t) => UA(t, !0), Aj = (t) => kr(t, (e) => _i(t, e, !0)), Cj = (t) => kr(t, (e) => _i(t, e, !1)), Ej = (t) => kr(t, (e) => _i(t, e, !$t(t))), Tj = (t) => kr(t, (e) => _i(t, e, $t(t))), kj = (t) => kr(t, (e) => L.cursor(t.lineBlockAt(e.head).from)), Pj = (t) => kr(t, (e) => L.cursor(t.lineBlockAt(e.head).to)), rx = ({ state: t, dispatch: e }) => (e(xs(t, { anchor: 0 })), !0), sx = ({ state: t, dispatch: e }) => (e(xs(t, { anchor: t.doc.length })), !0), ix = ({ state: t, dispatch: e }) => (e(xs(t, { anchor: t.selection.main.anchor, head: 0 })), !0), nx = ({ state: t, dispatch: e }) => (e(xs(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0), Fj = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0), $j = ({ state: t, dispatch: e }) => {
  let r = Th(t).map(({ from: s, to: i }) => L.range(s, Math.min(i + 1, t.doc.length)));
  return e(t.update({ selection: L.create(r), userEvent: "select" })), !0;
}, Qj = ({ state: t, dispatch: e }) => {
  let r = La(t.selection, (s) => {
    let i = Ue(t), n = i.resolveStack(s.from, 1);
    if (s.empty) {
      let a = i.resolveStack(s.from, -1);
      a.node.from >= n.node.from && a.node.to <= n.node.to && (n = a);
    }
    for (let a = n; a; a = a.next) {
      let { node: l } = a;
      if ((l.from < s.from && l.to >= s.to || l.to > s.to && l.from <= s.from) && a.next)
        return L.range(l.to, l.from);
    }
    return s;
  });
  return r.eq(t.selection) ? !1 : (e(xs(t, r)), !0);
}, Bj = ({ state: t, dispatch: e }) => {
  let r = t.selection, s = null;
  return r.ranges.length > 1 ? s = L.create([r.main]) : r.main.empty || (s = L.create([L.cursor(r.main.head)])), s ? (e(xs(t, s)), !0) : !1;
};
function Pl(t, e) {
  if (t.state.readOnly)
    return !1;
  let r = "delete.selection", { state: s } = t, i = s.changeByRange((n) => {
    let { from: a, to: l } = n;
    if (a == l) {
      let c = e(n);
      c < a ? (r = "delete.backward", c = Du(t, c, !1)) : c > a && (r = "delete.forward", c = Du(t, c, !0)), a = Math.min(a, c), l = Math.max(l, c);
    } else
      a = Du(t, a, !1), l = Du(t, l, !0);
    return a == l ? { range: n } : { changes: { from: a, to: l }, range: L.cursor(a, a < n.head ? -1 : 1) };
  });
  return i.changes.empty ? !1 : (t.dispatch(s.update(i, {
    scrollIntoView: !0,
    userEvent: r,
    effects: r == "delete.selection" ? J.announce.of(s.phrase("Selection deleted")) : void 0
  })), !0);
}
function Du(t, e, r) {
  if (t instanceof J)
    for (let s of t.state.facet(J.atomicRanges).map((i) => i(t)))
      s.between(e, e, (i, n) => {
        i < e && n > e && (e = r ? n : i);
      });
  return e;
}
const YA = (t, e, r) => Pl(t, (s) => {
  let i = s.from, { state: n } = t, a = n.doc.lineAt(i), l, c;
  if (r && !e && i > a.from && i < a.from + 200 && !/[^ \t]/.test(l = a.text.slice(0, i - a.from))) {
    if (l[l.length - 1] == "	")
      return i - 1;
    let p = Ma(l, n.tabSize), d = p % Sc(n) || Sc(n);
    for (let m = 0; m < d && l[l.length - 1 - m] == " "; m++)
      i--;
    c = i;
  } else
    c = Dt(a.text, i - a.from, e, e) + a.from, c == i && a.number != (e ? n.doc.lines : 1) ? c += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(a.text.slice(c - a.from, i - a.from)) && (c = Dt(a.text, c - a.from, !1, !1) + a.from);
  return c;
}), Tf = (t) => YA(t, !1, !0), WA = (t) => YA(t, !0, !1), GA = (t, e) => Pl(t, (r) => {
  let s = r.head, { state: i } = t, n = i.doc.lineAt(s), a = i.charCategorizer(s);
  for (let l = null; ; ) {
    if (s == (e ? n.to : n.from)) {
      s == r.head && n.number != (e ? i.doc.lines : 1) && (s += e ? 1 : -1);
      break;
    }
    let c = Dt(n.text, s - n.from, e) + n.from, p = n.text.slice(Math.min(s, c) - n.from, Math.max(s, c) - n.from), d = a(p);
    if (l != null && d != l)
      break;
    (p != " " || s != r.head) && (l = d), s = c;
  }
  return s;
}), HA = (t) => GA(t, !1), Ij = (t) => GA(t, !0), Nj = (t) => Pl(t, (e) => {
  let r = t.lineBlockAt(e.head).to;
  return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
}), Mj = (t) => Pl(t, (e) => {
  let r = t.moveToLineBoundary(e, !1).head;
  return e.head > r ? r : Math.max(0, e.head - 1);
}), Lj = (t) => Pl(t, (e) => {
  let r = t.moveToLineBoundary(e, !0).head;
  return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
}), _j = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = t.changeByRange((s) => ({
    changes: { from: s.from, to: s.to, insert: Se.of(["", ""]) },
    range: L.cursor(s.from)
  }));
  return e(t.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
}, Rj = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = t.changeByRange((s) => {
    if (!s.empty || s.from == 0 || s.from == t.doc.length)
      return { range: s };
    let i = s.from, n = t.doc.lineAt(i), a = i == n.from ? i - 1 : Dt(n.text, i - n.from, !1) + n.from, l = i == n.to ? i + 1 : Dt(n.text, i - n.from, !0) + n.from;
    return {
      changes: { from: a, to: l, insert: t.doc.slice(i, l).append(t.doc.slice(a, i)) },
      range: L.cursor(l)
    };
  });
  return r.changes.empty ? !1 : (e(t.update(r, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Th(t) {
  let e = [], r = -1;
  for (let s of t.selection.ranges) {
    let i = t.doc.lineAt(s.from), n = t.doc.lineAt(s.to);
    if (!s.empty && s.to == n.from && (n = t.doc.lineAt(s.to - 1)), r >= i.number) {
      let a = e[e.length - 1];
      a.to = n.to, a.ranges.push(s);
    } else
      e.push({ from: i.from, to: n.to, ranges: [s] });
    r = n.number + 1;
  }
  return e;
}
function JA(t, e, r) {
  if (t.readOnly)
    return !1;
  let s = [], i = [];
  for (let n of Th(t)) {
    if (r ? n.to == t.doc.length : n.from == 0)
      continue;
    let a = t.doc.lineAt(r ? n.to + 1 : n.from - 1), l = a.length + 1;
    if (r) {
      s.push({ from: n.to, to: a.to }, { from: n.from, insert: a.text + t.lineBreak });
      for (let c of n.ranges)
        i.push(L.range(Math.min(t.doc.length, c.anchor + l), Math.min(t.doc.length, c.head + l)));
    } else {
      s.push({ from: a.from, to: n.from }, { from: n.to, insert: t.lineBreak + a.text });
      for (let c of n.ranges)
        i.push(L.range(c.anchor - l, c.head - l));
    }
  }
  return s.length ? (e(t.update({
    changes: s,
    scrollIntoView: !0,
    selection: L.create(i, t.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const qj = ({ state: t, dispatch: e }) => JA(t, e, !1), jj = ({ state: t, dispatch: e }) => JA(t, e, !0);
function KA(t, e, r) {
  if (t.readOnly)
    return !1;
  let s = [];
  for (let i of Th(t))
    r ? s.push({ from: i.from, insert: t.doc.slice(i.from, i.to) + t.lineBreak }) : s.push({ from: i.to, insert: t.lineBreak + t.doc.slice(i.from, i.to) });
  return e(t.update({ changes: s, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const Xj = ({ state: t, dispatch: e }) => KA(t, e, !1), Zj = ({ state: t, dispatch: e }) => KA(t, e, !0), Vj = (t) => {
  if (t.state.readOnly)
    return !1;
  let { state: e } = t, r = e.changes(Th(e).map(({ from: i, to: n }) => (i > 0 ? i-- : n < e.doc.length && n++, { from: i, to: n }))), s = La(e.selection, (i) => {
    let n;
    if (t.lineWrapping) {
      let a = t.lineBlockAt(i.head), l = t.coordsAtPos(i.head, i.assoc || 1);
      l && (n = a.bottom + t.documentTop - l.bottom + t.defaultLineHeight / 2);
    }
    return t.moveVertically(i, !0, n);
  }).map(r);
  return t.dispatch({ changes: r, selection: s, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function zj(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let r = Ue(t).resolveInner(e), s = r.childBefore(e), i = r.childAfter(e), n;
  return s && i && s.to <= e && i.from >= e && (n = s.type.prop(ge.closedBy)) && n.indexOf(i.name) > -1 && t.doc.lineAt(s.to).from == t.doc.lineAt(i.from).from && !/\S/.test(t.sliceDoc(s.to, i.from)) ? { from: s.to, to: i.from } : null;
}
const ax = /* @__PURE__ */ eC(!1), Uj = /* @__PURE__ */ eC(!0);
function eC(t) {
  return ({ state: e, dispatch: r }) => {
    if (e.readOnly)
      return !1;
    let s = e.changeByRange((i) => {
      let { from: n, to: a } = i, l = e.doc.lineAt(n), c = !t && n == a && zj(e, n);
      t && (n = a = (a <= l.to ? l : e.doc.lineAt(a)).to);
      let p = new bh(e, { simulateBreak: n, simulateDoubleBreak: !!c }), d = vg(p, n);
      for (d == null && (d = Ma(/^\s*/.exec(e.doc.lineAt(n).text)[0], e.tabSize)); a < l.to && /\s/.test(l.text[a - l.from]); )
        a++;
      c ? { from: n, to: a } = c : n > l.from && n < l.from + 100 && !/\S/.test(l.text.slice(0, n)) && (n = l.from);
      let m = ["", Ko(e, d)];
      return c && m.push(Ko(e, p.lineIndent(l.from, -1))), {
        changes: { from: n, to: a, insert: Se.of(m) },
        range: L.cursor(n + 1 + m[1].length)
      };
    });
    return r(e.update(s, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Cg(t, e) {
  let r = -1;
  return t.changeByRange((s) => {
    let i = [];
    for (let a = s.from; a <= s.to; ) {
      let l = t.doc.lineAt(a);
      l.number > r && (s.empty || s.to > l.from) && (e(l, i, s), r = l.number), a = l.to + 1;
    }
    let n = t.changes(i);
    return {
      changes: i,
      range: L.range(n.mapPos(s.anchor, 1), n.mapPos(s.head, 1))
    };
  });
}
const Yj = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = /* @__PURE__ */ Object.create(null), s = new bh(t, { overrideIndentation: (n) => {
    let a = r[n];
    return a == null ? -1 : a;
  } }), i = Cg(t, (n, a, l) => {
    let c = vg(s, n.from);
    if (c == null)
      return;
    /\S/.test(n.text) || (c = 0);
    let p = /^\s*/.exec(n.text)[0], d = Ko(t, c);
    (p != d || l.from < n.from + p.length) && (r[n.from] = c, a.push({ from: n.from, to: n.from + p.length, insert: d }));
  });
  return i.changes.empty || e(t.update(i, { userEvent: "indent" })), !0;
}, tC = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Cg(t, (r, s) => {
  s.push({ from: r.from, insert: t.facet(Dh) });
}), { userEvent: "input.indent" })), !0), rC = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Cg(t, (r, s) => {
  let i = /^\s*/.exec(r.text)[0];
  if (!i)
    return;
  let n = Ma(i, t.tabSize), a = 0, l = Ko(t, Math.max(0, n - Sc(t)));
  for (; a < i.length && a < l.length && i.charCodeAt(a) == l.charCodeAt(a); )
    a++;
  s.push({ from: r.from + a, to: r.from + i.length, insert: l.slice(a) });
}), { userEvent: "delete.dedent" })), !0), Wj = (t) => (t.setTabFocusMode(), !0), Gj = [
  { key: "Ctrl-b", run: $A, shift: qA, preventDefault: !0 },
  { key: "Ctrl-f", run: QA, shift: jA },
  { key: "Ctrl-p", run: NA, shift: VA },
  { key: "Ctrl-n", run: MA, shift: zA },
  { key: "Ctrl-a", run: yj, shift: kj },
  { key: "Ctrl-e", run: Oj, shift: Pj },
  { key: "Ctrl-d", run: WA },
  { key: "Ctrl-h", run: Tf },
  { key: "Ctrl-k", run: Nj },
  { key: "Ctrl-Alt-h", run: HA },
  { key: "Ctrl-o", run: _j },
  { key: "Ctrl-t", run: Rj },
  { key: "Ctrl-v", run: Ef }
], Hj = /* @__PURE__ */ [
  { key: "ArrowLeft", run: $A, shift: qA, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: lj, shift: bj, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: mj, shift: Ej, preventDefault: !0 },
  { key: "ArrowRight", run: QA, shift: jA, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: uj, shift: vj, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: gj, shift: Tj, preventDefault: !0 },
  { key: "ArrowUp", run: NA, shift: VA, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: rx, shift: ix },
  { mac: "Ctrl-ArrowUp", run: K1, shift: ex },
  { key: "ArrowDown", run: MA, shift: zA, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: sx, shift: nx },
  { mac: "Ctrl-ArrowDown", run: Ef, shift: tx },
  { key: "PageUp", run: K1, shift: ex },
  { key: "PageDown", run: Ef, shift: tx },
  { key: "Home", run: fj, shift: Cj, preventDefault: !0 },
  { key: "Mod-Home", run: rx, shift: ix },
  { key: "End", run: dj, shift: Aj, preventDefault: !0 },
  { key: "Mod-End", run: sx, shift: nx },
  { key: "Enter", run: ax, shift: ax },
  { key: "Mod-a", run: Fj },
  { key: "Backspace", run: Tf, shift: Tf },
  { key: "Delete", run: WA },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: HA },
  { key: "Mod-Delete", mac: "Alt-Delete", run: Ij },
  { mac: "Mod-Backspace", run: Mj },
  { mac: "Mod-Delete", run: Lj }
].concat(/* @__PURE__ */ Gj.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))), Jj = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: hj, shift: Sj },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: pj, shift: wj },
  { key: "Alt-ArrowUp", run: qj },
  { key: "Shift-Alt-ArrowUp", run: Xj },
  { key: "Alt-ArrowDown", run: jj },
  { key: "Shift-Alt-ArrowDown", run: Zj },
  { key: "Escape", run: Bj },
  { key: "Mod-Enter", run: Uj },
  { key: "Alt-l", mac: "Ctrl-l", run: $j },
  { key: "Mod-i", run: Qj, preventDefault: !0 },
  { key: "Mod-[", run: rC },
  { key: "Mod-]", run: tC },
  { key: "Mod-Alt-\\", run: Yj },
  { key: "Shift-Mod-k", run: Vj },
  { key: "Shift-Mod-\\", run: Dj },
  { key: "Mod-/", run: Xq },
  { key: "Alt-A", run: Vq },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: Wj }
].concat(Hj), Kj = { key: "Tab", run: tC, shift: rC }, ox = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class xa {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, r, s = 0, i = e.length, n, a) {
    this.test = a, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(s, i), this.bufferStart = s, this.normalize = n ? (l) => n(ox(l)) : ox, this.query = this.normalize(r);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Zt(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let r = eg(e), s = this.bufferStart + this.bufferPos;
      this.bufferPos += es(e);
      let i = this.normalize(r);
      if (i.length)
        for (let n = 0, a = s; ; n++) {
          let l = i.charCodeAt(n), c = this.match(l, a, this.bufferPos + this.bufferStart);
          if (n == i.length - 1) {
            if (c)
              return this.value = c, this;
            break;
          }
          a == s && n < r.length && r.charCodeAt(n) == l && a++;
        }
    }
  }
  match(e, r, s) {
    let i = null;
    for (let n = 0; n < this.matches.length; n += 2) {
      let a = this.matches[n], l = !1;
      this.query.charCodeAt(a) == e && (a == this.query.length - 1 ? i = { from: this.matches[n + 1], to: s } : (this.matches[n]++, l = !0)), l || (this.matches.splice(n, 2), n -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: r, to: s } : this.matches.push(1, r)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
}
typeof Symbol != "undefined" && (xa.prototype[Symbol.iterator] = function() {
  return this;
});
const sC = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, Eg = "gm" + (/x/.unicode == null ? "" : "u");
class iC {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, r, s, i = 0, n = e.length) {
    if (this.text = e, this.to = n, this.curLine = "", this.done = !1, this.value = sC, /\\[sWDnr]|\n|\r|\[\^/.test(r))
      return new nC(e, r, s, i, n);
    this.re = new RegExp(r, Eg + (s != null && s.ignoreCase ? "i" : "")), this.test = s == null ? void 0 : s.test, this.iter = e.iter();
    let a = e.lineAt(i);
    this.curLineStart = a.from, this.matchPos = Ec(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let r = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (r) {
        let s = this.curLineStart + r.index, i = s + r[0].length;
        if (this.matchPos = Ec(this.text, i + (s == i ? 1 : 0)), s == this.curLineStart + this.curLine.length && this.nextLine(), (s < i || s > this.value.to) && (!this.test || this.test(s, i, r)))
          return this.value = { from: s, to: i, match: r }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Rp = /* @__PURE__ */ new WeakMap();
class Kn {
  constructor(e, r) {
    this.from = e, this.text = r;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, r, s) {
    let i = Rp.get(e);
    if (!i || i.from >= s || i.to <= r) {
      let l = new Kn(r, e.sliceString(r, s));
      return Rp.set(e, l), l;
    }
    if (i.from == r && i.to == s)
      return i;
    let { text: n, from: a } = i;
    return a > r && (n = e.sliceString(r, a) + n, a = r), i.to < s && (n += e.sliceString(i.to, s)), Rp.set(e, new Kn(a, n)), new Kn(r, n.slice(r - a, s - a));
  }
}
class nC {
  constructor(e, r, s, i, n) {
    this.text = e, this.to = n, this.done = !1, this.value = sC, this.matchPos = Ec(e, i), this.re = new RegExp(r, Eg + (s != null && s.ignoreCase ? "i" : "")), this.test = s == null ? void 0 : s.test, this.flat = Kn.get(e, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, r = this.re.exec(this.flat.text);
      if (r && !r[0] && r.index == e && (this.re.lastIndex = e + 1, r = this.re.exec(this.flat.text)), r) {
        let s = this.flat.from + r.index, i = s + r[0].length;
        if ((this.flat.to >= this.to || r.index + r[0].length <= this.flat.text.length - 10) && (!this.test || this.test(s, i, r)))
          return this.value = { from: s, to: i, match: r }, this.matchPos = Ec(this.text, i + (s == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Kn.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol != "undefined" && (iC.prototype[Symbol.iterator] = nC.prototype[Symbol.iterator] = function() {
  return this;
});
function eX(t) {
  try {
    return new RegExp(t, Eg), !0;
  } catch {
    return !1;
  }
}
function Ec(t, e) {
  if (e >= t.length)
    return e;
  let r = t.lineAt(e), s;
  for (; e < r.to && (s = r.text.charCodeAt(e - r.from)) >= 56320 && s < 57344; )
    e++;
  return e;
}
function kf(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), r = Qe("input", { class: "cm-textfield", name: "line", value: e }), s = Qe("form", {
    class: "cm-gotoLine",
    onkeydown: (n) => {
      n.keyCode == 27 ? (n.preventDefault(), t.dispatch({ effects: $o.of(!1) }), t.focus()) : n.keyCode == 13 && (n.preventDefault(), i());
    },
    onsubmit: (n) => {
      n.preventDefault(), i();
    }
  }, Qe("label", t.state.phrase("Go to line"), ": ", r), " ", Qe("button", { class: "cm-button", type: "submit" }, t.state.phrase("go")), Qe("button", {
    name: "close",
    onclick: () => {
      t.dispatch({ effects: $o.of(!1) }), t.focus();
    },
    "aria-label": t.state.phrase("close"),
    type: "button"
  }, [""]));
  function i() {
    let n = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(r.value);
    if (!n)
      return;
    let { state: a } = t, l = a.doc.lineAt(a.selection.main.head), [, c, p, d, m] = n, y = d ? +d.slice(1) : 0, g = p ? +p : l.number;
    if (p && m) {
      let w = g / 100;
      c && (w = w * (c == "-" ? -1 : 1) + l.number / a.doc.lines), g = Math.round(a.doc.lines * w);
    } else p && c && (g = g * (c == "-" ? -1 : 1) + l.number);
    let x = a.doc.line(Math.max(1, Math.min(a.doc.lines, g))), v = L.cursor(x.from + Math.max(0, Math.min(y, x.length)));
    t.dispatch({
      effects: [$o.of(!1), J.scrollIntoView(v.from, { y: "center" })],
      selection: v
    }), t.focus();
  }
  return { dom: s };
}
const $o = /* @__PURE__ */ pe.define(), lx = /* @__PURE__ */ ut.define({
  create() {
    return !0;
  },
  update(t, e) {
    for (let r of e.effects)
      r.is($o) && (t = r.value);
    return t;
  },
  provide: (t) => Go.from(t, (e) => e ? kf : null)
}), tX = (t) => {
  let e = Wo(t, kf);
  if (!e) {
    let r = [$o.of(!0)];
    t.state.field(lx, !1) == null && r.push(pe.appendConfig.of([lx, rX])), t.dispatch({ effects: r }), e = Wo(t, kf);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, rX = /* @__PURE__ */ J.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
}), sX = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, iX = /* @__PURE__ */ re.define({
  combine(t) {
    return Os(t, sX, {
      highlightWordAroundCursor: (e, r) => e || r,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function nX(t) {
  return [cX, uX];
}
const aX = /* @__PURE__ */ ce.mark({ class: "cm-selectionMatch" }), oX = /* @__PURE__ */ ce.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function ux(t, e, r, s) {
  return (r == 0 || t(e.sliceDoc(r - 1, r)) != Xe.Word) && (s == e.doc.length || t(e.sliceDoc(s, s + 1)) != Xe.Word);
}
function lX(t, e, r, s) {
  return t(e.sliceDoc(r, r + 1)) == Xe.Word && t(e.sliceDoc(s - 1, s)) == Xe.Word;
}
const uX = /* @__PURE__ */ st.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = t.state.facet(iX), { state: r } = t, s = r.selection;
    if (s.ranges.length > 1)
      return ce.none;
    let i = s.main, n, a = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return ce.none;
      let c = r.wordAt(i.head);
      if (!c)
        return ce.none;
      a = r.charCategorizer(i.head), n = r.sliceDoc(c.from, c.to);
    } else {
      let c = i.to - i.from;
      if (c < e.minSelectionLength || c > 200)
        return ce.none;
      if (e.wholeWords) {
        if (n = r.sliceDoc(i.from, i.to), a = r.charCategorizer(i.head), !(ux(a, r, i.from, i.to) && lX(a, r, i.from, i.to)))
          return ce.none;
      } else if (n = r.sliceDoc(i.from, i.to), !n)
        return ce.none;
    }
    let l = [];
    for (let c of t.visibleRanges) {
      let p = new xa(r.doc, n, c.from, c.to);
      for (; !p.next().done; ) {
        let { from: d, to: m } = p.value;
        if ((!a || ux(a, r, d, m)) && (i.empty && d <= i.from && m >= i.to ? l.push(oX.range(d, m)) : (d >= i.to || m <= i.from) && l.push(aX.range(d, m)), l.length > e.maxMatches))
          return ce.none;
      }
    }
    return ce.set(l);
  }
}, {
  decorations: (t) => t.decorations
}), cX = /* @__PURE__ */ J.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), hX = ({ state: t, dispatch: e }) => {
  let { selection: r } = t, s = L.create(r.ranges.map((i) => t.wordAt(i.head) || L.cursor(i.head)), r.mainIndex);
  return s.eq(r) ? !1 : (e(t.update({ selection: s })), !0);
};
function pX(t, e) {
  let { main: r, ranges: s } = t.selection, i = t.wordAt(r.head), n = i && i.from == r.from && i.to == r.to;
  for (let a = !1, l = new xa(t.doc, e, s[s.length - 1].to); ; )
    if (l.next(), l.done) {
      if (a)
        return null;
      l = new xa(t.doc, e, 0, Math.max(0, s[s.length - 1].from - 1)), a = !0;
    } else {
      if (a && s.some((c) => c.from == l.value.from))
        continue;
      if (n) {
        let c = t.wordAt(l.value.from);
        if (!c || c.from != l.value.from || c.to != l.value.to)
          continue;
      }
      return l.value;
    }
}
const dX = ({ state: t, dispatch: e }) => {
  let { ranges: r } = t.selection;
  if (r.some((n) => n.from === n.to))
    return hX({ state: t, dispatch: e });
  let s = t.sliceDoc(r[0].from, r[0].to);
  if (t.selection.ranges.some((n) => t.sliceDoc(n.from, n.to) != s))
    return !1;
  let i = pX(t, s);
  return i ? (e(t.update({
    selection: t.selection.addRange(L.range(i.from, i.to), !1),
    effects: J.scrollIntoView(i.to)
  })), !0) : !1;
}, _a = /* @__PURE__ */ re.define({
  combine(t) {
    return Os(t, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new AX(e),
      scrollToMatch: (e) => J.scrollIntoView(e)
    });
  }
});
class aC {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || eX(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (r, s) => s == "n" ? `
` : s == "r" ? "\r" : s == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new yX(this) : new mX(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, r = 0, s) {
    let i = e.doc ? e : we.create({ doc: e });
    return s == null && (s = i.doc.length), this.regexp ? jn(this, i, r, s) : qn(this, i, r, s);
  }
}
class oC {
  constructor(e) {
    this.spec = e;
  }
}
function qn(t, e, r, s) {
  return new xa(e.doc, t.unquoted, r, s, t.caseSensitive ? void 0 : (i) => i.toLowerCase(), t.wholeWord ? fX(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function fX(t, e) {
  return (r, s, i, n) => ((n > r || n + i.length < s) && (n = Math.max(0, r - 2), i = t.sliceString(n, Math.min(t.length, s + 2))), (e(Tc(i, r - n)) != Xe.Word || e(kc(i, r - n)) != Xe.Word) && (e(kc(i, s - n)) != Xe.Word || e(Tc(i, s - n)) != Xe.Word));
}
class mX extends oC {
  constructor(e) {
    super(e);
  }
  nextMatch(e, r, s) {
    let i = qn(this.spec, e, s, e.doc.length).nextOverlapping();
    if (i.done) {
      let n = Math.min(e.doc.length, r + this.spec.unquoted.length);
      i = qn(this.spec, e, 0, n).nextOverlapping();
    }
    return i.done || i.value.from == r && i.value.to == s ? null : i.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, r, s) {
    for (let i = s; ; ) {
      let n = Math.max(r, i - 1e4 - this.spec.unquoted.length), a = qn(this.spec, e, n, i), l = null;
      for (; !a.nextOverlapping().done; )
        l = a.value;
      if (l)
        return l;
      if (n == r)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, r, s) {
    let i = this.prevMatchInRange(e, 0, r);
    return i || (i = this.prevMatchInRange(e, Math.max(0, s - this.spec.unquoted.length), e.doc.length)), i && (i.from != r || i.to != s) ? i : null;
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, r) {
    let s = qn(this.spec, e, 0, e.doc.length), i = [];
    for (; !s.next().done; ) {
      if (i.length >= r)
        return null;
      i.push(s.value);
    }
    return i;
  }
  highlight(e, r, s, i) {
    let n = qn(this.spec, e, Math.max(0, r - this.spec.unquoted.length), Math.min(s + this.spec.unquoted.length, e.doc.length));
    for (; !n.next().done; )
      i(n.value.from, n.value.to);
  }
}
function jn(t, e, r, s) {
  return new iC(e.doc, t.search, {
    ignoreCase: !t.caseSensitive,
    test: t.wholeWord ? gX(e.charCategorizer(e.selection.main.head)) : void 0
  }, r, s);
}
function Tc(t, e) {
  return t.slice(Dt(t, e, !1), e);
}
function kc(t, e) {
  return t.slice(e, Dt(t, e));
}
function gX(t) {
  return (e, r, s) => !s[0].length || (t(Tc(s.input, s.index)) != Xe.Word || t(kc(s.input, s.index)) != Xe.Word) && (t(kc(s.input, s.index + s[0].length)) != Xe.Word || t(Tc(s.input, s.index + s[0].length)) != Xe.Word);
}
class yX extends oC {
  nextMatch(e, r, s) {
    let i = jn(this.spec, e, s, e.doc.length).next();
    return i.done && (i = jn(this.spec, e, 0, r).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, r, s) {
    for (let i = 1; ; i++) {
      let n = Math.max(
        r,
        s - i * 1e4
        /* FindPrev.ChunkSize */
      ), a = jn(this.spec, e, n, s), l = null;
      for (; !a.next().done; )
        l = a.value;
      if (l && (n == r || l.from > n + 10))
        return l;
      if (n == r)
        return null;
    }
  }
  prevMatch(e, r, s) {
    return this.prevMatchInRange(e, 0, r) || this.prevMatchInRange(e, s, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (r, s) => {
      if (s == "&")
        return e.match[0];
      if (s == "$")
        return "$";
      for (let i = s.length; i > 0; i--) {
        let n = +s.slice(0, i);
        if (n > 0 && n < e.match.length)
          return e.match[n] + s.slice(i);
      }
      return r;
    });
  }
  matchAll(e, r) {
    let s = jn(this.spec, e, 0, e.doc.length), i = [];
    for (; !s.next().done; ) {
      if (i.length >= r)
        return null;
      i.push(s.value);
    }
    return i;
  }
  highlight(e, r, s, i) {
    let n = jn(this.spec, e, Math.max(
      0,
      r - 250
      /* RegExp.HighlightMargin */
    ), Math.min(s + 250, e.doc.length));
    for (; !n.next().done; )
      i(n.value.from, n.value.to);
  }
}
const el = /* @__PURE__ */ pe.define(), Tg = /* @__PURE__ */ pe.define(), bi = /* @__PURE__ */ ut.define({
  create(t) {
    return new qp(Pf(t).create(), null);
  },
  update(t, e) {
    for (let r of e.effects)
      r.is(el) ? t = new qp(r.value.create(), t.panel) : r.is(Tg) && (t = new qp(t.query, r.value ? kg : null));
    return t;
  },
  provide: (t) => Go.from(t, (e) => e.panel)
});
class qp {
  constructor(e, r) {
    this.query = e, this.panel = r;
  }
}
const OX = /* @__PURE__ */ ce.mark({ class: "cm-searchMatch" }), xX = /* @__PURE__ */ ce.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), DX = /* @__PURE__ */ st.fromClass(class {
  constructor(t) {
    this.view = t, this.decorations = this.highlight(t.state.field(bi));
  }
  update(t) {
    let e = t.state.field(bi);
    (e != t.startState.field(bi) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t, panel: e }) {
    if (!e || !t.spec.valid)
      return ce.none;
    let { view: r } = this, s = new _s();
    for (let i = 0, n = r.visibleRanges, a = n.length; i < a; i++) {
      let { from: l, to: c } = n[i];
      for (; i < a - 1 && c > n[i + 1].from - 500; )
        c = n[++i].to;
      t.highlight(r.state, l, c, (p, d) => {
        let m = r.state.selection.ranges.some((y) => y.from == p && y.to == d);
        s.add(p, d, m ? xX : OX);
      });
    }
    return s.finish();
  }
}, {
  decorations: (t) => t.decorations
});
function Fl(t) {
  return (e) => {
    let r = e.state.field(bi, !1);
    return r && r.query.spec.valid ? t(e, r) : cC(e);
  };
}
const Pc = /* @__PURE__ */ Fl((t, { query: e }) => {
  let { to: r } = t.state.selection.main, s = e.nextMatch(t.state, r, r);
  if (!s)
    return !1;
  let i = L.single(s.from, s.to), n = t.state.facet(_a);
  return t.dispatch({
    selection: i,
    effects: [Pg(t, s), n.scrollToMatch(i.main, t)],
    userEvent: "select.search"
  }), uC(t), !0;
}), Fc = /* @__PURE__ */ Fl((t, { query: e }) => {
  let { state: r } = t, { from: s } = r.selection.main, i = e.prevMatch(r, s, s);
  if (!i)
    return !1;
  let n = L.single(i.from, i.to), a = t.state.facet(_a);
  return t.dispatch({
    selection: n,
    effects: [Pg(t, i), a.scrollToMatch(n.main, t)],
    userEvent: "select.search"
  }), uC(t), !0;
}), bX = /* @__PURE__ */ Fl((t, { query: e }) => {
  let r = e.matchAll(t.state, 1e3);
  return !r || !r.length ? !1 : (t.dispatch({
    selection: L.create(r.map((s) => L.range(s.from, s.to))),
    userEvent: "select.search.matches"
  }), !0);
}), vX = ({ state: t, dispatch: e }) => {
  let r = t.selection;
  if (r.ranges.length > 1 || r.main.empty)
    return !1;
  let { from: s, to: i } = r.main, n = [], a = 0;
  for (let l = new xa(t.doc, t.sliceDoc(s, i)); !l.next().done; ) {
    if (n.length > 1e3)
      return !1;
    l.value.from == s && (a = n.length), n.push(L.range(l.value.from, l.value.to));
  }
  return e(t.update({
    selection: L.create(n, a),
    userEvent: "select.search.matches"
  })), !0;
}, cx = /* @__PURE__ */ Fl((t, { query: e }) => {
  let { state: r } = t, { from: s, to: i } = r.selection.main;
  if (r.readOnly)
    return !1;
  let n = e.nextMatch(r, s, s);
  if (!n)
    return !1;
  let a = n, l = [], c, p, d = [];
  a.from == s && a.to == i && (p = r.toText(e.getReplacement(a)), l.push({ from: a.from, to: a.to, insert: p }), a = e.nextMatch(r, a.from, a.to), d.push(J.announce.of(r.phrase("replaced match on line $", r.doc.lineAt(s).number) + ".")));
  let m = t.state.changes(l);
  return a && (c = L.single(a.from, a.to).map(m), d.push(Pg(t, a)), d.push(r.facet(_a).scrollToMatch(c.main, t))), t.dispatch({
    changes: m,
    selection: c,
    effects: d,
    userEvent: "input.replace"
  }), !0;
}), SX = /* @__PURE__ */ Fl((t, { query: e }) => {
  if (t.state.readOnly)
    return !1;
  let r = e.matchAll(t.state, 1e9).map((i) => {
    let { from: n, to: a } = i;
    return { from: n, to: a, insert: e.getReplacement(i) };
  });
  if (!r.length)
    return !1;
  let s = t.state.phrase("replaced $ matches", r.length) + ".";
  return t.dispatch({
    changes: r,
    effects: J.announce.of(s),
    userEvent: "input.replace.all"
  }), !0;
});
function kg(t) {
  return t.state.facet(_a).createPanel(t);
}
function Pf(t, e) {
  var r, s, i, n, a;
  let l = t.selection.main, c = l.empty || l.to > l.from + 100 ? "" : t.sliceDoc(l.from, l.to);
  if (e && !c)
    return e;
  let p = t.facet(_a);
  return new aC({
    search: ((r = e == null ? void 0 : e.literal) !== null && r !== void 0 ? r : p.literal) ? c : c.replace(/\n/g, "\\n"),
    caseSensitive: (s = e == null ? void 0 : e.caseSensitive) !== null && s !== void 0 ? s : p.caseSensitive,
    literal: (i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : p.literal,
    regexp: (n = e == null ? void 0 : e.regexp) !== null && n !== void 0 ? n : p.regexp,
    wholeWord: (a = e == null ? void 0 : e.wholeWord) !== null && a !== void 0 ? a : p.wholeWord
  });
}
function lC(t) {
  let e = Wo(t, kg);
  return e && e.dom.querySelector("[main-field]");
}
function uC(t) {
  let e = lC(t);
  e && e == t.root.activeElement && e.select();
}
const cC = (t) => {
  let e = t.state.field(bi, !1);
  if (e && e.panel) {
    let r = lC(t);
    if (r && r != t.root.activeElement) {
      let s = Pf(t.state, e.query.spec);
      s.valid && t.dispatch({ effects: el.of(s) }), r.focus(), r.select();
    }
  } else
    t.dispatch({ effects: [
      Tg.of(!0),
      e ? el.of(Pf(t.state, e.query.spec)) : pe.appendConfig.of(EX)
    ] });
  return !0;
}, hC = (t) => {
  let e = t.state.field(bi, !1);
  if (!e || !e.panel)
    return !1;
  let r = Wo(t, kg);
  return r && r.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: Tg.of(!1) }), !0;
}, wX = [
  { key: "Mod-f", run: cC, scope: "editor search-panel" },
  { key: "F3", run: Pc, shift: Fc, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Pc, shift: Fc, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: hC, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: vX },
  { key: "Mod-Alt-g", run: tX },
  { key: "Mod-d", run: dX, preventDefault: !0 }
];
class AX {
  constructor(e) {
    this.view = e;
    let r = this.query = e.state.field(bi).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Qe("input", {
      value: r.search,
      placeholder: sr(e, "Find"),
      "aria-label": sr(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Qe("input", {
      value: r.replace,
      placeholder: sr(e, "Replace"),
      "aria-label": sr(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Qe("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: r.caseSensitive,
      onchange: this.commit
    }), this.reField = Qe("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: r.regexp,
      onchange: this.commit
    }), this.wordField = Qe("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: r.wholeWord,
      onchange: this.commit
    });
    function s(i, n, a) {
      return Qe("button", { class: "cm-button", name: i, onclick: n, type: "button" }, a);
    }
    this.dom = Qe("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      s("next", () => Pc(e), [sr(e, "next")]),
      s("prev", () => Fc(e), [sr(e, "previous")]),
      s("select", () => bX(e), [sr(e, "all")]),
      Qe("label", null, [this.caseField, sr(e, "match case")]),
      Qe("label", null, [this.reField, sr(e, "regexp")]),
      Qe("label", null, [this.wordField, sr(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Qe("br"),
        this.replaceField,
        s("replace", () => cx(e), [sr(e, "replace")]),
        s("replaceAll", () => SX(e), [sr(e, "replace all")])
      ],
      Qe("button", {
        name: "close",
        onclick: () => hC(e),
        "aria-label": sr(e, "close"),
        type: "button"
      }, [""])
    ]);
  }
  commit() {
    let e = new aC({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: el.of(e) }));
  }
  keydown(e) {
    $_(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? Fc : Pc)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), cx(this.view));
  }
  update(e) {
    for (let r of e.transactions)
      for (let s of r.effects)
        s.is(el) && !s.value.eq(this.query) && this.setQuery(s.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(_a).top;
  }
}
function sr(t, e) {
  return t.state.phrase(e);
}
const bu = 30, vu = /[\s\.,:;?!]/;
function Pg(t, { from: e, to: r }) {
  let s = t.state.doc.lineAt(e), i = t.state.doc.lineAt(r).to, n = Math.max(s.from, e - bu), a = Math.min(i, r + bu), l = t.state.sliceDoc(n, a);
  if (n != s.from) {
    for (let c = 0; c < bu; c++)
      if (!vu.test(l[c + 1]) && vu.test(l[c])) {
        l = l.slice(c);
        break;
      }
  }
  if (a != i) {
    for (let c = l.length - 1; c > l.length - bu; c--)
      if (!vu.test(l[c - 1]) && vu.test(l[c])) {
        l = l.slice(0, c);
        break;
      }
  }
  return J.announce.of(`${t.state.phrase("current match")}. ${l} ${t.state.phrase("on line")} ${s.number}.`);
}
const CX = /* @__PURE__ */ J.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), EX = [
  bi,
  /* @__PURE__ */ Li.low(DX),
  CX
];
class pC {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesin the editor, the extension will create
  these for you.)
  */
  constructor(e, r, s, i) {
    this.state = e, this.pos = r, this.explicit = s, this.view = i, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let r = Ue(this.state).resolveInner(this.pos, -1);
    for (; r && e.indexOf(r.name) < 0; )
      r = r.parent;
    return r ? {
      from: r.from,
      to: this.pos,
      text: this.state.sliceDoc(r.from, this.pos),
      type: r.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let r = this.state.doc.lineAt(this.pos), s = Math.max(r.from, this.pos - 250), i = r.text.slice(s - r.from, this.pos - r.from), n = i.search(fC(e, !1));
    return n < 0 ? null : { from: s + n, to: this.pos, text: i.slice(n) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, r, s) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(r), s && s.onDocChange && (this.abortOnDocChange = !0));
  }
}
function hx(t) {
  let e = Object.keys(t).join(""), r = /\w/.test(e);
  return r && (e = e.replace(/\w/g, "")), `[${r ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function TX(t) {
  let e = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of t) {
    e[i[0]] = !0;
    for (let n = 1; n < i.length; n++)
      r[i[n]] = !0;
  }
  let s = hx(e) + hx(r) + "*$";
  return [new RegExp("^" + s), new RegExp(s)];
}
function dC(t) {
  let e = t.map((i) => typeof i == "string" ? { label: i } : i), [r, s] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : TX(e);
  return (i) => {
    let n = i.matchBefore(s);
    return n || i.explicit ? { from: n ? n.from : i.pos, options: e, validFor: r } : null;
  };
}
function kX(t, e) {
  return (r) => {
    for (let s = Ue(r.state).resolveInner(r.pos, -1); s; s = s.parent) {
      if (t.indexOf(s.name) > -1)
        return null;
      if (s.type.isTop)
        break;
    }
    return e(r);
  };
}
class px {
  constructor(e, r, s, i) {
    this.completion = e, this.source = r, this.match = s, this.score = i;
  }
}
function an(t) {
  return t.selection.main.from;
}
function fC(t, e) {
  var r;
  let { source: s } = t, i = e && s[0] != "^", n = s[s.length - 1] != "$";
  return !i && !n ? t : new RegExp(`${i ? "^" : ""}(?:${s})${n ? "$" : ""}`, (r = t.flags) !== null && r !== void 0 ? r : t.ignoreCase ? "i" : "");
}
const Fg = /* @__PURE__ */ Ks.define();
function PX(t, e, r, s) {
  let { main: i } = t.selection, n = r - i.from, a = s - i.from;
  return Object.assign(Object.assign({}, t.changeByRange((l) => {
    if (l != i && r != s && t.sliceDoc(l.from + n, l.from + a) != t.sliceDoc(r, s))
      return { range: l };
    let c = t.toText(e);
    return {
      changes: { from: l.from + n, to: s == i.from ? l.to : l.from + a, insert: c },
      range: L.cursor(l.from + n + c.length)
    };
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const dx = /* @__PURE__ */ new WeakMap();
function FX(t) {
  if (!Array.isArray(t))
    return t;
  let e = dx.get(t);
  return e || dx.set(t, e = dC(t)), e;
}
const $c = /* @__PURE__ */ pe.define(), tl = /* @__PURE__ */ pe.define();
class $X {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let r = 0; r < e.length; ) {
      let s = Zt(e, r), i = es(s);
      this.chars.push(s);
      let n = e.slice(r, r + i), a = n.toUpperCase();
      this.folded.push(Zt(a == n ? n.toLowerCase() : a, 0)), r += i;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, r) {
    return this.score = e, this.matched = r, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: r, folded: s, any: i, precise: n, byWord: a } = this;
    if (r.length == 1) {
      let b = Zt(e, 0), k = es(b), Q = k == e.length ? 0 : -100;
      if (b != r[0]) if (b == s[0])
        Q += -200;
      else
        return null;
      return this.ret(Q, [0, k]);
    }
    let l = e.indexOf(this.pattern);
    if (l == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let c = r.length, p = 0;
    if (l < 0) {
      for (let b = 0, k = Math.min(e.length, 200); b < k && p < c; ) {
        let Q = Zt(e, b);
        (Q == r[p] || Q == s[p]) && (i[p++] = b), b += es(Q);
      }
      if (p < c)
        return null;
    }
    let d = 0, m = 0, y = !1, g = 0, x = -1, v = -1, w = /[a-z]/.test(e), C = !0;
    for (let b = 0, k = Math.min(e.length, 200), Q = 0; b < k && m < c; ) {
      let F = Zt(e, b);
      l < 0 && (d < c && F == r[d] && (n[d++] = b), g < c && (F == r[g] || F == s[g] ? (g == 0 && (x = b), v = b + 1, g++) : g = 0));
      let $, N = F < 255 ? F >= 48 && F <= 57 || F >= 97 && F <= 122 ? 2 : F >= 65 && F <= 90 ? 1 : 0 : ($ = eg(F)) != $.toLowerCase() ? 1 : $ != $.toUpperCase() ? 2 : 0;
      (!b || N == 1 && w || Q == 0 && N != 0) && (r[m] == F || s[m] == F && (y = !0) ? a[m++] = b : a.length && (C = !1)), Q = N, b += es(F);
    }
    return m == c && a[0] == 0 && C ? this.result(-100 + (y ? -200 : 0), a, e) : g == c && x == 0 ? this.ret(-200 - e.length + (v == e.length ? 0 : -100), [0, v]) : l > -1 ? this.ret(-700 - e.length, [l, l + this.pattern.length]) : g == c ? this.ret(-900 - e.length, [x, v]) : m == c ? this.result(-100 + (y ? -200 : 0) + -700 + (C ? 0 : -1100), a, e) : r.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, r, s) {
    let i = [], n = 0;
    for (let a of r) {
      let l = a + (this.astral ? es(Zt(s, a)) : 1);
      n && i[n - 1] == a ? i[n - 1] = l : (i[n++] = a, i[n++] = l);
    }
    return this.ret(e - s.length, i);
  }
}
class QX {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let r = e.slice(0, this.pattern.length), s = r == this.pattern ? 0 : r.toLowerCase() == this.folded ? -200 : null;
    return s == null ? null : (this.matched = [0, r.length], this.score = s + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const pt = /* @__PURE__ */ re.define({
  combine(t) {
    return Os(t, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: BX,
      filterStrict: !1,
      compareCompletions: (e, r) => e.label.localeCompare(r.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, r) => e && r,
      closeOnBlur: (e, r) => e && r,
      icons: (e, r) => e && r,
      tooltipClass: (e, r) => (s) => fx(e(s), r(s)),
      optionClass: (e, r) => (s) => fx(e(s), r(s)),
      addToOptions: (e, r) => e.concat(r),
      filterStrict: (e, r) => e || r
    });
  }
});
function fx(t, e) {
  return t ? e ? t + " " + e : t : e;
}
function BX(t, e, r, s, i, n) {
  let a = t.textDirection == _e.RTL, l = a, c = !1, p = "top", d, m, y = e.left - i.left, g = i.right - e.right, x = s.right - s.left, v = s.bottom - s.top;
  if (l && y < Math.min(x, g) ? l = !1 : !l && g < Math.min(x, y) && (l = !0), x <= (l ? y : g))
    d = Math.max(i.top, Math.min(r.top, i.bottom - v)) - e.top, m = Math.min(400, l ? y : g);
  else {
    c = !0, m = Math.min(
      400,
      (a ? e.right : i.right - e.left) - 30
      /* Info.Margin */
    );
    let b = i.bottom - e.bottom;
    b >= v || b > e.top ? d = r.bottom - e.top : (p = "bottom", d = e.bottom - r.top);
  }
  let w = (e.bottom - e.top) / n.offsetHeight, C = (e.right - e.left) / n.offsetWidth;
  return {
    style: `${p}: ${d / w}px; max-width: ${m / C}px`,
    class: "cm-completionInfo-" + (c ? a ? "left-narrow" : "right-narrow" : l ? "left" : "right")
  };
}
function IX(t) {
  let e = t.addToOptions.slice();
  return t.icons && e.push({
    render(r) {
      let s = document.createElement("div");
      return s.classList.add("cm-completionIcon"), r.type && s.classList.add(...r.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), s.setAttribute("aria-hidden", "true"), s;
    },
    position: 20
  }), e.push({
    render(r, s, i, n) {
      let a = document.createElement("span");
      a.className = "cm-completionLabel";
      let l = r.displayLabel || r.label, c = 0;
      for (let p = 0; p < n.length; ) {
        let d = n[p++], m = n[p++];
        d > c && a.appendChild(document.createTextNode(l.slice(c, d)));
        let y = a.appendChild(document.createElement("span"));
        y.appendChild(document.createTextNode(l.slice(d, m))), y.className = "cm-completionMatchedText", c = m;
      }
      return c < l.length && a.appendChild(document.createTextNode(l.slice(c))), a;
    },
    position: 50
  }, {
    render(r) {
      if (!r.detail)
        return null;
      let s = document.createElement("span");
      return s.className = "cm-completionDetail", s.textContent = r.detail, s;
    },
    position: 80
  }), e.sort((r, s) => r.position - s.position).map((r) => r.render);
}
function jp(t, e, r) {
  if (t <= r)
    return { from: 0, to: t };
  if (e < 0 && (e = 0), e <= t >> 1) {
    let i = Math.floor(e / r);
    return { from: i * r, to: (i + 1) * r };
  }
  let s = Math.floor((t - e) / r);
  return { from: t - (s + 1) * r, to: t - s * r };
}
class NX {
  constructor(e, r, s) {
    this.view = e, this.stateField = r, this.applyCompletion = s, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (c) => this.placeInfo(c),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(r), { options: n, selected: a } = i.open, l = e.state.facet(pt);
    this.optionContent = IX(l), this.optionClass = l.optionClass, this.tooltipClass = l.tooltipClass, this.range = jp(n.length, a, l.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (c) => {
      let { options: p } = e.state.field(r).open;
      for (let d = c.target, m; d && d != this.dom; d = d.parentNode)
        if (d.nodeName == "LI" && (m = /-(\d+)$/.exec(d.id)) && +m[1] < p.length) {
          this.applyCompletion(e, p[+m[1]]), c.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (c) => {
      let p = e.state.field(this.stateField, !1);
      p && p.tooltip && e.state.facet(pt).closeOnBlur && c.relatedTarget != e.contentDOM && e.dispatch({ effects: tl.of(null) });
    }), this.showOptions(n, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, r) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, r, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var r;
    let s = e.state.field(this.stateField), i = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), s != i) {
      let { options: n, selected: a, disabled: l } = s.open;
      (!i.open || i.open.options != n) && (this.range = jp(n.length, a, e.state.facet(pt).maxRenderedOptions), this.showOptions(n, s.id)), this.updateSel(), l != ((r = i.open) === null || r === void 0 ? void 0 : r.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!l);
    }
  }
  updateTooltipClass(e) {
    let r = this.tooltipClass(e);
    if (r != this.currentClass) {
      for (let s of this.currentClass.split(" "))
        s && this.dom.classList.remove(s);
      for (let s of r.split(" "))
        s && this.dom.classList.add(s);
      this.currentClass = r;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), r = e.open;
    if ((r.selected > -1 && r.selected < this.range.from || r.selected >= this.range.to) && (this.range = jp(r.options.length, r.selected, this.view.state.facet(pt).maxRenderedOptions), this.showOptions(r.options, e.id)), this.updateSelectedOption(r.selected)) {
      this.destroyInfo();
      let { completion: s } = r.options[r.selected], { info: i } = s;
      if (!i)
        return;
      let n = typeof i == "string" ? document.createTextNode(i) : i(s);
      if (!n)
        return;
      "then" in n ? n.then((a) => {
        a && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(a, s);
      }).catch((a) => Ut(this.view.state, a, "completion info")) : this.addInfoPane(n, s);
    }
  }
  addInfoPane(e, r) {
    this.destroyInfo();
    let s = this.info = document.createElement("div");
    if (s.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      s.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: i, destroy: n } = e;
      s.appendChild(i), this.infoDestroy = n || null;
    }
    this.dom.appendChild(s), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let r = null;
    for (let s = this.list.firstChild, i = this.range.from; s; s = s.nextSibling, i++)
      s.nodeName != "LI" || !s.id ? i-- : i == e ? s.hasAttribute("aria-selected") || (s.setAttribute("aria-selected", "true"), r = s) : s.hasAttribute("aria-selected") && s.removeAttribute("aria-selected");
    return r && LX(this.list, r), r;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let r = this.dom.getBoundingClientRect(), s = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), n = this.space;
    if (!n) {
      let a = this.dom.ownerDocument.documentElement;
      n = { left: 0, top: 0, right: a.clientWidth, bottom: a.clientHeight };
    }
    return i.top > Math.min(n.bottom, r.bottom) - 10 || i.bottom < Math.max(n.top, r.top) + 10 ? null : this.view.state.facet(pt).positionInfo(this.view, r, i, s, n, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, r, s) {
    const i = document.createElement("ul");
    i.id = r, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions")), i.addEventListener("mousedown", (a) => {
      a.target == i && a.preventDefault();
    });
    let n = null;
    for (let a = s.from; a < s.to; a++) {
      let { completion: l, match: c } = e[a], { section: p } = l;
      if (p) {
        let y = typeof p == "string" ? p : p.name;
        if (y != n && (a > s.from || s.from == 0))
          if (n = y, typeof p != "string" && p.header)
            i.appendChild(p.header(p));
          else {
            let g = i.appendChild(document.createElement("completion-section"));
            g.textContent = y;
          }
      }
      const d = i.appendChild(document.createElement("li"));
      d.id = r + "-" + a, d.setAttribute("role", "option");
      let m = this.optionClass(l);
      m && (d.className = m);
      for (let y of this.optionContent) {
        let g = y(l, this.view.state, this.view, c);
        g && d.appendChild(g);
      }
    }
    return s.from && i.classList.add("cm-completionListIncompleteTop"), s.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function MX(t, e) {
  return (r) => new NX(r, t, e);
}
function LX(t, e) {
  let r = t.getBoundingClientRect(), s = e.getBoundingClientRect(), i = r.height / t.offsetHeight;
  s.top < r.top ? t.scrollTop -= (r.top - s.top) / i : s.bottom > r.bottom && (t.scrollTop += (s.bottom - r.bottom) / i);
}
function mx(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function _X(t, e) {
  let r = [], s = null, i = (p) => {
    r.push(p);
    let { section: d } = p.completion;
    if (d) {
      s || (s = []);
      let m = typeof d == "string" ? d : d.name;
      s.some((y) => y.name == m) || s.push(typeof d == "string" ? { name: m } : d);
    }
  }, n = e.facet(pt);
  for (let p of t)
    if (p.hasResult()) {
      let d = p.result.getMatch;
      if (p.result.filter === !1)
        for (let m of p.result.options)
          i(new px(m, p.source, d ? d(m) : [], 1e9 - r.length));
      else {
        let m = e.sliceDoc(p.from, p.to), y, g = n.filterStrict ? new QX(m) : new $X(m);
        for (let x of p.result.options)
          if (y = g.match(x.label)) {
            let v = x.displayLabel ? d ? d(x, y.matched) : [] : y.matched;
            i(new px(x, p.source, v, y.score + (x.boost || 0)));
          }
      }
    }
  if (s) {
    let p = /* @__PURE__ */ Object.create(null), d = 0, m = (y, g) => {
      var x, v;
      return ((x = y.rank) !== null && x !== void 0 ? x : 1e9) - ((v = g.rank) !== null && v !== void 0 ? v : 1e9) || (y.name < g.name ? -1 : 1);
    };
    for (let y of s.sort(m))
      d -= 1e5, p[y.name] = d;
    for (let y of r) {
      let { section: g } = y.completion;
      g && (y.score += p[typeof g == "string" ? g : g.name]);
    }
  }
  let a = [], l = null, c = n.compareCompletions;
  for (let p of r.sort((d, m) => m.score - d.score || c(d.completion, m.completion))) {
    let d = p.completion;
    !l || l.label != d.label || l.detail != d.detail || l.type != null && d.type != null && l.type != d.type || l.apply != d.apply || l.boost != d.boost ? a.push(p) : mx(p.completion) > mx(l) && (a[a.length - 1] = p), l = p.completion;
  }
  return a;
}
class Wn {
  constructor(e, r, s, i, n, a) {
    this.options = e, this.attrs = r, this.tooltip = s, this.timestamp = i, this.selected = n, this.disabled = a;
  }
  setSelected(e, r) {
    return e == this.selected || e >= this.options.length ? this : new Wn(this.options, gx(r, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, r, s, i, n, a) {
    if (i && !a && e.some((p) => p.isPending))
      return i.setDisabled();
    let l = _X(e, r);
    if (!l.length)
      return i && e.some((p) => p.isPending) ? i.setDisabled() : null;
    let c = r.facet(pt).selectOnOpen ? 0 : -1;
    if (i && i.selected != c && i.selected != -1) {
      let p = i.options[i.selected].completion;
      for (let d = 0; d < l.length; d++)
        if (l[d].completion == p) {
          c = d;
          break;
        }
    }
    return new Wn(l, gx(s, c), {
      pos: e.reduce((p, d) => d.hasResult() ? Math.min(p, d.from) : p, 1e8),
      create: VX,
      above: n.aboveCursor
    }, i ? i.timestamp : Date.now(), c, !1);
  }
  map(e) {
    return new Wn(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new Wn(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class Qc {
  constructor(e, r, s) {
    this.active = e, this.id = r, this.open = s;
  }
  static start() {
    return new Qc(XX, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: r } = e, s = r.facet(pt), i = (s.override || r.languageDataAt("autocomplete", an(r)).map(FX)).map((l) => (this.active.find((c) => c.source == l) || new vr(
      l,
      this.active.some(
        (c) => c.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, s));
    i.length == this.active.length && i.every((l, c) => l == this.active[c]) && (i = this.active);
    let n = this.open, a = e.effects.some((l) => l.is($g));
    n && e.docChanged && (n = n.map(e.changes)), e.selection || i.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !RX(i, this.active) || a ? n = Wn.build(i, r, this.id, n, s, a) : n && n.disabled && !i.some((l) => l.isPending) && (n = null), !n && i.every((l) => !l.isPending) && i.some((l) => l.hasResult()) && (i = i.map((l) => l.hasResult() ? new vr(
      l.source,
      0
      /* State.Inactive */
    ) : l));
    for (let l of e.effects)
      l.is(gC) && (n = n && n.setSelected(l.value, this.id));
    return i == this.active && n == this.open ? this : new Qc(i, this.id, n);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? qX : jX;
  }
}
function RX(t, e) {
  if (t == e)
    return !0;
  for (let r = 0, s = 0; ; ) {
    for (; r < t.length && !t[r].hasResult(); )
      r++;
    for (; s < e.length && !e[s].hasResult(); )
      s++;
    let i = r == t.length, n = s == e.length;
    if (i || n)
      return i == n;
    if (t[r++].result != e[s++].result)
      return !1;
  }
}
const qX = {
  "aria-autocomplete": "list"
}, jX = {};
function gx(t, e) {
  let r = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t
  };
  return e > -1 && (r["aria-activedescendant"] = t + "-" + e), r;
}
const XX = [];
function mC(t, e) {
  if (t.isUserEvent("input.complete")) {
    let s = t.annotation(Fg);
    if (s && e.activateOnCompletion(s))
      return 12;
  }
  let r = t.isUserEvent("input.type");
  return r && e.activateOnTyping ? 5 : r ? 1 : t.isUserEvent("delete.backward") ? 2 : t.selection ? 8 : t.docChanged ? 16 : 0;
}
class vr {
  constructor(e, r, s = !1) {
    this.source = e, this.state = r, this.explicit = s;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(e, r) {
    let s = mC(e, r), i = this;
    (s & 8 || s & 16 && this.touches(e)) && (i = new vr(
      i.source,
      0
      /* State.Inactive */
    )), s & 4 && i.state == 0 && (i = new vr(
      this.source,
      1
      /* State.Pending */
    )), i = i.updateFor(e, s);
    for (let n of e.effects)
      if (n.is($c))
        i = new vr(i.source, 1, n.value);
      else if (n.is(tl))
        i = new vr(
          i.source,
          0
          /* State.Inactive */
        );
      else if (n.is($g))
        for (let a of n.value)
          a.source == i.source && (i = a);
    return i;
  }
  updateFor(e, r) {
    return this.map(e.changes);
  }
  map(e) {
    return this;
  }
  touches(e) {
    return e.changes.touchesRange(an(e.state));
  }
}
class ea extends vr {
  constructor(e, r, s, i, n, a) {
    super(e, 3, r), this.limit = s, this.result = i, this.from = n, this.to = a;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, r) {
    var s;
    if (!(r & 3))
      return this.map(e.changes);
    let i = this.result;
    i.map && !e.changes.empty && (i = i.map(i, e.changes));
    let n = e.changes.mapPos(this.from), a = e.changes.mapPos(this.to, 1), l = an(e.state);
    if (l > a || !i || r & 2 && (an(e.startState) == this.from || l < this.limit))
      return new vr(
        this.source,
        r & 4 ? 1 : 0
        /* State.Inactive */
      );
    let c = e.changes.mapPos(this.limit);
    return ZX(i.validFor, e.state, n, a) ? new ea(this.source, this.explicit, c, i, n, a) : i.update && (i = i.update(i, n, a, new pC(e.state, l, !1))) ? new ea(this.source, this.explicit, c, i, i.from, (s = i.to) !== null && s !== void 0 ? s : an(e.state)) : new vr(this.source, 1, this.explicit);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new ea(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new vr(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function ZX(t, e, r, s) {
  if (!t)
    return !1;
  let i = e.sliceDoc(r, s);
  return typeof t == "function" ? t(i, r, s, e) : fC(t, !0).test(i);
}
const $g = /* @__PURE__ */ pe.define({
  map(t, e) {
    return t.map((r) => r.map(e));
  }
}), gC = /* @__PURE__ */ pe.define(), zt = /* @__PURE__ */ ut.define({
  create() {
    return Qc.start();
  },
  update(t, e) {
    return t.update(e);
  },
  provide: (t) => [
    mg.from(t, (e) => e.tooltip),
    J.contentAttributes.from(t, (e) => e.attrs)
  ]
});
function Qg(t, e) {
  const r = e.completion.apply || e.completion.label;
  let s = t.state.field(zt).active.find((i) => i.source == e.source);
  return s instanceof ea ? (typeof r == "string" ? t.dispatch(Object.assign(Object.assign({}, PX(t.state, r, s.from, s.to)), { annotations: Fg.of(e.completion) })) : r(t, e.completion, s.from, s.to), !0) : !1;
}
const VX = /* @__PURE__ */ MX(zt, Qg);
function Su(t, e = "option") {
  return (r) => {
    let s = r.state.field(zt, !1);
    if (!s || !s.open || s.open.disabled || Date.now() - s.open.timestamp < r.state.facet(pt).interactionDelay)
      return !1;
    let i = 1, n;
    e == "page" && (n = Ww(r, s.open.tooltip)) && (i = Math.max(2, Math.floor(n.dom.offsetHeight / n.dom.querySelector("li").offsetHeight) - 1));
    let { length: a } = s.open.options, l = s.open.selected > -1 ? s.open.selected + i * (t ? 1 : -1) : t ? 0 : a - 1;
    return l < 0 ? l = e == "page" ? 0 : a - 1 : l >= a && (l = e == "page" ? a - 1 : 0), r.dispatch({ effects: gC.of(l) }), !0;
  };
}
const zX = (t) => {
  let e = t.state.field(zt, !1);
  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(pt).interactionDelay ? !1 : Qg(t, e.open.options[e.open.selected]);
}, yx = (t) => t.state.field(zt, !1) ? (t.dispatch({ effects: $c.of(!0) }), !0) : !1, UX = (t) => {
  let e = t.state.field(zt, !1);
  return !e || !e.active.some(
    (r) => r.state != 0
    /* State.Inactive */
  ) ? !1 : (t.dispatch({ effects: tl.of(null) }), !0);
};
class YX {
  constructor(e, r) {
    this.active = e, this.context = r, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const WX = 50, GX = 1e3, HX = /* @__PURE__ */ st.fromClass(class {
  constructor(t) {
    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of t.state.field(zt).active)
      e.isPending && this.startQuery(e);
  }
  update(t) {
    let e = t.state.field(zt), r = t.state.facet(pt);
    if (!t.selectionSet && !t.docChanged && t.startState.field(zt) == e)
      return;
    let s = t.transactions.some((n) => {
      let a = mC(n, r);
      return a & 8 || (n.selection || n.docChanged) && !(a & 3);
    });
    for (let n = 0; n < this.running.length; n++) {
      let a = this.running[n];
      if (s || a.context.abortOnDocChange && t.docChanged || a.updates.length + t.transactions.length > WX && Date.now() - a.time > GX) {
        for (let l of a.context.abortListeners)
          try {
            l();
          } catch (c) {
            Ut(this.view.state, c);
          }
        a.context.abortListeners = null, this.running.splice(n--, 1);
      } else
        a.updates.push(...t.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((n) => n.effects.some((a) => a.is($c))) && (this.pendingStart = !0);
    let i = this.pendingStart ? 50 : r.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((n) => n.isPending && !this.running.some((a) => a.active.source == n.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
      for (let n of t.transactions)
        n.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && n.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: t } = this.view, e = t.field(zt);
    for (let r of e.active)
      r.isPending && !this.running.some((s) => s.active.source == r.source) && this.startQuery(r);
    this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(pt).updateSyncTime));
  }
  startQuery(t) {
    let { state: e } = this.view, r = an(e), s = new pC(e, r, t.explicit, this.view), i = new YX(t, s);
    this.running.push(i), Promise.resolve(t.source(s)).then((n) => {
      i.context.aborted || (i.done = n || null, this.scheduleAccept());
    }, (n) => {
      this.view.dispatch({ effects: tl.of(null) }), Ut(this.view.state, n);
    });
  }
  scheduleAccept() {
    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(pt).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var t;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], r = this.view.state.facet(pt), s = this.view.state.field(zt);
    for (let i = 0; i < this.running.length; i++) {
      let n = this.running[i];
      if (n.done === void 0)
        continue;
      if (this.running.splice(i--, 1), n.done) {
        let l = an(n.updates.length ? n.updates[0].startState : this.view.state), c = Math.min(l, n.done.from + (n.active.explicit ? 0 : 1)), p = new ea(n.active.source, n.active.explicit, c, n.done, n.done.from, (t = n.done.to) !== null && t !== void 0 ? t : l);
        for (let d of n.updates)
          p = p.update(d, r);
        if (p.hasResult()) {
          e.push(p);
          continue;
        }
      }
      let a = s.active.find((l) => l.source == n.active.source);
      if (a && a.isPending)
        if (n.done == null) {
          let l = new vr(
            n.active.source,
            0
            /* State.Inactive */
          );
          for (let c of n.updates)
            l = l.update(c, r);
          l.isPending || e.push(l);
        } else
          this.startQuery(a);
    }
    (e.length || s.open && s.open.disabled) && this.view.dispatch({ effects: $g.of(e) });
  }
}, {
  eventHandlers: {
    blur(t) {
      let e = this.view.state.field(zt, !1);
      if (e && e.tooltip && this.view.state.facet(pt).closeOnBlur) {
        let r = e.open && Ww(this.view, e.open.tooltip);
        (!r || !r.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: tl.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: $c.of(!1) }), 20), this.composing = 0;
    }
  }
}), JX = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), KX = /* @__PURE__ */ Li.highest(/* @__PURE__ */ J.domEventHandlers({
  keydown(t, e) {
    let r = e.state.field(zt, !1);
    if (!r || !r.open || r.open.disabled || r.open.selected < 0 || t.key.length > 1 || t.ctrlKey && !(JX && t.altKey) || t.metaKey)
      return !1;
    let s = r.open.options[r.open.selected], i = r.active.find((a) => a.source == s.source), n = s.completion.commitCharacters || i.result.commitCharacters;
    return n && n.indexOf(t.key) > -1 && Qg(e, s), !1;
  }
})), yC = /* @__PURE__ */ J.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '""',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "''" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class eZ {
  constructor(e, r, s, i) {
    this.field = e, this.line = r, this.from = s, this.to = i;
  }
}
class Bg {
  constructor(e, r, s) {
    this.field = e, this.from = r, this.to = s;
  }
  map(e) {
    let r = e.mapPos(this.from, -1, Ot.TrackDel), s = e.mapPos(this.to, 1, Ot.TrackDel);
    return r == null || s == null ? null : new Bg(this.field, r, s);
  }
}
class Ig {
  constructor(e, r) {
    this.lines = e, this.fieldPositions = r;
  }
  instantiate(e, r) {
    let s = [], i = [r], n = e.doc.lineAt(r), a = /^\s*/.exec(n.text)[0];
    for (let c of this.lines) {
      if (s.length) {
        let p = a, d = /^\t*/.exec(c)[0].length;
        for (let m = 0; m < d; m++)
          p += e.facet(Dh);
        i.push(r + p.length - d), c = p + c.slice(d);
      }
      s.push(c), r += c.length + 1;
    }
    let l = this.fieldPositions.map((c) => new Bg(c.field, i[c.line] + c.from, i[c.line] + c.to));
    return { text: s, ranges: l };
  }
  static parse(e) {
    let r = [], s = [], i = [], n;
    for (let a of e.split(/\r\n?|\n/)) {
      for (; n = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(a); ) {
        let l = n[1] ? +n[1] : null, c = n[2] || n[3] || "", p = -1, d = c.replace(/\\[{}]/g, (m) => m[1]);
        for (let m = 0; m < r.length; m++)
          (l != null ? r[m].seq == l : d && r[m].name == d) && (p = m);
        if (p < 0) {
          let m = 0;
          for (; m < r.length && (l == null || r[m].seq != null && r[m].seq < l); )
            m++;
          r.splice(m, 0, { seq: l, name: d }), p = m;
          for (let y of i)
            y.field >= p && y.field++;
        }
        i.push(new eZ(p, s.length, n.index, n.index + d.length)), a = a.slice(0, n.index) + c + a.slice(n.index + n[0].length);
      }
      a = a.replace(/\\([{}])/g, (l, c, p) => {
        for (let d of i)
          d.line == s.length && d.from > p && (d.from--, d.to--);
        return c;
      }), s.push(a);
    }
    return new Ig(s, i);
  }
}
let tZ = /* @__PURE__ */ ce.widget({ widget: /* @__PURE__ */ new class extends ei {
  toDOM() {
    let t = document.createElement("span");
    return t.className = "cm-snippetFieldPosition", t;
  }
  ignoreEvent() {
    return !1;
  }
}() }), rZ = /* @__PURE__ */ ce.mark({ class: "cm-snippetField" });
class Ra {
  constructor(e, r) {
    this.ranges = e, this.active = r, this.deco = ce.set(e.map((s) => (s.from == s.to ? tZ : rZ).range(s.from, s.to)));
  }
  map(e) {
    let r = [];
    for (let s of this.ranges) {
      let i = s.map(e);
      if (!i)
        return null;
      r.push(i);
    }
    return new Ra(r, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((r) => this.ranges.some((s) => s.field == this.active && s.from <= r.from && s.to >= r.to));
  }
}
const $l = /* @__PURE__ */ pe.define({
  map(t, e) {
    return t && t.map(e);
  }
}), sZ = /* @__PURE__ */ pe.define(), rl = /* @__PURE__ */ ut.define({
  create() {
    return null;
  },
  update(t, e) {
    for (let r of e.effects) {
      if (r.is($l))
        return r.value;
      if (r.is(sZ) && t)
        return new Ra(t.ranges, r.value);
    }
    return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t;
  },
  provide: (t) => J.decorations.from(t, (e) => e ? e.deco : ce.none)
});
function Ng(t, e) {
  return L.create(t.filter((r) => r.field == e).map((r) => L.range(r.from, r.to)));
}
function iZ(t) {
  let e = Ig.parse(t);
  return (r, s, i, n) => {
    let { text: a, ranges: l } = e.instantiate(r.state, i), { main: c } = r.state.selection, p = {
      changes: { from: i, to: n == c.from ? c.to : n, insert: Se.of(a) },
      scrollIntoView: !0,
      annotations: s ? [Fg.of(s), tt.userEvent.of("input.complete")] : void 0
    };
    if (l.length && (p.selection = Ng(l, 0)), l.some((d) => d.field > 0)) {
      let d = new Ra(l, 0), m = p.effects = [$l.of(d)];
      r.state.field(rl, !1) === void 0 && m.push(pe.appendConfig.of([rl, uZ, cZ, yC]));
    }
    r.dispatch(r.state.update(p));
  };
}
function OC(t) {
  return ({ state: e, dispatch: r }) => {
    let s = e.field(rl, !1);
    if (!s || t < 0 && s.active == 0)
      return !1;
    let i = s.active + t, n = t > 0 && !s.ranges.some((a) => a.field == i + t);
    return r(e.update({
      selection: Ng(s.ranges, i),
      effects: $l.of(n ? null : new Ra(s.ranges, i)),
      scrollIntoView: !0
    })), !0;
  };
}
const nZ = ({ state: t, dispatch: e }) => t.field(rl, !1) ? (e(t.update({ effects: $l.of(null) })), !0) : !1, aZ = /* @__PURE__ */ OC(1), oZ = /* @__PURE__ */ OC(-1), lZ = [
  { key: "Tab", run: aZ, shift: oZ },
  { key: "Escape", run: nZ }
], Ox = /* @__PURE__ */ re.define({
  combine(t) {
    return t.length ? t[0] : lZ;
  }
}), uZ = /* @__PURE__ */ Li.highest(/* @__PURE__ */ Cl.compute([Ox], (t) => t.facet(Ox)));
function Rt(t, e) {
  return Object.assign(Object.assign({}, e), { apply: iZ(t) });
}
const cZ = /* @__PURE__ */ J.domEventHandlers({
  mousedown(t, e) {
    let r = e.state.field(rl, !1), s;
    if (!r || (s = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null)
      return !1;
    let i = r.ranges.find((n) => n.from <= s && n.to >= s);
    return !i || i.field == r.active ? !1 : (e.dispatch({
      selection: Ng(r.ranges, i.field),
      effects: $l.of(r.ranges.some((n) => n.field > i.field) ? new Ra(r.ranges, i.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), sl = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, Hi = /* @__PURE__ */ pe.define({
  map(t, e) {
    let r = e.mapPos(t, -1, Ot.TrackAfter);
    return r == null ? void 0 : r;
  }
}), Mg = /* @__PURE__ */ new class extends dn {
}();
Mg.startSide = 1;
Mg.endSide = -1;
const xC = /* @__PURE__ */ ut.define({
  create() {
    return Ce.empty;
  },
  update(t, e) {
    if (t = t.map(e.changes), e.selection) {
      let r = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (s) => s >= r.from && s <= r.to });
    }
    for (let r of e.effects)
      r.is(Hi) && (t = t.update({ add: [Mg.range(r.value, r.value + 1)] }));
    return t;
  }
});
function hZ() {
  return [dZ, xC];
}
const Xp = "()[]{}<>";
function DC(t) {
  for (let e = 0; e < Xp.length; e += 2)
    if (Xp.charCodeAt(e) == t)
      return Xp.charAt(e + 1);
  return eg(t < 128 ? t : t + 1);
}
function bC(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || sl;
}
const pZ = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), dZ = /* @__PURE__ */ J.inputHandler.of((t, e, r, s) => {
  if ((pZ ? t.composing : t.compositionStarted) || t.state.readOnly)
    return !1;
  let i = t.state.selection.main;
  if (s.length > 2 || s.length == 2 && es(Zt(s, 0)) == 1 || e != i.from || r != i.to)
    return !1;
  let n = gZ(t.state, s);
  return n ? (t.dispatch(n), !0) : !1;
}), fZ = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = bC(t, t.selection.main.head).brackets || sl.brackets, s = null, i = t.changeByRange((n) => {
    if (n.empty) {
      let a = yZ(t.doc, n.head);
      for (let l of r)
        if (l == a && kh(t.doc, n.head) == DC(Zt(l, 0)))
          return {
            changes: { from: n.head - l.length, to: n.head + l.length },
            range: L.cursor(n.head - l.length)
          };
    }
    return { range: s = n };
  });
  return s || e(t.update(i, { scrollIntoView: !0, userEvent: "delete.backward" })), !s;
}, mZ = [
  { key: "Backspace", run: fZ }
];
function gZ(t, e) {
  let r = bC(t, t.selection.main.head), s = r.brackets || sl.brackets;
  for (let i of s) {
    let n = DC(Zt(i, 0));
    if (e == i)
      return n == i ? DZ(t, i, s.indexOf(i + i + i) > -1, r) : OZ(t, i, n, r.before || sl.before);
    if (e == n && vC(t, t.selection.main.from))
      return xZ(t, i, n);
  }
  return null;
}
function vC(t, e) {
  let r = !1;
  return t.field(xC).between(0, t.doc.length, (s) => {
    s == e && (r = !0);
  }), r;
}
function kh(t, e) {
  let r = t.sliceString(e, e + 2);
  return r.slice(0, es(Zt(r, 0)));
}
function yZ(t, e) {
  let r = t.sliceString(e - 2, e);
  return es(Zt(r, 0)) == r.length ? r : r.slice(1);
}
function OZ(t, e, r, s) {
  let i = null, n = t.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: r, from: a.to }],
        effects: Hi.of(a.to + e.length),
        range: L.range(a.anchor + e.length, a.head + e.length)
      };
    let l = kh(t.doc, a.head);
    return !l || /\s/.test(l) || s.indexOf(l) > -1 ? {
      changes: { insert: e + r, from: a.head },
      effects: Hi.of(a.head + e.length),
      range: L.cursor(a.head + e.length)
    } : { range: i = a };
  });
  return i ? null : t.update(n, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function xZ(t, e, r) {
  let s = null, i = t.changeByRange((n) => n.empty && kh(t.doc, n.head) == r ? {
    changes: { from: n.head, to: n.head + r.length, insert: r },
    range: L.cursor(n.head + r.length)
  } : s = { range: n });
  return s ? null : t.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function DZ(t, e, r, s) {
  let i = s.stringPrefixes || sl.stringPrefixes, n = null, a = t.changeByRange((l) => {
    if (!l.empty)
      return {
        changes: [{ insert: e, from: l.from }, { insert: e, from: l.to }],
        effects: Hi.of(l.to + e.length),
        range: L.range(l.anchor + e.length, l.head + e.length)
      };
    let c = l.head, p = kh(t.doc, c), d;
    if (p == e) {
      if (xx(t, c))
        return {
          changes: { insert: e + e, from: c },
          effects: Hi.of(c + e.length),
          range: L.cursor(c + e.length)
        };
      if (vC(t, c)) {
        let m = r && t.sliceDoc(c, c + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: c, to: c + m.length, insert: m },
          range: L.cursor(c + m.length)
        };
      }
    } else {
      if (r && t.sliceDoc(c - 2 * e.length, c) == e + e && (d = Dx(t, c - 2 * e.length, i)) > -1 && xx(t, d))
        return {
          changes: { insert: e + e + e + e, from: c },
          effects: Hi.of(c + e.length),
          range: L.cursor(c + e.length)
        };
      if (t.charCategorizer(c)(p) != Xe.Word && Dx(t, c, i) > -1 && !bZ(t, c, e, i))
        return {
          changes: { insert: e + e, from: c },
          effects: Hi.of(c + e.length),
          range: L.cursor(c + e.length)
        };
    }
    return { range: n = l };
  });
  return n ? null : t.update(a, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function xx(t, e) {
  let r = Ue(t).resolveInner(e + 1);
  return r.parent && r.from == e;
}
function bZ(t, e, r, s) {
  let i = Ue(t).resolveInner(e, -1), n = s.reduce((a, l) => Math.max(a, l.length), 0);
  for (let a = 0; a < 5; a++) {
    let l = t.sliceDoc(i.from, Math.min(i.to, i.from + r.length + n)), c = l.indexOf(r);
    if (!c || c > -1 && s.indexOf(l.slice(0, c)) > -1) {
      let d = i.firstChild;
      for (; d && d.from == i.from && d.to - d.from > r.length + c; ) {
        if (t.sliceDoc(d.to - r.length, d.to) == r)
          return !1;
        d = d.firstChild;
      }
      return !0;
    }
    let p = i.to == e && i.parent;
    if (!p)
      break;
    i = p;
  }
  return !1;
}
function Dx(t, e, r) {
  let s = t.charCategorizer(e);
  if (s(t.sliceDoc(e - 1, e)) != Xe.Word)
    return e;
  for (let i of r) {
    let n = e - i.length;
    if (t.sliceDoc(n, e) == i && s(t.sliceDoc(n - 1, n)) != Xe.Word)
      return n;
  }
  return -1;
}
function vZ(t = {}) {
  return [
    KX,
    zt,
    pt.of(t),
    HX,
    SZ,
    yC
  ];
}
const SC = [
  { key: "Ctrl-Space", run: yx },
  { mac: "Alt-`", run: yx },
  { key: "Escape", run: UX },
  { key: "ArrowDown", run: /* @__PURE__ */ Su(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Su(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Su(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Su(!1, "page") },
  { key: "Enter", run: zX }
], SZ = /* @__PURE__ */ Li.highest(/* @__PURE__ */ Cl.computeN([pt], (t) => t.facet(pt).defaultKeymap ? [SC] : []));
class bx {
  constructor(e, r, s) {
    this.from = e, this.to = r, this.diagnostic = s;
  }
}
class zi {
  constructor(e, r, s) {
    this.diagnostics = e, this.panel = r, this.selected = s;
  }
  static init(e, r, s) {
    let i = s.facet(il).markerFilter;
    i && (e = i(e, s));
    let n = e.slice().sort((d, m) => d.from - m.from || d.to - m.to), a = new _s(), l = [], c = 0;
    for (let d = 0; ; ) {
      let m = d == n.length ? null : n[d];
      if (!m && !l.length)
        break;
      let y, g;
      for (l.length ? (y = c, g = l.reduce((v, w) => Math.min(v, w.to), m && m.from > y ? m.from : 1e8)) : (y = m.from, g = m.to, l.push(m), d++); d < n.length; ) {
        let v = n[d];
        if (v.from == y && (v.to > v.from || v.to == y))
          l.push(v), d++, g = Math.min(v.to, g);
        else {
          g = Math.min(v.from, g);
          break;
        }
      }
      let x = NZ(l);
      if (l.some((v) => v.from == v.to || v.from == v.to - 1 && s.doc.lineAt(v.from).to == v.from))
        a.add(y, y, ce.widget({
          widget: new $Z(x),
          diagnostics: l.slice()
        }));
      else {
        let v = l.reduce((w, C) => C.markClass ? w + " " + C.markClass : w, "");
        a.add(y, g, ce.mark({
          class: "cm-lintRange cm-lintRange-" + x + v,
          diagnostics: l.slice(),
          inclusiveEnd: l.some((w) => w.to > g)
        }));
      }
      c = g;
      for (let v = 0; v < l.length; v++)
        l[v].to <= c && l.splice(v--, 1);
    }
    let p = a.finish();
    return new zi(p, r, Da(p));
  }
}
function Da(t, e = null, r = 0) {
  let s = null;
  return t.between(r, 1e9, (i, n, { spec: a }) => {
    if (!(e && a.diagnostics.indexOf(e) < 0))
      if (!s)
        s = new bx(i, n, e || a.diagnostics[0]);
      else {
        if (a.diagnostics.indexOf(s.diagnostic) < 0)
          return !1;
        s = new bx(s.from, n, s.diagnostic);
      }
  }), s;
}
function wZ(t, e) {
  let r = e.pos, s = e.end || r, i = t.state.facet(il).hideOn(t, r, s);
  if (i != null)
    return i;
  let n = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((a) => a.is(Lg)) || t.changes.touchesRange(n.from, Math.max(n.to, s)));
}
function wC(t, e) {
  return t.field(lr, !1) ? e : e.concat(pe.appendConfig.of(MZ));
}
function AZ(t, e) {
  return {
    effects: wC(t, [Lg.of(e)])
  };
}
const Lg = /* @__PURE__ */ pe.define(), _g = /* @__PURE__ */ pe.define(), AC = /* @__PURE__ */ pe.define(), lr = /* @__PURE__ */ ut.define({
  create() {
    return new zi(ce.none, null, null);
  },
  update(t, e) {
    if (e.docChanged && t.diagnostics.size) {
      let r = t.diagnostics.map(e.changes), s = null, i = t.panel;
      if (t.selected) {
        let n = e.changes.mapPos(t.selected.from, 1);
        s = Da(r, t.selected.diagnostic, n) || Da(r, null, n);
      }
      !r.size && i && e.state.facet(il).autoPanel && (i = null), t = new zi(r, i, s);
    }
    for (let r of e.effects)
      if (r.is(Lg)) {
        let s = e.state.facet(il).autoPanel ? r.value.length ? nl.open : null : t.panel;
        t = zi.init(r.value, s, e.state);
      } else r.is(_g) ? t = new zi(t.diagnostics, r.value ? nl.open : null, t.selected) : r.is(AC) && (t = new zi(t.diagnostics, t.panel, r.value));
    return t;
  },
  provide: (t) => [
    Go.from(t, (e) => e.panel),
    J.decorations.from(t, (e) => e.diagnostics)
  ]
}), CZ = /* @__PURE__ */ ce.mark({ class: "cm-lintRange cm-lintRange-active" });
function EZ(t, e, r) {
  let { diagnostics: s } = t.state.field(lr), i, n = -1, a = -1;
  s.between(e - (r < 0 ? 1 : 0), e + (r > 0 ? 1 : 0), (c, p, { spec: d }) => {
    if (e >= c && e <= p && (c == p || (e > c || r > 0) && (e < p || r < 0)))
      return i = d.diagnostics, n = c, a = p, !1;
  });
  let l = t.state.facet(il).tooltipFilter;
  return i && l && (i = l(i, t.state)), i ? {
    pos: n,
    end: a,
    above: t.state.doc.lineAt(n).to < a,
    create() {
      return { dom: TZ(t, i) };
    }
  } : null;
}
function TZ(t, e) {
  return Qe("ul", { class: "cm-tooltip-lint" }, e.map((r) => EC(t, r, !1)));
}
const kZ = (t) => {
  let e = t.state.field(lr, !1);
  (!e || !e.panel) && t.dispatch({ effects: wC(t.state, [_g.of(!0)]) });
  let r = Wo(t, nl.open);
  return r && r.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, vx = (t) => {
  let e = t.state.field(lr, !1);
  return !e || !e.panel ? !1 : (t.dispatch({ effects: _g.of(!1) }), !0);
}, PZ = (t) => {
  let e = t.state.field(lr, !1);
  if (!e)
    return !1;
  let r = t.state.selection.main, s = e.diagnostics.iter(r.to + 1);
  return !s.value && (s = e.diagnostics.iter(0), !s.value || s.from == r.from && s.to == r.to) ? !1 : (t.dispatch({ selection: { anchor: s.from, head: s.to }, scrollIntoView: !0 }), !0);
}, FZ = [
  { key: "Mod-Shift-m", run: kZ, preventDefault: !0 },
  { key: "F8", run: PZ }
], il = /* @__PURE__ */ re.define({
  combine(t) {
    return Object.assign({ sources: t.map((e) => e.source).filter((e) => e != null) }, Os(t.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (e, r) => e ? r ? (s) => e(s) || r(s) : e : r
    }));
  }
});
function CC(t) {
  let e = [];
  if (t)
    e: for (let { name: r } of t) {
      for (let s = 0; s < r.length; s++) {
        let i = r[s];
        if (/[a-zA-Z]/.test(i) && !e.some((n) => n.toLowerCase() == i.toLowerCase())) {
          e.push(i);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function EC(t, e, r) {
  var s;
  let i = r ? CC(e.actions) : [];
  return Qe("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Qe("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(t) : e.message), (s = e.actions) === null || s === void 0 ? void 0 : s.map((n, a) => {
    let l = !1, c = (y) => {
      if (y.preventDefault(), l)
        return;
      l = !0;
      let g = Da(t.state.field(lr).diagnostics, e);
      g && n.apply(t, g.from, g.to);
    }, { name: p } = n, d = i[a] ? p.indexOf(i[a]) : -1, m = d < 0 ? p : [
      p.slice(0, d),
      Qe("u", p.slice(d, d + 1)),
      p.slice(d + 1)
    ];
    return Qe("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: c,
      onmousedown: c,
      "aria-label": ` Action: ${p}${d < 0 ? "" : ` (access key "${i[a]})"`}.`
    }, m);
  }), e.source && Qe("div", { class: "cm-diagnosticSource" }, e.source));
}
class $Z extends ei {
  constructor(e) {
    super(), this.sev = e;
  }
  eq(e) {
    return e.sev == this.sev;
  }
  toDOM() {
    return Qe("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class Sx {
  constructor(e, r) {
    this.diagnostic = r, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = EC(e, r, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class nl {
  constructor(e) {
    this.view = e, this.items = [];
    let r = (i) => {
      if (i.keyCode == 27)
        vx(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: n } = this.items[this.selectedIndex], a = CC(n.actions);
        for (let l = 0; l < a.length; l++)
          if (a[l].toUpperCase().charCodeAt(0) == i.keyCode) {
            let c = Da(this.view.state.field(lr).diagnostics, n);
            c && n.actions[l].apply(e, c.from, c.to);
          }
      } else
        return;
      i.preventDefault();
    }, s = (i) => {
      for (let n = 0; n < this.items.length; n++)
        this.items[n].dom.contains(i.target) && this.moveSelection(n);
    };
    this.list = Qe("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: r,
      onclick: s
    }), this.dom = Qe("div", { class: "cm-panel-lint" }, this.list, Qe("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => vx(this.view)
    }, "")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(lr).selected;
    if (!e)
      return -1;
    for (let r = 0; r < this.items.length; r++)
      if (this.items[r].diagnostic == e.diagnostic)
        return r;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: r } = this.view.state.field(lr), s = 0, i = !1, n = null, a = /* @__PURE__ */ new Set();
    for (e.between(0, this.view.state.doc.length, (l, c, { spec: p }) => {
      for (let d of p.diagnostics) {
        if (a.has(d))
          continue;
        a.add(d);
        let m = -1, y;
        for (let g = s; g < this.items.length; g++)
          if (this.items[g].diagnostic == d) {
            m = g;
            break;
          }
        m < 0 ? (y = new Sx(this.view, d), this.items.splice(s, 0, y), i = !0) : (y = this.items[m], m > s && (this.items.splice(s, m - s), i = !0)), r && y.diagnostic == r.diagnostic ? y.dom.hasAttribute("aria-selected") || (y.dom.setAttribute("aria-selected", "true"), n = y) : y.dom.hasAttribute("aria-selected") && y.dom.removeAttribute("aria-selected"), s++;
      }
    }); s < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new Sx(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), n ? (this.list.setAttribute("aria-activedescendant", n.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: n.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: l, panel: c }) => {
        let p = c.height / this.list.offsetHeight;
        l.top < c.top ? this.list.scrollTop -= (c.top - l.top) / p : l.bottom > c.bottom && (this.list.scrollTop += (l.bottom - c.bottom) / p);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function r() {
      let s = e;
      e = s.nextSibling, s.remove();
    }
    for (let s of this.items)
      if (s.dom.parentNode == this.list) {
        for (; e != s.dom; )
          r();
        e = s.dom.nextSibling;
      } else
        this.list.insertBefore(s.dom, e);
    for (; e; )
      r();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let r = this.view.state.field(lr), s = Da(r.diagnostics, this.items[e].diagnostic);
    s && this.view.dispatch({
      selection: { anchor: s.from, head: s.to },
      scrollIntoView: !0,
      effects: AC.of(s)
    });
  }
  static open(e) {
    return new nl(e);
  }
}
function QZ(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function wu(t) {
  return QZ(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const BZ = /* @__PURE__ */ J.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ wu("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ wu("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ wu("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ wu("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function IZ(t) {
  return t == "error" ? 4 : t == "warning" ? 3 : t == "info" ? 2 : 1;
}
function NZ(t) {
  let e = "hint", r = 1;
  for (let s of t) {
    let i = IZ(s.severity);
    i > r && (r = i, e = s.severity);
  }
  return e;
}
const MZ = [
  lr,
  /* @__PURE__ */ J.decorations.compute([lr], (t) => {
    let { selected: e, panel: r } = t.field(lr);
    return !e || !r || e.from == e.to ? ce.none : ce.set([
      CZ.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ OR(EZ, { hideOn: wZ }),
  BZ
], LZ = [
  kR(),
  $R(),
  W_(),
  Jq(),
  Cq(),
  L_(),
  X_(),
  we.allowMultipleSelections.of(!0),
  dq(),
  DA(Pq, { fallback: !0 }),
  Mq(),
  hZ(),
  vZ(),
  oR(),
  cR(),
  tR(),
  nX(),
  Cl.of([
    ...mZ,
    ...Jj,
    ...wX,
    ...oj,
    ...vq,
    ...SC,
    ...FZ
  ])
];
class Bc {
  /**
  @internal
  */
  constructor(e, r, s, i, n, a, l, c, p, d = 0, m) {
    this.p = e, this.stack = r, this.state = s, this.reducePos = i, this.pos = n, this.score = a, this.buffer = l, this.bufferBase = c, this.curContext = p, this.lookAhead = d, this.parent = m;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, r) => r % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, r, s = 0) {
    let i = e.parser.context;
    return new Bc(e, [], r, s, s, 0, [], 0, i ? new wx(i, i.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, r) {
    this.stack.push(this.state, r, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var r;
    let s = e >> 19, i = e & 65535, { parser: n } = this.p, a = this.reducePos < this.pos - 25;
    a && this.setLookAhead(this.pos);
    let l = n.dynamicPrecedence(i);
    if (l && (this.score += l), s == 0) {
      this.pushState(n.getGoto(this.state, i, !0), this.reducePos), i < n.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, a ? 8 : 4, !0), this.reduceContext(i, this.reducePos);
      return;
    }
    let c = this.stack.length - (s - 1) * 3 - (e & 262144 ? 6 : 0), p = c ? this.stack[c - 2] : this.p.ranges[0].from, d = this.reducePos - p;
    d >= 2e3 && !(!((r = this.p.parser.nodeSet.types[i]) === null || r === void 0) && r.isAnonymous) && (p == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = d) : this.p.lastBigReductionSize < d && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = p, this.p.lastBigReductionSize = d));
    let m = c ? this.stack[c - 1] : 0, y = this.bufferBase + this.buffer.length - m;
    if (i < n.minRepeatTerm || e & 131072) {
      let g = n.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(i, p, g, y + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[c];
    else {
      let g = this.stack[c - 3];
      this.state = n.getGoto(g, i, !0);
    }
    for (; this.stack.length > c; )
      this.stack.pop();
    this.reduceContext(i, p);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, r, s, i = 4, n = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let a = this, l = this.buffer.length;
      if (l == 0 && a.parent && (l = a.bufferBase - a.parent.bufferBase, a = a.parent), l > 0 && a.buffer[l - 4] == 0 && a.buffer[l - 1] > -1) {
        if (r == s)
          return;
        if (a.buffer[l - 2] >= r) {
          a.buffer[l - 2] = s;
          return;
        }
      }
    }
    if (!n || this.pos == s)
      this.buffer.push(e, r, s, i);
    else {
      let a = this.buffer.length;
      if (a > 0 && this.buffer[a - 4] != 0) {
        let l = !1;
        for (let c = a; c > 0 && this.buffer[c - 2] > s; c -= 4)
          if (this.buffer[c - 1] >= 0) {
            l = !0;
            break;
          }
        if (l)
          for (; a > 0 && this.buffer[a - 2] > s; )
            this.buffer[a] = this.buffer[a - 4], this.buffer[a + 1] = this.buffer[a - 3], this.buffer[a + 2] = this.buffer[a - 2], this.buffer[a + 3] = this.buffer[a - 1], a -= 4, i > 4 && (i -= 4);
      }
      this.buffer[a] = e, this.buffer[a + 1] = r, this.buffer[a + 2] = s, this.buffer[a + 3] = i;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, r, s, i) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if ((e & 262144) == 0) {
      let n = e, { parser: a } = this.p;
      (i > this.pos || r <= a.maxNode) && (this.pos = i, a.stateFlag(
        n,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = i)), this.pushState(n, s), this.shiftContext(r, s), r <= a.maxNode && this.buffer.push(r, s, i, 4);
    } else
      this.pos = i, this.shiftContext(r, s), r <= this.p.parser.maxNode && this.buffer.push(r, s, i, 4);
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, r, s, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, r, s, i);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, r) {
    let s = this.p.reused.length - 1;
    (s < 0 || this.p.reused[s] != e) && (this.p.reused.push(e), s++);
    let i = this.pos;
    this.reducePos = this.pos = i + e.length, this.pushState(r, i), this.buffer.push(
      s,
      i,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, r = e.buffer.length;
    for (; r > 0 && e.buffer[r - 2] > e.reducePos; )
      r -= 4;
    let s = e.buffer.slice(r), i = e.bufferBase + r;
    for (; e && i == e.bufferBase; )
      e = e.parent;
    return new Bc(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, s, i, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, r) {
    let s = e <= this.p.parser.maxNode;
    s && this.storeNode(e, this.pos, r, 4), this.storeNode(0, this.pos, r, s ? 8 : 4), this.pos = this.reducePos = r, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let r = new _Z(this); ; ) {
      let s = this.p.parser.stateSlot(
        r.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(r.state, e);
      if (s == 0)
        return !1;
      if ((s & 65536) == 0)
        return !0;
      r.reduce(s);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let r = this.p.parser.nextStates(this.state);
    if (r.length > 8 || this.stack.length >= 120) {
      let i = [];
      for (let n = 0, a; n < r.length; n += 2)
        (a = r[n + 1]) != this.state && this.p.parser.hasAction(a, e) && i.push(r[n], a);
      if (this.stack.length < 120)
        for (let n = 0; i.length < 8 && n < r.length; n += 2) {
          let a = r[n + 1];
          i.some((l, c) => c & 1 && l == a) || i.push(r[n], a);
        }
      r = i;
    }
    let s = [];
    for (let i = 0; i < r.length && s.length < 4; i += 2) {
      let n = r[i + 1];
      if (n == this.state)
        continue;
      let a = this.split();
      a.pushState(n, this.pos), a.storeNode(0, a.pos, a.pos, 4, !0), a.shiftContext(r[i], this.pos), a.reducePos = this.pos, a.score -= 200, s.push(a);
    }
    return s;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, r = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((r & 65536) == 0)
      return !1;
    if (!e.validAction(this.state, r)) {
      let s = r >> 19, i = r & 65535, n = this.stack.length - s * 3;
      if (n < 0 || e.getGoto(this.stack[n], i, !1) < 0) {
        let a = this.findForcedReduction();
        if (a == null)
          return !1;
        r = a;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(r), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, r = [], s = (i, n) => {
      if (!r.includes(i))
        return r.push(i), e.allActions(i, (a) => {
          if (!(a & 393216)) if (a & 65536) {
            let l = (a >> 19) - n;
            if (l > 1) {
              let c = a & 65535, p = this.stack.length - l * 3;
              if (p >= 0 && e.getGoto(this.stack[p], c, !1) >= 0)
                return l << 19 | 65536 | c;
            }
          } else {
            let l = s(a, n + 1);
            if (l != null)
              return l;
          }
        });
    };
    return s(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let r = 0; r < this.stack.length; r += 3)
      if (this.stack[r] != e.stack[r])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, r) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(r)));
  }
  reduceContext(e, r) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(r)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let r = new wx(this.curContext.tracker, e);
      r.hash != this.curContext.hash && this.emitContext(), this.curContext = r;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class wx {
  constructor(e, r) {
    this.tracker = e, this.context = r, this.hash = e.strict ? e.hash(r) : 0;
  }
}
class _Z {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let r = e & 65535, s = e >> 19;
    s == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (s - 1) * 3;
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], r, !0);
    this.state = i;
  }
}
class Ic {
  constructor(e, r, s) {
    this.stack = e, this.pos = r, this.index = s, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, r = e.bufferBase + e.buffer.length) {
    return new Ic(e, r, r - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new Ic(this.stack, this.pos, this.index);
  }
}
function mo(t, e = Uint16Array) {
  if (typeof t != "string")
    return t;
  let r = null;
  for (let s = 0, i = 0; s < t.length; ) {
    let n = 0;
    for (; ; ) {
      let a = t.charCodeAt(s++), l = !1;
      if (a == 126) {
        n = 65535;
        break;
      }
      a >= 92 && a--, a >= 34 && a--;
      let c = a - 32;
      if (c >= 46 && (c -= 46, l = !0), n += c, l)
        break;
      n *= 46;
    }
    r ? r[i++] = n : r = new e(n);
  }
  return r;
}
class zu {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const Ax = new zu();
class RZ {
  /**
  @internal
  */
  constructor(e, r) {
    this.input = e, this.ranges = r, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = Ax, this.rangeIndex = 0, this.pos = this.chunkPos = r[0].from, this.range = r[0], this.end = r[r.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, r) {
    let s = this.range, i = this.rangeIndex, n = this.pos + e;
    for (; n < s.from; ) {
      if (!i)
        return null;
      let a = this.ranges[--i];
      n -= s.from - a.to, s = a;
    }
    for (; r < 0 ? n > s.to : n >= s.to; ) {
      if (i == this.ranges.length - 1)
        return null;
      let a = this.ranges[++i];
      n += a.from - s.to, s = a;
    }
    return n;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let r of this.ranges)
      if (r.to > e)
        return Math.max(e, r.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingwhen looking forwardor even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let r = this.chunkOff + e, s, i;
    if (r >= 0 && r < this.chunk.length)
      s = this.pos + e, i = this.chunk.charCodeAt(r);
    else {
      let n = this.resolveOffset(e, 1);
      if (n == null)
        return -1;
      if (s = n, s >= this.chunk2Pos && s < this.chunk2Pos + this.chunk2.length)
        i = this.chunk2.charCodeAt(s - this.chunk2Pos);
      else {
        let a = this.rangeIndex, l = this.range;
        for (; l.to <= s; )
          l = this.ranges[++a];
        this.chunk2 = this.input.chunk(this.chunk2Pos = s), s + this.chunk2.length > l.to && (this.chunk2 = this.chunk2.slice(0, l.to - s)), i = this.chunk2.charCodeAt(0);
      }
    }
    return s >= this.token.lookAhead && (this.token.lookAhead = s + 1), i;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, r = 0) {
    let s = r ? this.resolveOffset(r, -1) : this.pos;
    if (s == null || s < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = s;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, r) {
    this.token.value = e, this.token.end = r;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: r } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = r, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), r = this.pos + e.length;
      this.chunk = r > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, r) {
    if (r ? (this.token = r, r.start = e, r.lookAhead = e + 1, r.value = r.extended = -1) : this.token = Ax, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, r) {
    if (e >= this.chunkPos && r <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, r - this.chunkPos);
    if (e >= this.chunk2Pos && r <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, r - this.chunk2Pos);
    if (e >= this.range.from && r <= this.range.to)
      return this.input.read(e, r);
    let s = "";
    for (let i of this.ranges) {
      if (i.from >= r)
        break;
      i.to > e && (s += this.input.read(Math.max(i.from, e), Math.min(i.to, r)));
    }
    return s;
  }
}
class ta {
  constructor(e, r) {
    this.data = e, this.id = r;
  }
  token(e, r) {
    let { parser: s } = r.p;
    TC(this.data, e, r, this.id, s.data, s.tokenPrecTable);
  }
}
ta.prototype.contextual = ta.prototype.fallback = ta.prototype.extend = !1;
class Nc {
  constructor(e, r, s) {
    this.precTable = r, this.elseToken = s, this.data = typeof e == "string" ? mo(e) : e;
  }
  token(e, r) {
    let s = e.pos, i = 0;
    for (; ; ) {
      let n = e.next < 0, a = e.resolveOffset(1, 1);
      if (TC(this.data, e, r, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (n || i++, a == null)
        break;
      e.reset(a, e.token);
    }
    i && (e.reset(s, e.token), e.acceptToken(this.elseToken, i));
  }
}
Nc.prototype.contextual = ta.prototype.fallback = ta.prototype.extend = !1;
class mr {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, r = {}) {
    this.token = e, this.contextual = !!r.contextual, this.fallback = !!r.fallback, this.extend = !!r.extend;
  }
}
function TC(t, e, r, s, i, n) {
  let a = 0, l = 1 << s, { dialect: c } = r.p.parser;
  e: for (; (l & t[a]) != 0; ) {
    let p = t[a + 1];
    for (let g = a + 3; g < p; g += 2)
      if ((t[g + 1] & l) > 0) {
        let x = t[g];
        if (c.allows(x) && (e.token.value == -1 || e.token.value == x || qZ(x, e.token.value, i, n))) {
          e.acceptToken(x);
          break;
        }
      }
    let d = e.next, m = 0, y = t[a + 2];
    if (e.next < 0 && y > m && t[p + y * 3 - 3] == 65535) {
      a = t[p + y * 3 - 1];
      continue e;
    }
    for (; m < y; ) {
      let g = m + y >> 1, x = p + g + (g << 1), v = t[x], w = t[x + 1] || 65536;
      if (d < v)
        y = g;
      else if (d >= w)
        m = g + 1;
      else {
        a = t[x + 2], e.advance();
        continue e;
      }
    }
    break;
  }
}
function Cx(t, e, r) {
  for (let s = e, i; (i = t[s]) != 65535; s++)
    if (i == r)
      return s - e;
  return -1;
}
function qZ(t, e, r, s) {
  let i = Cx(r, s, e);
  return i < 0 || Cx(r, s, t) < i;
}
const ir = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
let Zp = null;
function Ex(t, e, r) {
  let s = t.cursor(Ne.IncludeAnonymous);
  for (s.moveTo(e); ; )
    if (!(r < 0 ? s.childBefore(e) : s.childAfter(e)))
      for (; ; ) {
        if ((r < 0 ? s.to < e : s.from > e) && !s.type.isError)
          return r < 0 ? Math.max(0, Math.min(
            s.to - 1,
            e - 25
            /* Lookahead.Margin */
          )) : Math.min(t.length, Math.max(
            s.from + 1,
            e + 25
            /* Lookahead.Margin */
          ));
        if (r < 0 ? s.prevSibling() : s.nextSibling())
          break;
        if (!s.parent())
          return r < 0 ? 0 : t.length;
      }
}
class jZ {
  constructor(e, r) {
    this.fragments = e, this.nodeSet = r, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? Ex(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? Ex(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let r = this.trees.length - 1;
      if (r < 0)
        return this.nextFragment(), null;
      let s = this.trees[r], i = this.index[r];
      if (i == s.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let n = s.children[i], a = this.start[r] + s.positions[i];
      if (a > e)
        return this.nextStart = a, null;
      if (n instanceof Ze) {
        if (a == e) {
          if (a < this.safeFrom)
            return null;
          let l = a + n.length;
          if (l <= this.safeTo) {
            let c = n.prop(ge.lookAhead);
            if (!c || l + c < this.fragment.to)
              return n;
          }
        }
        this.index[r]++, a + n.length >= Math.max(this.safeFrom, e) && (this.trees.push(n), this.start.push(a), this.index.push(0));
      } else
        this.index[r]++, this.nextStart = a + n.length;
    }
  }
}
class XZ {
  constructor(e, r) {
    this.stream = r, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((s) => new zu());
  }
  getActions(e) {
    let r = 0, s = null, { parser: i } = e.p, { tokenizers: n } = i, a = i.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), l = e.curContext ? e.curContext.hash : 0, c = 0;
    for (let p = 0; p < n.length; p++) {
      if ((1 << p & a) == 0)
        continue;
      let d = n[p], m = this.tokens[p];
      if (!(s && !d.fallback) && ((d.contextual || m.start != e.pos || m.mask != a || m.context != l) && (this.updateCachedToken(m, d, e), m.mask = a, m.context = l), m.lookAhead > m.end + 25 && (c = Math.max(m.lookAhead, c)), m.value != 0)) {
        let y = r;
        if (m.extended > -1 && (r = this.addActions(e, m.extended, m.end, r)), r = this.addActions(e, m.value, m.end, r), !d.extend && (s = m, r > y))
          break;
      }
    }
    for (; this.actions.length > r; )
      this.actions.pop();
    return c && e.setLookAhead(c), !s && e.pos == this.stream.end && (s = new zu(), s.value = e.p.parser.eofTerm, s.start = s.end = e.pos, r = this.addActions(e, s.value, s.end, r)), this.mainToken = s, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let r = new zu(), { pos: s, p: i } = e;
    return r.start = s, r.end = Math.min(s + 1, i.stream.end), r.value = s == i.stream.end ? i.parser.eofTerm : 0, r;
  }
  updateCachedToken(e, r, s) {
    let i = this.stream.clipPos(s.pos);
    if (r.token(this.stream.reset(i, e), s), e.value > -1) {
      let { parser: n } = s.p;
      for (let a = 0; a < n.specialized.length; a++)
        if (n.specialized[a] == e.value) {
          let l = n.specializers[a](this.stream.read(e.start, e.end), s);
          if (l >= 0 && s.p.parser.dialect.allows(l >> 1)) {
            (l & 1) == 0 ? e.value = l >> 1 : e.extended = l >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(i + 1);
  }
  putAction(e, r, s, i) {
    for (let n = 0; n < i; n += 3)
      if (this.actions[n] == e)
        return i;
    return this.actions[i++] = e, this.actions[i++] = r, this.actions[i++] = s, i;
  }
  addActions(e, r, s, i) {
    let { state: n } = e, { parser: a } = e.p, { data: l } = a;
    for (let c = 0; c < 2; c++)
      for (let p = a.stateSlot(
        n,
        c ? 2 : 1
        /* ParseState.Actions */
      ); ; p += 3) {
        if (l[p] == 65535)
          if (l[p + 1] == 1)
            p = As(l, p + 2);
          else {
            i == 0 && l[p + 1] == 2 && (i = this.putAction(As(l, p + 2), r, s, i));
            break;
          }
        l[p] == r && (i = this.putAction(As(l, p + 1), r, s, i));
      }
    return i;
  }
}
class ZZ {
  constructor(e, r, s, i) {
    this.parser = e, this.input = r, this.ranges = i, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new RZ(r, i), this.tokens = new XZ(e, this.stream), this.topTerm = e.top[1];
    let { from: n } = i[0];
    this.stacks = [Bc.start(this, e.top[0], n)], this.fragments = s.length && this.stream.end - n > e.bufferLength * 4 ? new jZ(s, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, r = this.minStackPos, s = this.stacks = [], i, n;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [a] = e;
      for (; a.forceReduce() && a.stack.length && a.stack[a.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let a = 0; a < e.length; a++) {
      let l = e[a];
      for (; ; ) {
        if (this.tokens.mainToken = null, l.pos > r)
          s.push(l);
        else {
          if (this.advanceStack(l, s, e))
            continue;
          {
            i || (i = [], n = []), i.push(l);
            let c = this.tokens.getMainToken(l);
            n.push(c.value, c.end);
          }
        }
        break;
      }
    }
    if (!s.length) {
      let a = i && zZ(i);
      if (a)
        return ir && console.log("Finish with " + this.stackID(a)), this.stackToTree(a);
      if (this.parser.strict)
        throw ir && i && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + r);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i) {
      let a = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, n, s);
      if (a)
        return ir && console.log("Force-finish " + this.stackID(a)), this.stackToTree(a.forceAll());
    }
    if (this.recovering) {
      let a = this.recovering == 1 ? 1 : this.recovering * 3;
      if (s.length > a)
        for (s.sort((l, c) => c.score - l.score); s.length > a; )
          s.pop();
      s.some((l) => l.reducePos > r) && this.recovering--;
    } else if (s.length > 1) {
      e: for (let a = 0; a < s.length - 1; a++) {
        let l = s[a];
        for (let c = a + 1; c < s.length; c++) {
          let p = s[c];
          if (l.sameState(p) || l.buffer.length > 500 && p.buffer.length > 500)
            if ((l.score - p.score || l.buffer.length - p.buffer.length) > 0)
              s.splice(c--, 1);
            else {
              s.splice(a--, 1);
              continue e;
            }
        }
      }
      s.length > 12 && s.splice(
        12,
        s.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = s[0].pos;
    for (let a = 1; a < s.length; a++)
      s[a].pos < this.minStackPos && (this.minStackPos = s[a].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, r, s) {
    let i = e.pos, { parser: n } = this, a = ir ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && i > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let p = e.curContext && e.curContext.tracker.strict, d = p ? e.curContext.hash : 0;
      for (let m = this.fragments.nodeAt(i); m; ) {
        let y = this.parser.nodeSet.types[m.type.id] == m.type ? n.getGoto(e.state, m.type.id) : -1;
        if (y > -1 && m.length && (!p || (m.prop(ge.contextHash) || 0) == d))
          return e.useNode(m, y), ir && console.log(a + this.stackID(e) + ` (via reuse of ${n.getName(m.type.id)})`), !0;
        if (!(m instanceof Ze) || m.children.length == 0 || m.positions[0] > 0)
          break;
        let g = m.children[0];
        if (g instanceof Ze && m.positions[0] == 0)
          m = g;
        else
          break;
      }
    }
    let l = n.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (l > 0)
      return e.reduce(l), ir && console.log(a + this.stackID(e) + ` (via always-reduce ${n.getName(
        l & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let c = this.tokens.getActions(e);
    for (let p = 0; p < c.length; ) {
      let d = c[p++], m = c[p++], y = c[p++], g = p == c.length || !s, x = g ? e : e.split(), v = this.tokens.mainToken;
      if (x.apply(d, m, v ? v.start : x.pos, y), ir && console.log(a + this.stackID(x) + ` (via ${(d & 65536) == 0 ? "shift" : `reduce of ${n.getName(
        d & 65535
        /* Action.ValueMask */
      )}`} for ${n.getName(m)} @ ${i}${x == e ? "" : ", split"})`), g)
        return !0;
      x.pos > i ? r.push(x) : s.push(x);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, r) {
    let s = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > s)
        return Tx(e, r), !0;
    }
  }
  runRecovery(e, r, s) {
    let i = null, n = !1;
    for (let a = 0; a < e.length; a++) {
      let l = e[a], c = r[a << 1], p = r[(a << 1) + 1], d = ir ? this.stackID(l) + " -> " : "";
      if (l.deadEnd && (n || (n = !0, l.restart(), ir && console.log(d + this.stackID(l) + " (restarted)"), this.advanceFully(l, s))))
        continue;
      let m = l.split(), y = d;
      for (let g = 0; m.forceReduce() && g < 10 && (ir && console.log(y + this.stackID(m) + " (via force-reduce)"), !this.advanceFully(m, s)); g++)
        ir && (y = this.stackID(m) + " -> ");
      for (let g of l.recoverByInsert(c))
        ir && console.log(d + this.stackID(g) + " (via recover-insert)"), this.advanceFully(g, s);
      this.stream.end > l.pos ? (p == l.pos && (p++, c = 0), l.recoverByDelete(c, p), ir && console.log(d + this.stackID(l) + ` (via recover-delete ${this.parser.getName(c)})`), Tx(l, s)) : (!i || i.score < l.score) && (i = l);
    }
    return i;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), Ze.build({
      buffer: Ic.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let r = (Zp || (Zp = /* @__PURE__ */ new WeakMap())).get(e);
    return r || Zp.set(e, r = String.fromCodePoint(this.nextStackID++)), r + e;
  }
}
function Tx(t, e) {
  for (let r = 0; r < e.length; r++) {
    let s = e[r];
    if (s.pos == t.pos && s.sameState(t)) {
      e[r].score < t.score && (e[r] = t);
      return;
    }
  }
  e.push(t);
}
class VZ {
  constructor(e, r, s) {
    this.source = e, this.flags = r, this.disabled = s;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const Vp = (t) => t;
class kC {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || Vp, this.reduce = e.reduce || Vp, this.reuse = e.reuse || Vp, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class ba extends iA {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let r = e.nodeNames.split(" ");
    this.minRepeatTerm = r.length;
    for (let l = 0; l < e.repeatNodeCount; l++)
      r.push("");
    let s = Object.keys(e.topRules).map((l) => e.topRules[l][1]), i = [];
    for (let l = 0; l < r.length; l++)
      i.push([]);
    function n(l, c, p) {
      i[l].push([c, c.deserialize(String(p))]);
    }
    if (e.nodeProps)
      for (let l of e.nodeProps) {
        let c = l[0];
        typeof c == "string" && (c = ge[c]);
        for (let p = 1; p < l.length; ) {
          let d = l[p++];
          if (d >= 0)
            n(d, c, l[p++]);
          else {
            let m = l[p + -d];
            for (let y = -d; y > 0; y--)
              n(l[p++], c, m);
            p++;
          }
        }
      }
    this.nodeSet = new gg(r.map((l, c) => _t.define({
      name: c >= this.minRepeatTerm ? void 0 : l,
      id: c,
      props: i[c],
      top: s.indexOf(c) > -1,
      error: c == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(c) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = Kw;
    let a = mo(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let l = 0; l < this.specializerSpecs.length; l++)
      this.specialized[l] = this.specializerSpecs[l].term;
    this.specializers = this.specializerSpecs.map(kx), this.states = mo(e.states, Uint32Array), this.data = mo(e.stateData), this.goto = mo(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((l) => typeof l == "number" ? new ta(a, l) : l), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, r, s) {
    let i = new ZZ(this, e, r, s);
    for (let n of this.wrappers)
      i = n(i, e, r, s);
    return i;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, r, s = !1) {
    let i = this.goto;
    if (r >= i[0])
      return -1;
    for (let n = i[r + 1]; ; ) {
      let a = i[n++], l = a & 1, c = i[n++];
      if (l && s)
        return c;
      for (let p = n + (a >> 1); n < p; n++)
        if (i[n] == e)
          return c;
      if (l)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, r) {
    let s = this.data;
    for (let i = 0; i < 2; i++)
      for (let n = this.stateSlot(
        e,
        i ? 2 : 1
        /* ParseState.Actions */
      ), a; ; n += 3) {
        if ((a = s[n]) == 65535)
          if (s[n + 1] == 1)
            a = s[n = As(s, n + 2)];
          else {
            if (s[n + 1] == 2)
              return As(s, n + 2);
            break;
          }
        if (a == r || a == 0)
          return As(s, n + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, r) {
    return this.states[e * 6 + r];
  }
  /**
  @internal
  */
  stateFlag(e, r) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & r) > 0;
  }
  /**
  @internal
  */
  validAction(e, r) {
    return !!this.allActions(e, (s) => s == r ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, r) {
    let s = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), i = s ? r(s) : void 0;
    for (let n = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); i == null; n += 3) {
      if (this.data[n] == 65535)
        if (this.data[n + 1] == 1)
          n = As(this.data, n + 2);
        else
          break;
      i = r(As(this.data, n + 1));
    }
    return i;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let r = [];
    for (let s = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1)
          s = As(this.data, s + 2);
        else
          break;
      if ((this.data[s + 2] & 1) == 0) {
        let i = this.data[s + 1];
        r.some((n, a) => a & 1 && n == i) || r.push(this.data[s], i);
      }
    }
    return r;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let r = Object.assign(Object.create(ba.prototype), this);
    if (e.props && (r.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let s = this.topRules[e.top];
      if (!s)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      r.top = s;
    }
    return e.tokenizers && (r.tokenizers = this.tokenizers.map((s) => {
      let i = e.tokenizers.find((n) => n.from == s);
      return i ? i.to : s;
    })), e.specializers && (r.specializers = this.specializers.slice(), r.specializerSpecs = this.specializerSpecs.map((s, i) => {
      let n = e.specializers.find((l) => l.from == s.external);
      if (!n)
        return s;
      let a = Object.assign(Object.assign({}, s), { external: n.to });
      return r.specializers[i] = kx(a), a;
    })), e.contextTracker && (r.context = e.contextTracker), e.dialect && (r.dialect = this.parseDialect(e.dialect)), e.strict != null && (r.strict = e.strict), e.wrap && (r.wrappers = r.wrappers.concat(e.wrap)), e.bufferLength != null && (r.bufferLength = e.bufferLength), r;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let r = this.dynamicPrecedences;
    return r == null ? 0 : r[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let r = Object.keys(this.dialects), s = r.map(() => !1);
    if (e)
      for (let n of e.split(" ")) {
        let a = r.indexOf(n);
        a >= 0 && (s[a] = !0);
      }
    let i = null;
    for (let n = 0; n < r.length; n++)
      if (!s[n])
        for (let a = this.dialects[r[n]], l; (l = this.data[a++]) != 65535; )
          (i || (i = new Uint8Array(this.maxTerm + 1)))[l] = 1;
    return new VZ(e, s, i);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new ba(e);
  }
}
function As(t, e) {
  return t[e] | t[e + 1] << 16;
}
function zZ(t) {
  let e = null;
  for (let r of t) {
    let s = r.p.stoppedAt;
    (r.pos == r.p.stream.end || s != null && r.pos > s) && r.p.parser.stateFlag(
      r.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < r.score) && (e = r);
  }
  return e;
}
function kx(t) {
  if (t.external) {
    let e = t.extend ? 1 : 0;
    return (r, s) => t.external(r, s) << 1 | e;
  }
  return t.get;
}
const UZ = 315, YZ = 316, Px = 1, WZ = 2, GZ = 3, HZ = 4, JZ = 317, KZ = 319, eV = 320, tV = 5, rV = 6, sV = 0, Ff = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], PC = 125, iV = 59, $f = 47, nV = 42, aV = 43, oV = 45, lV = 60, uV = 44, cV = 63, hV = 46, pV = 91, dV = new kC({
  start: !1,
  shift(t, e) {
    return e == tV || e == rV || e == KZ ? t : e == eV;
  },
  strict: !1
}), fV = new mr((t, e) => {
  let { next: r } = t;
  (r == PC || r == -1 || e.context) && t.acceptToken(JZ);
}, { contextual: !0, fallback: !0 }), mV = new mr((t, e) => {
  let { next: r } = t, s;
  Ff.indexOf(r) > -1 || r == $f && ((s = t.peek(1)) == $f || s == nV) || r != PC && r != iV && r != -1 && !e.context && t.acceptToken(UZ);
}, { contextual: !0 }), gV = new mr((t, e) => {
  t.next == pV && !e.context && t.acceptToken(YZ);
}, { contextual: !0 }), yV = new mr((t, e) => {
  let { next: r } = t;
  if (r == aV || r == oV) {
    if (t.advance(), r == t.next) {
      t.advance();
      let s = !e.context && e.canShift(Px);
      t.acceptToken(s ? Px : WZ);
    }
  } else r == cV && t.peek(1) == hV && (t.advance(), t.advance(), (t.next < 48 || t.next > 57) && t.acceptToken(GZ));
}, { contextual: !0 });
function zp(t, e) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t == 95 || t >= 192 || !e && t >= 48 && t <= 57;
}
const OV = new mr((t, e) => {
  if (t.next != lV || !e.dialectEnabled(sV) || (t.advance(), t.next == $f)) return;
  let r = 0;
  for (; Ff.indexOf(t.next) > -1; )
    t.advance(), r++;
  if (zp(t.next, !0)) {
    for (t.advance(), r++; zp(t.next, !1); )
      t.advance(), r++;
    for (; Ff.indexOf(t.next) > -1; )
      t.advance(), r++;
    if (t.next == uV) return;
    for (let s = 0; ; s++) {
      if (s == 7) {
        if (!zp(t.next, !0)) return;
        break;
      }
      if (t.next != "extends".charCodeAt(s)) break;
      t.advance(), r++;
    }
  }
  t.acceptToken(HZ, -r);
}), xV = xh({
  "get set async static": T.modifier,
  "for while do if else switch try catch finally return throw break continue default case": T.controlKeyword,
  "in of await yield void typeof delete instanceof as satisfies": T.operatorKeyword,
  "let var const using function class extends": T.definitionKeyword,
  "import export from": T.moduleKeyword,
  "with debugger new": T.keyword,
  TemplateString: T.special(T.string),
  super: T.atom,
  BooleanLiteral: T.bool,
  this: T.self,
  null: T.null,
  Star: T.modifier,
  VariableName: T.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": T.function(T.variableName),
  VariableDefinition: T.definition(T.variableName),
  Label: T.labelName,
  PropertyName: T.propertyName,
  PrivatePropertyName: T.special(T.propertyName),
  "CallExpression/MemberExpression/PropertyName": T.function(T.propertyName),
  "FunctionDeclaration/VariableDefinition": T.function(T.definition(T.variableName)),
  "ClassDeclaration/VariableDefinition": T.definition(T.className),
  "NewExpression/VariableName": T.className,
  PropertyDefinition: T.definition(T.propertyName),
  PrivatePropertyDefinition: T.definition(T.special(T.propertyName)),
  UpdateOp: T.updateOperator,
  "LineComment Hashbang": T.lineComment,
  BlockComment: T.blockComment,
  Number: T.number,
  String: T.string,
  Escape: T.escape,
  ArithOp: T.arithmeticOperator,
  LogicOp: T.logicOperator,
  BitOp: T.bitwiseOperator,
  CompareOp: T.compareOperator,
  RegExp: T.regexp,
  Equals: T.definitionOperator,
  Arrow: T.function(T.punctuation),
  ": Spread": T.punctuation,
  "( )": T.paren,
  "[ ]": T.squareBracket,
  "{ }": T.brace,
  "InterpolationStart InterpolationEnd": T.special(T.brace),
  ".": T.derefOperator,
  ", ;": T.separator,
  "@": T.meta,
  TypeName: T.typeName,
  TypeDefinition: T.definition(T.typeName),
  "type enum interface implements namespace module declare": T.definitionKeyword,
  "abstract global Privacy readonly override": T.modifier,
  "is keyof unique infer asserts": T.operatorKeyword,
  JSXAttributeValue: T.attributeValue,
  JSXText: T.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": T.angleBracket,
  "JSXIdentifier JSXNameSpacedName": T.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": T.attributeName,
  "JSXBuiltin/JSXIdentifier": T.standard(T.tagName)
}), DV = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, in: 52, out: 55, const: 56, extends: 60, this: 64, true: 72, false: 72, null: 84, void: 88, typeof: 92, super: 108, new: 142, delete: 154, yield: 163, await: 167, class: 172, public: 235, private: 235, protected: 235, readonly: 237, instanceof: 256, satisfies: 259, import: 292, keyof: 349, unique: 353, infer: 359, asserts: 395, is: 397, abstract: 417, implements: 419, type: 421, let: 424, var: 426, using: 429, interface: 435, enum: 439, namespace: 445, module: 447, declare: 451, global: 455, for: 474, of: 483, while: 486, with: 490, do: 494, if: 498, else: 500, switch: 504, case: 510, try: 516, catch: 520, finally: 524, return: 528, throw: 532, break: 536, continue: 540, debugger: 544 }, bV = { __proto__: null, async: 129, get: 131, set: 133, declare: 195, public: 197, private: 197, protected: 197, static: 199, abstract: 201, override: 203, readonly: 209, accessor: 211, new: 401 }, vV = { __proto__: null, "<": 193 }, SV = ba.deserialize({
  version: 14,
  states: "$EOQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Ik'#IkO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JqO6[Q!0MxO'#JrO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO7eQMhO'#F|O9[Q`O'#F{OOQ!0Lf'#Jr'#JrOOQ!0Lb'#Jq'#JqO9aQ`O'#GwOOQ['#K^'#K^O9lQ`O'#IXO9qQ!0LrO'#IYOOQ['#J_'#J_OOQ['#I^'#I^Q`QlOOQ`QlOOO9yQ!L^O'#DvO:QQlO'#EOO:XQlO'#EQO9gQ`O'#GsO:`QMhO'#CoO:nQ`O'#EnO:yQ`O'#EyO;OQMhO'#FeO;mQ`O'#GsOOQO'#K_'#K_O;rQ`O'#K_O<QQ`O'#G{O<QQ`O'#G|O<QQ`O'#HOO9gQ`O'#HRO<wQ`O'#HUO>`Q`O'#CeO>pQ`O'#HbO>xQ`O'#HhO>xQ`O'#HjO`QlO'#HlO>xQ`O'#HnO>xQ`O'#HqO>}Q`O'#HwO?SQ!0LsO'#H}O%[QlO'#IPO?_Q!0LsO'#IRO?jQ!0LsO'#ITO9qQ!0LrO'#IVO?uQ!0MxO'#CiO@wQpO'#DlQOQ`OOO%[QlO'#EQOA_Q`O'#ETO:`QMhO'#EnOAjQ`O'#EnOAuQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Ju'#JuO%[QlO'#JuOOQO'#Jx'#JxOOQO'#Ig'#IgOBuQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J|'#J|OCqQ!0MSO'#EgOC{QpO'#EWOOQO'#Jw'#JwODaQpO'#JxOEnQpO'#EWOC{QpO'#EgPE{O&2DjO'#CbPOOO)CD|)CD|OOOO'#I_'#I_OFWO#tO,59UOOQ!0Lh,59U,59UOOOO'#I`'#I`OFfO&jO,59UOFtQ!L^O'#DcOOOO'#Ib'#IbOF{O#@ItO,59{OOQ!0Lf,59{,59{OGZQlO'#IcOGnQ`O'#JsOImQ!fO'#JsO+}QlO'#JsOItQ`O,5:ROJ[Q`O'#EpOJiQ`O'#KSOJtQ`O'#KROJtQ`O'#KROJ|Q`O,5;^OKRQ`O'#KQOOQ!0Ln,5:^,5:^OKYQlO,5:^OMWQ!0MxO,5:fOMwQ`O,5:nONbQ!0LrO'#KPONiQ`O'#KOO9aQ`O'#KOON}Q`O'#KOO! VQ`O,5;]O! [Q`O'#KOO!#aQ!fO'#JrOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$PQ!fO,5:sOOQS'#Jy'#JyOOQO-E<i-E<iO9gQ`O,5=_O!$gQ`O,5=_O!$lQlO,5;ZO!&oQMhO'#EkO!(YQ`O,5;ZO!(_QlO'#DyO!(iQpO,5;dO!(qQpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)PQlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IoO!+SQ!0LrO,5<iO%[QlO,5;eO!&oQMhO,5;eO!+qQMhO,5;eO!-cQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-jQ,UO'#FjO!.gQ,UO'#KWO!.RQ,UO'#KWO!.nQ,UO'#KWOOQO'#KW'#KWO!/SQ,UO,5<SOOOW,5<`,5<`O!/eQlO'#FvOOOW'#In'#InO7VO7dO,5<QO!/lQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0]Q$IUO'#CyOOQ!0Lh'#C}'#C}O!0pO#@ItO'#DRO!1^QMjO,5<eO!1eQ`O,5<hO!3QQ(CWO'#GXO!3_Q`O'#GYO!3dQ`O'#GYO!5SQ(CWO'#G^O!6XQpO'#GbOOQO'#Gn'#GnO!+xQMhO'#GmOOQO'#Gp'#GpO!+xQMhO'#GoO!6zQ$IUO'#JkOOQ!0Lh'#Jk'#JkO!7UQ`O'#JjO!7dQ`O'#JiO!7lQ`O'#CuOOQ!0Lh'#C{'#C{O!7}Q`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO1SQ`O'#DZO!+xQMhO'#GPO!+xQMhO'#GRO!8SQ`O'#GTO!8XQ`O'#GUO!3dQ`O'#G[O!+xQMhO'#GaO<QQ`O'#JjO!8^Q`O'#EqO!8{Q`O,5<gOOQ!0Lb'#Cr'#CrO!9TQ`O'#ErO!9}QpO'#EsOOQ!0Lb'#KQ'#KQO!:UQ!0LrO'#K`O9qQ!0LrO,5=cO`QlO,5>sOOQ['#Jg'#JgOOQ[,5>t,5>tOOQ[-E<[-E<[O!<TQ!0MxO,5:bO!9xQpO,5:`O!>nQ!0MxO,5:jO%[QlO,5:jO!AUQ!0MxO,5:lOOQO,5@y,5@yO!AuQMhO,5=_O!BTQ!0LrO'#JhO9[Q`O'#JhO!BfQ!0LrO,59ZO!BqQpO,59ZO!ByQMhO,59ZO:`QMhO,59ZO!CUQ`O,5;ZO!C^Q`O'#HaO!CrQ`O'#KcO%[QlO,5;}O!9xQpO,5<PO!CzQ`O,5=zO!DPQ`O,5=zO!DUQ`O,5=zO9qQ!0LrO,5=zO<QQ`O,5=jOOQO'#Cy'#CyO!DdQpO,5=gO!DlQMhO,5=hO!DwQ`O,5=jO!D|Q!bO,5=mO!EUQ`O'#K_O>}Q`O'#HWO9gQ`O'#HYO!EZQ`O'#HYO:`QMhO'#H[O!E`Q`O'#H[OOQ[,5=p,5=pO!EeQ`O'#H]O!EvQ`O'#CoO!E{Q`O,59PO!FVQ`O,59PO!H[QlO,59POOQ[,59P,59PO!HlQ!0LrO,59PO%[QlO,59PO!JwQlO'#HdOOQ['#He'#HeOOQ['#Hf'#HfO`QlO,5=|O!K_Q`O,5=|O`QlO,5>SO`QlO,5>UO!KdQ`O,5>WO`QlO,5>YO!KiQ`O,5>]O!KnQlO,5>cOOQ[,5>i,5>iO%[QlO,5>iO9qQ!0LrO,5>kOOQ[,5>m,5>mO# xQ`O,5>mOOQ[,5>o,5>oO# xQ`O,5>oOOQ[,5>q,5>qO#!fQpO'#D_O%[QlO'#JuO##XQpO'#JuO##cQpO'#DmO##tQpO'#DmO#&VQlO'#DmO#&^Q`O'#JtO#&fQ`O,5:WO#&kQ`O'#EtO#&yQ`O'#KTO#'RQ`O,5;_O#'WQpO'#DmO#'eQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#'lQ`O,5:oO>}Q`O,5;YO!BqQpO,5;YO!ByQMhO,5;YO:`QMhO,5;YO#'tQ`O,5@aO#'yQ07dO,5:sOOQO-E<e-E<eO#)PQ!0MSO,5;ROC{QpO,5:rO#)ZQpO,5:rOC{QpO,5;RO!BfQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#)hQ!0LrO,5;RO#)sQ!0LrO,5;RO!BqQpO,5:rOOQO,5;X,5;XO#*RQ!0LrO,5;RPOOO'#I]'#I]P#*gO&2DjO,58|POOO,58|,58|OOOO-E<]-E<]OOQ!0Lh1G.p1G.pOOOO-E<^-E<^OOOO,59},59}O#*rQ!bO,59}OOOO-E<`-E<`OOQ!0Lf1G/g1G/gO#*wQ!fO,5>}O+}QlO,5>}OOQO,5?T,5?TO#+RQlO'#IcOOQO-E<a-E<aO#+`Q`O,5@_O#+hQ!fO,5@_O#+oQ`O,5@mOOQ!0Lf1G/m1G/mO%[QlO,5@nO#+wQ`O'#IiOOQO-E<g-E<gO#+oQ`O,5@mOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@kO#,]Q!0LrO,5@kO#,nQ!0LrO,5@kO#,uQ`O,5@jO9aQ`O,5@jO#,}Q`O,5@jO#-]Q`O'#IlO#,uQ`O,5@jOOQ!0Lb1G0w1G0wO!(iQpO,5:uO!(tQpO,5:uOOQS,5:w,5:wO#-}QdO,5:wO#.VQMhO1G2yO9gQ`O1G2yOOQ!0Lf1G0u1G0uO#.eQ!0MxO1G0uO#/jQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0WQ!0MzO'#JkO!$lQlO1G0uO#2cQ!fO'#JvO%[QlO'#JvO#2mQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#2rQ`O1G1OO#5WQ!0MxO1G1PO#5_Q!0MxO1G1PO#7uQ!0MxO1G1PO#7|Q!0MxO1G1PO#:dQ!0MxO1G1PO#<zQ!0MxO1G1PO#=RQ!0MxO1G1PO#=YQ!0MxO1G1PO#?pQ!0MxO1G1PO#?wQ!0MxO1G1PO#BUQ?MtO'#CiO#DPQ?MtO1G1`O#DWQ?MtO'#JrO#DkQ!0MxO,5?ZOOQ!0Lb-E<m-E<mO#FxQ!0MxO1G1PO#GuQ!0MzO1G1POOQ!0Lf1G1P1G1PO#HxQMjO'#J{O#ISQ`O,5:xO#IXQ!0MxO1G1cO#I{Q,UO,5<WO#JTQ,UO,5<XO#J]Q,UO'#FoO#JtQ`O'#FnOOQO'#KX'#KXOOQO'#Im'#ImO#JyQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#K[Q?MtO'#JqO#KfQ`O,5<bO!)PQlO,5<bOOOW-E<l-E<lOOQ!0Lf1G1l1G1lO#KkQpO'#KWOOQ!0Lf,5<d,5<dO#KsQpO,5<dO#KxQMhO'#DTOOOO'#Ia'#IaO#LPO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8XQ`O'#IqO#L[Q`O,5<zOOQ!0Lh,5<w,5<wO!+xQMhO'#ItO#LxQMjO,5=XO!+xQMhO'#IvO#MkQMjO,5=ZO!&oQMhO,5=]OOQO1G2S1G2SO#MuQ!dO'#CrO#NYQ(CWO'#ErO$ _QpO'#GbO$ uQ!dO,5<sO$ |Q`O'#KZO9aQ`O'#KZO$![Q`O,5<uO!+xQMhO,5<tO$!aQ`O'#GZO$!rQ`O,5<tO$!wQ!dO'#GWO$#UQ!dO'#K[O$#`Q`O'#K[O!&oQMhO'#K[O$#eQ`O,5<xO$#jQlO'#JuO$#tQpO'#GcO##tQpO'#GcO$$VQ`O'#GgO!3dQ`O'#GkO$$[Q!0LrO'#IsO$$gQpO,5<|OOQ!0Lp,5<|,5<|O$$nQpO'#GcO$${QpO'#GdO$%^QpO'#GdO$%cQMjO,5=XO$%sQMjO,5=ZOOQ!0Lh,5=^,5=^O!+xQMhO,5@UO!+xQMhO,5@UO$&TQ`O'#IxO$&iQ`O,5@TO$&qQ`O,59aOOQ!0Lh,59i,59iO$'hQ$IYO,59uOOQ!0Lh'#Jo'#JoO$(ZQMjO,5<kO$(|QMjO,5<mO@oQ`O,5<oOOQ!0Lh,5<p,5<pO$)WQ`O,5<vO$)]QMjO,5<{O$)mQ`O,5@UO$){Q`O'#KOO!$lQlO1G2RO$*QQ`O1G2RO9aQ`O'#KRO9aQ`O'#EtO%[QlO'#EtO9aQ`O'#IzO$*VQ!0LrO,5@zOOQ[1G2}1G2}OOQ[1G4_1G4_OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$,XQ!0MxO1G0UOOQ[1G2y1G2yO!&oQMhO1G2yO%[QlO1G2yO#.YQ`O1G2yO$.]QMhO'#EkOOQ!0Lb,5@S,5@SO$.jQ!0LrO,5@SOOQ[1G.u1G.uO!BfQ!0LrO1G.uO!BqQpO1G.uO!ByQMhO1G.uO$.{Q`O1G0uO$/QQ`O'#CiO$/]Q`O'#KdO$/eQ`O,5={O$/jQ`O'#KdO$/oQ`O'#KdO$/}Q`O'#JQO$0]Q`O,5@}O$0eQ!fO1G1iOOQ!0Lf1G1k1G1kO9gQ`O1G3fO@oQ`O1G3fO$0lQ`O1G3fO$0qQ`O1G3fOOQ[1G3f1G3fO!DwQ`O1G3UO!&oQMhO1G3RO$0vQ`O1G3ROOQ[1G3S1G3SO!&oQMhO1G3SO$0{Q`O1G3SO$1TQpO'#HQOOQ[1G3U1G3UO!6SQpO'#I|O!D|Q!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$1]QMhO,5=tO9gQ`O,5=tO$$VQ`O,5=vO9[Q`O,5=vO!BqQpO,5=vO!ByQMhO,5=vO:`QMhO,5=vO$1kQ`O'#KbO$1vQ`O,5=wOOQ[1G.k1G.kO$1{Q!0LrO1G.kO@oQ`O1G.kO$2WQ`O1G.kO9qQ!0LrO1G.kO$4`Q!fO,5APO$4mQ`O,5APO9aQ`O,5APO$4xQlO,5>OO$5PQ`O,5>OOOQ[1G3h1G3hO`QlO1G3hOOQ[1G3n1G3nOOQ[1G3p1G3pO>xQ`O1G3rO$5UQlO1G3tO$9YQlO'#HsOOQ[1G3w1G3wO$9gQ`O'#HyO>}Q`O'#H{OOQ[1G3}1G3}O$9oQlO1G3}O9qQ!0LrO1G4TOOQ[1G4V1G4VOOQ!0Lb'#G_'#G_O9qQ!0LrO1G4XO9qQ!0LrO1G4ZO$=vQ`O,5@aO!)PQlO,5;`O9aQ`O,5;`O>}Q`O,5:XO!)PQlO,5:XO!BqQpO,5:XO$={Q?MtO,5:XOOQO,5;`,5;`O$>VQpO'#IdO$>mQ`O,5@`OOQ!0Lf1G/r1G/rO$>uQpO'#IjO$?PQ`O,5@oOOQ!0Lb1G0y1G0yO##tQpO,5:XOOQO'#If'#IfO$?XQpO,5:qOOQ!0Ln,5:q,5:qO#'oQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO>}Q`O1G0tO!BqQpO1G0tO!ByQMhO1G0tOOQ!0Lb1G5{1G5{O!BfQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$?`Q!0LrO1G0mO$?kQ!0LrO1G0mO!BqQpO1G0^OC{QpO1G0^O$?yQ!0LrO1G0mOOQO1G0^1G0^O$@_Q!0MxO1G0mPOOO-E<Z-E<ZPOOO1G.h1G.hOOOO1G/i1G/iO$@iQ!bO,5<iO$@qQ!fO1G4iOOQO1G4o1G4oO%[QlO,5>}O$@{Q`O1G5yO$ATQ`O1G6XO$A]Q!fO1G6YO9aQ`O,5?TO$AgQ!0MxO1G6VO%[QlO1G6VO$AwQ!0LrO1G6VO$BYQ`O1G6UO$BYQ`O1G6UO9aQ`O1G6UO$BbQ`O,5?WO9aQ`O,5?WOOQO,5?W,5?WO$BvQ`O,5?WO$){Q`O,5?WOOQO-E<j-E<jOOQS1G0a1G0aOOQS1G0c1G0cO#.QQ`O1G0cOOQ[7+(e7+(eO!&oQMhO7+(eO%[QlO7+(eO$CUQ`O7+(eO$CaQMhO7+(eO$CoQ!0MzO,5=XO$EzQ!0MzO,5=ZO$HVQ!0MzO,5=XO$JhQ!0MzO,5=ZO$LyQ!0MzO,59uO% OQ!0MzO,5<kO%#ZQ!0MzO,5<mO%%fQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%'wQ!0MxO7+&aO%(kQlO'#IeO%(xQ`O,5@bO%)QQ!fO,5@bOOQ!0Lf1G0P1G0PO%)[Q`O7+&jOOQ!0Lf7+&j7+&jO%)aQ?MtO,5:fO%[QlO7+&zO%)kQ?MtO,5:bO%)xQ?MtO,5:jO%*SQ?MtO,5:lO%*^QMhO'#IhO%*hQ`O,5@gOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%*pQ!jO,5<ZO!)PQlO,5<YOOQO-E<k-E<kOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%*{Q`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%+QQ!dO,59oOOOO-E<_-E<_OOQ!0Lh1G/X1G/XO%+XQ!0MxO7+'kOOQ!0Lh,5?],5?]O%+{QMhO1G2fP%,SQ`O'#IqPOQ!0Lh-E<o-E<oO%,pQMjO,5?`OOQ!0Lh-E<r-E<rO%-cQMjO,5?bOOQ!0Lh-E<t-E<tO%-mQ!dO1G2wO%-tQ!dO'#CrO%.[QMhO'#KRO$#jQlO'#JuOOQ!0Lh1G2_1G2_O%.cQ`O'#IpO%.wQ`O,5@uO%.wQ`O,5@uO%/PQ`O,5@uO%/[Q`O,5@uOOQO1G2a1G2aO%/jQMjO1G2`O!+xQMhO1G2`O%/zQ(CWO'#IrO%0XQ`O,5@vO!&oQMhO,5@vO%0aQ!dO,5@vOOQ!0Lh1G2d1G2dO%2qQ!fO'#CiO%2{Q`O,5=POOQ!0Lb,5<},5<}O%3TQpO,5<}OOQ!0Lb,5=O,5=OOClQ`O,5<}O%3`QpO,5<}OOQ!0Lb,5=R,5=RO$){Q`O,5=VOOQO,5?_,5?_OOQO-E<q-E<qOOQ!0Lp1G2h1G2hO##tQpO,5<}O$#jQlO,5=PO%3nQ`O,5=OO%3yQpO,5=OO!+xQMhO'#ItO%4sQMjO1G2sO!+xQMhO'#IvO%5fQMjO1G2uO%5pQMjO1G5pO%5zQMjO1G5pOOQO,5?d,5?dOOQO-E<v-E<vOOQO1G.{1G.{O!9xQpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%6XQ`O1G2ZO!+xQMhO1G2bO!+xQMhO1G5pO!+xQMhO1G5pO%6^Q!0MxO7+'mOOQ!0Lf7+'m7+'mO!$lQlO7+'mO%7QQ`O,5;`OOQ!0Lb,5?f,5?fOOQ!0Lb-E<x-E<xO%7VQ!dO'#K]O#'oQ`O7+(eO4UQ!fO7+(eO$CXQ`O7+(eO%7aQ!0MvO'#CiO%7tQ!0MvO,5=SO%8fQ`O,5=SO%8nQ`O,5=SOOQ!0Lb1G5n1G5nOOQ[7+$a7+$aO!BfQ!0LrO7+$aO!BqQpO7+$aO!$lQlO7+&aO%8sQ`O'#JPO%9[Q`O,5AOOOQO1G3g1G3gO9gQ`O,5AOO%9[Q`O,5AOO%9dQ`O,5AOOOQO,5?l,5?lOOQO-E=O-E=OOOQ!0Lf7+'T7+'TO%9iQ`O7+)QO9qQ!0LrO7+)QO9gQ`O7+)QO@oQ`O7+)QOOQ[7+(p7+(pO%9nQ!0MvO7+(mO!&oQMhO7+(mO!DrQ`O7+(nOOQ[7+(n7+(nO!&oQMhO7+(nO%9xQ`O'#KaO%:TQ`O,5=lOOQO,5?h,5?hOOQO-E<z-E<zOOQ[7+(s7+(sO%;gQpO'#HZOOQ[1G3`1G3`O!&oQMhO1G3`O%[QlO1G3`O%;nQ`O1G3`O%;yQMhO1G3`O9qQ!0LrO1G3bO$$VQ`O1G3bO9[Q`O1G3bO!BqQpO1G3bO!ByQMhO1G3bO%<XQ`O'#JOO%<mQ`O,5@|O%<uQpO,5@|OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@oQ`O7+$VO9qQ!0LrO7+$VO%=QQ`O7+$VO%[QlO1G6kO%[QlO1G6lO%=VQ!0LrO1G6kO%=aQlO1G3jO%=hQ`O1G3jO%=mQlO1G3jOOQ[7+)S7+)SO9qQ!0LrO7+)^O`QlO7+)`OOQ['#Kg'#KgOOQ['#JR'#JRO%=tQlO,5>_OOQ[,5>_,5>_O%[QlO'#HtO%>RQ`O'#HvOOQ[,5>e,5>eO9aQ`O,5>eOOQ[,5>g,5>gOOQ[7+)i7+)iOOQ[7+)o7+)oOOQ[7+)s7+)sOOQ[7+)u7+)uO%>WQpO1G5{O%>rQ?MtO1G0zO%>|Q`O1G0zOOQO1G/s1G/sO%?XQ?MtO1G/sO>}Q`O1G/sO!)PQlO'#DmOOQO,5?O,5?OOOQO-E<b-E<bOOQO,5?U,5?UOOQO-E<h-E<hO!BqQpO1G/sOOQO-E<d-E<dOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#'oQ`O7+%uOOQ!0Lf7+&`7+&`O>}Q`O7+&`O!BqQpO7+&`OOQO7+%x7+%xO$@_Q!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%?cQ!0LrO7+&XO!BfQ!0LrO7+%xO!BqQpO7+%xO%?nQ!0LrO7+&XO%?|Q!0MxO7++qO%[QlO7++qO%@^Q`O7++pO%@^Q`O7++pOOQO1G4r1G4rO9aQ`O1G4rO%@fQ`O1G4rOOQS7+%}7+%}O#'oQ`O<<LPO4UQ!fO<<LPO%@tQ`O<<LPOOQ[<<LP<<LPO!&oQMhO<<LPO%[QlO<<LPO%@|Q`O<<LPO%AXQ!0MzO,5?`O%CdQ!0MzO,5?bO%EoQ!0MzO1G2`O%HQQ!0MzO1G2sO%J]Q!0MzO1G2uO%LhQ!fO,5?PO%[QlO,5?POOQO-E<c-E<cO%LrQ`O1G5|OOQ!0Lf<<JU<<JUO%LzQ?MtO1G0uO& RQ?MtO1G1PO& YQ?MtO1G1PO&#ZQ?MtO1G1PO&#bQ?MtO1G1PO&%cQ?MtO1G1PO&'dQ?MtO1G1PO&'kQ?MtO1G1PO&'rQ?MtO1G1PO&)sQ?MtO1G1PO&)zQ?MtO1G1PO&*RQ!0MxO<<JfO&+yQ?MtO1G1PO&,vQ?MvO1G1PO&-yQ?MvO'#JkO&0PQ?MtO1G1cO&0^Q?MtO1G0UO&0hQMjO,5?SOOQO-E<f-E<fO!)PQlO'#FqOOQO'#KY'#KYOOQO1G1u1G1uO&0rQ`O1G1tO&0wQ?MtO,5?ZOOOW7+'h7+'hOOOO1G/Z1G/ZO&1RQ!dO1G4wOOQ!0Lh7+(Q7+(QP!&oQMhO,5?]O!+xQMhO7+(cO&1YQ`O,5?[O9aQ`O,5?[OOQO-E<n-E<nO&1hQ`O1G6aO&1hQ`O1G6aO&1pQ`O1G6aO&1{QMjO7+'zO&2]Q!dO,5?^O&2gQ`O,5?^O!&oQMhO,5?^OOQO-E<p-E<pO&2lQ!dO1G6bO&2vQ`O1G6bO&3OQ`O1G2kO!&oQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%3TQpO1G2iO!BqQpO1G2iOClQ`O1G2iOOQ!0Lb1G2q1G2qO&3TQpO1G2iO&3cQ`O1G2kO$){Q`O1G2jOClQ`O1G2jO$#jQlO1G2kO&3kQ`O1G2jO&4_QMjO,5?`OOQ!0Lh-E<s-E<sO&5QQMjO,5?bOOQ!0Lh-E<u-E<uO!+xQMhO7++[OOQ!0Lh1G/c1G/cO&5[Q`O1G/cOOQ!0Lh7+'u7+'uO&5aQMjO7+'|O&5qQMjO7++[O&5{QMjO7++[O&6YQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&6|Q`O1G0zO!&oQMhO'#IyO&7RQ`O,5@wO&9TQ!fO<<LPO!&oQMhO1G2nO&9[Q!0LrO1G2nOOQ[<<G{<<G{O!BfQ!0LrO<<G{O&9mQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?k,5?kO&:aQ`O,5?kO&:fQ`O,5?kOOQO-E<}-E<}O&:tQ`O1G6jO&:tQ`O1G6jO9gQ`O1G6jO@oQ`O<<LlOOQ[<<Ll<<LlO&:|Q`O<<LlO9qQ!0LrO<<LlOOQ[<<LX<<LXO%9nQ!0MvO<<LXOOQ[<<LY<<LYO!DrQ`O<<LYO&;RQpO'#I{O&;^Q`O,5@{O!)PQlO,5@{OOQ[1G3W1G3WOOQO'#I}'#I}O9qQ!0LrO'#I}O&;fQpO,5=uOOQ[,5=u,5=uO&;mQpO'#EgO&;tQpO'#GeO&;yQ`O7+(zO&<OQ`O7+(zOOQ[7+(z7+(zO!&oQMhO7+(zO%[QlO7+(zO&<WQ`O7+(zOOQ[7+(|7+(|O9qQ!0LrO7+(|O$$VQ`O7+(|O9[Q`O7+(|O!BqQpO7+(|O&<cQ`O,5?jOOQO-E<|-E<|OOQO'#H^'#H^O&<nQ`O1G6hO9qQ!0LrO<<GqOOQ[<<Gq<<GqO@oQ`O<<GqO&<vQ`O7+,VO&<{Q`O7+,WO%[QlO7+,VO%[QlO7+,WOOQ[7+)U7+)UO&=QQ`O7+)UO&=VQlO7+)UO&=^Q`O7+)UOOQ[<<Lx<<LxOOQ[<<Lz<<LzOOQ[-E=P-E=POOQ[1G3y1G3yO&=cQ`O,5>`OOQ[,5>b,5>bO&=hQ`O1G4PO9aQ`O7+&fO!)PQlO7+&fOOQO7+%_7+%_O&=mQ?MtO1G6YO>}Q`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO>}Q`O<<IzOOQO<<Is<<IsO$@_Q!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!BfQ!0LrO<<IdO&=wQ!0LrO<<IsO&>SQ!0MxO<= ]O&>dQ`O<= [OOQO7+*^7+*^O9aQ`O7+*^OOQ[ANAkANAkO&>lQ!fOANAkO!&oQMhOANAkO#'oQ`OANAkO4UQ!fOANAkO&>sQ`OANAkO%[QlOANAkO&>{Q!0MzO7+'zO&A^Q!0MzO,5?`O&CiQ!0MzO,5?bO&EtQ!0MzO7+'|O&HVQ!fO1G4kO&HaQ?MtO7+&aO&JeQ?MvO,5=XO&LlQ?MvO,5=ZO&L|Q?MvO,5=XO&M^Q?MvO,5=ZO&MnQ?MvO,59uO' tQ?MvO,5<kO'#wQ?MvO,5<mO'&]Q?MvO,5<{O'(RQ?MtO7+'kO'(`Q?MtO7+'mO'(mQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*c7+*cO'(rQMjO<<K}OOQO1G4v1G4vO'(yQ`O1G4vO')UQ`O1G4vO')dQ`O7++{O')dQ`O7++{O!&oQMhO1G4xO')lQ!dO1G4xO')vQ`O7++|O'*OQ`O7+(VO'*ZQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!BqQpO7+(TOClQ`O7+(TO'*eQ`O7+(VO!&oQMhO7+(VO$){Q`O7+(UO'*jQ`O7+(VOClQ`O7+(UO'*rQMjO<<NvOOQ!0Lh7+$}7+$}O!+xQMhO<<NvO'*|Q!dO,5?eOOQO-E<w-E<wO'+WQ!0MvO7+(YO!&oQMhO7+(YOOQ[AN=gAN=gO9gQ`O1G5VOOQO1G5V1G5VO'+hQ`O1G5VO'+mQ`O7+,UO'+mQ`O7+,UO9qQ!0LrOANBWO@oQ`OANBWOOQ[ANBWANBWOOQ[ANAsANAsOOQ[ANAtANAtO'+uQ`O,5?gOOQO-E<y-E<yO',QQ?MtO1G6gOOQO,5?i,5?iOOQO-E<{-E<{OOQ[1G3a1G3aO',[Q`O,5=POOQ[<<Lf<<LfO!&oQMhO<<LfO&;yQ`O<<LfO',aQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9qQ!0LrO<<LhO$$VQ`O<<LhO9[Q`O<<LhO',iQpO1G5UO',tQ`O7+,SOOQ[AN=]AN=]O9qQ!0LrOAN=]OOQ[<= q<= qOOQ[<= r<= rO',|Q`O<= qO'-RQ`O<= rOOQ[<<Lp<<LpO'-WQ`O<<LpO'-]QlO<<LpOOQ[1G3z1G3zO>}Q`O7+)kO'-dQ`O<<JQO'-oQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$@_Q!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<Mx<<MxOOQ[G27VG27VO!&oQMhOG27VO#'oQ`OG27VO'-yQ!fOG27VO4UQ!fOG27VO'.QQ`OG27VO'.YQ?MtO<<JfO'.gQ?MvO1G2`O'0]Q?MvO,5?`O'2`Q?MvO,5?bO'4cQ?MvO1G2sO'6fQ?MvO1G2uO'8iQ?MtO<<KXO'8vQ?MtO<<I{OOQO1G1w1G1wO!+xQMhOANAiOOQO7+*b7+*bO'9TQ`O7+*bO'9`Q`O<= gO'9hQ!dO7+*dOOQ!0Lb<<Kq<<KqO$){Q`O<<KqOClQ`O<<KqO'9rQ`O<<KqO!&oQMhO<<KqOOQ!0Lb<<Ko<<KoO!BqQpO<<KoO'9}Q!dO<<KqOOQ!0Lb<<Kp<<KpO':XQ`O<<KqO!&oQMhO<<KqO$){Q`O<<KpO':^QMjOANDbO':hQ!0MvO<<KtOOQO7+*q7+*qO9gQ`O7+*qO':xQ`O<= pOOQ[G27rG27rO9qQ!0LrOG27rO!)PQlO1G5RO';QQ`O7+,RO';YQ`O1G2kO&;yQ`OANBQOOQ[ANBQANBQO!&oQMhOANBQO';_Q`OANBQOOQ[ANBSANBSO9qQ!0LrOANBSO$$VQ`OANBSOOQO'#H_'#H_OOQO7+*p7+*pOOQ[G22wG22wOOQ[ANE]ANE]OOQ[ANE^ANE^OOQ[ANB[ANB[O';gQ`OANB[OOQ[<<MV<<MVO!)PQlOAN?lOOQOG24yG24yO$@_Q!0MxOG24yO#'oQ`OLD,qOOQ[LD,qLD,qO!&oQMhOLD,qO';lQ!fOLD,qO';sQ?MvO7+'zO'=iQ?MvO,5?`O'?lQ?MvO,5?bO'AoQ?MvO7+'|O'CeQMjOG27TOOQO<<M|<<M|OOQ!0LbANA]ANA]O$){Q`OANA]OClQ`OANA]O'CuQ!dOANA]OOQ!0LbANAZANAZO'C|Q`OANA]O!&oQMhOANA]O'DXQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N]<<N]OOQ[LD-^LD-^O'DcQ?MtO7+*mOOQO'#Gf'#GfOOQ[G27lG27lO&;yQ`OG27lO!&oQMhOG27lOOQ[G27nG27nO9qQ!0LrOG27nOOQ[G27vG27vO'DmQ?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#'oQ`O!$(!]O!&oQMhO!$(!]O'DwQ!0MzOG27TOOQ!0LbG26wG26wO$){Q`OG26wO'GYQ`OG26wOClQ`OG26wO'GeQ!dOG26wO!&oQMhOG26wOOQ[LD-WLD-WO&;yQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#'oQ`O!)9EwOOQ!0LbLD,cLD,cO$){Q`OLD,cOClQ`OLD,cO'GlQ`OLD,cO'GwQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'HOQ?MvOG27TOOQ!0Lb!$( }!$( }O$){Q`O!$( }OClQ`O!$( }O'ItQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$){Q`O!)9EiOClQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$){Q`O!.K;TOOQ!0Lb!4/0o!4/0oO!)PQlO'#DzO1PQ`O'#EXO'JPQ!fO'#JqO'JWQ!L^O'#DvO'J_QlO'#EOO'JfQ!fO'#CiO'L|Q!fO'#CiO!)PQlO'#EQO'M^QlO,5;ZO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO'#IoO( aQ`O,5<iO!)PQlO,5;eO( iQMhO,5;eO(#SQMhO,5;eO!)PQlO,5;wO!&oQMhO'#GmO( iQMhO'#GmO!&oQMhO'#GoO( iQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&oQMhO'#GPO( iQMhO'#GPO!&oQMhO'#GRO( iQMhO'#GRO!&oQMhO'#GaO( iQMhO'#GaO!)PQlO,5:jO(#ZQpO'#D_O(#eQpO'#JuO!)PQlO,5@nO'M^QlO1G0uO(#oQ?MtO'#CiO!)PQlO1G2PO!&oQMhO'#ItO( iQMhO'#ItO!&oQMhO'#IvO( iQMhO'#IvO(#yQ!dO'#CrO!&oQMhO,5<tO( iQMhO,5<tO'M^QlO1G2RO!)PQlO7+&zO!&oQMhO1G2`O( iQMhO1G2`O!&oQMhO'#ItO( iQMhO'#ItO!&oQMhO'#IvO( iQMhO'#IvO!&oQMhO1G2bO( iQMhO1G2bO'M^QlO7+'mO'M^QlO7+&aO!&oQMhOANAiO( iQMhOANAiO($^Q`O'#EoO($cQ`O'#EoO($kQ`O'#F]O($pQ`O'#EyO($uQ`O'#KSO(%QQ`O'#KQO(%]Q`O,5;ZO(%bQMjO,5<eO(%iQ`O'#GYO(%nQ`O'#GYO(%sQ`O,5<gO(%{Q`O,5;ZO(&TQ?MtO1G1`O(&[Q`O,5<tO(&aQ`O,5<tO(&fQ`O,5<vO(&kQ`O,5<vO(&pQ`O1G2RO(&uQ`O1G0uO(&zQMjO<<K}O('RQMjO<<K}O7eQMhO'#F|O9[Q`O'#F{OAjQ`O'#EnO!)PQlO,5;tO!3dQ`O'#GYO!3dQ`O'#GYO!3dQ`O'#G[O!3dQ`O'#G[O!+xQMhO7+(cO!+xQMhO7+(cO%-mQ!dO1G2wO%-mQ!dO1G2wO!&oQMhO,5=]O!&oQMhO,5=]",
  stateData: "((X~O'{OS'|OSTOS'}RQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&V!WO&]!XO&_!YO&a!ZO&c![O&f!]O&l!^O&r!_O&t!`O&v!aO&x!bO&z!cO(SSO(UTO(XUO(`VO(n[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|;wO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(T!lO(UTO(XUO(d!mO(n!sO~O'}!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'y]X(`]X(q]X(x]X(y]X~O!g%RX~P(qO_!}O(U#PO(V!}O(W#PO~O_#QO(W#PO(X#PO(Y#QO~Ox#SO!U#TO(a#TO(b#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S;{O(UTO(XUO(`VO(n[O~O![#ZO!]#WO!Y(gP!Y(uP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(UTO(XUO(`VO(n[O~Op#mO![#iO!|]O#i#lO#j#iO(S;|O!k(rP~P.iO!l#oO(S#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~Oa(eX'y(eX'v(eX!k(eX!Y(eX!_(eX%i(eX!g(eX~P1qO#S$dO#`$eO$Q$eOP(fXR(fX[(fXj(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX!_(fX%i(fX~Oa(fX'y(fX'v(fX!Y(fX!k(fXv(fX!g(fX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%cOk%cOl%cOp%WOr%XOs$tOt$tOz%YO|%ZO!O%[O!S${O!_$|O!i%aO!l$xO#j%bO$W%_O$t%]O$v%^O$y%`O(S$sO(UTO(XUO(`$uO(x$}O(y%POg(]P~O!l%dO~O!S%gO!_%hO(S%fO~O!g%lO~Oa%mO'y%mO~O!Q%qO~P%[O(T!lO~P%[O%n%uO~P%[Oh%VO!l%dO(S%fO(T!lO~Oe%|O!l%dO(S%fO~Oj$RO~O!Q&RO!_&OO!l&QO%j&UO(S%fO(T!lO(UTO(XUO`)VP~O!x#sO~O%s&WO!S)RX!_)RX(S)RX~O(S&XO~Ol!PO!u&^O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&cOe&bO!x&`O%h&aO%{&_O~P<VOd&fOeyOl!PO!_&eO!u&^O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&iO#`&lO%j&gO(T!lO~P=[O!l&mO!u&qO~O!l#oO~O!_XO~Oa%mO'w&yO'y%mO~Oa%mO'w&|O'y%mO~Oa%mO'w'OO'y%mO~O'v]X!Y]Xv]X!k]X&Z]X!_]X%i]X!g]X~P(qO!b']O!c'UO!d'UO(T!lO(UTO(XUO~Os'SO!S'RO!['VO(d'QO!^(hP!^(wP~P@cOn'`O!_'^O(S%fO~Oe'eO!l%dO(S%fO~O!Q&RO!l&QO~Os!nO!S!oO!|;wO#T!pO#U!pO#W!pO#X!pO(T!lO(UTO(XUO(d!mO(n!sO~O!b'kO!c'jO!d'jO#V!pO#['lO#]'lO~PA}Oa%mOh%VO!g#vO!l%dO'y%mO(q'nO~O!p'rO#`'pO~PC]Os!nO!S!oO(UTO(XUO(d!mO(n!sO~O!_XOs(lX!S(lX!b(lX!c(lX!d(lX!|(lX#T(lX#U(lX#V(lX#W(lX#X(lX#[(lX#](lX(T(lX(U(lX(X(lX(d(lX(n(lX~O!c'jO!d'jO(T!lO~PC{O(O'vO(P'vO(Q'xO~O_!}O(U'zO(V!}O(W'zO~O_#QO(W'zO(X'zO(Y#QO~Ov'|O~P%[Ox#SO!U#TO(a#TO(b(PO~O![(RO!Y'VX!Y']X!]'VX!]']X~P+}O!](TO!Y(gX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](TO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~O!Y(gX~PGvO!Y(YO~O!Y(tX!](tX!g(tX!k(tX(q(tX~O#`(tX#k#dX!^(tX~PIyO#`(ZO!Y(vX!](vX~O!]([O!Y(uX~O!Y(_O~O#`$eO~PIyO!^(`O~P`OR#zO!Q#yO!S#{O!l#xO(`VOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(q!na(x!na(y!na~Oa!na'y!na'v!na!Y!na!k!nav!na!_!na%i!na!g!na~PKaO!k(aO~O!g#vO#`(bO(q'nO!](sXa(sX'y(sX~O!k(sX~PM|O!S%gO!_%hO!|]O#i(gO#j(fO(S%fO~O!](hO!k(rX~O!k(jO~O!S%gO!_%hO#j(fO(S%fO~OP(fXR(fX[(fXj(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX~O!g#vO!k(fX~P! jOR(lO!Q(kO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(S!{a~P!#kO!x(pO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~O#k(vO~O![(xO!k(jP~P%[O(d(zO(n[O~O!S(|O!l#xO(d(zO(n[O~OP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_!eO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(S)ZO(UTO(XUO(`VO(n[O~O!]$_Oa$qa'y$qa'v$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)bO~P!&oOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%[O!S${O!_$|O!i%aO!l$xO#j%bO$W%_O$t%]O$v%^O$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~Og(oP~P!+xO!Q)gO!g)fO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)fO!_(zX$Z(zX$](zX$_(zX$f(zX~O!Q)gO~P!.RO!Q)gO!_(zX$Z(zX$](zX$_(zX$f(zX~O!_)iO$Z)mO$])hO$_)hO$f)nO~O![)qO~P!)PO$]$hO$_$gO$f)uO~On$zX!Q$zX#S$zX'x$zX(x$zX(y$zX~OgmXg$zXnmX!]mX#`mX~P!/wOx)wO(a)xO(b)zO~On*TO!Q)|O'x)}O(x$}O(y%PO~Og){O~P!0{Og*UO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S*WO!_*XO!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(UTO(XUO(`$uO(x$}O(y%PO~O![*[O(S*VO!k(}P~P!1jO#k*^O~O!l*_O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(S*aO(UTO(XUO(`$uO(x$}O(y%PO~O![*dO!Y)OP~P!3iOr*pOs!nO!S*fO!b*nO!c*hO!d*hO!l*_O#[*oO%`*jO(T!lO(UTO(XUO(d!mO~O!^*mO~P!5^O#S$dOn(_X!Q(_X'x(_X(x(_X(y(_X!](_X#`(_X~Og(_X$O(_X~P!6`On*uO#`*tOg(^X!](^X~O!]*vOg(]X~Oj%cOk%cOl%cO(S&XOg(]P~Os*yO~O!l+OO~O(S(tO~Op+TO!S%gO![#iO!_%hO!|]O#i#lO#j#iO(S%fO!k(rP~O!g#vO#k+UO~O!S%gO![+WO!]([O!_%hO(S%fO!Y(uP~Os'YO!S+YO![+XO(UTO(XUO(d(zO~O!^(wP~P!9iO!]+ZOa)SX'y)SX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~Oa!ja!]!ja'y!ja'v!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:aOR#zO!Q#yO!S#{O!l#xO(`VOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(q!ra(x!ra(y!ra~Oa!ra'y!ra'v!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!<wOR#zO!Q#yO!S#{O!l#xO(`VOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(q!ta(x!ta(y!ta~Oa!ta'y!ta'v!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?_Oh%VOn+dO!_'^O%i+cO~O!g+fOa([X!_([X'y([X!]([X~Oa%mO!_XO'y%mO~Oh%VO!l%dO~Oh%VO!l%dO(S%fO~O!g#vO#k(vO~Ob+qO%j+rO(S+nO(UTO(XUO!^)WP~O!]+sO`)VX~O[+wO~O`+xO~O!_&OO(S%fO(T!lO`)VP~Oh%VO#`+}O~Oh%VOn,QO!_$|O~O!_,SO~O!Q,UO!_XO~O%n%uO~O!x,ZO~Oe,`O~Ob,aO(S#nO(UTO(XUO!^)UP~Oe%|O~O%j!QO(S&XO~P=[O[,fO`,eO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(UTO(XUO(`VO(n[O~O!_!eO!u!gO$W!kO(S!dO~P!F_O`,eOa%mO'y%mO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oa,kOl!OO!uwO%l!OO%m!OO%n!OO~P!HwO!l&mO~O&],qO~O!_,sO~O&n,uO&p,vOP&kaQ&kaS&kaY&kaa&kad&kae&kal&kap&kar&kas&kat&kaz&ka|&ka!O&ka!S&ka!W&ka!X&ka!_&ka!i&ka!l&ka!o&ka!p&ka!q&ka!s&ka!u&ka!x&ka!|&ka$W&ka$n&ka%h&ka%j&ka%l&ka%m&ka%n&ka%q&ka%s&ka%v&ka%w&ka%y&ka&V&ka&]&ka&_&ka&a&ka&c&ka&f&ka&l&ka&r&ka&t&ka&v&ka&x&ka&z&ka'v&ka(S&ka(U&ka(X&ka(`&ka(n&ka!^&ka&d&kab&ka&i&ka~O(S,{O~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P# }O!g-QO#`-POh(iX!]#hX!^#hX!g(iX!l(iX~O!](iX!^(iX~P#!pOh%VO!g-SO!l%dO!]!aX!^!aX~Os!nO!S!oO(UTO(XUO(d!mO~OP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_!eO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(UTO(XUO(`VO(n[O~O(S<rO~P#$VO!]-WO!^(hX~O!^-YO~O!g-QO#`-PO!]#hX!^#hX~O!]-ZO!^(wX~O!^-]O~O!c-^O!d-^O(T!lO~P##tO!^-aO~P'_On-dO!_'^O~O!Y-iO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(T!{a(U!{a(X!{a(d!{a(n!{a~P!#kO!p-nO#`-lO~PC]O!c-pO!d-pO(T!lO~PC{Oa%mO#`-lO'y%mO~Oa%mO!g#vO#`-lO'y%mO~Oa%mO!g#vO!p-nO#`-lO'y%mO(q'nO~O(O'vO(P'vO(Q-uO~Ov-vO~O!Y'Va!]'Va~P!:aO![-zO!Y'VX!]'VX~P%[O!](TO!Y(ga~O!Y(ga~PGvO!]([O!Y(ua~O!S%gO![.OO!_%hO(S%fO!Y']X!]']X~O#`.QO!](sa!k(saa(sa'y(sa~O!g#vO~P#,]O!](hO!k(ra~O!S%gO!_%hO#j.UO(S%fO~Op.ZO!S%gO![.WO!_%hO!|]O#i.YO#j.WO(S%fO!]'`X!k'`X~OR._O!l#xO~Oh%VOn.bO!_'^O%i.aO~Oa#ci!]#ci'y#ci'v#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:aOn=|O!Q)|O'x)}O(x$}O(y%PO~O#k#_aa#_a#`#_a'y#_a!]#_a!k#_a!_#_a!Y#_a~P#/XO#k(_XP(_XR(_X[(_Xa(_Xj(_Xr(_X!S(_X!l(_X!p(_X#R(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#t(_X#u(_X#v(_X#x(_X#z(_X#{(_X'y(_X(`(_X(q(_X!k(_X!Y(_X'v(_Xv(_X!_(_X%i(_X!g(_X~P!6`O!].oO!k(jX~P!:aO!k.rO~O!Y.tO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(`VO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#2wO#n$OO~P#2wOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(`VO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#5fO#r$QO~P#5fOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(`VOa#mi!]#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8TOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(`VO(y#}Oa#mi!]#mi#z#mi#{#mi'y#mi(q#mi(x#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#:kO#x#mi~P#:kO#v$SO~P#8TOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(`VO(x#|O(y#}Oa#mi!]#mi#{#mi'y#mi(q#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#=aO#z$WO~P#=aOP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X!]]X!^]X~O$O]X~P#@OOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO#x<VO#z<XO#{<YO(`VO(q$YO(x#|O(y#}O~O$O.vO~P#B]O#S$dO#`<`O$Q<`O$O(fX!^(fX~P! jOa'ca!]'ca'y'ca'v'ca!k'ca!Y'cav'ca!_'ca%i'ca!g'ca~P!:aO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(`VO(x#mi(y#mi~P#E_On=|O!Q)|O'x)}O(x$}O(y%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(`#mi~P#E_O!].zOg(oX~P!0{Og.|O~Oa$Pi!]$Pi'y$Pi'v$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:aO$].}O$_.}O~O$]/OO$_/OO~O!g)fO#`/PO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/QO~O!_)iO$Z/SO$])hO$_)hO$f/TO~O!]<ZO!^(eX~P#B]O!^/UO~O!g)fO$f(zX~O$f/WO~Ov/XO~P!&oOx)wO(a)xO(b/[O~O!S/_O~O(x$}On%aa!Q%aa'x%aa(y%aa!]%aa#`%aa~Og%aa$O%aa~P#LaO(y%POn%ca!Q%ca'x%ca(x%ca!]%ca#`%ca~Og%ca$O%ca~P#MSO!]fX!gfX!kfX!k$zX(qfX~P!/wO![/hO!]([O(S/gO!Y(uP!Y)OP~P!1jOr*pO!b*nO!c*hO!d*hO!l*_O#[*oO%`*jO(T!lO(UTO(XUO~Os<oO!S/iO![+XO!^*mO(d<nO!^(wP~P#NmO!k/jO~P#/XO!]/kO!g#vO(q'nO!k(}X~O!k/pO~O!S%gO![*[O!_%hO(S%fO!k(}P~O#k/rO~O!Y$zX!]$zX!g%RX~P!/wO!]/sO!Y)OX~P#/XO!g/uO~O!Y/wO~OpkO(S/xO~P.iOh%VOr/}O!g#vO!l%dO(q'nO~O!g+fO~Oa%mO!]0RO'y%mO~O!^0TO~P!5^O!c0UO!d0UO(T!lO~P##tOs!nO!S0VO(UTO(XUO(d!mO~O#[0XO~Og%aa!]%aa#`%aa$O%aa~P!0{Og%ca!]%ca#`%ca$O%ca~P!0{Oj%cOk%cOl%cO(S&XOg'lX!]'lX~O!]*vOg(]a~Og0bO~OR0cO!Q0cO!S0dO#S$dOn}a'x}a(x}a(y}a!]}a#`}a~Og}a$O}a~P$&vO!Q)|O'x)}On$sa(x$sa(y$sa!]$sa#`$sa~Og$sa$O$sa~P$'rO!Q)|O'x)}On$ua(x$ua(y$ua!]$ua#`$ua~Og$ua$O$ua~P$(eO#k0gO~Og%Ta!]%Ta#`%Ta$O%Ta~P!0{On0iO#`0hOg(^a!](^a~O!g#vO~O#k0lO~O!]+ZOa)Sa'y)Sa~OR#zO!Q#yO!S#{O!l#xO(`VOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(q!ri(x!ri(y!ri~Oa!ri'y!ri'v!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$*bOh%VOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(UTO(XUO(`$uO(x$}O(y%PO~Op0uO%]0vO(S0tO~P$,xO!g+fOa([a!_([a'y([a!]([a~O#k0|O~O[]X!]fX!^fX~O!]0}O!^)WX~O!^1PO~O[1QO~Ob1SO(S+nO(UTO(XUO~O!_&OO(S%fO`'tX!]'tX~O!]+sO`)Va~O!k1VO~P!:aO[1YO~O`1ZO~O#`1^O~On1aO!_$|O~O(d(zO!^)TP~Oh%VOn1jO!_1gO%i1iO~O[1tO!]1rO!^)UX~O!^1uO~O`1wOa%mO'y%mO~O(S#nO(UTO(XUO~O#S$dO#`$eO$Q$eOP(fXR(fX[(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX~Oj1zO&Z1{Oa(fX~P$2cOj1zO#`$eO&Z1{O~Oa1}O~P%[Oa2PO~O&d2SOP&biQ&biS&biY&bia&bid&bie&bil&bip&bir&bis&bit&biz&bi|&bi!O&bi!S&bi!W&bi!X&bi!_&bi!i&bi!l&bi!o&bi!p&bi!q&bi!s&bi!u&bi!x&bi!|&bi$W&bi$n&bi%h&bi%j&bi%l&bi%m&bi%n&bi%q&bi%s&bi%v&bi%w&bi%y&bi&V&bi&]&bi&_&bi&a&bi&c&bi&f&bi&l&bi&r&bi&t&bi&v&bi&x&bi&z&bi'v&bi(S&bi(U&bi(X&bi(`&bi(n&bi!^&bib&bi&i&bi~Ob2YO!^2WO&i2XO~P`O!_XO!l2[O~O&p,vOP&kiQ&kiS&kiY&kia&kid&kie&kil&kip&kir&kis&kit&kiz&ki|&ki!O&ki!S&ki!W&ki!X&ki!_&ki!i&ki!l&ki!o&ki!p&ki!q&ki!s&ki!u&ki!x&ki!|&ki$W&ki$n&ki%h&ki%j&ki%l&ki%m&ki%n&ki%q&ki%s&ki%v&ki%w&ki%y&ki&V&ki&]&ki&_&ki&a&ki&c&ki&f&ki&l&ki&r&ki&t&ki&v&ki&x&ki&z&ki'v&ki(S&ki(U&ki(X&ki(`&ki(n&ki!^&ki&d&kib&ki&i&ki~O!Y2bO~O!]!aa!^!aa~P#B]Os!nO!S!oO![2hO(d!mO!]'WX!^'WX~P@cO!]-WO!^(ha~O!]'^X!^'^X~P!9iO!]-ZO!^(wa~O!^2oO~P'_Oa%mO#`2xO'y%mO~Oa%mO!g#vO#`2xO'y%mO~Oa%mO!g#vO!p2|O#`2xO'y%mO(q'nO~Oa%mO'y%mO~P!:aO!]$_Ov$qa~O!Y'Vi!]'Vi~P!:aO!](TO!Y(gi~O!]([O!Y(ui~O!Y(vi!](vi~P!:aO!](si!k(sia(si'y(si~P!:aO#`3OO!](si!k(sia(si'y(si~O!](hO!k(ri~O!S%gO!_%hO!|]O#i3TO#j3SO(S%fO~O!S%gO!_%hO#j3SO(S%fO~On3[O!_'^O%i3ZO~Oh%VOn3[O!_'^O%i3ZO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'y%aa(`%aa(q%aa!k%aa!Y%aa'v%aav%aa!_%aa%i%aa!g%aa~P#LaO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'y%ca(`%ca(q%ca!k%ca!Y%ca'v%cav%ca!_%ca%i%ca!g%ca~P#MSO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'y%aa(`%aa(q%aa!k%aa!Y%aa'v%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/XO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'y%ca(`%ca(q%ca!k%ca!Y%ca'v%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/XO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'y}a(`}a(q}a!k}a!Y}a'v}av}a!_}a%i}a!g}a~P$&vO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'y$sa(`$sa(q$sa!k$sa!Y$sa'v$sav$sa!_$sa%i$sa!g$sa~P$'rO#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'y$ua(`$ua(q$ua!k$ua!Y$ua'v$uav$ua!_$ua%i$ua!g$ua~P$(eO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'y%Ta(`%Ta(q%Ta!k%Ta!Y%Ta'v%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/XOa#cq!]#cq'y#cq'v#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:aO![3dO!]'XX!k'XX~P%[O!].oO!k(ja~O!].oO!k(ja~P!:aO!Y3gO~O$O!na!^!na~PKaO$O!ja!]!ja!^!ja~P#B]O$O!ra!^!ra~P!<wO$O!ta!^!ta~P!?_Og'[X!]'[X~P!+xO!].zOg(oa~OSfO!_3{O$d3|O~O!^4QO~Ov4RO~P#/XOa$mq!]$mq'y$mq'v$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:aO!Y4TO~P!&oO!S4UO~O!Q)|O'x)}O(y%POn'ha(x'ha!]'ha#`'ha~Og'ha$O'ha~P%,XO!Q)|O'x)}On'ja(x'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P%,zO(q$YO~P#/XO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!/wO(S<xO~P!1jO!S%gO![4XO!_%hO(S%fO!]'dX!k'dX~O!]/kO!k(}a~O!]/kO!g#vO!k(}a~O!]/kO!g#vO(q'nO!k(}a~Og$|i!]$|i#`$|i$O$|i~P!0{O![4aO!Y'fX!]'fX~P!3iO!]/sO!Y)Oa~O!]/sO!Y)Oa~P#/XOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X~Oj%YX!g%YX~P%0kOj4fO!g#vO~Oh%VO!g#vO!l%dO~Oh%VOr4kO!l%dO(q'nO~Or4pO!g#vO(q'nO~Os!nO!S4qO(UTO(XUO(d!mO~O(x$}On%ai!Q%ai'x%ai(y%ai!]%ai#`%ai~Og%ai$O%ai~P%4[O(y%POn%ci!Q%ci'x%ci(x%ci!]%ci#`%ci~Og%ci$O%ci~P%4}Og(^i!](^i~P!0{O#`4wOg(^i!](^i~P!0{O!k4zO~Oa$oq!]$oq'y$oq'v$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:aO!Y5QO~O!]5RO!_)PX~P#/XOa$zX!_$zX%^]X'y$zX!]$zX~P!/wO%^5UOaoXnoX!QoX!_oX'xoX'yoX(xoX(yoX!]oX~Op5VO(S#nO~O%^5UO~Ob5]O%j5^O(S+nO(UTO(XUO!]'sX!^'sX~O!]0}O!^)Wa~O[5bO~O`5cO~Oa%mO'y%mO~P#/XO!]5kO#`5mO!^)TX~O!^5nO~Or5tOs!nO!S*fO!b!yO!c!vO!d!vO!|;wO#T!pO#U!pO#V!pO#W!pO#X!pO#[5sO#]!zO(T!lO(UTO(XUO(d!mO(n!sO~O!^5rO~P%:YOn5yO!_1gO%i5xO~Oh%VOn5yO!_1gO%i5xO~Ob6QO(S#nO(UTO(XUO!]'rX!^'rX~O!]1rO!^)Ua~O(UTO(XUO(d6SO~O`6WO~Oj6ZO&Z6[O~PM|O!k6]O~P%[Oa6_O~Oa6_O~P%[Ob2YO!^6dO&i2XO~P`O!g6fO~O!g6hOh(ii!](ii!^(ii!g(ii!l(iir(ii(q(ii~O!]#hi!^#hi~P#B]O#`6iO!]#hi!^#hi~O!]!ai!^!ai~P#B]Oa%mO#`6rO'y%mO~Oa%mO!g#vO#`6rO'y%mO~O!](sq!k(sqa(sq'y(sq~P!:aO!](hO!k(rq~O!S%gO!_%hO#j6yO(S%fO~O!_'^O%i6|O~On7QO!_'^O%i6|O~O#k'haP'haR'ha['haa'haj'har'ha!S'ha!l'ha!p'ha#R'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#v'ha#x'ha#z'ha#{'ha'y'ha(`'ha(q'ha!k'ha!Y'ha'v'hav'ha!_'ha%i'ha!g'ha~P%,XO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'y'ja(`'ja(q'ja!k'ja!Y'ja'v'jav'ja!_'ja%i'ja!g'ja~P%,zO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'y$|i(`$|i(q$|i!k$|i!Y$|i'v$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/XO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'y%ai(`%ai(q%ai!k%ai!Y%ai'v%aiv%ai!_%ai%i%ai!g%ai~P%4[O#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'y%ci(`%ci(q%ci!k%ci!Y%ci'v%civ%ci!_%ci%i%ci!g%ci~P%4}O!]'Xa!k'Xa~P!:aO!].oO!k(ji~O$O#ci!]#ci!^#ci~P#B]OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(`VO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#n#mi~P%MXO#n<PO~P%MXOP$[OR#zOr<]O!Q#yO!S#{O!l#xO!p$[O#n<PO#o<QO#p<QO#q<QO(`VO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#r#mi~P& aO#r<RO~P& aOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O(`VO#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#v#mi~P&#iOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO(`VO(y#}O#z#mi#{#mi$O#mi(q#mi(x#mi!]#mi!^#mi~O#x<VO~P&%jO#x#mi~P&%jO#v<TO~P&#iOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO#x<VO(`VO(x#|O(y#}O#{#mi$O#mi(q#mi!]#mi!^#mi~O#z#mi~P&'yO#z<XO~P&'yOa#|y!]#|y'y#|y'v#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:aO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<PO#o<QO#p<QO#q<QO(`VO(x#mi(y#mi~P&*uOn=}O!Q)|O'x)}O(x$}O(y%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(`#mi~P&*uO#S$dOP(_XR(_X[(_Xj(_Xn(_Xr(_X!Q(_X!S(_X!l(_X!p(_X#R(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#t(_X#u(_X#v(_X#x(_X#z(_X#{(_X$O(_X'x(_X(`(_X(q(_X(x(_X(y(_X!](_X!^(_X~O$O$Pi!]$Pi!^$Pi~P#B]O$O!ri!^!ri~P$*bOg'[a!]'[a~P!0{O!^7dO~O!]'ca!^'ca~P#B]O!Y7eO~P#/XO!g#vO(q'nO!]'da!k'da~O!]/kO!k(}i~O!]/kO!g#vO!k(}i~Og$|q!]$|q#`$|q$O$|q~P!0{O!Y'fa!]'fa~P#/XO!g7lO~O!]/sO!Y)Oi~P#/XO!]/sO!Y)Oi~O!Y7oO~Oh%VOr7tO!l%dO(q'nO~Oj7vO!g#vO~Or7yO!g#vO(q'nO~O!Q)|O'x)}O(y%POn'ia(x'ia!]'ia#`'ia~Og'ia$O'ia~P&3vO!Q)|O'x)}On'ka(x'ka(y'ka!]'ka#`'ka~Og'ka$O'ka~P&4iO!Y7{O~Og%Oq!]%Oq#`%Oq$O%Oq~P!0{Og(^q!](^q~P!0{O#`7|Og(^q!](^q~P!0{Oa$oy!]$oy'y$oy'v$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:aO!g6hO~O!]5RO!_)Pa~O!_'^OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(`$Ta(q$Ta(x$Ta(y$Ta~O%i6|O~P&7ZO%^8QOa%[i!_%[i'y%[i!]%[i~Oa#cy!]#cy'y#cy'v#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:aO[8SO~Ob8UO(S+nO(UTO(XUO~O!]0}O!^)Wi~O`8YO~O(d(zO!]'oX!^'oX~O!]5kO!^)Ta~O!^8cO~P%:YO(n!sO~P$${O#[8dO~O!_1gO~O!_1gO%i8fO~On8iO!_1gO%i8fO~O[8nO!]'ra!^'ra~O!]1rO!^)Ui~O!k8rO~O!k8sO~O!k8vO~O!k8vO~P%[Oa8xO~O!g8yO~O!k8zO~O!](vi!^(vi~P#B]Oa%mO#`9SO'y%mO~O!](sy!k(sya(sy'y(sy~P!:aO!](hO!k(ry~O%i9VO~P&7ZO!_'^O%i9VO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'y$|q(`$|q(q$|q!k$|q!Y$|q'v$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/XO#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'y'ia(`'ia(q'ia!k'ia!Y'ia'v'iav'ia!_'ia%i'ia!g'ia~P&3vO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'y'ka(`'ka(q'ka!k'ka!Y'ka'v'kav'ka!_'ka%i'ka!g'ka~P&4iO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'y%Oq(`%Oq(q%Oq!k%Oq!Y%Oq'v%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/XO!]'Xi!k'Xi~P!:aO$O#cq!]#cq!^#cq~P#B]O(x$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(`%aa(q%aa!]%aa!^%aa~On%aa!Q%aa'x%aa(y%aa~P&HnO(y%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(`%ca(q%ca!]%ca!^%ca~On%ca!Q%ca'x%ca(x%ca~P&JuOn=}O!Q)|O'x)}O(y%PO~P&HnOn=}O!Q)|O'x)}O(x$}O~P&JuOR0cO!Q0cO!S0dO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'x}a(`}a(q}a(x}a(y}a!]}a!^}a~O!Q)|O'x)}OP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(`$sa(q$sa(x$sa(y$sa!]$sa!^$sa~O!Q)|O'x)}OP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(`$ua(q$ua(x$ua(y$ua!]$ua!^$ua~On=}O!Q)|O'x)}O(x$}O(y%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(`%Ta(q%Ta!]%Ta!^%Ta~P'%zO$O$mq!]$mq!^$mq~P#B]O$O$oq!]$oq!^$oq~P#B]O!^9dO~O$O9eO~P!0{O!g#vO!]'di!k'di~O!g#vO(q'nO!]'di!k'di~O!]/kO!k(}q~O!Y'fi!]'fi~P#/XO!]/sO!Y)Oq~Or9lO!g#vO(q'nO~O[9nO!Y9mO~P#/XO!Y9mO~Oj9tO!g#vO~Og(^y!](^y~P!0{O!]'ma!_'ma~P#/XOa%[q!_%[q'y%[q!]%[q~P#/XO[9yO~O!]0}O!^)Wq~O#`9}O!]'oa!^'oa~O!]5kO!^)Ti~P#B]O!S:PO~O!_1gO%i:SO~O(UTO(XUO(d:XO~O!]1rO!^)Uq~O!k:[O~O!k:]O~O!k:^O~O!k:^O~P%[O#`:aO!]#hy!^#hy~O!]#hy!^#hy~P#B]O%i:fO~P&7ZO!_'^O%i:fO~O$O#|y!]#|y!^#|y~P#B]OP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(`$|i(q$|i!]$|i!^$|i~P'%zO!Q)|O'x)}O(y%POP'haR'ha['haj'han'har'ha!S'ha!l'ha!p'ha#R'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#v'ha#x'ha#z'ha#{'ha$O'ha(`'ha(q'ha(x'ha!]'ha!^'ha~O!Q)|O'x)}OP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(`'ja(q'ja(x'ja(y'ja!]'ja!^'ja~O(x$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'x%ai(`%ai(q%ai(y%ai!]%ai!^%ai~O(y%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'x%ci(`%ci(q%ci(x%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#B]O$O#cy!]#cy!^#cy~P#B]O!g#vO!]'dq!k'dq~O!]/kO!k(}y~O!Y'fq!]'fq~P#/XOr:pO!g#vO(q'nO~O[:tO!Y:sO~P#/XO!Y:sO~Og(^!R!](^!R~P!0{Oa%[y!_%[y'y%[y!]%[y~P#/XO!]0}O!^)Wy~O!]5kO!^)Tq~O(S:zO~O!_1gO%i:}O~O!k;QO~O%i;VO~P&7ZOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(`$|q(q$|q!]$|q!^$|q~P'%zO!Q)|O'x)}O(y%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(`'ia(q'ia(x'ia!]'ia!^'ia~O!Q)|O'x)}OP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(`'ka(q'ka(x'ka(y'ka!]'ka!^'ka~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(`%Oq(q%Oq!]%Oq!^%Oq~P'%zOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!0{O!Y;ZO~P#/XOr;[O!g#vO(q'nO~O[;^O!Y;ZO~P#/XO!]'oq!^'oq~P#B]O!]#h!Z!^#h!Z~P#B]O#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'y%e!Z(`%e!Z(q%e!Z!k%e!Z!Y%e!Z'v%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/XOr;fO!g#vO(q'nO~O!Y;gO~P#/XOr;nO!g#vO(q'nO~O!Y;oO~P#/XOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(`%e!Z(q%e!Z!]%e!Z!^%e!Z~P'%zOr;rO!g#vO(q'nO~Ov(eX~P1qO!Q%qO~P!)PO(T!lO~P!)PO!YfX!]fX#`fX~P%0kOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X~O!gfX!k]X!kfX(qfX~P'JsOP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_XO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(S)ZO(UTO(XUO(`VO(n[O~O!]<ZO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<fO!S${O!_$|O!i=wO!l$xO#j<lO$W%_O$t<hO$v<jO$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~Ol)bO~P( iOr!eX(q!eX~P# }Or(iX(q(iX~P#!pO!^]X!^fX~P'JsO!YfX!Y$zX!]fX!]$zX#`fX~P!/wO#k<OO~O!g#vO#k<OO~O#`<`O~Oj<SO~O#`<pO!](vX!^(vX~O#`<`O!](tX!^(tX~O#k<qO~Og<sO~P!0{O#k<yO~O#k<zO~O!g#vO#k<{O~O!g#vO#k<qO~O$O<|O~P#B]O#k<}O~O#k=OO~O#k=TO~O#k=UO~O#k=VO~O#k=WO~O$O=XO~P!0{O$O=YO~P!0{Ok#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~'}T#o!X'{(T#ps#n#qr!Q'|$]'|(S$_(d~",
  goto: "$8g)[PPPPPP)]PP)`P)qP+R/WPPPP6bPP6xPP<pPPP@dP@zP@zPPP@zPCSP@zP@zP@zPCWPC]PCzPHtPPPHxPPPPHxK{PPPLRLsPHxPHxPP! RHxPPPHxPHxP!#YHxP!&p!'u!(OP!(r!(v!(r!,TPPPPPPP!,t!'uPP!-U!.vP!2SHxHx!2X!5e!:R!:R!>QPPP!>YHxPPPPPPPPP!AiP!BvPPHx!DXPHxPHxHxHxHxHxPHx!EkP!HuP!K{P!LP!LZ!L_!L_P!HrP!Lc!LcP# iP# mHxPHx# s#$xCW@zP@zP@z@zP#&V@z@z#(i@z#+a@z#-m@z@z#.]#0q#0q#0v#1P#0q#1[PP#0qP@z#1t@z#5s@z@z6bPPP#9xPPP#:c#:cP#:cP#:y#:cPP#;PP#:vP#:v#;d#:v#<O#<U#<X)`#<[)`P#<c#<c#<cP)`P)`P)`P)`PP)`P#<i#<lP#<l)`P#<pP#<sP)`P)`P)`P)`P)`P)`)`PP#<y#=P#=[#=b#=h#=n#=t#>S#>Y#>d#>j#>t#>z#?[#?b#@S#@f#@l#@r#AQ#Ag#C[#Cj#Cq#E]#Ek#G]#Gk#Gq#Gw#G}#HX#H_#He#Ho#IR#IXPPPPPPPPPPP#I_PPPPPPP#JS#MZ#Ns#Nz$ SPPP$&nP$&w$)p$0Z$0^$0a$1`$1c$1j$1rP$1x$1{P$2i$2m$3e$4s$4x$5`PP$5e$5k$5o$5r$5v$5z$6v$7_$7v$7z$7}$8Q$8W$8Z$8_$8cR!|RoqOXst!Z#d%l&p&r&s&u,n,s2S2VY!vQ'^-`1g5qQ%svQ%{yQ&S|Q&h!VS'U!e-WQ'd!iS'j!r!yU*h$|*X*lQ+l%|Q+y&UQ,_&bQ-^']Q-h'eQ-p'kQ0U*nQ1q,`R<m;z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9SS#q];w!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU*{%[<e<fQ+q&OQ,a&eQ,h&mQ0r+dQ0w+fQ1S+rQ1y,fQ3W.bQ5V0vQ5]0}Q6Q1rQ7O3[Q8U5^R9Y7Q'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s!S!nQ!r!v!y!z$|'U']'^'j'k'l*h*l*n*o-W-^-`-p0U0X1g5q5s%[$ti#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q&V|Q'S!eS'Y%h-ZQ+q&OQ,a&eQ0f+OQ1S+rQ1X+xQ1x,eQ1y,fQ5]0}Q5f1ZQ6Q1rQ6T1tQ6U1wQ8U5^Q8X5cQ8q6WQ9|8YQ:Y8nR<o*XrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR,c&i&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=r=s[#]WZ#W#Z'V(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ%vxQ%zyS&P|&UQ&]!TQ'a!hQ'c!iQ(o#sS+k%{%|Q+o&OQ,Y&`Q,^&bS-g'd'eQ.d(pQ0{+lQ1R+rQ1T+sQ1W+wQ1l,ZS1p,_,`Q2t-hQ5[0}Q5`1QQ5e1YQ6P1qQ8T5^Q8W5bQ9x8SR:w9y!U$zi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y!^%xy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pQ+e%vQ,O&YQ,R&ZQ,]&bQ.c(oQ1k,YU1o,^,_,`Q3].dQ5z1lS6O1p1qQ8m6P#f=t#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o=u<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YW%Ti%V*v=pS&Y!Q&gQ&Z!RQ&[!SQ+S%cR+|&W%]%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}T)x$u)yV*{%[<e<fW'Y!e%h*X-ZS({#y#zQ+`%qQ+v&RS.](k(lQ1b,SQ4x0cR8^5k'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s$i$^c#Y#e%p%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.w.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ'W!eR2i-W!W!nQ!e!r!v!y!z$|'U']'^'j'k'l*X*h*l*n*o-W-^-`-p0U0X1g5q5sR1d,UnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&w!^Q't!xS(q#u<OQ+i%yQ,W&]Q,X&_Q-e'bQ-r'mS.m(v<qS0k+U<{Q0y+jQ1f,VQ2Z,uQ2],vQ2e-RQ2r-fQ2u-jS5P0l=VQ5W0zS5Z0|=WQ6j2gQ6n2sQ6s2zQ8R5XQ8}6lQ9O6oQ9R6tR:`8z$d$]c#Y#e%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gS(m#p'gQ(}#zS+_%p.wS.^(l(nR3U._'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS#q];wQ&r!XQ&s!YQ&u![Q&v!]R2R,qQ'_!hQ+b%vQ-c'aS.`(o+eQ2p-bW3Y.c.d0q0sQ6m2qW6z3V3X3]5TU9U6{6}7PU:e9W9X9ZS;T:d:gQ;b;UR;j;cU!wQ'^-`T5o1g5q!Q_OXZ`st!V!Z#d#h%d%l&g&i&p&r&s&u(h,n,s.V2S2V]!pQ!r'^-`1g5qT#q];w%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS({#y#zS.](k(l!s=^$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU$fd)],hS(n#p'gU*s%R(u3vU0e*z.i7]Q5T0rQ6{3WQ9X7OR:g9Ym!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sQ'r!uS(d#g1|S-n'i'uQ/n*ZQ/{*gQ2|-qQ4]/oQ4i/}Q4j0OQ4o0WQ7h4WS7s4k4mS7w4p4rQ9g7iQ9k7oQ9p7tQ9u7yS:o9l9mS;Y:p:sS;e;Z;[S;m;f;gS;q;n;oR;t;rQ#wbQ'q!uS(c#g1|S(e#m+TQ+V%eQ+g%wQ+m%}U-m'i'r'uQ.R(dQ/m*ZQ/|*gQ0P*iQ0x+hQ1m,[S2y-n-qQ3R.ZS4[/n/oQ4e/yS4h/{0WQ4l0QQ5|1nQ6u2|Q7g4WQ7k4]U7r4i4o4rQ7u4nQ8k5}S9f7h7iQ9j7oQ9r7wQ9s7xQ:V8lQ:m9gS:n9k9mQ:v9uQ;P:WS;X:o:sS;d;Y;ZS;l;e;gS;p;m;oQ;s;qQ;u;tQ=a=[Q=l=eR=m=fV!wQ'^-`%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS#wz!j!r=Z$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=a=r%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SQ%ej!^%wy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pS%}z!jQ+h%xQ,[&bW1n,],^,_,`U5}1o1p1qS8l6O6PQ:W8m!r=[$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ=e=qR=f=r%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SY#bWZ#W#Z(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ,i&m!p=]$Z$n)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=`'VU'Z!e%h*XR2k-Z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9S!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ,h&mQ0r+dQ3W.bQ7O3[R9Y7Q!b$Tc#Y%p(Q(W(r(w)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!P<U)[)o-U.w2c2f3h3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!f$Vc#Y%p(Q(W(r(w)U)V)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!T<W)[)o-U.w2c2f3h3n3o3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!^$Zc#Y%p(Q(W(r(w)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;xQ4V/fz=s)[)o-U.w2c2f3h3w4P6k7W7a7b8`8|9[9b9c:y;R=gQ=x=zR=y={'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS$oh$pR3|/P'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$kf$qQ$ifS)h$l)lR)t$qT$jf$qT)j$l)l'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$oh$pQ$rhR)s$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9S!s=q$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s#glOPXZst!Z!`!o#S#d#o#{$n%l&i&l&m&p&r&s&u&y'R'`(|)q*f+Y+d,k,n,s-d.b/Q/i0V0d1j1z1{1}2P2S2V2X3[3{4q5y6Z6[6_7Q8i8x!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}Q+P%`Q/^)|o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!U$yi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yQ*`$zU*i$|*X*lQ+Q%aQ0Q*j#f=c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n=d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YQ=h=tQ=i=uQ=j=vR=k=w!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YnoOXst!Z#d%l&p&r&s&u,n,s2S2VS*c${*WQ,|&|Q,}'OR4`/s%[%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q,P&ZQ1`,RQ5i1_R8]5jV*k$|*X*lU*k$|*X*lT5p1g5qS/y*f/iQ4n0VT7x4q:PQ+g%wQ0P*iQ0x+hQ1m,[Q5|1nQ8k5}Q:V8lR;P:W!U%Oi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yx*P$v)c*Q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=oS0Y*q0Z#f<a#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<b<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!d<t(s)a*Y*b.e.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={`<u3u7X7[7`9]:h:k;kS=P.g3aT=Q7Z9`!U%Qi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y|*R$v)c*S*q+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=oS0[*r0]#f<c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!h<v(s)a*Y*b.f.g.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={d<w3u7Y7Z7`9]9^:h:i:k;kS=R.h3bT=S7[9arnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ&d!UR,k&mrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR&d!UQ,T&[R1[+|snOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ1h,YS5w1k1lU8e5u5v5zS:R8g8hS:{:Q:TQ;_:|R;i;`Q&k!VR,d&gR6T1tR:Y8nS&P|&UR1T+sQ&p!WR,n&qR,t&vT2T,s2VR,x&wQ,w&wR2^,xQ'w!{R-t'wSsOtQ#dXT%os#dQ#OTR'y#OQ#RUR'{#RQ)y$uR/Z)yQ#UVR(O#UQ#XWU(U#X(V-{Q(V#YR-{(WQ-X'WR2j-XQ.p(wS3e.p3fR3f.qQ-`'^R2n-`Y!rQ'^-`1g5qR'h!rQ.{)cR3z.{U#_W%g*WU(]#_(^-|Q(^#`R-|(XQ-['ZR2l-[t`OXst!V!Z#d%l&g&i&p&r&s&u,n,s2S2VS#hZ%dU#r`#h.VR.V(hQ(i#jQ.S(eW.[(i.S3P6wQ3P.TR6w3QQ)l$lR/R)lQ$phR)r$pQ$`cU)_$`-w<[Q-w;xR<[)oQ/l*ZW4Y/l4Z7j9hU4Z/m/n/oS7j4[4]R9h7k$e*O$v(s)a)c*Y*b*q*r*|*}+R.g.h.j.k.l/Y/b/d/f/q/v0^0_0p1]3^3_3`3u3y4S4^4_4c4s4u4{4|4}5h7R7S7T7U7Z7[7^7_7`7f7m7p7z7}8P9]9^9_9i9q9v9w:h:i:j:k:l:q:u;W;];h;k=b=n=o=z={Q/t*bU4b/t4d7nQ4d/vR7n4cS*l$|*XR0S*lx*Q$v)c*q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=o!d.e(s)a*Y*b.g.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/c*Q.e7Xa7X3u7Z7[7`9]:h:k;kQ0Z*qQ3a.gU4t0Z3a9`R9`7Z|*S$v)c*q*r+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=o!h.f(s)a*Y*b.g.h.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/e*S.f7Ye7Y3u7Z7[7`9]9^:h:i:k;kQ0]*rQ3b.hU4v0]3b9aR9a7[Q*w%UR0a*wQ5S0pR8O5SQ+[%jR0o+[Q5l1bS8_5l:OR:O8`Q,V&]R1e,VQ5q1gR8b5qQ1s,aS6R1s8oR8o6TQ1O+oW5_1O5a8V9zQ5a1RQ8V5`R9z8WQ+t&PR1U+tQ2V,sR6c2VYrOXst#dQ&t!ZQ+^%lQ,m&pQ,o&rQ,p&sQ,r&uQ2Q,nS2T,s2VR6b2SQ%npQ&x!_Q&{!aQ&}!bQ'P!cQ'o!uQ+]%kQ+i%yQ+{&VQ,c&kQ,z&zW-k'i'q'r'uQ-r'mQ0R*kQ0y+jS1v,d,gQ2_,yQ2`,|Q2a,}Q2u-jW2w-m-n-q-sQ5W0zQ5d1XQ5g1]Q5{1mQ6V1xQ6a2RU6p2v2y2|Q6s2zQ8R5XQ8Z5fQ8[5hQ8a5pQ8j5|Q8p6US9P6q6uQ9R6tQ9{8XQ:U8kQ:Z8qQ:b9QQ:x9|Q;O:VQ;S:cR;a;PQ%yyQ'b!iQ'm!uU+j%z%{%|Q-R'TU-f'c'd'eS-j'i'sQ/z*gS0z+k+lQ2g-TS2s-g-hQ2z-oS4g/{0OQ5X0{Q6l2mQ6o2tQ6t2{U7q4i4j4mQ9o7sR:r9pS$wi=pR*x%VU%Ui%V=pR0`*vQ$viS(s#v+fS)a$b$cQ)c$dQ*Y$xS*b${*WQ*q%OQ*r%QQ*|%]Q*}%^Q+R%bQ.g<aQ.h<cQ.j<gQ.k<iQ.l<kQ/Y)wQ/b*PQ/d*RQ/f*TQ/q*^S/v*d/hQ0^*tQ0_*ul0p+c,Q.a1a1i3Z5x6|8f9V:S:f:};VQ1]+}Q3^<tQ3_<vQ3`<yS3u<^<_Q3y.zS4S/_4UQ4^/rQ4_/sQ4c/uQ4s0YQ4u0[Q4{0gQ4|0hQ4}0iQ5h1^Q7R<}Q7S=PQ7T=RQ7U=TQ7Z<bQ7[<dQ7^<hQ7_<jQ7`<lQ7f4VQ7m4aQ7p4fQ7z4wQ7}5RQ8P5UQ9]<zQ9^<uQ9_<wQ9i7lQ9q7vQ9v7|Q9w8QQ:h=OQ:i=QQ:j=SQ:k=UQ:l9eQ:q9nQ:u9tQ;W=XQ;]:tQ;h;^Q;k=YQ=b=pQ=n=xQ=o=yQ=z=|R={=}Q*z%[Q.i<eR7]<fnpOXst!Z#d%l&p&r&s&u,n,s2S2VQ!fPS#fZ#oQ&z!`W'f!o*f0V4qQ'}#SQ)O#{Q)p$nS,g&i&lQ,l&mQ,y&yS-O'R/iQ-b'`Q.s(|Q/V)qQ0m+YQ0s+dQ2O,kQ2q-dQ3X.bQ4O/QQ4y0dQ5v1jQ6X1zQ6Y1{Q6^1}Q6`2PQ6e2XQ7P3[Q7c3{Q8h5yQ8t6ZQ8u6[Q8w6_Q9Z7QQ:T8iR:_8x#[cOPXZst!Z!`!o#d#o#{%l&i&l&m&p&r&s&u&y'R'`(|*f+Y+d,k,n,s-d.b/i0V0d1j1z1{1}2P2S2V2X3[4q5y6Z6[6_7Q8i8xQ#YWQ#eYQ%puQ%rvS%tw!gS(Q#W(TQ(W#ZQ(r#uQ(w#xQ)P$OQ)Q$PQ)R$QQ)S$RQ)T$SQ)U$TQ)V$UQ)W$VQ)X$WQ)Y$XQ)[$ZQ)^$_Q)`$aQ)e$eW)o$n)q/Q3{Q+a%sQ+u&QS-U'V2hQ-s'pS-x(R-zQ-}(ZQ.P(bQ.n(vQ.q(xQ.u;vQ.w;yQ.x;zQ.y;}Q/]){Q0j+UQ2c-PQ2f-SQ2v-lQ2}.QQ3c.oQ3h<OQ3i<PQ3j<QQ3k<RQ3l<SQ3m<TQ3n<UQ3o<VQ3p<WQ3q<XQ3r<YQ3s.vQ3t<]Q3w<`Q3x<mQ4P<ZQ5O0lQ5Y0|Q6k<pQ6q2xQ6v3OQ7V3dQ7W<qQ7a<sQ7b<{Q8`5mQ8|6iQ9Q6rQ9[<|Q9b=VQ9c=WQ:c9SQ:y9}Q;R:aQ;x#SR=g=sR#[WR'X!el!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sS'T!e-WU*g$|*X*lS-T'U']S0O*h*nQ0W*oQ2m-^Q4m0UR4r0XR(y#xQ!fQT-_'^-`]!qQ!r'^-`1g5qQ#p]R'g;wR)d$dY!uQ'^-`1g5qQ'i!rS's!v!yS'u!z5sS-o'j'kQ-q'lR2{-pT#kZ%dS#jZ%dS%jm,jU(e#h#i#lS.T(f(gQ.X(hQ0n+ZQ3Q.UU3R.V.W.YS6x3S3TR9T6yd#^W#W#Z%g(R([*W+W.O/hr#gZm#h#i#l%d(f(g(h+Z.U.V.W.Y3S3T6yS*Z$x*_Q/o*[Q1|,jQ2d-QQ4W/kQ6g2[Q7i4XQ8{6hT=_'V+XV#aW%g*WU#`W%g*WS(S#W([U(X#Z+W/hS-V'V+XT-y(R.OV'[!e%h*XQ$lfR)v$qT)k$l)lR3}/PT*]$x*_T*e${*WQ0q+cQ1_,QQ3V.aQ5j1aQ5u1iQ6}3ZQ8g5xQ9W6|Q:Q8fQ:d9VQ:|:SQ;U:fQ;`:}R;c;VnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&j!VR,c&gtmOXst!U!V!Z#d%l&g&p&r&s&u,n,s2S2VR,j&mT%km,jR1c,SR,b&eQ&T|R+z&UR+p&OT&n!W&qT&o!W&qT2U,s2V",
  nodeNames: " ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 379,
  context: dV,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 37, 39, 51, 53, 55, ""],
    ["group", -26, 9, 17, 19, 68, 207, 211, 215, 216, 218, 221, 224, 234, 236, 242, 244, 246, 248, 251, 257, 263, 265, 267, 269, 271, 273, 274, "Statement", -34, 13, 14, 32, 35, 36, 42, 51, 54, 55, 57, 62, 70, 72, 76, 80, 82, 84, 85, 110, 111, 120, 121, 136, 139, 141, 142, 143, 144, 145, 147, 148, 167, 169, 171, "Expression", -23, 31, 33, 37, 41, 43, 45, 173, 175, 177, 178, 180, 181, 182, 184, 185, 186, 188, 189, 190, 201, 203, 205, 206, "Type", -3, 88, 103, 109, "ClassItem"],
    ["openedBy", 23, "<", 38, "InterpolationStart", 56, "[", 60, "{", 73, "(", 160, "JSXStartCloseTag"],
    ["closedBy", -2, 24, 168, ">", 40, "InterpolationEnd", 50, "]", 61, "}", 74, ")", 165, "JSXEndTag"]
  ],
  propSources: [xV],
  skippedNodes: [0, 5, 6, 277],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(VpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(VpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Vp(Y!b'{0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(W#S$i&j'|0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Vp(Y!b'|0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(U':f$i&j(Y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Y!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Vp(Y!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Vp(Y!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Y!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Y!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(VpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(VpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Vp(Y!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(n%1l(Vp(Y!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Vp(Y!b$]#t(S,2j(d$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Vp(Y!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Vp(Y!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(y+JY$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(X';W$i&j(VpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(VpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(VpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(VpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(VpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Vp(Y!b(T%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Vp(Y!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Vp(Y!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Vp(Y!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Vp(Y!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Y!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Y!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Y!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Y!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Y!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Y!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Vp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Vp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Vp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Vp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(VpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(VpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Vp(Y!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Vp(Y!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Vp(Y!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Vp(Y!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Vp(Y!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Vp(Y!b'}0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Vp(Y!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Y!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Y!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(VpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(VpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Vp(Y!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Vp(Y!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(q(Ct$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Vp(Y!b(`+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Vp(Y!b(S,2j$_#t(d$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Vp(Y!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(x+JY$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Vp(Y!b'{0/l$]#t(S,2j(d$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Vp(Y!b'|0/l$]#t(S,2j(d$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [mV, gV, yV, OV, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, fV, new Nc("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(b~~", 141, 339), new Nc("j~RQYZXz{^~^O(P~~aP!P!Qd~iO(Q~~", 25, 322)],
  topRules: { Script: [0, 7], SingleExpression: [1, 275], SingleClassItem: [2, 276] },
  dialects: { jsx: 0, ts: 15098 },
  dynamicPrecedences: { 80: 1, 82: 1, 94: 1, 169: 1, 199: 1 },
  specialized: [{ term: 326, get: (t) => DV[t] || -1 }, { term: 342, get: (t) => bV[t] || -1 }, { term: 95, get: (t) => vV[t] || -1 }],
  tokenPrec: 15124
}), FC = [
  /* @__PURE__ */ Rt("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Rt("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Rt("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Rt("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Rt("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Rt(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ Rt("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Rt(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ Rt(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Rt('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ Rt('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], wV = /* @__PURE__ */ FC.concat([
  /* @__PURE__ */ Rt("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Rt("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Rt("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), Fx = /* @__PURE__ */ new sA(), $C = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function ao(t) {
  return (e, r) => {
    let s = e.node.getChild("VariableDefinition");
    return s && r(s, t), !0;
  };
}
const AV = ["FunctionDeclaration"], CV = {
  FunctionDeclaration: /* @__PURE__ */ ao("function"),
  ClassDeclaration: /* @__PURE__ */ ao("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ ao("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ ao("type"),
  NamespaceDeclaration: /* @__PURE__ */ ao("namespace"),
  VariableDefinition(t, e) {
    t.matchContext(AV) || e(t, "variable");
  },
  TypeDefinition(t, e) {
    e(t, "type");
  },
  __proto__: null
};
function QC(t, e) {
  let r = Fx.get(e);
  if (r)
    return r;
  let s = [], i = !0;
  function n(a, l) {
    let c = t.sliceString(a.from, a.to);
    s.push({ label: c, type: l });
  }
  return e.cursor(Ne.IncludeAnonymous).iterate((a) => {
    if (i)
      i = !1;
    else if (a.name) {
      let l = CV[a.name];
      if (l && l(a, n) || $C.has(a.name))
        return !1;
    } else if (a.to - a.from > 8192) {
      for (let l of QC(t, a.node))
        s.push(l);
      return !1;
    }
  }), Fx.set(e, s), s;
}
const $x = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, BC = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  "JSXText",
  "JSXAttributeValue",
  "JSXOpenTag",
  "JSXCloseTag",
  "JSXSelfClosingTag",
  ".",
  "?."
];
function EV(t) {
  let e = Ue(t.state).resolveInner(t.pos, -1);
  if (BC.indexOf(e.name) > -1)
    return null;
  let r = e.name == "VariableName" || e.to - e.from < 20 && $x.test(t.state.sliceDoc(e.from, e.to));
  if (!r && !t.explicit)
    return null;
  let s = [];
  for (let i = e; i; i = i.parent)
    $C.has(i.name) && (s = s.concat(QC(t.state.doc, i)));
  return {
    options: s,
    from: r ? e.from : t.pos,
    validFor: $x
  };
}
const pr = /* @__PURE__ */ ya.define({
  name: "javascript",
  parser: /* @__PURE__ */ SV.configure({
    props: [
      /* @__PURE__ */ vh.add({
        IfStatement: /* @__PURE__ */ Vu({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ Vu({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: hq,
        SwitchBody: (t) => {
          let e = t.textAfter, r = /^\s*\}/.test(e), s = /^\s*(case|default)\b/.test(e);
          return t.baseIndent + (r ? 0 : s ? 1 : 2) * t.unit;
        },
        Block: /* @__PURE__ */ cq({ closing: "}" }),
        ArrowFunction: (t) => t.baseIndent + t.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ Vu({ except: /^\s*{/ }),
        JSXElement(t) {
          let e = /^\s*<\//.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        JSXEscape(t) {
          let e = /\s*\}/.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        }
      }),
      /* @__PURE__ */ Sh.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": hA,
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), IC = {
  test: (t) => /^JSX/.test(t.name),
  facet: /* @__PURE__ */ oA({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, NC = /* @__PURE__ */ pr.configure({ dialect: "ts" }, "typescript"), MC = /* @__PURE__ */ pr.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ Dg.add((t) => t.isTop ? [IC] : void 0)]
}), LC = /* @__PURE__ */ pr.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ Dg.add((t) => t.isTop ? [IC] : void 0)]
}, "typescript");
let _C = (t) => ({ label: t, type: "keyword" });
const RC = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(_C), TV = /* @__PURE__ */ RC.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(_C));
function kV(t = {}) {
  let e = t.jsx ? t.typescript ? LC : MC : t.typescript ? NC : pr, r = t.typescript ? wV.concat(TV) : FC.concat(RC);
  return new bg(e, [
    pr.data.of({
      autocomplete: kX(BC, dC(r))
    }),
    pr.data.of({
      autocomplete: EV
    }),
    t.jsx ? $V : []
  ]);
}
function PV(t) {
  for (; ; ) {
    if (t.name == "JSXOpenTag" || t.name == "JSXSelfClosingTag" || t.name == "JSXFragmentTag")
      return t;
    if (t.name == "JSXEscape" || !t.parent)
      return null;
    t = t.parent;
  }
}
function Qx(t, e, r = t.length) {
  for (let s = e == null ? void 0 : e.firstChild; s; s = s.nextSibling)
    if (s.name == "JSXIdentifier" || s.name == "JSXBuiltin" || s.name == "JSXNamespacedName" || s.name == "JSXMemberExpression")
      return t.sliceString(s.from, Math.min(s.to, r));
  return "";
}
const FV = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), $V = /* @__PURE__ */ J.inputHandler.of((t, e, r, s, i) => {
  if ((FV ? t.composing : t.compositionStarted) || t.state.readOnly || e != r || s != ">" && s != "/" || !pr.isActiveAt(t.state, e, -1))
    return !1;
  let n = i(), { state: a } = n, l = a.changeByRange((c) => {
    var p;
    let { head: d } = c, m = Ue(a).resolveInner(d - 1, -1), y;
    if (m.name == "JSXStartTag" && (m = m.parent), !(a.doc.sliceString(d - 1, d) != s || m.name == "JSXAttributeValue" && m.to > d)) {
      if (s == ">" && m.name == "JSXFragmentTag")
        return { range: c, changes: { from: d, insert: "</>" } };
      if (s == "/" && m.name == "JSXStartCloseTag") {
        let g = m.parent, x = g.parent;
        if (x && g.from == d - 2 && ((y = Qx(a.doc, x.firstChild, d)) || ((p = x.firstChild) === null || p === void 0 ? void 0 : p.name) == "JSXFragmentTag")) {
          let v = `${y}>`;
          return { range: L.cursor(d + v.length, -1), changes: { from: d, insert: v } };
        }
      } else if (s == ">") {
        let g = PV(m);
        if (g && g.name == "JSXOpenTag" && !/^\/?>|^<\//.test(a.doc.sliceString(d, d + 2)) && (y = Qx(a.doc, g, d)))
          return { range: c, changes: { from: d, insert: `</${y}>` } };
      }
    }
    return { range: c };
  });
  return l.changes.empty ? !1 : (t.dispatch([
    n,
    a.update(l, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
}), QV = 54, BV = 1, IV = 55, NV = 2, MV = 56, LV = 3, Bx = 4, _V = 5, Mc = 6, qC = 7, jC = 8, XC = 9, ZC = 10, RV = 11, qV = 12, jV = 13, Up = 57, XV = 14, Ix = 58, VC = 20, ZV = 22, zC = 23, VV = 24, Qf = 26, UC = 27, zV = 28, UV = 31, YV = 34, WV = 36, GV = 37, HV = 0, JV = 1, KV = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, ez = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, Nx = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function tz(t) {
  return t == 45 || t == 46 || t == 58 || t >= 65 && t <= 90 || t == 95 || t >= 97 && t <= 122 || t >= 161;
}
function YC(t) {
  return t == 9 || t == 10 || t == 13 || t == 32;
}
let Mx = null, Lx = null, _x = 0;
function Bf(t, e) {
  let r = t.pos + e;
  if (_x == r && Lx == t) return Mx;
  let s = t.peek(e);
  for (; YC(s); ) s = t.peek(++e);
  let i = "";
  for (; tz(s); )
    i += String.fromCharCode(s), s = t.peek(++e);
  return Lx = t, _x = r, Mx = i ? i.toLowerCase() : s == rz || s == sz ? void 0 : null;
}
const WC = 60, Lc = 62, Rg = 47, rz = 63, sz = 33, iz = 45;
function Rx(t, e) {
  this.name = t, this.parent = e;
}
const nz = [Mc, ZC, qC, jC, XC], az = new kC({
  start: null,
  shift(t, e, r, s) {
    return nz.indexOf(e) > -1 ? new Rx(Bf(s, 1) || "", t) : t;
  },
  reduce(t, e) {
    return e == VC && t ? t.parent : t;
  },
  reuse(t, e, r, s) {
    let i = e.type.id;
    return i == Mc || i == WV ? new Rx(Bf(s, 1) || "", t) : t;
  },
  strict: !1
}), oz = new mr((t, e) => {
  if (t.next != WC) {
    t.next < 0 && e.context && t.acceptToken(Up);
    return;
  }
  t.advance();
  let r = t.next == Rg;
  r && t.advance();
  let s = Bf(t, 0);
  if (s === void 0) return;
  if (!s) return t.acceptToken(r ? XV : Mc);
  let i = e.context ? e.context.name : null;
  if (r) {
    if (s == i) return t.acceptToken(RV);
    if (i && ez[i]) return t.acceptToken(Up, -2);
    if (e.dialectEnabled(HV)) return t.acceptToken(qV);
    for (let n = e.context; n; n = n.parent) if (n.name == s) return;
    t.acceptToken(jV);
  } else {
    if (s == "script") return t.acceptToken(qC);
    if (s == "style") return t.acceptToken(jC);
    if (s == "textarea") return t.acceptToken(XC);
    if (KV.hasOwnProperty(s)) return t.acceptToken(ZC);
    i && Nx[i] && Nx[i][s] ? t.acceptToken(Up, -1) : t.acceptToken(Mc);
  }
}, { contextual: !0 }), lz = new mr((t) => {
  for (let e = 0, r = 0; ; r++) {
    if (t.next < 0) {
      r && t.acceptToken(Ix);
      break;
    }
    if (t.next == iz)
      e++;
    else if (t.next == Lc && e >= 2) {
      r >= 3 && t.acceptToken(Ix, -2);
      break;
    } else
      e = 0;
    t.advance();
  }
});
function uz(t) {
  for (; t; t = t.parent)
    if (t.name == "svg" || t.name == "math") return !0;
  return !1;
}
const cz = new mr((t, e) => {
  if (t.next == Rg && t.peek(1) == Lc) {
    let r = e.dialectEnabled(JV) || uz(e.context);
    t.acceptToken(r ? _V : Bx, 2);
  } else t.next == Lc && t.acceptToken(Bx, 1);
});
function qg(t, e, r) {
  let s = 2 + t.length;
  return new mr((i) => {
    for (let n = 0, a = 0, l = 0; ; l++) {
      if (i.next < 0) {
        l && i.acceptToken(e);
        break;
      }
      if (n == 0 && i.next == WC || n == 1 && i.next == Rg || n >= 2 && n < s && i.next == t.charCodeAt(n - 2))
        n++, a++;
      else if ((n == 2 || n == s) && YC(i.next))
        a++;
      else if (n == s && i.next == Lc) {
        l > a ? i.acceptToken(e, -a) : i.acceptToken(r, -(a - 2));
        break;
      } else if ((i.next == 10 || i.next == 13) && l) {
        i.acceptToken(e, 1);
        break;
      } else
        n = a = 0;
      i.advance();
    }
  });
}
const hz = qg("script", QV, BV), pz = qg("style", IV, NV), dz = qg("textarea", MV, LV), fz = xh({
  "Text RawText": T.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": T.angleBracket,
  TagName: T.tagName,
  "MismatchedCloseTag/TagName": [T.tagName, T.invalid],
  AttributeName: T.attributeName,
  "AttributeValue UnquotedAttributeValue": T.attributeValue,
  Is: T.definitionOperator,
  "EntityReference CharacterReference": T.character,
  Comment: T.blockComment,
  ProcessingInst: T.processingInstruction,
  DoctypeDecl: T.documentMeta
}), mz = ba.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: " StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: az,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
    ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]
  ],
  propSources: [fz],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [hz, pz, dz, cz, oz, lz, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 509 },
  tokenPrec: 511
});
function GC(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let s of t.getChildren(zC)) {
    let i = s.getChild(VV), n = s.getChild(Qf) || s.getChild(UC);
    i && (r[e.read(i.from, i.to)] = n ? n.type.id == Qf ? e.read(n.from + 1, n.to - 1) : e.read(n.from, n.to) : "");
  }
  return r;
}
function qx(t, e) {
  let r = t.getChild(ZV);
  return r ? e.read(r.from, r.to) : " ";
}
function Yp(t, e, r) {
  let s;
  for (let i of r)
    if (!i.attrs || i.attrs(s || (s = GC(t.node.parent.firstChild, e))))
      return { parser: i.parser };
  return null;
}
function HC(t = [], e = []) {
  let r = [], s = [], i = [], n = [];
  for (let l of t)
    (l.tag == "script" ? r : l.tag == "style" ? s : l.tag == "textarea" ? i : n).push(l);
  let a = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let l of e) (a[l.name] || (a[l.name] = [])).push(l);
  return RR((l, c) => {
    let p = l.type.id;
    if (p == zV) return Yp(l, c, r);
    if (p == UV) return Yp(l, c, s);
    if (p == YV) return Yp(l, c, i);
    if (p == VC && n.length) {
      let d = l.node, m = d.firstChild, y = m && qx(m, c), g;
      if (y) {
        for (let x of n)
          if (x.tag == y && (!x.attrs || x.attrs(g || (g = GC(m, c))))) {
            let v = d.lastChild, w = v.type.id == GV ? v.from : d.to;
            if (w > m.to)
              return { parser: x.parser, overlay: [{ from: m.to, to: w }] };
          }
      }
    }
    if (a && p == zC) {
      let d = l.node, m;
      if (m = d.firstChild) {
        let y = a[c.read(m.from, m.to)];
        if (y) for (let g of y) {
          if (g.tagName && g.tagName != qx(d.parent, c)) continue;
          let x = d.lastChild;
          if (x.type.id == Qf) {
            let v = x.from + 1, w = x.lastChild, C = x.to - (w && w.isError ? 0 : 1);
            if (C > v) return { parser: g.parser, overlay: [{ from: v, to: C }] };
          } else if (x.type.id == UC)
            return { parser: g.parser, overlay: [{ from: x.from, to: x.to }] };
        }
      }
    }
    return null;
  });
}
const gz = 122, jx = 1, yz = 123, Oz = 124, JC = 2, xz = 125, Dz = 3, bz = 4, KC = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], vz = 58, Sz = 40, eE = 95, wz = 91, Uu = 45, Az = 46, Cz = 35, Ez = 37, Tz = 38, kz = 92, Pz = 10, Fz = 42;
function al(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 161;
}
function jg(t) {
  return t >= 48 && t <= 57;
}
function Xx(t) {
  return jg(t) || t >= 97 && t <= 102 || t >= 65 && t <= 70;
}
const tE = (t, e, r) => (s, i) => {
  for (let n = !1, a = 0, l = 0; ; l++) {
    let { next: c } = s;
    if (al(c) || c == Uu || c == eE || n && jg(c))
      !n && (c != Uu || l > 0) && (n = !0), a === l && c == Uu && a++, s.advance();
    else if (c == kz && s.peek(1) != Pz) {
      if (s.advance(), Xx(s.next)) {
        do
          s.advance();
        while (Xx(s.next));
        s.next == 32 && s.advance();
      } else s.next > -1 && s.advance();
      n = !0;
    } else {
      n && s.acceptToken(
        a == 2 && i.canShift(JC) ? e : c == Sz ? r : t
      );
      break;
    }
  }
}, $z = new mr(
  tE(yz, JC, Oz)
), Qz = new mr(
  tE(xz, Dz, bz)
), Bz = new mr((t) => {
  if (KC.includes(t.peek(-1))) {
    let { next: e } = t;
    (al(e) || e == eE || e == Cz || e == Az || e == Fz || e == wz || e == vz && al(t.peek(1)) || e == Uu || e == Tz) && t.acceptToken(gz);
  }
}), Iz = new mr((t) => {
  if (!KC.includes(t.peek(-1))) {
    let { next: e } = t;
    if (e == Ez && (t.advance(), t.acceptToken(jx)), al(e)) {
      do
        t.advance();
      while (al(t.next) || jg(t.next));
      t.acceptToken(jx);
    }
  }
}), Nz = xh({
  "AtKeyword import charset namespace keyframes media supports": T.definitionKeyword,
  "from to selector": T.keyword,
  NamespaceName: T.namespace,
  KeyframeName: T.labelName,
  KeyframeRangeName: T.operatorKeyword,
  TagName: T.tagName,
  ClassName: T.className,
  PseudoClassName: T.constant(T.className),
  IdName: T.labelName,
  "FeatureName PropertyName": T.propertyName,
  AttributeName: T.attributeName,
  NumberLiteral: T.number,
  KeywordQuery: T.keyword,
  UnaryQueryOp: T.operatorKeyword,
  "CallTag ValueName": T.atom,
  VariableName: T.variableName,
  Callee: T.operatorKeyword,
  Unit: T.unit,
  "UniversalSelector NestingSelector": T.definitionOperator,
  "MatchOp CompareOp": T.compareOperator,
  "ChildOp SiblingOp, LogicOp": T.logicOperator,
  BinOp: T.arithmeticOperator,
  Important: T.modifier,
  Comment: T.blockComment,
  ColorLiteral: T.color,
  "ParenthesizedContent StringLiteral": T.string,
  ":": T.punctuation,
  "PseudoOp #": T.derefOperator,
  "; ,": T.separator,
  "( )": T.paren,
  "[ ]": T.squareBracket,
  "{ }": T.brace
}), Mz = { __proto__: null, lang: 38, "nth-child": 38, "nth-last-child": 38, "nth-of-type": 38, "nth-last-of-type": 38, dir: 38, "host-context": 38, if: 84, url: 124, "url-prefix": 124, domain: 124, regexp: 124 }, Lz = { __proto__: null, or: 98, and: 98, not: 106, only: 106, layer: 170 }, _z = { __proto__: null, selector: 112, layer: 166 }, Rz = { __proto__: null, "@import": 162, "@media": 174, "@charset": 178, "@namespace": 182, "@keyframes": 188, "@supports": 200, "@scope": 204 }, qz = { __proto__: null, to: 207 }, jz = ba.deserialize({
  version: 14,
  states: "EbQYQdOOO#qQdOOP#xO`OOOOQP'#Cf'#CfOOQP'#Ce'#CeO#}QdO'#ChO$nQaO'#CcO$xQdO'#CkO%TQdO'#DpO%YQdO'#DrO%_QdO'#DuO%_QdO'#DxOOQP'#FV'#FVO&eQhO'#EhOOQS'#FU'#FUOOQS'#Ek'#EkQYQdOOO&lQdO'#EOO&PQhO'#EUO&lQdO'#EWO'aQdO'#EYO'lQdO'#E]O'tQhO'#EcO(VQdO'#EeO(bQaO'#CfO)VQ`O'#D{O)[Q`O'#F`O)gQdO'#F`QOQ`OOP)qO&jO'#CaPOOO)C@t)C@tOOQP'#Cj'#CjOOQP,59S,59SO#}QdO,59SO)|QdO,59VO%TQdO,5:[O%YQdO,5:^O%_QdO,5:aO%_QdO,5:cO%_QdO,5:dO%_QdO'#ErO*XQ`O,58}O*aQdO'#DzOOQS,58},58}OOQP'#Cn'#CnOOQO'#Dn'#DnOOQP,59V,59VO*hQ`O,59VO*mQ`O,59VOOQP'#Dq'#DqOOQP,5:[,5:[OOQO'#Ds'#DsO*rQpO,5:^O+]QaO,5:aO+sQaO,5:dOOQW'#DZ'#DZO,ZQhO'#DdO,xQhO'#FaO'tQhO'#DbO-WQ`O'#DhOOQW'#F['#F[O-]Q`O,5;SO-eQ`O'#DeOOQS-E8i-E8iOOQ['#Cs'#CsO-jQdO'#CtO.QQdO'#CzO.hQdO'#C}O/OQ!pO'#DPO1RQ!jO,5:jOOQO'#DU'#DUO*mQ`O'#DTO1cQ!nO'#FXO3`Q`O'#DVO3eQ`O'#DkOOQ['#FX'#FXO-`Q`O,5:pO3jQ!bO,5:rOOQS'#E['#E[O3rQ`O,5:tO3wQdO,5:tOOQO'#E_'#E_O4PQ`O,5:wO4UQhO,5:}O%_QdO'#DgOOQS,5;P,5;PO-eQ`O,5;PO4^QdO,5;PO4fQdO,5:gO4vQdO'#EtO5TQ`O,5;zO5TQ`O,5;zPOOO'#Ej'#EjP5`O&jO,58{POOO,58{,58{OOQP1G.n1G.nOOQP1G.q1G.qO*hQ`O1G.qO*mQ`O1G.qOOQP1G/v1G/vO5kQpO1G/xO5sQaO1G/{O6ZQaO1G/}O6qQaO1G0OO7XQaO,5;^OOQO-E8p-E8pOOQS1G.i1G.iO7cQ`O,5:fO7hQdO'#DoO7oQdO'#CrOOQP1G/x1G/xO&lQdO1G/xO7vQ!jO'#DZO8UQ!bO,59vO8^QhO,5:OOOQO'#F]'#F]O8XQ!bO,59zO'tQhO,59xO8fQhO'#EvO8sQ`O,5;{O9OQhO,59|O9uQhO'#DiOOQW,5:S,5:SOOQS1G0n1G0nOOQW,5:P,5:PO9|Q!fO'#FYOOQS'#FY'#FYOOQS'#Em'#EmO;^QdO,59`OOQ[,59`,59`O;tQdO,59fOOQ[,59f,59fO<[QdO,59iOOQ[,59i,59iOOQ[,59k,59kO&lQdO,59mO<rQhO'#EQOOQW'#EQ'#EQO=WQ`O1G0UO1[QhO1G0UOOQ[,59o,59oO'tQhO'#DXOOQ[,59q,59qO=]Q#tO,5:VOOQS1G0[1G0[OOQS1G0^1G0^OOQS1G0`1G0`O=hQ`O1G0`O=mQdO'#E`OOQS1G0c1G0cOOQS1G0i1G0iO=xQaO,5:RO-`Q`O1G0kOOQS1G0k1G0kO-eQ`O1G0kO>PQ!fO1G0ROOQO1G0R1G0ROOQO,5;`,5;`O>gQdO,5;`OOQO-E8r-E8rO>tQ`O1G1fPOOO-E8h-E8hPOOO1G.g1G.gOOQP7+$]7+$]OOQP7+%d7+%dO&lQdO7+%dOOQS1G0Q1G0QO?PQaO'#F_O?ZQ`O,5:ZO?`Q!fO'#ElO@^QdO'#FWO@hQ`O,59^O@mQ!bO7+%dO&lQdO1G/bO@uQhO1G/fOOQW1G/j1G/jOOQW1G/d1G/dOAWQhO,5;bOOQO-E8t-E8tOAfQhO'#DZOAtQhO'#F^OBPQ`O'#F^OBUQ`O,5:TOOQS-E8k-E8kOOQ[1G.z1G.zOOQ[1G/Q1G/QOOQ[1G/T1G/TOOQ[1G/X1G/XOBZQdO,5:lOOQS7+%p7+%pOB`Q`O7+%pOBeQhO'#DYOBmQ`O,59sO'tQhO,59sOOQ[1G/q1G/qOBuQ`O1G/qOOQS7+%z7+%zOBzQbO'#DPOOQO'#Eb'#EbOCYQ`O'#EaOOQO'#Ea'#EaOCeQ`O'#EwOCmQdO,5:zOOQS,5:z,5:zOOQ[1G/m1G/mOOQS7+&V7+&VO-`Q`O7+&VOCxQ!fO'#EsO&lQdO'#EsOEPQdO7+%mOOQO7+%m7+%mOOQO1G0z1G0zOEdQ!bO<<IOOElQdO'#EqOEvQ`O,5;yOOQP1G/u1G/uOOQS-E8j-E8jOFOQdO'#EpOFYQ`O,5;rOOQ]1G.x1G.xOOQP<<IO<<IOOFbQdO7+$|OOQO'#D]'#D]OFiQ!bO7+%QOFqQhO'#EoOF{Q`O,5;xO&lQdO,5;xOOQW1G/o1G/oOOQO'#ES'#ESOGTQ`O1G0WOOQS<<I[<<I[O&lQdO,59tOGnQhO1G/_OOQ[1G/_1G/_OGuQ`O1G/_OOQW-E8l-E8lOOQ[7+%]7+%]OOQO,5:{,5:{O=pQdO'#ExOCeQ`O,5;cOOQS,5;c,5;cOOQS-E8u-E8uOOQS1G0f1G0fOOQS<<Iq<<IqOG}Q!fO,5;_OOQS-E8q-E8qOOQO<<IX<<IXOOQPAN>jAN>jOIUQaO,5;]OOQO-E8o-E8oOI`QdO,5;[OOQO-E8n-E8nOOQW<<Hh<<HhOOQW<<Hl<<HlOIjQhO<<HlOI{QhO,5;ZOJWQ`O,5;ZOOQO-E8m-E8mOJ]QdO1G1dOBZQdO'#EuOJgQ`O7+%rOOQW7+%r7+%rOJoQ!bO1G/`OOQ[7+$y7+$yOJzQhO7+$yPKRQ`O'#EnOOQO,5;d,5;dOOQO-E8v-E8vOOQS1G0}1G0}OKWQ`OAN>WO&lQdO1G0uOK]Q`O7+'OOOQO,5;a,5;aOOQO-E8s-E8sOOQW<<I^<<I^OOQ[<<He<<HePOQW,5;Y,5;YOOQWG23rG23rOKeQdO7+&a",
  stateData: "Kx~O#sOS#tQQ~OW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#oRO~OQiOW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#ohO~O#m$SP~P!dO#tmO~O#ooO~O]qO`rOarOjsOmtO!juO!mwO#nvO~OpzO!^xO~P$SOc!QO#o|O#p}O~O#o!RO~O#o!TO~OW[OZ[O]TO`VOaVOjWOmXO!jYO!mZO#oRO~OS!]Oe!YO!V![O!Y!`O#q!XOp$TP~Ok$TP~P&POQ!jOe!cOm!dOp!eOr!mOt!mOz!kO!`!lO#o!bO#p!hO#}!fO~Ot!qO!`!lO#o!pO~Ot!sO#o!sO~OS!]Oe!YO!V![O!Y!`O#q!XO~Oe!vOpzO#Z!xO~O]YX`YX`!pXaYXjYXmYXpYX!^YX!jYX!mYX#nYX~O`!zO~Ok!{O#m$SXo$SX~O#m$SXo$SX~P!dO#u#OO#v#OO#w#QO~Oc#UO#o|O#p}O~OpzO!^xO~Oo$SP~P!dOe#`O~Oe#aO~Ol#bO!h#cO~O]qO`rOarOjsOmtO~Op!ia!^!ia!j!ia!m!ia#n!iad!ia~P*zOp!la!^!la!j!la!m!la#n!lad!la~P*zOR#gOS!]Oe!YOr#gOt#gO!V![O!Y!`O#q#dO#}!fO~O!R#iO!^#jOk$TXp$TX~Oe#mO~Ok#oOpzO~Oe!vO~O]#rO`#rOd#uOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl#wO~P&lO]#rO`#rOi#rOj#rOk#rOo#yO~P&lOP#zOSsXesXksXvsX!VsX!YsX!usX!wsX#qsX!TsXQsX]sX`sXdsXisXjsXmsXpsXrsXtsXzsX!`sX#osX#psX#}sXlsXosX!^sX!qsX#msX~Ov#{O!u#|O!w#}Ok$TP~P'tOe#aOS#{Xk#{Xv#{X!V#{X!Y#{X!u#{X!w#{X#q#{XQ#{X]#{X`#{Xd#{Xi#{Xj#{Xm#{Xp#{Xr#{Xt#{Xz#{X!`#{X#o#{X#p#{X#}#{Xl#{Xo#{X!^#{X!q#{X#m#{X~Oe$RO~Oe$TO~Ok$VOv#{O~Ok$WO~Ot$XO!`!lO~Op$YO~OpzO!R#iO~OpzO#Z$`O~O!q$bOk!oa#m!oao!oa~P&lOk#hX#m#hXo#hX~P!dOk!{O#m$Sao$Sa~O#u#OO#v#OO#w$hO~Ol$jO!h$kO~Op!ii!^!ii!j!ii!m!ii#n!iid!ii~P*zOp!ki!^!ki!j!ki!m!ki#n!kid!ki~P*zOp!li!^!li!j!li!m!li#n!lid!li~P*zOp#fa!^#fa~P$SOo$lO~Od$RP~P%_Od#zP~P&lO`!PXd}X!R}X!T!PX~O`$sO!T$tO~Od$uO!R#iO~Ok#jXp#jX!^#jX~P'tO!^#jOk$Tap$Ta~O!R#iOk!Uap!Ua!^!Uad!Ua`!Ua~OS!]Oe!YO!V![O!Y!`O#q$yO~Od$QP~P9dOv#{OQ#|X]#|X`#|Xd#|Xe#|Xi#|Xj#|Xk#|Xm#|Xp#|Xr#|Xt#|Xz#|X!`#|X#o#|X#p#|X#}#|Xl#|Xo#|X~O]#rO`#rOd%OOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl%PO~P&lO]#rO`#rOi#rOj#rOk#rOo%QO~P&lOe%SOS!tXk!tX!V!tX!Y!tX#q!tX~Ok%TO~Od%YOt%ZO!a%ZO~Ok%[O~Oo%cO#o%^O#}%]O~Od%dO~P$SOv#{O!^%hO!q%jOk!oi#m!oio!oi~P&lOk#ha#m#hao#ha~P!dOk!{O#m$Sio$Si~O!^%mOd$RX~P$SOd%oO~Ov#{OQ#`Xd#`Xe#`Xm#`Xp#`Xr#`Xt#`Xz#`X!^#`X!`#`X#o#`X#p#`X#}#`X~O!^%qOd#zX~P&lOd%sO~Ol%tOv#{O~OR#gOr#gOt#gO#q%vO#}!fO~O!R#iOk#jap#ja!^#ja~O`!PXd}X!R}X!^}X~O!R#iO!^%xOd$QX~O`%zO~Od%{O~O#o%|O~Ok&OO~O`&PO!R#iO~Od&ROk&QO~Od&UO~OP#zOpsX!^sXdsX~O#}%]Op#TX!^#TX~OpzO!^&WO~Oo&[O#o%^O#}%]O~Ov#{OQ#gXe#gXk#gXm#gXp#gXr#gXt#gXz#gX!^#gX!`#gX!q#gX#m#gX#o#gX#p#gX#}#gXo#gX~O!^%hO!q&`Ok!oq#m!oqo!oq~P&lOl&aOv#{O~Od#eX!^#eX~P%_O!^%mOd$Ra~Od#dX!^#dX~P&lO!^%qOd#za~Od&fO~P&lOd&gO!T&hO~Od#cX!^#cX~P9dO!^%xOd$Qa~O]&mOd&oO~OS#bae#ba!V#ba!Y#ba#q#ba~Od&qO~PG]Od&qOk&rO~Ov#{OQ#gae#gak#gam#gap#gar#gat#gaz#ga!^#ga!`#ga!q#ga#m#ga#o#ga#p#ga#}#gao#ga~Od#ea!^#ea~P$SOd#da!^#da~P&lOR#gOr#gOt#gO#q%vO#}%]O~O!R#iOd#ca!^#ca~O`&xO~O!^%xOd$Qi~P&lO]&mOd&|O~Ov#{Od|ik|i~Od&}O~PG]Ok'OO~Od'PO~O!^%xOd$Qq~Od#cq!^#cq~P&lO#s!a#t#}]#}v!m~",
  goto: "2h$UPPPPP$VP$YP$c$uP$cP%X$cPP%_PPP%e%o%oPPPPP%oPP%oP&]P%oP%o'W%oP't'w'}'}(^'}P'}P'}P'}'}P(m'}(yP(|PP)p)v$c)|$c*SP$cP$c$cP*Y*{+YP$YP+aP+dP$YP$YP$YP+j$YP+m+p+s+z$YP$YPP$YP,P,V,f,|-[-b-l-r-x.O.U.`.f.l.rPPPPPPPPPPP.x/R/w/z0|P1U1u2O2R2U2[RnQ_^OP`kz!{$dq[OPYZ`kuvwxz!v!{#`$d%mqSOPYZ`kuvwxz!v!{#`$d%mQpTR#RqQ!OVR#SrQ#S!QS$Q!i!jR$i#U!V!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'Q!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QU#g!Y$t&hU%`$Y%b&WR&V%_!V!iac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QR$S!kQ%W$RR&S%Xk!^]bf!Y![!g#i#j#m$P$R%X%xQ#e!YQ${#mQ%w$tQ&j%xR&w&hQ!ygQ#p!`Q$^!xR%f$`R#n!]!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QQ!qdR$X!rQ!PVR#TrQ#S!PR$i#TQ!SWR#VsQ!UXR#WtQ{UQ!wgQ#^yQ#o!_Q$U!nQ$[!uQ$_!yQ%e$^Q&Y%aQ&]%fR&v&XSjPzQ!}kQ$c!{R%k$dZiPkz!{$dR$P!gQ%}%SR&z&mR!rdR!teR$Z!tS%a$Y%bR&t&WV%_$Y%b&WQ#PmR$g#PQ`OSkPzU!a`k$dR$d!{Q$p#aY%p$p%u&d&l'QQ%u$sQ&d%qQ&l%zR'Q&xQ#t!cQ#v!dQ#x!eV$}#t#v#xQ%X$RR&T%XQ%y$zS&k%y&yR&y&lQ%r$pR&e%rQ%n$mR&c%nQyUR#]yQ%i$aR&_%iQ!|jS$e!|$fR$f!}Q&n%}R&{&nQ#k!ZR$x#kQ%b$YR&Z%bQ&X%aR&u&X__OP`kz!{$d^UOP`kz!{$dQ!VYQ!WZQ#XuQ#YvQ#ZwQ#[xQ$]!vQ$m#`R&b%mR$q#aQ!gaQ!oc[#q!c!d!e#t#v#xQ$a!zd$o#a$p$s%q%u%z&d&l&x'QQ$r#cQ%R#{S%g$a%iQ%l$kQ&^%hR&p&P]#s!c!d!e#t#v#xW!Z]b!g$PQ!ufQ#f!YQ#l![Q$v#iQ$w#jQ$z#mS%V$R%XR&i%xQ#h!YQ%w$tR&w&hR$|#mR$n#`QlPR#_zQ!_]Q!nbQ$O!gR%U$P",
  nodeNames: " Unit VariableName VariableName QueryCallee Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector . ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue AtKeyword # ; ] [ BracketedValue } { BracedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee IfExpression if ArgList IfBranch KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp ComparisonQuery CompareOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector ParenthesizedSelector CallQuery ArgList , CallLiteral CallTag ParenthesizedContent PseudoClassName ArgList IdSelector IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp Block Declaration PropertyName Important ImportStatement import Layer layer LayerName layer MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports ScopeStatement scope to AtRule Styles",
  maxTerm: 143,
  nodeProps: [
    ["isolate", -2, 5, 36, ""],
    ["openedBy", 20, "(", 28, "[", 31, "{"],
    ["closedBy", 21, ")", 29, "]", 32, "}"]
  ],
  propSources: [Nz],
  skippedNodes: [0, 5, 106],
  repeatNodeCount: 15,
  tokenData: "JQ~R!YOX$qX^%i^p$qpq%iqr({rs-ust/itu6Wuv$qvw7Qwx7cxy9Qyz9cz{9h{|:R|}>t}!O?V!O!P?t!P!Q@]!Q![AU![!]BP!]!^B{!^!_C^!_!`DY!`!aDm!a!b$q!b!cEn!c!}$q!}#OG{#O#P$q#P#QH^#Q#R6W#R#o$q#o#pHo#p#q6W#q#rIQ#r#sIc#s#y$q#y#z%i#z$f$q$f$g%i$g#BY$q#BY#BZ%i#BZ$IS$q$IS$I_%i$I_$I|$q$I|$JO%i$JO$JT$q$JT$JU%i$JU$KV$q$KV$KW%i$KW&FU$q&FU&FV%i&FV;'S$q;'S;=`Iz<%lO$q`$tSOy%Qz;'S%Q;'S;=`%c<%lO%Q`%VS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q`%fP;=`<%l%Q~%nh#s~OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Q~'ah#s~!a`OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Qj)OUOy%Qz#]%Q#]#^)b#^;'S%Q;'S;=`%c<%lO%Qj)gU!a`Oy%Qz#a%Q#a#b)y#b;'S%Q;'S;=`%c<%lO%Qj*OU!a`Oy%Qz#d%Q#d#e*b#e;'S%Q;'S;=`%c<%lO%Qj*gU!a`Oy%Qz#c%Q#c#d*y#d;'S%Q;'S;=`%c<%lO%Qj+OU!a`Oy%Qz#f%Q#f#g+b#g;'S%Q;'S;=`%c<%lO%Qj+gU!a`Oy%Qz#h%Q#h#i+y#i;'S%Q;'S;=`%c<%lO%Qj,OU!a`Oy%Qz#T%Q#T#U,b#U;'S%Q;'S;=`%c<%lO%Qj,gU!a`Oy%Qz#b%Q#b#c,y#c;'S%Q;'S;=`%c<%lO%Qj-OU!a`Oy%Qz#h%Q#h#i-b#i;'S%Q;'S;=`%c<%lO%Qj-iS!qY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q~-xWOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c<%lO-u~.gOt~~.jRO;'S-u;'S;=`.s;=`O-u~.vXOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c;=`<%l-u<%lO-u~/fP;=`<%l-uj/nYjYOy%Qz!Q%Q!Q![0^![!c%Q!c!i0^!i#T%Q#T#Z0^#Z;'S%Q;'S;=`%c<%lO%Qj0cY!a`Oy%Qz!Q%Q!Q![1R![!c%Q!c!i1R!i#T%Q#T#Z1R#Z;'S%Q;'S;=`%c<%lO%Qj1WY!a`Oy%Qz!Q%Q!Q![1v![!c%Q!c!i1v!i#T%Q#T#Z1v#Z;'S%Q;'S;=`%c<%lO%Qj1}YrY!a`Oy%Qz!Q%Q!Q![2m![!c%Q!c!i2m!i#T%Q#T#Z2m#Z;'S%Q;'S;=`%c<%lO%Qj2tYrY!a`Oy%Qz!Q%Q!Q![3d![!c%Q!c!i3d!i#T%Q#T#Z3d#Z;'S%Q;'S;=`%c<%lO%Qj3iY!a`Oy%Qz!Q%Q!Q![4X![!c%Q!c!i4X!i#T%Q#T#Z4X#Z;'S%Q;'S;=`%c<%lO%Qj4`YrY!a`Oy%Qz!Q%Q!Q![5O![!c%Q!c!i5O!i#T%Q#T#Z5O#Z;'S%Q;'S;=`%c<%lO%Qj5TY!a`Oy%Qz!Q%Q!Q![5s![!c%Q!c!i5s!i#T%Q#T#Z5s#Z;'S%Q;'S;=`%c<%lO%Qj5zSrY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qd6ZUOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qd6tS!hS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qb7VSZQOy%Qz;'S%Q;'S;=`%c<%lO%Q~7fWOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z<%lO7c~8RRO;'S7c;'S;=`8[;=`O7c~8_XOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z;=`<%l7c<%lO7c~8}P;=`<%l7cj9VSeYOy%Qz;'S%Q;'S;=`%c<%lO%Q~9hOd~n9oUWQvWOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qj:YWvW!mQOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj:wU!a`Oy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Qj;bY!a`#}YOy%Qz!Q%Q!Q![;Z![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj<VY!a`Oy%Qz{%Q{|<u|}%Q}!O<u!O!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj<zU!a`Oy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj=eU!a`#}YOy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj>O[!a`#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj>yS!^YOy%Qz;'S%Q;'S;=`%c<%lO%Qj?[WvWOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj?yU]YOy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Q~@bTvWOy%Qz{@q{;'S%Q;'S;=`%c<%lO%Q~@xS!a`#t~Oy%Qz;'S%Q;'S;=`%c<%lO%QjAZ[#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%QjBUU`YOy%Qz![%Q![!]Bh!];'S%Q;'S;=`%c<%lO%QbBoSaQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjCQSkYOy%Qz;'S%Q;'S;=`%c<%lO%QhCcU!TWOy%Qz!_%Q!_!`Cu!`;'S%Q;'S;=`%c<%lO%QhC|S!TW!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QlDaS!TW!hSOy%Qz;'S%Q;'S;=`%c<%lO%QjDtV!jQ!TWOy%Qz!_%Q!_!`Cu!`!aEZ!a;'S%Q;'S;=`%c<%lO%QbEbS!jQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjEqYOy%Qz}%Q}!OFa!O!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjFfW!a`Oy%Qz!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjGV[iY!a`Oy%Qz}%Q}!OGO!O!Q%Q!Q![GO![!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjHQSmYOy%Qz;'S%Q;'S;=`%c<%lO%QnHcSl^Oy%Qz;'S%Q;'S;=`%c<%lO%QjHtSpYOy%Qz;'S%Q;'S;=`%c<%lO%QjIVSoYOy%Qz;'S%Q;'S;=`%c<%lO%QfIhU!mQOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Q`I}P;=`<%l$q",
  tokenizers: [Bz, Iz, $z, Qz, 1, 2, 3, 4, new Nc("m~RRYZ[z{a~~g~aO#v~~dP!P!Qg~lO#w~~", 28, 129)],
  topRules: { StyleSheet: [0, 6], Styles: [1, 105] },
  specialized: [{ term: 124, get: (t) => Mz[t] || -1 }, { term: 125, get: (t) => Lz[t] || -1 }, { term: 4, get: (t) => _z[t] || -1 }, { term: 25, get: (t) => Rz[t] || -1 }, { term: 123, get: (t) => qz[t] || -1 }],
  tokenPrec: 1963
});
let Wp = null;
function Gp() {
  if (!Wp && typeof document == "object" && document.body) {
    let { style: t } = document.body, e = [], r = /* @__PURE__ */ new Set();
    for (let s in t)
      s != "cssText" && s != "cssFloat" && typeof t[s] == "string" && (/[A-Z]/.test(s) && (s = s.replace(/[A-Z]/g, (i) => "-" + i.toLowerCase())), r.has(s) || (e.push(s), r.add(s)));
    Wp = e.sort().map((s) => ({ type: "property", label: s, apply: s + ": " }));
  }
  return Wp || [];
}
const Zx = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((t) => ({ type: "class", label: t })), Vx = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((t) => ({ type: "keyword", label: t })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((t) => ({ type: "constant", label: t }))), Xz = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((t) => ({ type: "type", label: t })), Zz = /* @__PURE__ */ [
  "@charset",
  "@color-profile",
  "@container",
  "@counter-style",
  "@font-face",
  "@font-feature-values",
  "@font-palette-values",
  "@import",
  "@keyframes",
  "@layer",
  "@media",
  "@namespace",
  "@page",
  "@position-try",
  "@property",
  "@scope",
  "@starting-style",
  "@supports",
  "@view-transition"
].map((t) => ({ type: "keyword", label: t })), Ss = /^(\w[\w-]*|-\w[\w-]*|)$/, Vz = /^-(-[\w-]*)?$/;
function zz(t, e) {
  var r;
  if ((t.name == "(" || t.type.isError) && (t = t.parent || t), t.name != "ArgList")
    return !1;
  let s = (r = t.parent) === null || r === void 0 ? void 0 : r.firstChild;
  return (s == null ? void 0 : s.name) != "Callee" ? !1 : e.sliceString(s.from, s.to) == "var";
}
const zx = /* @__PURE__ */ new sA(), Uz = ["Declaration"];
function Yz(t) {
  for (let e = t; ; ) {
    if (e.type.isTop)
      return e;
    if (!(e = e.parent))
      return t;
  }
}
function rE(t, e, r) {
  if (e.to - e.from > 4096) {
    let s = zx.get(e);
    if (s)
      return s;
    let i = [], n = /* @__PURE__ */ new Set(), a = e.cursor(Ne.IncludeAnonymous);
    if (a.firstChild())
      do
        for (let l of rE(t, a.node, r))
          n.has(l.label) || (n.add(l.label), i.push(l));
      while (a.nextSibling());
    return zx.set(e, i), i;
  } else {
    let s = [], i = /* @__PURE__ */ new Set();
    return e.cursor().iterate((n) => {
      var a;
      if (r(n) && n.matchContext(Uz) && ((a = n.node.nextSibling) === null || a === void 0 ? void 0 : a.name) == ":") {
        let l = t.sliceString(n.from, n.to);
        i.has(l) || (i.add(l), s.push({ label: l, type: "variable" }));
      }
    }), s;
  }
}
const Wz = (t) => (e) => {
  let { state: r, pos: s } = e, i = Ue(r).resolveInner(s, -1), n = i.type.isError && i.from == i.to - 1 && r.doc.sliceString(i.from, i.to) == "-";
  if (i.name == "PropertyName" || (n || i.name == "TagName") && /^(Block|Styles)$/.test(i.resolve(i.to).name))
    return { from: i.from, options: Gp(), validFor: Ss };
  if (i.name == "ValueName")
    return { from: i.from, options: Vx, validFor: Ss };
  if (i.name == "PseudoClassName")
    return { from: i.from, options: Zx, validFor: Ss };
  if (t(i) || (e.explicit || n) && zz(i, r.doc))
    return {
      from: t(i) || n ? i.from : s,
      options: rE(r.doc, Yz(i), t),
      validFor: Vz
    };
  if (i.name == "TagName") {
    for (let { parent: c } = i; c; c = c.parent)
      if (c.name == "Block")
        return { from: i.from, options: Gp(), validFor: Ss };
    return { from: i.from, options: Xz, validFor: Ss };
  }
  if (i.name == "AtKeyword")
    return { from: i.from, options: Zz, validFor: Ss };
  if (!e.explicit)
    return null;
  let a = i.resolve(s), l = a.childBefore(s);
  return l && l.name == ":" && a.name == "PseudoClassSelector" ? { from: s, options: Zx, validFor: Ss } : l && l.name == ":" && a.name == "Declaration" || a.name == "ArgList" ? { from: s, options: Vx, validFor: Ss } : a.name == "Block" || a.name == "Styles" ? { from: s, options: Gp(), validFor: Ss } : null;
}, Gz = /* @__PURE__ */ Wz((t) => t.name == "VariableName"), _c = /* @__PURE__ */ ya.define({
  name: "css",
  parser: /* @__PURE__ */ jz.configure({
    props: [
      /* @__PURE__ */ vh.add({
        Declaration: /* @__PURE__ */ Vu()
      }),
      /* @__PURE__ */ Sh.add({
        "Block KeyframeList": hA
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function Hz() {
  return new bg(_c, _c.data.of({ autocomplete: Gz }));
}
const oo = ["_blank", "_self", "_top", "_parent"], Hp = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], Jp = ["get", "post", "put", "delete"], Kp = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], nr = ["true", "false"], ae = {}, Jz = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: oo,
      hreflang: null
    }
  },
  abbr: ae,
  address: ae,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: ae,
  aside: ae,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: ae,
  base: { attrs: { href: null, target: oo } },
  bdi: ae,
  bdo: ae,
  blockquote: { attrs: { cite: null } },
  body: ae,
  br: ae,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: Kp,
      formmethod: Jp,
      formnovalidate: ["novalidate"],
      formtarget: oo,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: ae,
  center: ae,
  cite: ae,
  code: ae,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: ae,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: ae,
  div: ae,
  dl: ae,
  dt: ae,
  em: ae,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: ae,
  figure: ae,
  footer: ae,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Hp,
      autocomplete: ["on", "off"],
      enctype: Kp,
      method: Jp,
      novalidate: ["novalidate"],
      target: oo
    }
  },
  h1: ae,
  h2: ae,
  h3: ae,
  h4: ae,
  h5: ae,
  h6: ae,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: ae,
  hgroup: ae,
  hr: ae,
  html: {
    attrs: { manifest: null }
  },
  i: ae,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: Kp,
      formmethod: Jp,
      formnovalidate: ["novalidate"],
      formtarget: oo,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: ae,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: ae,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: ae,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Hp,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: ae,
  noscript: ae,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: ae,
  param: { attrs: { name: null, value: null } },
  pre: ae,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: ae,
  rt: ae,
  ruby: ae,
  samp: ae,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Hp
    }
  },
  section: ae,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: ae,
  source: { attrs: { src: null, type: null, media: null } },
  span: ae,
  strong: ae,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: ae,
  summary: ae,
  sup: ae,
  table: ae,
  tbody: ae,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: ae,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: ae,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: ae,
  time: { attrs: { datetime: null } },
  title: ae,
  tr: ae,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: ae,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: ae
}, sE = {
  accesskey: null,
  class: null,
  contenteditable: nr,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: nr,
  autocorrect: nr,
  autocapitalize: nr,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": nr,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": nr,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": nr,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": nr,
  "aria-hidden": nr,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": nr,
  "aria-multiselectable": nr,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": nr,
  "aria-relevant": null,
  "aria-required": nr,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, iE = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((t) => "on" + t);
for (let t of iE)
  sE[t] = null;
class Rc {
  constructor(e, r) {
    this.tags = Object.assign(Object.assign({}, Jz), e), this.globalAttrs = Object.assign(Object.assign({}, sE), r), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}
Rc.default = /* @__PURE__ */ new Rc();
function va(t, e, r = t.length) {
  if (!e)
    return "";
  let s = e.firstChild, i = s && s.getChild("TagName");
  return i ? t.sliceString(i.from, Math.min(i.to, r)) : "";
}
function Sa(t, e = !1) {
  for (; t; t = t.parent)
    if (t.name == "Element")
      if (e)
        e = !1;
      else
        return t;
  return null;
}
function nE(t, e, r) {
  let s = r.tags[va(t, Sa(e))];
  return (s == null ? void 0 : s.children) || r.allTags;
}
function Xg(t, e) {
  let r = [];
  for (let s = Sa(e); s && !s.type.isTop; s = Sa(s.parent)) {
    let i = va(t, s);
    if (i && s.lastChild.name == "CloseTag")
      break;
    i && r.indexOf(i) < 0 && (e.name == "EndTag" || e.from >= s.firstChild.to) && r.push(i);
  }
  return r;
}
const aE = /^[:\-\.\w\u00b7-\uffff]*$/;
function Ux(t, e, r, s, i) {
  let n = /\s*>/.test(t.sliceDoc(i, i + 5)) ? "" : ">", a = Sa(r, !0);
  return {
    from: s,
    to: i,
    options: nE(t.doc, a, e).map((l) => ({ label: l, type: "type" })).concat(Xg(t.doc, r).map((l, c) => ({
      label: "/" + l,
      apply: "/" + l + n,
      type: "type",
      boost: 99 - c
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function Yx(t, e, r, s) {
  let i = /\s*>/.test(t.sliceDoc(s, s + 5)) ? "" : ">";
  return {
    from: r,
    to: s,
    options: Xg(t.doc, e).map((n, a) => ({ label: n, apply: n + i, type: "type", boost: 99 - a })),
    validFor: aE
  };
}
function Kz(t, e, r, s) {
  let i = [], n = 0;
  for (let a of nE(t.doc, r, e))
    i.push({ label: "<" + a, type: "type" });
  for (let a of Xg(t.doc, r))
    i.push({ label: "</" + a + ">", type: "type", boost: 99 - n++ });
  return { from: s, to: s, options: i, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function eU(t, e, r, s, i) {
  let n = Sa(r), a = n ? e.tags[va(t.doc, n)] : null, l = a && a.attrs ? Object.keys(a.attrs) : [], c = a && a.globalAttrs === !1 ? l : l.length ? l.concat(e.globalAttrNames) : e.globalAttrNames;
  return {
    from: s,
    to: i,
    options: c.map((p) => ({ label: p, type: "property" })),
    validFor: aE
  };
}
function tU(t, e, r, s, i) {
  var n;
  let a = (n = r.parent) === null || n === void 0 ? void 0 : n.getChild("AttributeName"), l = [], c;
  if (a) {
    let p = t.sliceDoc(a.from, a.to), d = e.globalAttrs[p];
    if (!d) {
      let m = Sa(r), y = m ? e.tags[va(t.doc, m)] : null;
      d = (y == null ? void 0 : y.attrs) && y.attrs[p];
    }
    if (d) {
      let m = t.sliceDoc(s, i).toLowerCase(), y = '"', g = '"';
      /^['"]/.test(m) ? (c = m[0] == '"' ? /^[^"]*$/ : /^[^']*$/, y = "", g = t.sliceDoc(i, i + 1) == m[0] ? "" : m[0], m = m.slice(1), s++) : c = /^[^\s<>='"]*$/;
      for (let x of d)
        l.push({ label: x, apply: y + x + g, type: "constant" });
    }
  }
  return { from: s, to: i, options: l, validFor: c };
}
function rU(t, e) {
  let { state: r, pos: s } = e, i = Ue(r).resolveInner(s, -1), n = i.resolve(s);
  for (let a = s, l; n == i && (l = i.childBefore(a)); ) {
    let c = l.lastChild;
    if (!c || !c.type.isError || c.from < c.to)
      break;
    n = i = l, a = c.from;
  }
  return i.name == "TagName" ? i.parent && /CloseTag$/.test(i.parent.name) ? Yx(r, i, i.from, s) : Ux(r, t, i, i.from, s) : i.name == "StartTag" ? Ux(r, t, i, s, s) : i.name == "StartCloseTag" || i.name == "IncompleteCloseTag" ? Yx(r, i, s, s) : i.name == "OpenTag" || i.name == "SelfClosingTag" || i.name == "AttributeName" ? eU(r, t, i, i.name == "AttributeName" ? i.from : s, s) : i.name == "Is" || i.name == "AttributeValue" || i.name == "UnquotedAttributeValue" ? tU(r, t, i, i.name == "Is" ? s : i.from, s) : e.explicit && (n.name == "Element" || n.name == "Text" || n.name == "Document") ? Kz(r, t, i, s) : null;
}
function sU(t) {
  let { extraTags: e, extraGlobalAttributes: r } = t, s = r || e ? new Rc(e, r) : Rc.default;
  return (i) => rU(s, i);
}
const iU = /* @__PURE__ */ pr.parser.configure({ top: "SingleExpression" }), oE = [
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript" || t.lang == "ts",
    parser: NC.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/babel" || t.type == "text/jsx",
    parser: MC.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript-jsx",
    parser: LC.parser
  },
  {
    tag: "script",
    attrs(t) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(t.type);
    },
    parser: iU
  },
  {
    tag: "script",
    attrs(t) {
      return !t.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(t.type);
    },
    parser: pr.parser
  },
  {
    tag: "style",
    attrs(t) {
      return (!t.lang || t.lang == "css") && (!t.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(t.type));
    },
    parser: _c.parser
  }
], lE = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ _c.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ iE.map((t) => ({ name: t, parser: pr.parser }))), uE = /* @__PURE__ */ ya.define({
  name: "html",
  parser: /* @__PURE__ */ mz.configure({
    props: [
      /* @__PURE__ */ vh.add({
        Element(t) {
          let e = /^(\s*)(<\/)?/.exec(t.textAfter);
          return t.node.to <= t.pos + e[0].length ? t.continue() : t.lineIndent(t.node.from) + (e[2] ? 0 : t.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        },
        Document(t) {
          if (t.pos + /\s*/.exec(t.textAfter)[0].length < t.node.to)
            return t.continue();
          let e = null, r;
          for (let s = t.node; ; ) {
            let i = s.lastChild;
            if (!i || i.name != "Element" || i.to != s.to)
              break;
            e = s = i;
          }
          return e && !((r = e.lastChild) && (r.name == "CloseTag" || r.name == "SelfClosingTag")) ? t.lineIndent(e.from) + t.unit : null;
        }
      }),
      /* @__PURE__ */ Sh.add({
        Element(t) {
          let e = t.firstChild, r = t.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: r.name == "CloseTag" ? r.from : t.to };
        }
      }),
      /* @__PURE__ */ wA.add({
        "OpenTag CloseTag": (t) => t.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
}), Yu = /* @__PURE__ */ uE.configure({
  wrap: /* @__PURE__ */ HC(oE, lE)
});
function nU(t = {}) {
  let e = "", r;
  t.matchClosingTags === !1 && (e = "noMatch"), t.selfClosingTags === !0 && (e = (e ? e + " " : "") + "selfClosing"), (t.nestedLanguages && t.nestedLanguages.length || t.nestedAttributes && t.nestedAttributes.length) && (r = HC((t.nestedLanguages || []).concat(oE), (t.nestedAttributes || []).concat(lE)));
  let s = r ? uE.configure({ wrap: r, dialect: e }) : e ? Yu.configure({ dialect: e }) : Yu;
  return new bg(s, [
    Yu.data.of({ autocomplete: sU(t) }),
    t.autoCloseTags !== !1 ? aU : [],
    kV().support,
    Hz().support
  ]);
}
const Wx = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), aU = /* @__PURE__ */ J.inputHandler.of((t, e, r, s, i) => {
  if (t.composing || t.state.readOnly || e != r || s != ">" && s != "/" || !Yu.isActiveAt(t.state, e, -1))
    return !1;
  let n = i(), { state: a } = n, l = a.changeByRange((c) => {
    var p, d, m;
    let y = a.doc.sliceString(c.from - 1, c.to) == s, { head: g } = c, x = Ue(a).resolveInner(g, -1), v;
    if (y && s == ">" && x.name == "EndTag") {
      let w = x.parent;
      if (((d = (p = w.parent) === null || p === void 0 ? void 0 : p.lastChild) === null || d === void 0 ? void 0 : d.name) != "CloseTag" && (v = va(a.doc, w.parent, g)) && !Wx.has(v)) {
        let C = g + (a.doc.sliceString(g, g + 1) === ">" ? 1 : 0), b = `</${v}>`;
        return { range: c, changes: { from: g, to: C, insert: b } };
      }
    } else if (y && s == "/" && x.name == "IncompleteCloseTag") {
      let w = x.parent;
      if (x.from == g - 2 && ((m = w.lastChild) === null || m === void 0 ? void 0 : m.name) != "CloseTag" && (v = va(a.doc, w, g)) && !Wx.has(v)) {
        let C = g + (a.doc.sliceString(g, g + 1) === ">" ? 1 : 0), b = `${v}>`;
        return {
          range: L.cursor(g + b.length, -1),
          changes: { from: g, to: C, insert: b }
        };
      }
    }
    return { range: c };
  });
  return l.changes.empty ? !1 : (t.dispatch([
    n,
    a.update(l, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), oU = {
  svg: {
    info: "svg element",
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "defs",
      "path",
      "text",
      "rect",
      "circle",
      "ellipse",
      "line",
      "polyline",
      "polygon",
      "use",
      "image",
      "svg",
      "g",
      "view",
      "switch",
      "a",
      "altGlyphDef",
      "script",
      "style",
      "symbol",
      "marker",
      "clipPath",
      "mask",
      "linearGradient",
      "radialGradient",
      "pattern",
      "filter",
      "cursor",
      "font",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform",
      "color-profile",
      "font-face"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      onunload: null,
      onabort: null,
      onerror: null,
      onresize: null,
      onscroll: null,
      onzoom: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      viewBox: null,
      preserveAspectRatio: null,
      zoomAndPan: null,
      x: null,
      y: null,
      width: null,
      height: null,
      contentScriptType: null,
      contentStyleType: null,
      version: null
    }
  },
  g: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "defs",
      "path",
      "text",
      "rect",
      "circle",
      "ellipse",
      "line",
      "polyline",
      "polygon",
      "use",
      "image",
      "svg",
      "g",
      "view",
      "switch",
      "a",
      "altGlyphDef",
      "script",
      "style",
      "symbol",
      "marker",
      "clipPath",
      "mask",
      "linearGradient",
      "radialGradient",
      "pattern",
      "filter",
      "cursor",
      "font",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform",
      "color-profile",
      "font-face"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null
    }
  },
  defs: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "defs",
      "path",
      "text",
      "rect",
      "circle",
      "ellipse",
      "line",
      "polyline",
      "polygon",
      "use",
      "image",
      "svg",
      "g",
      "view",
      "switch",
      "a",
      "altGlyphDef",
      "script",
      "style",
      "symbol",
      "marker",
      "clipPath",
      "mask",
      "linearGradient",
      "radialGradient",
      "pattern",
      "filter",
      "cursor",
      "font",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform",
      "color-profile",
      "font-face"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null
    }
  },
  desc: {
    globalAttrs: !1,
    children: [],
    attrs: {
      id: null,
      class: null,
      style: null,
      content: null
    }
  },
  title: {
    globalAttrs: !1,
    children: [],
    attrs: {
      id: null,
      class: null,
      style: null,
      content: null
    }
  },
  symbol: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "defs",
      "path",
      "text",
      "rect",
      "circle",
      "ellipse",
      "line",
      "polyline",
      "polygon",
      "use",
      "image",
      "svg",
      "g",
      "view",
      "switch",
      "a",
      "altGlyphDef",
      "style",
      "symbol",
      "marker",
      "clipPath",
      "mask",
      "linearGradient",
      "radialGradient",
      "pattern",
      "filter",
      "cursor",
      "font",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform",
      "color-profile",
      "font-face"
    ],
    attrs: {
      id: null,
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      viewBox: null,
      preserveAspectRatio: null
    }
  },
  use: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null,
      x: null,
      y: null,
      width: null,
      height: null
    }
  },
  image: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      color: [
        "inherit",
        "white",
        "silver",
        "gray",
        "black",
        "navy",
        "blue",
        "aqua",
        "teal",
        "green",
        "olive"
      ],
      "color-interpolation": null,
      "color-rendering": null,
      "clip-path": [
        "auto",
        "inherit",
        "none"
      ],
      "clip-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      cursor: [
        "auto",
        "crosshair",
        "default",
        "pointer",
        "move",
        "e-resize",
        "ne-resize",
        "nw-resize",
        "n-resize",
        "se-resize",
        "sw-resize",
        "s-resize",
        "w-resize",
        "text",
        "wait",
        "help",
        "inherit"
      ],
      display: null,
      filter: [
        "none",
        "inherit"
      ],
      "image-rendering": null,
      mask: [
        "none",
        "inherit"
      ],
      opacity: null,
      "pointer-events": null,
      "shape-rendering": null,
      "text-rendering": null,
      visibility: null,
      clip: [
        "auto",
        "inherit"
      ],
      overflow: null,
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null,
      x: null,
      y: null,
      width: null,
      height: null
    }
  },
  switch: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "path",
      "text",
      "rect",
      "circle",
      "ellipse",
      "line",
      "polyline",
      "polygon",
      "use",
      "image",
      "svg",
      "g",
      "switch",
      "a",
      "foreignObject",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null
    }
  },
  style: {
    globalAttrs: !1,
    children: [],
    attrs: {
      id: null,
      type: null,
      media: null,
      title: null
    }
  },
  path: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      color: [
        "inherit",
        "white",
        "silver",
        "gray",
        "black",
        "navy",
        "blue",
        "aqua",
        "teal",
        "green",
        "olive"
      ],
      "color-interpolation": null,
      "color-rendering": null,
      fill: null,
      "fill-opacity": null,
      "fill-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      stroke: null,
      "stroke-dasharray": null,
      "stroke-dashoffset": null,
      "stroke-linecap": null,
      "stroke-linejoin": null,
      "stroke-miterlimit": null,
      "stroke-opacity": null,
      "stroke-width": null,
      "clip-path": [
        "auto",
        "inherit",
        "none"
      ],
      "clip-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      cursor: [
        "auto",
        "crosshair",
        "default",
        "pointer",
        "move",
        "e-resize",
        "ne-resize",
        "nw-resize",
        "n-resize",
        "se-resize",
        "sw-resize",
        "s-resize",
        "w-resize",
        "text",
        "wait",
        "help",
        "inherit"
      ],
      display: null,
      filter: [
        "none",
        "inherit"
      ],
      "image-rendering": null,
      mask: [
        "none",
        "inherit"
      ],
      opacity: null,
      "pointer-events": null,
      "shape-rendering": null,
      "text-rendering": null,
      visibility: null,
      "marker-start": [
        "none",
        "inherit"
      ],
      "marker-mid": [
        "none",
        "inherit"
      ],
      "marker-end": [
        "none",
        "inherit"
      ],
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null,
      d: null,
      pathLength: null
    }
  },
  rect: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      color: [
        "inherit",
        "white",
        "silver",
        "gray",
        "black",
        "navy",
        "blue",
        "aqua",
        "teal",
        "green",
        "olive"
      ],
      "color-interpolation": null,
      "color-rendering": null,
      fill: null,
      "fill-opacity": null,
      "fill-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      stroke: null,
      "stroke-dasharray": null,
      "stroke-dashoffset": null,
      "stroke-linecap": null,
      "stroke-linejoin": null,
      "stroke-miterlimit": null,
      "stroke-opacity": null,
      "stroke-width": null,
      "clip-path": [
        "auto",
        "inherit",
        "none"
      ],
      "clip-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      cursor: [
        "auto",
        "crosshair",
        "default",
        "pointer",
        "move",
        "e-resize",
        "ne-resize",
        "nw-resize",
        "n-resize",
        "se-resize",
        "sw-resize",
        "s-resize",
        "w-resize",
        "text",
        "wait",
        "help",
        "inherit"
      ],
      display: null,
      filter: [
        "none",
        "inherit"
      ],
      "image-rendering": null,
      mask: [
        "none",
        "inherit"
      ],
      opacity: null,
      "pointer-events": null,
      "shape-rendering": null,
      "text-rendering": null,
      visibility: null,
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null,
      x: null,
      y: null,
      width: null,
      height: null,
      rx: null,
      ry: null
    }
  },
  circle: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      color: [
        "inherit",
        "white",
        "silver",
        "gray",
        "black",
        "navy",
        "blue",
        "aqua",
        "teal",
        "green",
        "olive"
      ],
      "color-interpolation": null,
      "color-rendering": null,
      fill: null,
      "fill-opacity": null,
      "fill-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      stroke: null,
      "stroke-dasharray": null,
      "stroke-dashoffset": null,
      "stroke-linecap": null,
      "stroke-linejoin": null,
      "stroke-miterlimit": null,
      "stroke-opacity": null,
      "stroke-width": null,
      "clip-path": [
        "auto",
        "inherit",
        "none"
      ],
      "clip-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      cursor: [
        "auto",
        "crosshair",
        "default",
        "pointer",
        "move",
        "e-resize",
        "ne-resize",
        "nw-resize",
        "n-resize",
        "se-resize",
        "sw-resize",
        "s-resize",
        "w-resize",
        "text",
        "wait",
        "help",
        "inherit"
      ],
      display: null,
      filter: [
        "none",
        "inherit"
      ],
      "image-rendering": null,
      mask: [
        "none",
        "inherit"
      ],
      opacity: null,
      "pointer-events": null,
      "shape-rendering": null,
      "text-rendering": null,
      visibility: null,
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null,
      cx: null,
      cy: null,
      r: null
    }
  },
  ellipse: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      color: [
        "inherit",
        "white",
        "silver",
        "gray",
        "black",
        "navy",
        "blue",
        "aqua",
        "teal",
        "green",
        "olive"
      ],
      "color-interpolation": null,
      "color-rendering": null,
      fill: null,
      "fill-opacity": null,
      "fill-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      stroke: null,
      "stroke-dasharray": null,
      "stroke-dashoffset": null,
      "stroke-linecap": null,
      "stroke-linejoin": null,
      "stroke-miterlimit": null,
      "stroke-opacity": null,
      "stroke-width": null,
      "clip-path": [
        "auto",
        "inherit",
        "none"
      ],
      "clip-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      cursor: [
        "auto",
        "crosshair",
        "default",
        "pointer",
        "move",
        "e-resize",
        "ne-resize",
        "nw-resize",
        "n-resize",
        "se-resize",
        "sw-resize",
        "s-resize",
        "w-resize",
        "text",
        "wait",
        "help",
        "inherit"
      ],
      display: null,
      filter: [
        "none",
        "inherit"
      ],
      "image-rendering": null,
      mask: [
        "none",
        "inherit"
      ],
      opacity: null,
      "pointer-events": null,
      "shape-rendering": null,
      "text-rendering": null,
      visibility: null,
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null,
      cx: null,
      cy: null,
      rx: null,
      ry: null
    }
  },
  line: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      color: [
        "inherit",
        "white",
        "silver",
        "gray",
        "black",
        "navy",
        "blue",
        "aqua",
        "teal",
        "green",
        "olive"
      ],
      "color-interpolation": null,
      "color-rendering": null,
      fill: null,
      "fill-opacity": null,
      "fill-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      stroke: null,
      "stroke-dasharray": null,
      "stroke-dashoffset": null,
      "stroke-linecap": null,
      "stroke-linejoin": null,
      "stroke-miterlimit": null,
      "stroke-opacity": null,
      "stroke-width": null,
      "clip-path": [
        "auto",
        "inherit",
        "none"
      ],
      "clip-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      cursor: [
        "auto",
        "crosshair",
        "default",
        "pointer",
        "move",
        "e-resize",
        "ne-resize",
        "nw-resize",
        "n-resize",
        "se-resize",
        "sw-resize",
        "s-resize",
        "w-resize",
        "text",
        "wait",
        "help",
        "inherit"
      ],
      display: null,
      filter: [
        "none",
        "inherit"
      ],
      "image-rendering": null,
      mask: [
        "none",
        "inherit"
      ],
      opacity: null,
      "pointer-events": null,
      "shape-rendering": null,
      "text-rendering": null,
      visibility: null,
      "marker-start": [
        "none",
        "inherit"
      ],
      "marker-mid": [
        "none",
        "inherit"
      ],
      "marker-end": [
        "none",
        "inherit"
      ],
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null,
      x1: null,
      y1: null,
      x2: null,
      y2: null
    }
  },
  polyline: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      color: [
        "inherit",
        "white",
        "silver",
        "gray",
        "black",
        "navy",
        "blue",
        "aqua",
        "teal",
        "green",
        "olive"
      ],
      "color-interpolation": null,
      "color-rendering": null,
      fill: null,
      "fill-opacity": null,
      "fill-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      stroke: null,
      "stroke-dasharray": null,
      "stroke-dashoffset": null,
      "stroke-linecap": null,
      "stroke-linejoin": null,
      "stroke-miterlimit": null,
      "stroke-opacity": null,
      "stroke-width": null,
      "clip-path": [
        "auto",
        "inherit",
        "none"
      ],
      "clip-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      cursor: [
        "auto",
        "crosshair",
        "default",
        "pointer",
        "move",
        "e-resize",
        "ne-resize",
        "nw-resize",
        "n-resize",
        "se-resize",
        "sw-resize",
        "s-resize",
        "w-resize",
        "text",
        "wait",
        "help",
        "inherit"
      ],
      display: null,
      filter: [
        "none",
        "inherit"
      ],
      "image-rendering": null,
      mask: [
        "none",
        "inherit"
      ],
      opacity: null,
      "pointer-events": null,
      "shape-rendering": null,
      "text-rendering": null,
      visibility: null,
      "marker-start": [
        "none",
        "inherit"
      ],
      "marker-mid": [
        "none",
        "inherit"
      ],
      "marker-end": [
        "none",
        "inherit"
      ],
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null,
      points: null
    }
  },
  polygon: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      color: [
        "inherit",
        "white",
        "silver",
        "gray",
        "black",
        "navy",
        "blue",
        "aqua",
        "teal",
        "green",
        "olive"
      ],
      "color-interpolation": null,
      "color-rendering": null,
      fill: null,
      "fill-opacity": null,
      "fill-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      stroke: null,
      "stroke-dasharray": null,
      "stroke-dashoffset": null,
      "stroke-linecap": null,
      "stroke-linejoin": null,
      "stroke-miterlimit": null,
      "stroke-opacity": null,
      "stroke-width": null,
      "clip-path": [
        "auto",
        "inherit",
        "none"
      ],
      "clip-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      cursor: [
        "auto",
        "crosshair",
        "default",
        "pointer",
        "move",
        "e-resize",
        "ne-resize",
        "nw-resize",
        "n-resize",
        "se-resize",
        "sw-resize",
        "s-resize",
        "w-resize",
        "text",
        "wait",
        "help",
        "inherit"
      ],
      display: null,
      filter: [
        "none",
        "inherit"
      ],
      "image-rendering": null,
      mask: [
        "none",
        "inherit"
      ],
      opacity: null,
      "pointer-events": null,
      "shape-rendering": null,
      "text-rendering": null,
      visibility: null,
      "marker-start": [
        "none",
        "inherit"
      ],
      "marker-mid": [
        "none",
        "inherit"
      ],
      "marker-end": [
        "none",
        "inherit"
      ],
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null,
      points: null
    }
  },
  text: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "tspan",
      "tref",
      "textPath",
      "altGlyph",
      "a",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      color: [
        "inherit",
        "white",
        "silver",
        "gray",
        "black",
        "navy",
        "blue",
        "aqua",
        "teal",
        "green",
        "olive"
      ],
      "color-interpolation": null,
      "color-rendering": null,
      fill: null,
      "fill-opacity": null,
      "fill-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      stroke: null,
      "stroke-dasharray": null,
      "stroke-dashoffset": null,
      "stroke-linecap": null,
      "stroke-linejoin": null,
      "stroke-miterlimit": null,
      "stroke-opacity": null,
      "stroke-width": null,
      "font-family": null,
      "font-size": [
        "inherit"
      ],
      "font-size-adjust": [
        "none",
        "inherit"
      ],
      "font-stretch": [
        "normal",
        "wider",
        "narrower",
        "ultra-condensed",
        "extra-condensed",
        "semi-condensed",
        "semi-expanded",
        "expanded",
        "extra-expanded",
        "ultra-expanded",
        "inherit"
      ],
      "font-style": null,
      "font-variant": null,
      "font-weight": null,
      "clip-path": [
        "auto",
        "inherit",
        "none"
      ],
      "clip-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      cursor: [
        "auto",
        "crosshair",
        "default",
        "pointer",
        "move",
        "e-resize",
        "ne-resize",
        "nw-resize",
        "n-resize",
        "se-resize",
        "sw-resize",
        "s-resize",
        "w-resize",
        "text",
        "wait",
        "help",
        "inherit"
      ],
      display: null,
      filter: [
        "none",
        "inherit"
      ],
      "image-rendering": null,
      mask: [
        "none",
        "inherit"
      ],
      opacity: null,
      "pointer-events": null,
      "shape-rendering": null,
      "text-rendering": null,
      visibility: null,
      "alignment-baseline": null,
      "baseline-shift": [
        "baseline",
        "sub",
        "super",
        "inherit"
      ],
      direction: null,
      "dominant-baseline": null,
      "glyph-orientation-horizontal": [
        "inherit"
      ],
      "glyph-orientation-vertical": [
        "inherit",
        "auto"
      ],
      "letter-spacing": [
        "auto",
        "exact"
      ],
      "text-anchor": null,
      "text-decoration": [
        "none",
        "underline",
        "overline",
        "line-through"
      ],
      "unicode-bidi": null,
      "word-spacing": [
        "auto",
        "exact"
      ],
      "writing-mode": null,
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null,
      x: null,
      y: null,
      textLength: null,
      lengthAdjust: null
    }
  },
  tspan: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "tspan",
      "tref",
      "altGlyph",
      "a",
      "animate",
      "set",
      "animateColor"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      color: [
        "inherit",
        "white",
        "silver",
        "gray",
        "black",
        "navy",
        "blue",
        "aqua",
        "teal",
        "green",
        "olive"
      ],
      "color-interpolation": null,
      "color-rendering": null,
      fill: null,
      "fill-opacity": null,
      "fill-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      stroke: null,
      "stroke-dasharray": null,
      "stroke-dashoffset": null,
      "stroke-linecap": null,
      "stroke-linejoin": null,
      "stroke-miterlimit": null,
      "stroke-opacity": null,
      "stroke-width": null,
      "font-family": null,
      "font-size": [
        "inherit"
      ],
      "font-size-adjust": [
        "none",
        "inherit"
      ],
      "font-stretch": [
        "normal",
        "wider",
        "narrower",
        "ultra-condensed",
        "extra-condensed",
        "semi-condensed",
        "semi-expanded",
        "expanded",
        "extra-expanded",
        "ultra-expanded",
        "inherit"
      ],
      "font-style": null,
      "font-variant": null,
      "font-weight": null,
      "clip-path": [
        "auto",
        "inherit",
        "none"
      ],
      "clip-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      cursor: [
        "auto",
        "crosshair",
        "default",
        "pointer",
        "move",
        "e-resize",
        "ne-resize",
        "nw-resize",
        "n-resize",
        "se-resize",
        "sw-resize",
        "s-resize",
        "w-resize",
        "text",
        "wait",
        "help",
        "inherit"
      ],
      display: null,
      filter: [
        "none",
        "inherit"
      ],
      "image-rendering": null,
      mask: [
        "none",
        "inherit"
      ],
      opacity: null,
      "pointer-events": null,
      "shape-rendering": null,
      "text-rendering": null,
      visibility: null,
      "alignment-baseline": null,
      "baseline-shift": [
        "baseline",
        "sub",
        "super",
        "inherit"
      ],
      direction: null,
      "dominant-baseline": null,
      "glyph-orientation-horizontal": [
        "inherit"
      ],
      "glyph-orientation-vertical": [
        "inherit",
        "auto"
      ],
      "letter-spacing": [
        "auto",
        "exact"
      ],
      "text-anchor": null,
      "text-decoration": [
        "none",
        "underline",
        "overline",
        "line-through"
      ],
      "unicode-bidi": null,
      "word-spacing": [
        "auto",
        "exact"
      ],
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      x: null,
      y: null,
      dx: null,
      dy: null,
      rotate: null,
      textLength: null,
      lengthAdjust: null
    }
  },
  tref: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "animate",
      "set",
      "animateColor"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      color: [
        "inherit",
        "white",
        "silver",
        "gray",
        "black",
        "navy",
        "blue",
        "aqua",
        "teal",
        "green",
        "olive"
      ],
      "color-interpolation": null,
      "color-rendering": null,
      fill: null,
      "fill-opacity": null,
      "fill-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      stroke: null,
      "stroke-dasharray": null,
      "stroke-dashoffset": null,
      "stroke-linecap": null,
      "stroke-linejoin": null,
      "stroke-miterlimit": null,
      "stroke-opacity": null,
      "stroke-width": null,
      "font-family": null,
      "font-size": [
        "inherit"
      ],
      "font-size-adjust": [
        "none",
        "inherit"
      ],
      "font-stretch": [
        "normal",
        "wider",
        "narrower",
        "ultra-condensed",
        "extra-condensed",
        "semi-condensed",
        "semi-expanded",
        "expanded",
        "extra-expanded",
        "ultra-expanded",
        "inherit"
      ],
      "font-style": null,
      "font-variant": null,
      "font-weight": null,
      "clip-path": [
        "auto",
        "inherit",
        "none"
      ],
      "clip-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      cursor: [
        "auto",
        "crosshair",
        "default",
        "pointer",
        "move",
        "e-resize",
        "ne-resize",
        "nw-resize",
        "n-resize",
        "se-resize",
        "sw-resize",
        "s-resize",
        "w-resize",
        "text",
        "wait",
        "help",
        "inherit"
      ],
      display: null,
      filter: [
        "none",
        "inherit"
      ],
      "image-rendering": null,
      mask: [
        "none",
        "inherit"
      ],
      opacity: null,
      "pointer-events": null,
      "shape-rendering": null,
      "text-rendering": null,
      visibility: null,
      "alignment-baseline": null,
      "baseline-shift": [
        "baseline",
        "sub",
        "super",
        "inherit"
      ],
      direction: null,
      "dominant-baseline": null,
      "glyph-orientation-horizontal": [
        "inherit"
      ],
      "glyph-orientation-vertical": [
        "inherit",
        "auto"
      ],
      "letter-spacing": [
        "auto",
        "exact"
      ],
      "text-anchor": null,
      "text-decoration": [
        "none",
        "underline",
        "overline",
        "line-through"
      ],
      "unicode-bidi": null,
      "word-spacing": [
        "auto",
        "exact"
      ],
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      x: null,
      y: null,
      dx: null,
      dy: null,
      rotate: null,
      textLength: null,
      lengthAdjust: null
    }
  },
  textPath: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "tspan",
      "tref",
      "altGlyph",
      "a",
      "animate",
      "set",
      "animateColor"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      fill: null,
      "fill-opacity": null,
      "fill-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      stroke: null,
      "stroke-dasharray": null,
      "stroke-dashoffset": null,
      "stroke-linecap": null,
      "stroke-linejoin": null,
      "stroke-miterlimit": null,
      "stroke-opacity": null,
      "stroke-width": null,
      "font-family": null,
      "font-size": [
        "inherit"
      ],
      "font-size-adjust": [
        "none",
        "inherit"
      ],
      "font-stretch": [
        "normal",
        "wider",
        "narrower",
        "ultra-condensed",
        "extra-condensed",
        "semi-condensed",
        "semi-expanded",
        "expanded",
        "extra-expanded",
        "ultra-expanded",
        "inherit"
      ],
      "font-style": null,
      "font-variant": null,
      "font-weight": null,
      "clip-path": [
        "auto",
        "inherit",
        "none"
      ],
      "clip-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      cursor: [
        "auto",
        "crosshair",
        "default",
        "pointer",
        "move",
        "e-resize",
        "ne-resize",
        "nw-resize",
        "n-resize",
        "se-resize",
        "sw-resize",
        "s-resize",
        "w-resize",
        "text",
        "wait",
        "help",
        "inherit"
      ],
      display: null,
      filter: [
        "none",
        "inherit"
      ],
      "image-rendering": null,
      mask: [
        "none",
        "inherit"
      ],
      opacity: null,
      "pointer-events": null,
      "shape-rendering": null,
      "text-rendering": null,
      visibility: null,
      "alignment-baseline": null,
      "baseline-shift": [
        "baseline",
        "sub",
        "super",
        "inherit"
      ],
      direction: null,
      "dominant-baseline": null,
      "glyph-orientation-horizontal": [
        "inherit"
      ],
      "glyph-orientation-vertical": [
        "inherit",
        "auto"
      ],
      "letter-spacing": [
        "auto",
        "exact"
      ],
      "text-anchor": null,
      "text-decoration": [
        "none",
        "underline",
        "overline",
        "line-through"
      ],
      "unicode-bidi": null,
      "word-spacing": [
        "auto",
        "exact"
      ],
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      startOffset: null,
      textLength: null,
      lengthAdjust: null,
      method: null,
      spacing: null
    }
  },
  altGlyph: {
    globalAttrs: !1,
    children: [],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      color: [
        "inherit",
        "white",
        "silver",
        "gray",
        "black",
        "navy",
        "blue",
        "aqua",
        "teal",
        "green",
        "olive"
      ],
      "color-interpolation": null,
      "color-rendering": null,
      fill: null,
      "fill-opacity": null,
      "fill-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      stroke: null,
      "stroke-dasharray": null,
      "stroke-dashoffset": null,
      "stroke-linecap": null,
      "stroke-linejoin": null,
      "stroke-miterlimit": null,
      "stroke-opacity": null,
      "stroke-width": null,
      "font-family": null,
      "font-size": [
        "inherit"
      ],
      "font-size-adjust": [
        "none",
        "inherit"
      ],
      "font-stretch": [
        "normal",
        "wider",
        "narrower",
        "ultra-condensed",
        "extra-condensed",
        "semi-condensed",
        "semi-expanded",
        "expanded",
        "extra-expanded",
        "ultra-expanded",
        "inherit"
      ],
      "font-style": null,
      "font-variant": null,
      "font-weight": null,
      "clip-path": [
        "auto",
        "inherit",
        "none"
      ],
      "clip-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      cursor: [
        "auto",
        "crosshair",
        "default",
        "pointer",
        "move",
        "e-resize",
        "ne-resize",
        "nw-resize",
        "n-resize",
        "se-resize",
        "sw-resize",
        "s-resize",
        "w-resize",
        "text",
        "wait",
        "help",
        "inherit"
      ],
      display: null,
      filter: [
        "none",
        "inherit"
      ],
      "image-rendering": null,
      mask: [
        "none",
        "inherit"
      ],
      opacity: null,
      "pointer-events": null,
      "shape-rendering": null,
      "text-rendering": null,
      visibility: null,
      "alignment-baseline": null,
      "baseline-shift": [
        "baseline",
        "sub",
        "super",
        "inherit"
      ],
      direction: null,
      "dominant-baseline": null,
      "glyph-orientation-horizontal": [
        "inherit"
      ],
      "glyph-orientation-vertical": [
        "inherit",
        "auto"
      ],
      "letter-spacing": [
        "auto",
        "exact"
      ],
      "text-anchor": null,
      "text-decoration": [
        "none",
        "underline",
        "overline",
        "line-through"
      ],
      "unicode-bidi": null,
      "word-spacing": [
        "auto",
        "exact"
      ],
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      glyphRef: null,
      format: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      x: null,
      y: null,
      dx: null,
      dy: null,
      rotate: null
    }
  },
  altGlyphDef: {
    globalAttrs: !1,
    children: [
      "altGlyphItem",
      "glyphRef"
    ],
    attrs: {
      id: null
    }
  },
  altGlyphItem: {
    globalAttrs: !1,
    children: [
      "glyphRef"
    ],
    attrs: {
      id: null
    }
  },
  glyphRef: {
    globalAttrs: !1,
    children: [],
    attrs: {
      id: null,
      "font-family": null,
      "font-size": [
        "inherit"
      ],
      "font-size-adjust": [
        "none",
        "inherit"
      ],
      "font-stretch": [
        "normal",
        "wider",
        "narrower",
        "ultra-condensed",
        "extra-condensed",
        "semi-condensed",
        "semi-expanded",
        "expanded",
        "extra-expanded",
        "ultra-expanded",
        "inherit"
      ],
      "font-style": null,
      "font-variant": null,
      "font-weight": null,
      class: null,
      style: null,
      glyphRef: null,
      format: null,
      x: null,
      y: null,
      dx: null,
      dy: null
    }
  },
  marker: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "defs",
      "path",
      "text",
      "rect",
      "circle",
      "ellipse",
      "line",
      "polyline",
      "polygon",
      "use",
      "image",
      "svg",
      "g",
      "view",
      "switch",
      "a",
      "altGlyphDef",
      "style",
      "symbol",
      "marker",
      "clipPath",
      "mask",
      "linearGradient",
      "radialGradient",
      "pattern",
      "filter",
      "cursor",
      "font",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform",
      "color-profile",
      "font-face"
    ],
    attrs: {
      id: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      viewBox: null,
      preserveAspectRatio: null,
      refX: null,
      refY: null,
      markerUnits: null,
      markerWidth: null,
      markerHeight: null,
      orient: null
    }
  },
  "color-profile": {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata"
    ],
    attrs: {
      id: null,
      local: null,
      name: null,
      "rendering-intent": null
    }
  },
  linearGradient: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "stop",
      "animate",
      "set",
      "animateTransform"
    ],
    attrs: {
      id: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      gradientUnits: null,
      gradientTransform: null,
      x1: null,
      y1: null,
      x2: null,
      y2: null,
      spreadMethod: null
    }
  },
  radialGradient: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "stop",
      "animate",
      "set",
      "animateTransform"
    ],
    attrs: {
      id: null,
      externalResourcesRequired: null,
      gradientUnits: null,
      gradientTransform: null,
      cx: null,
      cy: null,
      r: null,
      fx: null,
      fy: null,
      spreadMethod: null
    }
  },
  stop: {
    globalAttrs: !1,
    children: [
      "animate",
      "set",
      "animateColor"
    ],
    attrs: {
      id: null,
      "stop-color": null,
      "stop-opacity": null,
      class: null,
      style: null,
      offset: null
    }
  },
  pattern: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "defs",
      "path",
      "text",
      "rect",
      "circle",
      "ellipse",
      "line",
      "polyline",
      "polygon",
      "use",
      "image",
      "svg",
      "g",
      "view",
      "switch",
      "a",
      "altGlyphDef",
      "style",
      "symbol",
      "marker",
      "clipPath",
      "mask",
      "linearGradient",
      "radialGradient",
      "pattern",
      "filter",
      "cursor",
      "font",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform",
      "color-profile",
      "font-face"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      viewBox: null,
      preserveAspectRatio: null,
      patternUnits: null,
      patternTransform: null,
      x: null,
      y: null,
      width: null,
      height: null
    }
  },
  clipPath: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "path",
      "text",
      "rect",
      "circle",
      "ellipse",
      "line",
      "polyline",
      "polygon",
      "use",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      fill: null,
      "fill-opacity": null,
      "fill-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      stroke: null,
      "stroke-dasharray": null,
      "stroke-dashoffset": null,
      "stroke-linecap": null,
      "stroke-linejoin": null,
      "stroke-miterlimit": null,
      "stroke-opacity": null,
      "stroke-width": null,
      "font-family": null,
      "font-size": [
        "inherit"
      ],
      "font-size-adjust": [
        "none",
        "inherit"
      ],
      "font-stretch": [
        "normal",
        "wider",
        "narrower",
        "ultra-condensed",
        "extra-condensed",
        "semi-condensed",
        "semi-expanded",
        "expanded",
        "extra-expanded",
        "ultra-expanded",
        "inherit"
      ],
      "font-style": null,
      "font-variant": null,
      "font-weight": null,
      "clip-path": [
        "auto",
        "inherit",
        "none"
      ],
      "clip-rule": [
        "evenodd",
        "nonzero",
        "inherit"
      ],
      cursor: [
        "auto",
        "crosshair",
        "default",
        "pointer",
        "move",
        "e-resize",
        "ne-resize",
        "nw-resize",
        "n-resize",
        "se-resize",
        "sw-resize",
        "s-resize",
        "w-resize",
        "text",
        "wait",
        "help",
        "inherit"
      ],
      display: null,
      filter: [
        "none",
        "inherit"
      ],
      "image-rendering": null,
      mask: [
        "none",
        "inherit"
      ],
      opacity: null,
      "pointer-events": null,
      "shape-rendering": null,
      "text-rendering": null,
      visibility: null,
      "alignment-baseline": null,
      "baseline-shift": [
        "baseline",
        "sub",
        "super",
        "inherit"
      ],
      direction: null,
      "dominant-baseline": null,
      "glyph-orientation-horizontal": [
        "inherit"
      ],
      "glyph-orientation-vertical": [
        "inherit",
        "auto"
      ],
      "letter-spacing": [
        "auto",
        "exact"
      ],
      "text-anchor": null,
      "text-decoration": [
        "none",
        "underline",
        "overline",
        "line-through"
      ],
      "unicode-bidi": null,
      "word-spacing": [
        "auto",
        "exact"
      ],
      "writing-mode": null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null,
      clipPathUnits: null
    }
  },
  mask: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "defs",
      "path",
      "text",
      "rect",
      "circle",
      "ellipse",
      "line",
      "polyline",
      "polygon",
      "use",
      "image",
      "svg",
      "g",
      "view",
      "switch",
      "a",
      "altGlyphDef",
      "style",
      "symbol",
      "marker",
      "clipPath",
      "mask",
      "linearGradient",
      "radialGradient",
      "pattern",
      "filter",
      "cursor",
      "font",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform",
      "color-profile",
      "font-face"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null,
      maskUnits: null,
      x: null,
      y: null,
      width: null,
      height: null
    }
  },
  filter: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "feBlend",
      "feFlood",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      filterUnits: null,
      primitiveUnits: null,
      x: null,
      y: null,
      width: null,
      height: null,
      filterRes: null
    }
  },
  feDistantLight: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      azimuth: null,
      elevation: null
    }
  },
  fePointLight: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      x: null,
      y: null,
      z: null
    }
  },
  feSpotLight: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      x: null,
      y: null,
      z: null,
      pointsAtX: null,
      pointsAtY: null,
      pointsAtZ: null,
      specularExponent: null,
      limitingConeAngle: null
    }
  },
  feBlend: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      in: null,
      in2: null,
      mode: null
    }
  },
  feColorMatrix: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      in: null,
      type: null,
      values: null
    }
  },
  feComponentTransfer: {
    globalAttrs: !1,
    children: [
      "feFuncR",
      "feFuncG",
      "feFuncB",
      "feFuncA"
    ],
    attrs: {
      id: null,
      in: null
    }
  },
  feFuncR: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      type: null,
      tableValues: null,
      slope: null,
      intercept: null,
      amplitude: null,
      exponent: null,
      offset: null,
      type2: null
    }
  },
  feFuncG: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      type: null,
      tableValues: null,
      slope: null,
      intercept: null,
      amplitude: null,
      exponent: null,
      offset: null,
      type2: null
    }
  },
  feFuncB: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      type: null,
      tableValues: null,
      slope: null,
      intercept: null,
      amplitude: null,
      exponent: null,
      offset: null,
      type2: null
    }
  },
  feFuncA: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      type: null,
      tableValues: null,
      slope: null,
      intercept: null,
      amplitude: null,
      exponent: null,
      offset: null,
      type3: null
    }
  },
  feComposite: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      in: null,
      in2: null,
      operator: null,
      k1: null,
      k2: null,
      k3: null,
      k4: null
    }
  },
  feConvolveMatrix: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      in: null,
      order: null,
      kernelMatrix: null,
      divisor: null,
      bias: null,
      targetX: null,
      targetY: null,
      edgeMode: null,
      kernelUnitLength: null,
      preserveAlpha: null
    }
  },
  feDiffuseLighting: {
    globalAttrs: !1,
    children: [
      "feDistantLight",
      "fePointLight",
      "feSpotLight",
      "animate",
      "set",
      "animateColor"
    ],
    attrs: {
      id: null,
      "lighting-color": null,
      in: null,
      class: null,
      style: null,
      surfaceScale: null,
      diffuseConstant: null
    }
  },
  feDisplacementMap: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      in: null,
      in2: null,
      scale: null,
      xChannelSelector: null,
      yChannelSelector: null
    }
  },
  feFlood: {
    globalAttrs: !1,
    children: [
      "animate",
      "set",
      "animateColor"
    ],
    attrs: {
      id: null,
      "flood-color": null,
      "flood-opacity": null,
      in: null,
      class: null,
      style: null
    }
  },
  feGaussianBlur: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      in: null,
      stdDeviation: null
    }
  },
  feImage: {
    globalAttrs: !1,
    children: [
      "animate",
      "set",
      "animateTransform"
    ],
    attrs: {
      id: null,
      x: null,
      y: null,
      width: null,
      height: null,
      result: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null
    }
  },
  feMerge: {
    globalAttrs: !1,
    children: [
      "feMergeNode"
    ],
    attrs: {
      id: null,
      x: null,
      y: null,
      width: null,
      height: null,
      result: null
    }
  },
  feMergeNode: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      in: null
    }
  },
  feMorphology: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      in: null,
      operator: null,
      radius: null
    }
  },
  feOffset: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      in: null,
      dx: null,
      dy: null
    }
  },
  feSpecularLighting: {
    globalAttrs: !1,
    children: [
      "feDistantLight",
      "fePointLight",
      "feSpotLight",
      "animate",
      "set",
      "animateColor"
    ],
    attrs: {
      id: null,
      "lighting-color": null,
      in: null,
      class: null,
      style: null,
      surfaceScale: null,
      specularConstant: null,
      specularExponent: null
    }
  },
  feTile: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      in: null
    }
  },
  feTurbulence: {
    globalAttrs: !1,
    children: [
      "animate",
      "set"
    ],
    attrs: {
      id: null,
      x: null,
      y: null,
      width: null,
      height: null,
      result: null,
      baseFrequency: null,
      numOctaves: null,
      seed: null,
      stitchTiles: null,
      type: null
    }
  },
  cursor: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      externalResourcesRequired: null,
      x: null,
      y: null
    }
  },
  a: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "defs",
      "path",
      "text",
      "rect",
      "circle",
      "ellipse",
      "line",
      "polyline",
      "polygon",
      "use",
      "image",
      "svg",
      "g",
      "view",
      "switch",
      "a",
      "altGlyphDef",
      "style",
      "symbol",
      "marker",
      "clipPath",
      "mask",
      "linearGradient",
      "radialGradient",
      "pattern",
      "filter",
      "cursor",
      "font",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform",
      "color-profile",
      "font-face"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null,
      target: null
    }
  },
  view: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata"
    ],
    attrs: {
      id: null,
      externalResourcesRequired: null,
      viewBox: null,
      preserveAspectRatio: null,
      zoomAndPan: null,
      viewTarget: null
    }
  },
  animate: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      onbegin: null,
      onend: null,
      onrepeat: null,
      begin: null,
      dur: null,
      end: null,
      min: null,
      max: null,
      restart: null,
      repeatCount: null,
      repeatDur: null,
      fill: null,
      calcMode: null,
      values: null,
      keyTimes: null,
      keySplines: null,
      from: null,
      to: null,
      by: null,
      additive: null,
      accumulate: null,
      externalResourcesRequired: null
    }
  },
  set: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      onbegin: null,
      onend: null,
      onrepeat: null,
      begin: null,
      dur: null,
      end: null,
      min: null,
      max: null,
      restart: null,
      repeatCount: null,
      repeatDur: null,
      fill: null,
      externalResourcesRequired: null,
      to: null
    }
  },
  animateMotion: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "mpath"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      onbegin: null,
      onend: null,
      onrepeat: null,
      begin: null,
      dur: null,
      end: null,
      min: null,
      max: null,
      restart: null,
      repeatCount: null,
      repeatDur: null,
      fill: null,
      calcMode: null,
      values: null,
      keyTimes: null,
      keySplines: null,
      from: null,
      to: null,
      by: null,
      additive: null,
      accumulate: null,
      externalResourcesRequired: null,
      path: null,
      keyPoints: null,
      rotate: null,
      origin: null
    }
  },
  mpath: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata"
    ],
    attrs: {
      id: null,
      externalResourcesRequired: null
    }
  },
  animateColor: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      onbegin: null,
      onend: null,
      onrepeat: null,
      begin: null,
      dur: null,
      end: null,
      min: null,
      max: null,
      restart: null,
      repeatCount: null,
      repeatDur: null,
      fill: null,
      calcMode: null,
      values: null,
      keyTimes: null,
      keySplines: null,
      from: null,
      to: null,
      by: null,
      additive: null,
      accumulate: null,
      externalResourcesRequired: null
    }
  },
  animateTransform: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata"
    ],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      onbegin: null,
      onend: null,
      onrepeat: null,
      begin: null,
      dur: null,
      end: null,
      min: null,
      max: null,
      restart: null,
      repeatCount: null,
      repeatDur: null,
      fill: null,
      calcMode: null,
      values: null,
      keyTimes: null,
      keySplines: null,
      from: null,
      to: null,
      by: null,
      additive: null,
      accumulate: null,
      externalResourcesRequired: null,
      type: null
    }
  },
  font: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "font-face",
      "missing-glyph",
      "glyph",
      "hkern",
      "vkern"
    ],
    attrs: {
      id: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      "horiz-origin-x": null,
      "horiz-origin-y": null,
      "horiz-adv-x": null,
      "vert-origin-x": null,
      "vert-origin-y": null,
      "vert-adv-y": null
    }
  },
  glyph: {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "defs",
      "path",
      "text",
      "rect",
      "circle",
      "ellipse",
      "line",
      "polyline",
      "polygon",
      "use",
      "image",
      "svg",
      "g",
      "view",
      "switch",
      "a",
      "altGlyphDef",
      "script",
      "style",
      "symbol",
      "marker",
      "clipPath",
      "mask",
      "linearGradient",
      "radialGradient",
      "pattern",
      "filter",
      "cursor",
      "font",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform",
      "color-profile",
      "font-face"
    ],
    attrs: {
      id: null,
      class: null,
      style: null,
      unicode: null,
      "glyph-name": null,
      d: null,
      "vert-text-orient": null,
      arabic: null,
      han: null,
      "horiz-adv-x": null,
      "vert-adv-y": null
    }
  },
  "missing-glyph": {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "defs",
      "path",
      "text",
      "rect",
      "circle",
      "ellipse",
      "line",
      "polyline",
      "polygon",
      "use",
      "image",
      "svg",
      "g",
      "view",
      "switch",
      "a",
      "altGlyphDef",
      "script",
      "style",
      "symbol",
      "marker",
      "clipPath",
      "mask",
      "linearGradient",
      "radialGradient",
      "pattern",
      "filter",
      "cursor",
      "font",
      "animate",
      "set",
      "animateMotion",
      "animateColor",
      "animateTransform",
      "color-profile",
      "font-face"
    ],
    attrs: {
      id: null,
      class: null,
      style: null,
      d: null,
      "horiz-adv-x": null,
      "vert-adv-y": null
    }
  },
  hkern: {
    globalAttrs: !1,
    children: [],
    attrs: {
      id: null,
      u1: null,
      g1: null,
      u2: null,
      g2: null,
      k: null
    }
  },
  vkern: {
    globalAttrs: !1,
    children: [],
    attrs: {
      id: null,
      u1: null,
      g1: null,
      u2: null,
      g2: null,
      k: null
    }
  },
  "font-face": {
    globalAttrs: !1,
    children: [
      "desc",
      "title",
      "metadata",
      "font-face-src",
      "definition-src"
    ],
    attrs: {
      id: null,
      "font-family": null,
      "font-style": null,
      "font-variant": null,
      "font-weight": null,
      "font-stretch": null,
      "font-size": [
        "inherit"
      ],
      "unicode-range": null,
      "units-per-em": null,
      "panose-1": null,
      stemv: null,
      stemh: null,
      slope: null,
      "cap-height": null,
      "x-height": null,
      "accent-height": null,
      ascent: null,
      descent: null,
      widths: null,
      bbox: null,
      ideographic: null,
      baseline: null,
      centerline: null,
      mathline: null,
      hanging: null,
      topline: null,
      "underline-position": null,
      "underline-thickness": null,
      "strikethrough-position": null,
      "strikethrough-thickness": null,
      "overline-position": null,
      "overline-thickness": null
    }
  },
  "font-face-src": {
    globalAttrs: !1,
    children: [
      "font-face-uri",
      "font-face-name"
    ],
    attrs: {
      id: null
    }
  },
  "font-face-uri": {
    globalAttrs: !1,
    children: [
      "font-face-format"
    ],
    attrs: {
      id: null
    }
  },
  "font-face-format": {
    globalAttrs: !1,
    children: [],
    attrs: {
      id: null,
      string: null
    }
  },
  "font-face-name": {
    globalAttrs: !1,
    children: [],
    attrs: {
      id: null,
      name: null
    }
  },
  "definition-src": {
    globalAttrs: !1,
    children: [],
    attrs: {
      id: null
    }
  },
  metadata: {
    globalAttrs: !1,
    children: [],
    attrs: {
      id: null
    }
  },
  foreignObject: {
    globalAttrs: !1,
    children: [],
    attrs: {
      id: null,
      requiredFeatures: null,
      requiredExtensions: null,
      systemLanguage: null,
      onfocusin: null,
      onfocusout: null,
      onactivate: null,
      onclick: null,
      onmousedown: null,
      onmouseup: null,
      onmouseover: null,
      onmousemove: null,
      onmouseout: null,
      onload: null,
      externalResourcesRequired: null,
      class: null,
      style: null,
      transform: null,
      x: null,
      y: null,
      width: null,
      height: null,
      content: null
    }
  }
};
function lU(t) {
  for (let e in t) {
    const r = Object.assign({}, t[e].attrs || {});
    for (let s in r)
      if (s.substring(0, 2) === "on") {
        const i = s.substring(2);
        r[`g-on:${i}`] = r[s], r[`@${i}`] = r[s];
      } else
        r[`g-bind:${s}`] = r[s], r[`:${s}`] = r[s];
    e === "svg" && (r["g-on:init"] = "", r["@init"] = ""), e === "defs" && (r["g-for"] = ""), r["g-if"] = "", t[e].attrs = r;
  }
  return t;
}
const Zg = ({ variant: t, settings: e, styles: r }) => {
  const s = J.theme(
    {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      "&": {
        backgroundColor: e.background,
        color: e.foreground
      },
      ".cm-content": {
        caretColor: e.caret
      },
      ".cm-cursor, .cm-dropCursor": {
        borderLeftColor: e.caret
      },
      "&.cm-focused .cm-selectionBackgroundm .cm-selectionBackground, .cm-content ::selection": {
        backgroundColor: e.selection
      },
      ".cm-activeLine": {
        backgroundColor: e.lineHighlight
      },
      ".cm-gutters": {
        backgroundColor: e.gutterBackground,
        color: e.gutterForeground
      },
      ".cm-activeLineGutter": {
        backgroundColor: e.lineHighlight
      }
    },
    {
      dark: t === "dark"
    }
  ), i = kl.define(r);
  return [s, DA(i)];
}, uU = Zg({
  variant: "dark",
  settings: {
    background: "transparent",
    foreground: "#e0e0e0",
    caret: "#ffffffa6",
    selection: "#122bbb",
    gutterBackground: "var(--background-color, transparent)",
    gutterForeground: "#e0e0e090",
    lineHighlight: "#ffffff0f"
  },
  styles: [
    {
      tag: T.comment,
      color: "#6272a4"
    },
    {
      tag: [T.string, T.special(T.brace)],
      color: "#f8c555"
    },
    {
      tag: [T.number, T.self, T.bool, T.null],
      color: "#bd93f9"
    },
    {
      tag: [T.keyword, T.operator],
      color: "#ff79c6"
    },
    {
      tag: [T.definitionKeyword, T.typeName],
      color: "#e2777a"
    },
    {
      tag: T.definition(T.typeName),
      color: "#f8f8f2"
    },
    {
      tag: [
        T.className,
        T.definition(T.propertyName),
        T.function(T.variableName),
        T.attributeName
      ],
      color: "#7ec699"
    }
  ]
}), cU = Zg({
  variant: "light",
  settings: {
    background: "transparent",
    foreground: "#4d4d4c",
    caret: "#000000",
    selection: "#036dd626",
    gutterBackground: "var(--background-color, transparent)",
    gutterForeground: "#4d4d4c80",
    lineHighlight: "#8a91991a"
  },
  styles: [
    {
      tag: T.comment,
      color: "#8e908c"
    },
    {
      tag: [T.variableName, T.self, T.propertyName, T.attributeName, T.regexp],
      color: "#c82829"
    },
    {
      tag: [T.number, T.bool, T.null],
      color: "#f5871f"
    },
    {
      tag: [T.className, T.typeName, T.definition(T.typeName)],
      color: "#c99e00"
    },
    {
      tag: [T.string, T.special(T.brace)],
      color: "#718c00"
    },
    {
      tag: T.operator,
      color: "#3e999f"
    },
    {
      tag: [T.definition(T.propertyName), T.function(T.variableName)],
      color: "#4271ae"
    },
    {
      tag: T.keyword,
      color: "#8959a8"
    },
    {
      tag: T.derefOperator,
      color: "#4d4d4c"
    }
  ]
});
Zg({
  variant: "dark",
  settings: {
    background: "#2d2f3f",
    foreground: "#f8f8f2",
    caret: "#f8f8f0",
    selection: "#44475a",
    gutterBackground: "#282a36",
    gutterForeground: "rgb(144, 145, 148)",
    lineHighlight: "#44475a"
  },
  styles: [
    {
      tag: T.comment,
      color: "#6272a4"
    },
    {
      tag: [T.string, T.special(T.brace)],
      color: "#f1fa8c"
    },
    {
      tag: [T.number, T.self, T.bool, T.null],
      color: "#bd93f9"
    },
    {
      tag: [T.keyword, T.operator],
      color: "#ff79c6"
    },
    {
      tag: [T.definitionKeyword, T.typeName],
      color: "#8be9fd"
    },
    {
      tag: T.definition(T.typeName),
      color: "#f8f8f2"
    },
    {
      tag: [
        T.className,
        T.definition(T.propertyName),
        T.function(T.variableName),
        T.attributeName
      ],
      color: "#50fa7b"
    }
  ]
});
const Gx = {
  dark: uU,
  light: cU
}, Hx = pr.parser.configure({ top: "SingleExpression" }), hU = [
  {
    tag: "script",
    attrs: (t) => t.type === "methods",
    parser: pr.parser
  },
  {
    tag: "g-script",
    attrs: (t) => t.type === "methods",
    parser: pr.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type === "data" || t.type === "config",
    parser: Hx
  },
  {
    tag: "g-script",
    attrs: (t) => t.type === "data" || t.type === "config",
    parser: Hx
  }
], pU = lU(oU), dU = nU({
  extraTags: pU,
  nestedLanguages: hU
}), cE = new Na(), hE = new Na(), pE = pe.define();
function fU(t, e, r) {
  const s = [
    LZ,
    Cl.of([Kj]),
    dU,
    mU,
    J.updateListener.of(
      (i) => {
        i.docChanged && typeof r == "function" && r(i);
      }
    ),
    cE.of(dE(e)),
    hE.of(fE(!1))
  ];
  return we.create({
    doc: t,
    extensions: s
  });
}
function dE(t) {
  return Gx[t] || Gx.light;
}
function fE(t) {
  return J.editable.of(t);
}
const mU = ut.define({
  create() {
    return ce.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let r of e.effects)
      r.is(pE) ? t = t.update({ add: [gU.range(r.value)] }) : t = ce.none;
    return t;
  },
  provide: (t) => J.decorations.from(t)
}), gU = ce.line({
  attributes: { style: "background-color: #C0C0C040" }
});
function yU(t = "", e = document.body, r = void 0, s = "light") {
  const i = fU(t, s, r);
  let n = !1;
  const a = new J({ state: i, parent: e, editable: !1 });
  return e.addEventListener("keydown", (l) => {
    l.key === "/" && l.stopPropagation();
  }), Object.defineProperties(
    a,
    {
      theme: {
        set(l) {
          s = l, a.dispatch({
            effects: cE.reconfigure(dE(l))
          });
        },
        get() {
          return s;
        }
      },
      editable: {
        set(l) {
          n = l, a.dispatch({
            effects: hE.reconfigure(fE(n))
          });
        },
        get() {
          return n;
        }
      },
      linesHighlight: {
        get() {
          return (l) => {
            l.forEach((c) => {
              a.dispatch({
                effects: pE.of(a.state.doc.line(c).from)
              });
            });
          };
        }
      },
      diagnostic: {
        get() {
          return (l) => {
            a.dispatch(AZ(a.state, l));
          };
        }
      }
    }
  ), a;
}
function OU(t) {
  let e = 0;
  return (...r) => {
    clearTimeout(e), e = setTimeout(() => {
      t(...r);
    }, 400);
  };
}
var ar, en, Cs;
class xU extends Fi {
  constructor() {
    super();
    At(this, ar);
    At(this, en);
    At(this, Cs, "");
    this.shadowRoot.innerHTML = `
      <style>
        #container {
          width:100%; 
          height: 100%;
        }
        #container .cm-editor {
          height: 100%
        }
        #container.mode-show .cm-editor .cm-gutters {
          display: none;
        } 
        #container.mode-show .cm-editor .cm-activeLine {
          background-color: transparent;
        }
      </style>
      <div id="container" ></div>
    `, mt(this, en, this.shadowRoot.querySelector("#container")), mt(this, ar, yU("", Y(this, en), OU((r) => {
      mt(this, Cs, Y(this, ar).state.doc.toString()), this[os]("update", { code: Y(this, Cs) });
    })));
  }
  get code() {
    return Y(this, Cs);
  }
  set code(r) {
    Y(this, Cs) !== r && (mt(this, Cs, r), Y(this, ar).dispatch({
      changes: { from: 0, to: Y(this, ar).state.doc.length, insert: Y(this, Cs) }
    }));
  }
  set theme(r) {
    Y(this, ar).theme = r;
  }
  get theme() {
    return Y(this, ar).theme;
  }
  set editable(r) {
    Y(this, ar).editable = r, r ? Y(this, en).classList.remove("mode-show") : Y(this, en).classList.add("mode-show");
  }
  get editable() {
    return Y(this, ar).editable;
  }
  linesHighlight(r) {
    Y(this, ar).linesHighlight(r);
  }
  diagnostic(r) {
    Y(this, ar).diagnostic(r);
  }
}
ar = new WeakMap(), en = new WeakMap(), Cs = new WeakMap();
async function DU(t) {
  const e = `<!DOCTYPE html>
<html lang="en">
<head>
  <title>Example | graphane</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/grapper/dist/module/view.js"><\/script>
</head>
<body>
${t}
</body>
</html>`, r = new Blob([e], { type: "text/html" }), s = "grapper-view.example.html";
  if ("showSaveFilePicker" in window) {
    try {
      const l = await showSaveFilePicker({
        suggestedName: s
      });
      if (!l)
        return;
      const c = await l.createWritable();
      await c.write(r), await c.close();
    } catch (l) {
      l.name !== "AbortError" && console.error(l.name, l.message);
    }
    return;
  }
  const n = URL.createObjectURL(r), a = document.createElement("a");
  a.href = n, a.download = s, a.style.display = "none", document.body.append(a), a.click(), setTimeout(() => {
    URL.revokeObjectURL(n), a.remove();
  }, 1e3);
}
const bU = `
  <style>
    :host {
      display                  : block;
      container-type           : inline-size; 
      width                    : 100%;
      min-width                : 200px;
      font-size                : 13px;
      --border-radius          : var(--editor-general-border-radius, 6px);
      --fore-color             : var(--editor-fore-color, #666);
      --background-color       : var(--editor-general-color-background, #f6f6f7);
      --background-color-hover : var(--editor-general-color-background, #ddd);
    }
    :host([theme="dark"]) {
      --fore-color             : var(--editor-general-color-background, #f8f8f2);
      --background-color       : var(--editor-fore-color, #161618);
      --background-color-hover : var(--editor-fore-color, #44475a);
    }
    :host([mode="readonly"]) .header { 
      margin-bottom : -28px !important;
    }
    .big { display: none; }
    .small { display: inline-block; }
    #content-editor {
      border-radius    : var(--border-radius);
      background-color : var(--background-color);
      padding          : 0 4px 4px 4px;
      height           : 100%;
      box-sizing: border-box;   
   }
    .hidden {
      display : none;
    }
    .header {
      display         : flex;
      align-items     : center;
      justify-content : space-between;
      padding-top     : 4px;
      color           : var(--fore-color);
      font-family     : sans-serif;
      font-size       : 0.8em;
      z-index         : 20;
    }
     #title {
      font-size: 1.4em;
      margin-left: 8px;
      font-weight: 600;
      overflow: hidden;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .header .toolbar {
      display: flex;
      flex-wrap: nowrap;
    }
    .header .text{
      position      : relative;
      top           : -5px;
      padding       : 2px 4px;
    }
    .header #text-copy{
      display       : none;
      position      : relative;
      top           : -5px;
      padding       : 2px 6px;
      border-radius : var(--border-radius);
    }
    .header button {
      cursor           : pointer;
      border           : none;
      border-radius    : var(--border-radius);
      color            : var(--fore-color);
      background-color : transparent;
      padding-top      : 4px;
      height           : 30px;
    }
    .header button:hover:not([disabled="true"]), 
     .header button:hover:not([disabled="true"]) svg {
      background-color : var(--background-color-hover);
    }
    .header button[disabled="true"] svg{
      opacity : 0.5;
    }
    .header button svg {
      cursor : pointer;
      stroke : var(--fore-color);
    }
    .body {
      height: calc(100% - 32px);
      overflow : auto; 
    }
    .body g-editor-provider {
      display : block;
      height: 100%;
    }
    @container (min-width: 580px) {
      .big { display: inline-block; }
      .small { display: none; }
    }
  </style>
`, vU = `
<svg width="19" height="19" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M16.7227 4.48683L18.4984 2.71004C19.5728 1.63568 21.4074 2.12723 21.8007 3.5949C21.9832 4.27604 21.7885 5.00285 21.2899 5.50147L10.1125 16.6789C9.55602 17.235 8.8698 17.6438 8.11571 17.8682L5.28957 18.7103L6.13166 15.8842C6.35614 15.1301 6.76486 14.4439 7.32102 13.8875L16.7227 4.48683ZM16.7227 4.48683L19.4994 7.26349M17.9205 14.5V19.4998C17.9205 20.8078 16.8602 21.8681 15.5522 21.8681H4.50014C3.19215 21.8681 2.13184 20.8078 2.13184 19.4998V8.44769C2.13184 7.1397 3.19215 6.07939 4.50014 6.07939H9.49992"  stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`, SU = `
<svg width="19" height="19" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M15.4332 6.3561L17.2089 4.5793C18.2832 3.50494 20.1178 3.99649 20.5111 5.46416C20.6937 6.1453 20.4989 6.87211 20.0003 7.37073L8.82288 18.5481C8.26644 19.1042 7.58023 19.513 6.82614 19.7375L4 20.5796L4.84209 17.7535C5.06657 16.9994 5.47528 16.3132 6.03145 15.7567L15.4332 6.3561ZM15.4332 6.3561L18.2098 9.13276" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M2 3L21.5 22.5" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`, wU = `
<svg width="19" height="19" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M3 14.0769C3.95037 18.0462 7.56452 21 11.878 21C16.9159 21 21 16.9706 21 12C21 7.02944 16.9159 3 11.878 3C8.35867 3 5.30478 4.96631 3.78351 7.84615"  stroke-width="1" stroke-linecap="round"/>
  <path d="M3 5V9H6"  stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`, AU = `
<svg width="19" height="19" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M2 4H7.5" stroke-width="1" stroke-linecap="round"/>
  <path d="M2 20H7.5" stroke-width="1" stroke-linecap="round"/>
  <path d="M5 8H22" stroke-width="1" stroke-linecap="round"/>
  <path d="M5 12H22" stroke-width="1" stroke-linecap="round"/>
  <path d="M5 16H16" stroke-width="1" stroke-linecap="round"/>
</svg>`, CU = `
<svg width="19" height="19" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M9.1875 2.625H14.8125C14.8125 2.625 15.75 2.625 15.75 3.5625V5.4375C15.75 5.4375 15.75 6.375 14.8125 6.375H9.1875C9.1875 6.375 8.25 6.375 8.25 5.4375V3.5625C8.25 3.5625 8.25 2.625 9.1875 2.625Z"  stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M8.25 4.5H6.375C5.87772 4.5 5.40081 4.69754 5.04917 5.04917C4.69754 5.40081 4.5 5.87772 4.5 6.375V19.5C4.5 19.9973 4.69754 20.4742 5.04917 20.8258C5.40081 21.1775 5.87772 21.375 6.375 21.375H17.625C18.1223 21.375 18.5992 21.1775 18.9508 20.8258C19.3025 20.4742 19.5 19.9973 19.5 19.5V17.625"  stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M15.75 4.5H17.625C18.1223 4.5 18.5992 4.69754 18.9508 5.04917C19.3025 5.40081 19.5 5.87772 19.5 6.375V10.125V18"  stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`, EU = `
<svg width="19" height="19" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M20.4375 14.8125V18.5625C20.4375 19.0598 20.24 19.5367 19.8883 19.8883C19.5367 20.24 19.0598 20.4375 18.5625 20.4375H5.4375C4.94022 20.4375 4.46331 20.24 4.11167 19.8883C3.76004 19.5367 3.5625 19.0598 3.5625 18.5625V14.8125"  stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M7.3125 10.125L12 14.8125L16.6875 10.125"  stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M12 14.8125V3.5625"  stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`, TU = `
  <div id="content-editor">
    <div class="header">
      <div id="title"></div>
      <div class="toolbar">
        <p id="text-copy">Copied</p>
        <button id="copy" title="copy to clipboard">
          ${CU} <span class="text big">copy</span>
        </button>
        <button id="save" title="save to disk">
          ${EU} <span class="text big">save</span>
        </button>
        <button id="modeEdit" title="edit the code" class="hidden">
          ${vU} <span class="text big">edit</span>
        </button>
        <button id="reload" title="reload the original code" class="hidden">
          ${wU} <span class="text big">reload</span>
        </button>
        <button id="rearrange" title="rearrange the code" class="hidden">
          ${AU} <span class="text big">rearrange</span>
        </button> 
        <button id="modeShow" title="exit and reload the original code" class="hidden">
          ${SU} <span class="text big">exit</span>
        </button>
      </div>
    </div>
    <div class="body">
      <g-editor-provider></g-editor-provider>
    </div>
  </div>
`;
let Au = !1;
function mE() {
  document.documentElement.classList.contains("dark") && !Au ? (Au = !0, document.documentElement.dispatchEvent(new CustomEvent("themeChanged", { detail: { theme: "dark" } }))) : !document.documentElement.classList.contains("dark") && Au && (Au = !1, document.documentElement.dispatchEvent(new CustomEvent("themeChanged", { detail: { theme: "light" } })));
}
new MutationObserver(mE).observe(document.documentElement, { attributes: !0 });
const Jx = Symbol();
function kU(t, e, r) {
  var i;
  if (!t || t[Jx])
    return;
  t[Jx] = !0;
  const s = () => r(PU(e.code, t.errors));
  t.addEventListener("render", s), t.addEventListener("error", s), ((i = t.errors) == null ? void 0 : i.length) > 0 && s();
}
const Kx = (t) => t.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&"), eD = (t, e) => t.substring(0, e).split(`
`).length;
function PU(t, e) {
  e = Object.values(e.reduce((i, n) => (i[n.toString()] = n, i), {}));
  const r = [];
  let s = "error";
  for (let i of e) {
    if (typeof i == "string")
      continue;
    const n = [...t.matchAll(
      Kx(String(i.code)).replace(/\s+/g, "\\s+").replace(/=/g, "\\s*=\\s*").replace(/>/g, "\\s*>\\s*")
    )];
    let a = i.message;
    n.length > 1 && (s = "warning", a += ' [Sorry, the exact error line cannot be determined, please review the warning code sections"]');
    for (let l of n.length ? n : [{ index: 0, 0: t }]) {
      const c = (l == null ? void 0 : l.index) || 0, p = l[0] || t;
      if (typeof i.scope == "string") {
        r.push({
          line: eD(t, c),
          from: c,
          to: c + n[0][0].length,
          message: a,
          severity: s
        });
        continue;
      }
      const d = i.scope.directive === "g-bind" ? `(g-bind)?:${i.scope.argument}` : i.scope.directive === "g-on" ? `(g-on:|@)${i.scope.argument}` : i.scope.directive, m = Kx(i.scope.expression), y = new RegExp(`${d}\\s*=\\s*["']${m}["']`), g = p.match(y);
      g && r.push({
        line: eD(t, c + g.index),
        from: c + g.index,
        to: c + g.index + g[0].length,
        message: a,
        severity: s
      });
    }
  }
  return r;
}
const FU = (t) => new Promise((e) => setTimeout(e, t)), gE = Symbol(), If = Symbol(), Nf = Symbol(), ed = Symbol(), tD = "readonly", Mf = "show", rD = "edit", $U = (t) => {
  if (typeof t != "string" || !t)
    return [];
  const e = [], r = t.split(";");
  for (let s of r) {
    const i = s.split("-");
    if (i.length === 1)
      e.push(Number.parseInt(i[0]));
    else
      for (let n = Number.parseInt(i[0]); n <= Number.parseInt(i[1]); n++)
        e.push(n);
  }
  return e;
};
var Es, Ge, He, di, fi, mi, gi;
class QU extends Fi {
  constructor() {
    super(...arguments);
    At(this, Es, "");
    At(this, Ge);
    At(this, He);
    At(this, di);
    At(this, fi);
    At(this, mi);
    At(this, gi);
  }
  async [Nr]() {
    var n, a;
    await FU(100);
    let r = null, s = !1;
    if (this.href) {
      if (r = this.getRootNode().querySelector(this.href), !r) {
        console.error(`element ${this.href} not found.`), this.shadowRoot.innerHTML = "";
        return;
      }
      if (r.tagName.toLowerCase() === "iframe" && (((n = r.contentDocument) == null ? void 0 : n.readyState) === "complete" && r.contentDocument.location.href !== "about:blank" ? r = (a = r.contentDocument) == null ? void 0 : a.body : r = await new Promise((l) => {
        r.addEventListener("load", () => {
          var c;
          l((c = r.contentDocument) == null ? void 0 : c.body);
        });
      }), !r)) {
        console.error(`iframe ${this.href} not accessible.`), this.shadowRoot.innerHTML = "";
        return;
      }
      s = r.tagName.toLowerCase() === "grapper-view";
    }
    const i = [...this.childNodes].filter((l) => l.nodeType === 8 || l.nodeType === 1 && l.tagName.toLowerCase() === "textarea");
    i.length && r && (r.innerHTML = i[0].textContent), mt(this, Es, r ? s ? r.outerHTML : r.innerHTML : i.length ? i[0].textContent : ""), mt(this, Ge, new QM(r == null ? void 0 : r.getRootNode())), await Y(this, Ge).load(Y(this, Es), this.options, this.keepFormat), Y(this, Ge).subscribe((l) => {
      if (s) {
        r.innerHTML = l.inner;
        const c = r.getAttributeNames(), p = l.el.getAttributeNames();
        c.forEach((d) => {
          l.el.hasAttribute(d) || r.removeAttribute(d);
        }), p.forEach((d) => {
          r.setAttribute(d, l.el.getAttribute(d));
        });
      } else r && (r.innerHTML = l.code, this[ed](r));
    }), this.shadowRoot.innerHTML = `
      ${bU}
      ${TU}
    `, this.shadowRoot.querySelector("#title").innerHTML = this.title || "", mt(this, He, this.shadowRoot.querySelector("g-editor-provider")), Y(this, He).code = Y(this, Ge).code, Y(this, He).readonly = this[nt].disabled || this[nt].mode !== "edit", Y(this, He).addEventListener("update", (l) => {
      Y(this, Ge).code = l.detail.code;
    }), Y(this, He).theme = this[nt].theme, document.documentElement.addEventListener("themeChanged", (l) => {
      this.setAttribute("theme", l.detail.theme);
    }), mE(), mt(this, di, this.shadowRoot.querySelector("#modeEdit")), mt(this, fi, this.shadowRoot.querySelector("#modeShow")), mt(this, mi, this.shadowRoot.querySelector("#reload")), mt(this, gi, this.shadowRoot.querySelector("#rearrange")), Y(this, di).addEventListener("click", () => this.mode = rD), Y(this, fi).addEventListener("click", () => this.mode = Mf), Y(this, mi).addEventListener("click", () => this.discardChanges()), Y(this, gi).addEventListener("click", () => this.rearrange()), this.shadowRoot.querySelector("#copy").addEventListener("click", () => this.toClipboard()), this.shadowRoot.querySelector("#save").addEventListener("click", () => this.toDisk()), this[If](), this[Nf](), this[ed](r);
  }
  async toClipboard() {
    const r = Y(this, Ge).code;
    if (r)
      try {
        await navigator.clipboard.writeText(r);
        const s = this.shadowRoot.querySelector("#text-copy");
        s && (s.style.display = "inline", setTimeout(() => {
          s.style.display = "none";
        }, "1500"));
      } catch (s) {
        console.error("Error copying to clipboard", s);
      }
  }
  async toDisk() {
    const r = Y(this, Ge).code;
    if (r)
      return DU(r);
  }
  async discardChanges() {
    this.isChanged && (await Y(this, Ge).load(Y(this, Es), this.options, this.keepFormat), Y(this, He).code = Y(this, Ge).code);
  }
  async rearrange() {
    await Y(this, Ge).load(Y(this, Ge).code), Y(this, He).code = Y(this, Ge).code;
  }
  [Nf](r) {
    Y(this, He).linesHighlight && (r = r || this.linesHighlight, Y(this, He).linesHighlight(r));
  }
  [gE]() {
    Y(this, He) && (Y(this, He).theme = this.theme);
  }
  [If]() {
    if (Y(this, He))
      switch (this.mode.toLowerCase()) {
        case tD:
          this.setAttribute("mode", tD), Y(this, di).classList.add("hidden"), Y(this, fi).classList.add("hidden"), Y(this, mi).classList.add("hidden"), Y(this, gi).classList.add("hidden"), Y(this, He).editable = !1;
          break;
        case Mf:
          Y(this, di).classList.remove("hidden"), Y(this, fi).classList.add("hidden"), Y(this, mi).classList.add("hidden"), Y(this, gi).classList.add("hidden"), Y(this, He).editable = !1;
          break;
        case rD:
          Y(this, di).classList.add("hidden"), Y(this, fi).classList.remove("hidden"), Y(this, mi).classList.remove("hidden"), Y(this, gi).classList.remove("hidden"), Y(this, He).editable = !0;
      }
  }
  [ed](r) {
    const s = r.tagName.toLowerCase() === "grapper-view" ? r : r.querySelector("grapper-view");
    s && kU(s, Y(this, Ge), (i) => {
      this.dispatchEvent(new CustomEvent("diagnostic", { detail: i })), Y(this, He).diagnostic && Y(this, He).diagnostic(i);
    });
  }
  resetChange() {
    mt(this, Es, Y(this, Ge).code);
  }
  update(r) {
    Y(this, Ge).load(r, this.options, this.keepFormat).then(() => {
      Y(this, He).code = Y(this, Ge).code;
    });
  }
  set code(r) {
    mt(this, Es, r), this.update(r);
  }
  get code() {
    return Y(this, Ge).code;
  }
  get isChanged() {
    return Y(this, Es) !== Y(this, Ge).code;
  }
}
Es = new WeakMap(), Ge = new WeakMap(), He = new WeakMap(), di = new WeakMap(), fi = new WeakMap(), mi = new WeakMap(), gi = new WeakMap();
oD(xU).tag("g-editor-provider");
oD(QU).attr({ name: "title", type: "string", value: "", posUpdate: Nr }).attr({ name: "href", type: "string", value: "", posUpdate: Nr }).attr({ name: "keep-format", type: "boolean", value: !1, posUpdate: Nr }).attr({ name: "options", type: "object", value: {}, posUpdate: Nr }).attr({ name: "theme", type: "string", value: "light", posUpdate: gE }).attr({ name: "mode", type: "string", value: Mf, posUpdate: If }).attr({
  name: "lines-highlight",
  get() {
    return $U(this[nt].linesHighlight);
  },
  type: "string",
  value: "",
  postUpdate: Nf
}).tag("g-editor");
//# sourceMappingURL=editor.js.map
